{"meta":{"title":"MyBlog","subtitle":"We are the dreamers. We make it happen 'cause we can see it.","description":"謝謝你來，謝謝你還在","author":"Hsing Yu","url":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io","root":"/"},"pages":[{"title":"Hello!","date":"2023-04-08T11:59:17.144Z","updated":"2023-04-08T11:59:17.144Z","comments":true,"path":"about/index.html","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/about/index.html","excerpt":"","text":"# Hsing Yu 陳幸妤 在努力學習各種技術，完成所有夢想與理想，成為自己的那曙光！ 路漫漫其修遠兮， 吾將上下而求索。 每日目標 leetcode 1 題 CPE 1 題 英文 1 篇 這個網站目前是為了督促我自己樣成讀英文跟寫程式的習慣，之後會再寫一些整理的技術或我在學的一些東西。 # 簡介 性別：女 生日: 2003/02/12 星座：水瓶座 興趣：排球、美術設計、書法 專長：游泳、機器人、資訊工程 (人工智慧、網頁) # 經歷 國立彰化女子高級中學 國立台中教育大學 資訊工程學系 (特殊選材) # 比賽 &amp; 獎項 2018 全國智能車挑戰賽 2018-2019 FIRST 機器人大賽台灣選拔賽 — 研究品質獎全國第一名 (作品：太空中的家鄉味) 彰化縣 108 學年教育盃機器人競賽 — 高中競賽組佳作 2019 WRO 中南區賽高中競賽組 (機器人計分 / 計時賽) 2019 WRO 國際奧林匹亞機器人全國總決賽 — 高中創意組佳作 (作品：AI 智能交通小幫手) 台灣青年黑客松 6th — APP 組 (作品：防疫下的共享經濟) 2022 NCPC 全國大專電腦軟體設計競賽 國立台中教育大學 菁英獎 # 各種檢定 2023 CPE: 4 題 # 專案經歷 2021 彰化縣資優生報考系統 2021 彰化高中學生會選舉投票系統 2021 國立馬祖高級中學網站 2021~ 國教署 Q&amp;A 系統 (未完成) 2022~ 台中教育大學資工系網站 (未完成) 2023~ 進階程式設計課程自動評分系統 (未完成) # 參與團隊 2019~2020 國立彰化女子高級中學 電腦研習社 (機器人組與軟程組) 社長 2019~ 彰化資訊志工隊 隊員 2021~ 國立台中教育大學 空手道社 2021~ 國立台中教育大學 資工系女子排球隊 隊員、副隊長 (2021~2023) # 活動經歷 講師 2021 鹿鳴國中假日班 Webduino 課程 2021、2022 彰化女中學期課後程式加強課程 C++ 程式語言 2022 國立馬祖高中、桃園市立新屋高中 新興科技認知推廣計畫 - VR 體驗活動 2022 國立台中教育大學「程式戰鬥營」教學 C 程式語言 主辦人 彰化女中 2019、2020 C++ 寒暑假研習課 (共 6 場)、學期課後程式加強課程 主辦人、課堂協助指導 2020 彰中彰女電研聯合寒訓 主辦人、課堂協助指導 2021 舉辦大成國中寒假資訊科學營隊 協助教導 2019、2020 國中生機器人學園 (共 2 場) 2021 草湖國中寒假營隊 2022 芬園國中寒假營隊 學習探討 2020 高中人才培育計畫交大人工智慧與深度學習 (學習 AI 和深度學習的演進，機器學習的定義，線性模型推廣淺層神經網路，如何訓練神經網路) 2020Ewant 高中自主學習 交大生活中的機器人科技 (學習機器人的發展及未來應用) 2020 高中職生 AI 扎根系列活動 (學習 AI 基礎知識與實作 AWS DeepRacer) 2020 教育部資訊安全人才培育計畫 (學習 Linux、基礎資安分析實務、基礎程式逆向工程) 參與活動 2020 SITCON 學生計算機年會 # 目標待完成 CPE: 7 題 托福 iBT 考試：達標 參加 ICPC 得名 參加 ITSA 全國大專程式設計極客挑戰 得名 出國讀書 # 待續..."}],"posts":[{"title":"1372. Longest ZigZag Path in a Binary Tree","slug":"coding/leetcode/1372-Longest-ZigZag-Path-in-a-Binary-Tree","date":"2023-04-19T01:58:24.000Z","updated":"2023-04-19T01:59:49.856Z","comments":true,"path":"coding/leetcode/1372-Longest-ZigZag-Path-in-a-Binary-Tree/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/1372-Longest-ZigZag-Path-in-a-Binary-Tree/","excerpt":"","text":"⭐️⭐️ # 題目敘述 You are given the root of a binary tree. A ZigZag path for a binary tree is defined as follow: Choose any node in the binary tree and a direction (right or left). If the current direction is right, move to the right child of the current node; otherwise, move to the left child. Change the direction from right to left or from left to right. Repeat the second and third steps until you can't move in the tree. Zigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0). Return the longest ZigZag path contained in that tree. # Example 1 Input: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1] Output: 3 Explanation: Longest ZigZag path in blue nodes (right -&gt; left -&gt; right). # Example 2 Input: root = [1,1,1,null,1,null,null,1,1,null,1] Output: 4 Explanation: Longest ZigZag path in blue nodes (left -&gt; right -&gt; left -&gt; right). # Example 3: Input: root = [1] Output: 0 # 解題思路 # Solution class Solution &#123; int ans = 0; public int longestZigZag(TreeNode root) &#123; dfs(root, false, 0); dfs(root, true, 0); return ans; &#125; public void dfs(TreeNode node, boolean goLeft, int steps) &#123; if (node == null) &#123; return ; &#125; ans = Math.max(ans, steps); if (goLeft) &#123; dfs(node.left, false, steps + 1); dfs(node.right, true, 1); &#125; else &#123; dfs(node.left, false, 1); dfs(node.right, true, steps + 1); &#125; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Mediu","slug":"Mediu","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Mediu/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Tree","slug":"Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Tree/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Tree/"}]},{"title":"1431. Kids With the Greatest Number of Candies","slug":"coding/leetcode/1431-Kids-With-the-Greatest-Number-of-Candies","date":"2023-04-17T01:49:25.000Z","updated":"2023-04-17T02:18:36.130Z","comments":true,"path":"coding/leetcode/1431-Kids-With-the-Greatest-Number-of-Candies/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/1431-Kids-With-the-Greatest-Number-of-Candies/","excerpt":"","text":"⭐️ # 題目敘述 There are n kids with candies. You are given an integer array candies , where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies , denoting the number of extra candies that you have. Return a boolean array result of length n , where result[i] is true if, after giving the ith kid all the extraCandies , they will have the greatest number of candies among all the kids, or false otherwise. Note that multiple kids can have the greatest number of candies. # Example 1: Input: candies = [2,3,5,1,3], extraCandies = 3 Output: [true,true,true,false,true] Explanation: If you give all extraCandies to: Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids. Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids. Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids. Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids. Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids. # Example 2: Input: candies = [4,2,1,1,2], extraCandies = 1 Output: [true,false,false,false,false] Explanation: There is only 1 extra candy. Kid 1 will always have the greatest number of candies, even if a different kid is given the extra candy. # Example 3: Input: candies = [12,1,12], extraCandies = 10 Output: [true,false,true] # 解題思路 # Solution import java.util.ArrayList;import java.util.List;class Solution &#123; public List&lt;Boolean> kidsWithCandies(int[] candies, int extraCandies) &#123; int max = 0; for(int candy : candies)&#123; max = Math.max(candy, max); &#125; List&lt;Boolean> ans = new ArrayList&lt;>(); for(int candy : candies)&#123; int temp = candy + extraCandies; ans.add(temp &lt; max ? false : true); &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Easy","slug":"Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Easy/"}]},{"title":"uva 1587 - Box","slug":"coding/cpe/uva-1587-Box","date":"2023-04-15T13:16:47.000Z","updated":"2023-04-18T15:56:52.520Z","comments":true,"path":"coding/cpe/uva-1587-Box/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/uva-1587-Box/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Ivan works at a factory that produces heavy machinery. He has a simple job — he knocks up wooden boxes of different sizes to pack machinery for delivery to the customers. Each box is a rectangular parallelepiped. Ivan uses six rectangular wooden pallets to make a box. Each pallet is used for one side of the box. Joe delivers pallets for Ivan. Joe is not very smart and often makes mistakes — he brings Ivan pallets that do not fit together to make a box. But Joe does not trust Ivan. It always takes a lot of time to explain Joe that he has made a mistake. Fortunately, Joe adores everything related to computers and sincerely believes that computers never make mistakes. Ivan has decided to use this for his own advantage. Ivan asks you to write a program that given sizes of six rectangular pallets tells whether it is possible to make a box out of them. # Input Input file contains several test cases. Each of them consists of six lines. Each line describes one pallet and contains two integer numbers w and h (1 ≤ w, h ≤ 10 000) — width and height of the pallet in millimeters respectively. # Output For each test case, print one output line. Write a single word ‘POSSIBLE’ to the output file if it is possible to make a box using six given pallets for its sides. Write a single word ‘IMPOSSIBLE’ if it is not possible to do so. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 1345 2584 2584 683 2584 1345 683 1345 683 1345 2584 683 1234 4567 1234 4567 4567 4321 4322 4567 4321 1234 4321 1234 # Sample Output POSSIBLE IMPOSSIBLE # 解題技巧 # Solution","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"},{"name":"One Star","slug":"One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/One-Star/"}]},{"title":"uva 1585 - Score","slug":"coding/cpe/uva-1585-Score","date":"2023-04-15T06:30:55.000Z","updated":"2023-04-18T15:57:29.951Z","comments":true,"path":"coding/cpe/uva-1585-Score/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/uva-1585-Score/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 There is an objective test result such as “OOXXOXXOOO” . An ‘O’ means a correct answer of a problem and an ‘X’ means a wrong answer. The score of each problem of this test is calculated by itself and its just previous consecutive ‘O’s only when the answer is correct. For example, the score of the 10th problem is 3 that is obtained by itself and its two previous consecutive ‘O’s . Therefore, the score of “OOXXOXXOOO” is 10 which is calculated by “1+2+0+0+1+0+0+1+2+3” . You are to write a program calculating the scores of test results. # Input Your program is to read from standard input. The input consists of T test cases. The number of test cases T is given in the first line of the input. Each test case starts with a line containing a string composed by ‘O’ and ‘X’ and the length of the string is more than 0 and less than 80 . There is no spaces between ‘O’ and ‘X’ . # Output Your program is to write to standard output. Print exactly one line for each test case. The line is to contain the score of the test case. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 5 OOXXOXXOOO OOXXOOXXOO OXOXOXOXOXOXOX OOOOOOOOOO OOOOXOOOOXOOOOX # Sample Output 10 9 7 55 30 # 解題技巧 檢查 result 每一題是否正確。 'O' : 加上該題分數。 'X' : 則該題零分。 該題分數：前一題如果正確當前該題分數比前一題多一。 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for(int i = 0; i &lt; T; i++)&#123; String result = sc.next(); int curr = 1; boolean check = false; int ans = 0; for(int j = 0; j &lt; result.length(); j++)&#123; if(result.charAt(j) == 'X')&#123; check = false; curr = 1; &#125;else &#123; if(check)&#123; curr++; &#125; ans += curr; check = true; &#125; &#125; System.out.println(ans); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"},{"name":"One Star","slug":"One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/One-Star/"}]},{"title":"2218. Maximum Value of K Coins From Piles","slug":"coding/leetcode/2218-Maximum-Value-of-K-Coins-From-Piles","date":"2023-04-15T04:01:24.000Z","updated":"2023-04-15T06:30:22.898Z","comments":true,"path":"coding/leetcode/2218-Maximum-Value-of-K-Coins-From-Piles/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/2218-Maximum-Value-of-K-Coins-From-Piles/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 There are n piles of coins on a table. Each pile consists of a positive number of coins of assorted denominations. In one move, you can choose any coin on top of any pile, remove it, and add it to your wallet. Given a list piles , where piles[i] is a list of integers denoting the composition of the ith pile from top to bottom, and a positive integer k , return the maximum total value of coins you can have in your wallet if you choose exactly k coins optimally. # Example 1: Input: piles = [[1,100,3],[7,8,9]], k = 2 Output: 101 Explanation: The above diagram shows the different ways we can choose k coins. The maximum total we can obtain is 101. # Example 2: Input: piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7 Output: 706 Explanation: The maximum total can be obtained if we choose all coins from the last pile. # 解題思路 # Solution import java.util.Arrays;import java.util.List;class Solution &#123; public int maxValueOfCoins(List&lt;List&lt;Integer>> piles, int k) &#123; int[][] dp = new int[piles.size() + 1][k + 1]; Arrays.fill(dp[0], 0); for (int i = 1; i &lt;= piles.size(); i++) &#123; dp[i][0] = 0; &#125; for (int i = 1; i &lt;= piles.size(); i++) &#123; for (int j = 1; j &lt;= k; j++) &#123; int curr = 0; for (int x = 0; x &lt; Math.min(piles.get(i - 1).size(), j); x++) &#123; curr += piles.get(i - 1).get(x); dp[i][j] = Math.max(dp[i][j], curr + dp[i - 1][j - x - 1]); &#125; dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]); &#125; &#125; return dp[piles.size()][k]; &#125;&#125; 單字 denoting 表示 to represent something 片語 & 搭配詞 assorted denominations 個種面額","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Hard","slug":"Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hard/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"}]},{"title":"516. Longest Palindromic Subsequence","slug":"coding/leetcode/516-Longest-Palindromic-Subsequence","date":"2023-04-14T17:08:29.000Z","updated":"2023-04-15T04:04:21.474Z","comments":true,"path":"coding/leetcode/516-Longest-Palindromic-Subsequence/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/516-Longest-Palindromic-Subsequence/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a string s , find the longest palindromic subsequence's length in s . A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. # Example 1: Input: s = &quot;bbbab&quot; Output: 4 Explanation: One possible longest palindromic subsequence is &quot;bbbb&quot;. # Example 2: Input: s = &quot;cbbd&quot; Output: 2 Explanation: One possible longest palindromic subsequence is &quot;bb&quot;. # 解題思路 # Solution class Solution &#123; public int longestPalindromeSubseq(String s) &#123; int n = s.length(); int[] dp = new int[n]; for (int i = n - 1; i >= 0; i--) &#123; int[] newdp = new int[n]; newdp[i] = 1; for (int j = i + 1; j &lt; n; j++) &#123; if (s.charAt(i) == s.charAt(j)) &#123; newdp[j] = 2 + dp[j-1]; &#125; else &#123; newdp[j] = Math.max(dp[j], newdp[j-1]); &#125; &#125; dp = newdp; &#125; return dp[n-1]; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Medium","slug":"Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Medium/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"946. Validate Stack Sequences","slug":"coding/leetcode/946-Validate-Stack-Sequences","date":"2023-04-13T01:21:33.000Z","updated":"2023-04-15T04:04:30.724Z","comments":true,"path":"coding/leetcode/946-Validate-Stack-Sequences/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/946-Validate-Stack-Sequences/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given two integer arrays pushed and popped each with distinct values, return true if this could have been the result of a sequence of push and pop operations on an initially empty stack, or false otherwise. # Example 1: Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1] Output: true Explanation: We might do the following sequence: push(1), push(2), push(3), push(4), pop() -&gt; 4, push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1 # Example 2: Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2] Output: false Explanation: 1 cannot be popped before 2. # 解題思路 # Solution import java.util.Stack;class Solution &#123; public boolean validateStackSequences(int[] pushed, int[] popped) &#123; Stack&lt;Integer> stack = new Stack&lt;>(); int index = 0; for(int p : pushed)&#123; stack.push(p); while(!stack.isEmpty() &amp;&amp; stack.peek() == popped[index])&#123; stack.pop(); index++; &#125; &#125; return stack.isEmpty(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Medium","slug":"Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Medium/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"}]},{"title":"71. Simplify Path","slug":"coding/leetcode/71-Simplify-Path","date":"2023-04-12T03:22:17.000Z","updated":"2023-04-15T04:04:06.476Z","comments":true,"path":"coding/leetcode/71-Simplify-Path/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/71-Simplify-Path/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a string path , which is an absolute path (starting with a slash '/' ) to a file or directory in a Unix-style file system, convert it to the simplified canonical path. In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//' ) are treated as a single slash '/' . For this problem, any other format of periods such as '...' are treated as file/directory names. The canonical path should have the following format: The path starts with a single slash '/'. Any two directories are separated by a single slash '/'. The path does not end with a trailing '/'. The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..') Return the simplified canonical path. # Example 1: Input: path = &quot;/home/&quot; Output: &quot;/home&quot; Explanation: Note that there is no trailing slash after the last directory name. # Example 2: Input: path = &quot;/../&quot; Output: &quot;/&quot; Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. # Example 3: Input: path = &quot;/home//foo/&quot; Output: &quot;/home/foo&quot; Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. # 解題思路 # Solution import java.util.Stack;class Solution &#123; public String simplifyPath(String path) &#123; Stack&lt;String> stack = new Stack&lt;>(); for (String str : path.split(\"/\")) &#123; if (!stack.isEmpty() &amp;&amp; str.equals(\"..\")) &#123; stack.pop(); &#125; else if (!str.equals(\".\") &amp;&amp; !str.equals(\"\") &amp;&amp; !str.equals(\"..\")) &#123; stack.add(str); &#125; &#125; StringBuilder ans = new StringBuilder(); for (String str : stack) &#123; ans.append(\"/\").append(str); &#125; return ans.length() == 0 ? \"/\" : ans.toString(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Medium","slug":"Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Medium/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"}]},{"title":"2390. Removing Stars From a String","slug":"coding/leetcode/2390-Removing-Stars-From-a-String","date":"2023-04-11T03:05:05.000Z","updated":"2023-04-15T04:04:41.113Z","comments":true,"path":"coding/leetcode/2390-Removing-Stars-From-a-String/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/2390-Removing-Stars-From-a-String/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given a string s , which contains stars * . In one operation, you can: Choose a star in s . Remove the closest non-star character to its left, as well as remove the star itself. Return the string after all stars have been removed. Note: The input will be generated such that the operation is always possible. It can be shown that the resulting string will always be unique. # Example 1: Input: s = &quot;leet**cod*e&quot; Output: &quot;lecoe&quot; Explanation: Performing the removals from left to right: The closest character to the 1st star is 't' in &quot;leet**cod*e&quot; . s becomes &quot;lee*cod*e&quot; . The closest character to the 2nd star is 'e' in &quot;lee*cod*e&quot; . s becomes &quot;lecod*e&quot; . The closest character to the 3rd star is 'd' in &quot;lecod*e&quot; . s becomes &quot;lecoe&quot; . There are no more stars, so we return &quot;lecoe&quot; . # Example 2: Input: s = &quot;erase*****&quot; Output: &quot;&quot; Explanation: The entire string is removed, so we return an empty string. # 解題思路 # Solution import java.util.Stack;class Solution &#123; public String removeStars(String s) &#123; char[] toChar = s.toCharArray(); Stack&lt;Character> stack = new Stack&lt;>(); for(int i = 0; i &lt; s.length(); i++)&#123; if(toChar[i] == '*')&#123; stack.pop(); &#125;else &#123; stack.add(toChar[i]); &#125; &#125; String ans = \"\"; while(!stack.isEmpty())&#123; ans = stack.pop() + ans; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Medium","slug":"Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Medium/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"}]},{"title":"20. Valid Parentheses","slug":"coding/leetcode/20-Valid-Parentheses","date":"2023-04-10T01:44:58.000Z","updated":"2023-04-10T01:48:21.046Z","comments":true,"path":"coding/leetcode/20-Valid-Parentheses/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/20-Valid-Parentheses/","excerpt":"","text":"⭐️ # 題目敘述 Given a string s containing just the characters '(' , ')' , '&#123;' , '&#125;' , '[' and ']' , determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type. # Example 1: Input: s = &quot;()&quot; Output: true # Example 2: Input: s = &quot;(){}&quot; Output: true # Example 3: Input: s = &quot;(]&quot; Output: false # 解題思路 利用 stack。 # Solution import java.util.Stack;class Solution &#123; public boolean isValid(String s) &#123; if (s.length() % 2 != 0) &#123; return false; &#125; Stack&lt;Character> stack = new Stack&lt;>(); for (char c : s.toCharArray()) &#123; switch(c)&#123; case '(': case '&#123;': case '[': stack.push(c); break; case ')': if(stack.isEmpty() || stack.pop() != '(') return false; break; case '&#125;': if(stack.isEmpty() || stack.pop() != '&#123;') return false; break; case ']': if(stack.isEmpty() || stack.pop() != '[') return false; break; &#125; &#125; return (stack.isEmpty()); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Easy","slug":"Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Easy/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"}]},{"title":"You Are What You Eat - Part B","slug":"language/english/雜誌/You-Are-What-You-Eat-Part-B","date":"2023-04-09T22:01:06.000Z","updated":"2023-04-09T22:12:21.470Z","comments":true,"path":"language/english/雜誌/You-Are-What-You-Eat-Part-B/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/language/english/%E9%9B%9C%E8%AA%8C/You-Are-What-You-Eat-Part-B/","excerpt":"","text":"⭐️ # You Are What You Eat - Part B The next night, Tara is making dinner. 隔天晚上，塔拉正在做晚餐。 Blake: What are you cooking? Tara: I'm making steamed fish. I'm also going to make brown rice. That's healthier than white rice. Blake: Let's add lots of salt. That will make ti better. Tara: No way. Maybe we can add some low-fat cheese. What do you say? Blake: Well...all right. Can we also have some fruit? Tara: Sure! You can cut some apples. We'll eat them before dinner. Blake: I have a better idea. Let's have banana ice cream. Bananas are fruit. Tara: Forget it. Hurry up and get those apples. 單字 cook 煮；烹調 When you cook food, you prepare it to be eaten by heating it in a particular way, such as baking or boiling, and when food cooks, it is heated until it is ready to eat 片語 & 搭配詞 !! !! # 前言 BARRY: To understand what I'm about to tell you, you need to do something first. You need to believe int the impossible. Can you do that? Good. You see that red blur? That's me. That too. There I am again. My name is Barry Allen. I am the fastest man alive. 14 YEARS AGO My story is pretty simple. My whole life, I've been running. Usually from bullies. Sometimes I escaped. Sometimes I did not. NORA: Tell me what happened. BARRY: Those guys were picking on kids... ...just because they thought they weren't cool. It wasn't right. NORA: I know. BARRY: I guess I wasn't fast enough. NORA: No. You have such a good heart, Barry. And it's better to have a good heart than fast legs. HENRY: Hello? I'm home. NORA: Barry got into a fight. HENRY: Oh, yeah? NORA: And he won. HENRY: Way to go, slugger. Oh, and no more fighting. CLATTERING AND CLANKING BARRY: But after that night, I was running from something much scarier. NORA: Henry! Henry! BARRY: Something I could never explain. Something impossible. NORA SCREAMING BARRY: Mom! Mon! NORA: Barry, don't! Get back! BARRY: Mom! Mom! NORA: Ah! HENRY: Nora! NORA: Stay back! HENRY: Nora, hold on! Run, Barry. Run! BARRY: Mom? Dad? TODAY PANTING BARRY: Sorry. SIREN WAILS CHYRE: Second robbery this week. The teller ID'd Clyde Mardon as the shooter. What? Oh, jeez, the Mardon brothers are back? SINGH: What do we got? JOE: Perps took the bank, shot out the cameras... ...and killed the security guard there. I got unis kicking in doors of their known associates. SINGH: CSI been over it? JOE: No. SINGH: Where's Allen? BARRY: Unh! Sorry, sorry. SINGH: You can't keep covering for him. BARRY: Coming through. SINGH: I have to carry on without him. BARRY: Sorry I'm late, Captain Singh. SINGH: What was it this time? Forget to see your alarm clock? Before you answer, the excuse you gave last time was car trouble. Wanna know why that one was memorable? BARRY: I do not own a car. JOE: He was running an errand for me. Barry, did you get me what I asked for? BARRY: Yeah. Yeah, I did. I have it right... here. I had a few bites of it.","categories":[{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"雜誌","slug":"language/english/雜誌","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E9%9B%9C%E8%AA%8C/"}],"tags":[{"name":"難度 1","slug":"難度-1","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-1/"},{"name":"英文雜誌","slug":"英文雜誌","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E9%9B%9C%E8%AA%8C/"},{"name":"對話","slug":"對話","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%B0%8D%E8%A9%B1/"}]},{"title":"uva 1368 - DNA Consensus String","slug":"coding/cpe/uva-1368-DNA-Consensus-String","date":"2023-04-09T20:31:59.000Z","updated":"2023-04-18T15:57:29.027Z","comments":true,"path":"coding/cpe/uva-1368-DNA-Consensus-String/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/uva-1368-DNA-Consensus-String/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 DNA (Deoxyribonucleic Acid) is the molecule which contains the genetic instructions. It consists of four different nucleotides, namely Adenine, Thymine, Guanine, and Cytosine as shown in Figure 1. If we represent a nucleotide by its initial character, a DNA strand can be regarded as a long string (sequence of characters) consisting of the four characters A, T, G, and C. For example, assume we are given some part of a DNA strand which is composed of the following sequence of nucleotides: “Thymine-Adenine-Adenine-Cytosine-Thymine-Guanine-CytosineCytosine-Guanine-Adenine-Thymine” Then we can represent the above DNA strand with the string “TAACTGCCGAT.” The biologist Prof. Ahn found that a gene X commonly exists in the DNA strands of five different kinds of animals, namely dogs, cats, horses, cows, and monkeys. He also discovered that the DNA sequences of the gene X from each animal were very alike. See Figure 2. Prof. Ahn thought that humans might also have the gene X and decided to search for the DNA sequence of X in human DNA. However, before searching, he should define a representative DNA sequence of gene X because its sequences are not exactly the same in the DNA of the five animals. He decided to use the Hamming distance to define the representative sequence. The Hamming distance is the number of different characters at each position from two strings of equal length. For example, assume we are given the two strings “AGCAT” and “GGAAT.” The Hamming distance of these two strings is 2 because the 1st and the 3rd characters of the two strings are different. Using the Hamming distance, we can define a representative string for a set of multiple strings of equal length. Given a set of strings S = {s1, . . . , sm} of length n, the consensus error between a string y of length n and the set S is the sum of the Hamming distances between y and each si in S. If the consensus error between y and S is the minimum among all possible strings y of length n, y is called a consensus string of S. For example, given the three strings “AGCAT” “AGACT” and “GGAAT” the consensus string of the given strings is “AGAAT” because the sum of the Hamming distances between “AGAAT” and the three strings is 3 which is minimal. (In this case, the consensus string is unique, but in general, there can be more than one consensus string.) We use the consensus string as a representative of the DNA sequence. For the example of Figure 2 above, a consensus string of gene X is “GCAAATGGCTGTGCA” and the consensus error is 7. # Input Your program is to read from standard input. The input consists of T test cases. The number of test cases T is given in the first line of the input. Each test case starts with a line containing two integers m and n which are separated by a single space. The integer m (4 ≤ m ≤ 50) represents the number of DNA sequences and n (4 ≤ n ≤ 1000) represents the length of the DNA sequences, respectively. In each of the next m lines, each DNA sequence is given. # Output Your program is to write to standard output. Print the consensus string in the first line of each case and the consensus error in the second line of each case. If there exists more than one consensus string, print the lexicographically smallest consensus string. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 3 5 8 TATGATAC TAAGCTAC AAAGATCC TGAGATAC TAAGATGT 4 10 ACGTACGTAC CCGTACGTAG GCGTACGTAT TCGTACGTAA 6 10 ATGTTACCAT AAGTTACGAT AACAAAGCAA AAGTTACCTT AAGTTACCAA TACTTACCAA # Sample Output TAAGATAC 7 ACGTACGTAA 6 AAGTTACCAA 12 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int T = sc.nextInt(); // ACGT Map&lt;Character, Integer> toInt = new HashMap&lt;>(); Map&lt;Integer, Character> toChar = new HashMap&lt;>(); toInt.put('A', 0); toChar.put(0, 'A'); toInt.put('C', 1); toChar.put(1, 'C'); toInt.put('G', 2); toChar.put(2, 'G'); toInt.put('T', 3); toChar.put(3, 'T'); for (int i = 0; i &lt; T; i++) &#123; int m = sc.nextInt(); int n = sc.nextInt(); char[][] DNA = new char[m][n]; int[][] count = new int[n][4]; for (int j = 0; j &lt; m; j++) &#123; DNA[j] = sc.next().toCharArray(); for (int k = 0; k &lt; n; k++) &#123; count[k][toInt.get(DNA[j][k])]++; &#125; &#125; int sum = 0; for (int j = 0; j &lt; n; j++) &#123; int max = -1; int index = -1; for (int k = 3; k >= 0; k--) &#123; if (count[j][k] >= max) &#123; max = count[j][k]; index = k; &#125; &#125; System.out.print(toChar.get(index)); sum += m - max; &#125; System.out.println(); System.out.println(sum); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"},{"name":"One Star","slug":"One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/One-Star/"}]},{"title":"1857. Largest Color Value in a Directed Graph","slug":"coding/leetcode/1857-Largest-Color-Value-in-a-Directed-Graph","date":"2023-04-09T04:05:26.000Z","updated":"2023-04-09T04:22:08.696Z","comments":true,"path":"coding/leetcode/1857-Largest-Color-Value-in-a-Directed-Graph/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/1857-Largest-Color-Value-in-a-Directed-Graph/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 There is a directed graph of n colored nodes and m edges. The nodes are numbered from 0 to n - 1 . You are given a string colors where colors[i] is a lowercase English letter representing the color of the ith node in this graph (0-indexed). You are also given a 2D array edges where edges[j] = [aj, bj] indicates that there is a directed edge from node aj to node bj . A valid path in the graph is a sequence of nodes x1 -&gt; x2 -&gt; x3 -&gt; ... -&gt; xk such that there is a directed edge from xi to xi+1 for every 1 &lt;= i &lt; k . The color value of the path is the number of nodes that are colored the most frequently occurring color along that path. Return the largest color value of any valid path in the given graph, or -1 if the graph contains a cycle. # Example 1: Input: colors = &quot;abaca&quot;, edges = [[0,1],[0,2],[2,3],[3,4]] Output: 3 Explanation: The path 0 -&gt; 2 -&gt; 3 -&gt; 4 contains 3 nodes that are colored &quot;a&quot; (red in the above image) . # Example 2: Input: colors = &quot;a&quot;, edges = [[0,0]] Output: -1 Explanation: There is a cycle from 0 to 0. # 解題思路 # Solution import java.util.ArrayList;import java.util.LinkedList;import java.util.List;import java.util.Queue;class Solution &#123; public int largestPathValue(String colors, int[][] edges) &#123; List&lt;List&lt;Integer>> graph = new ArrayList&lt;>(); int length = colors.length(); int inDegree[] = new int[length]; int colorsDP[][] = new int[length][26]; int visited = 0; for (int i = 0; i &lt; length; i++) &#123; graph.add(new ArrayList&lt;>()); &#125; for (int i = 0; i &lt; edges.length; i++) &#123; int start = edges[i][0]; int end = edges[i][1]; graph.get(start).add(end); inDegree[end]++; &#125; Queue&lt;Integer> queue = new LinkedList&lt;>(); for (int i = 0; i &lt; inDegree.length; i++) &#123; if (inDegree[i] == 0) &#123; queue.add(i); &#125; &#125; while (!queue.isEmpty()) &#123; int parent = queue.poll(); int parentColor = colors.charAt(parent) - 'a'; colorsDP[parent][parentColor] = colorsDP[parent][parentColor] + 1; for (Integer child : graph.get(parent)) &#123; inDegree[child]--; if (inDegree[child] == 0) &#123; queue.add(child); &#125; for (int i = 0; i &lt; 26; i++) &#123; colorsDP[child][i] = Math.max(colorsDP[child][i], colorsDP[parent][i]); &#125; &#125; visited++; &#125; if (visited != length) return -1; int maxColor = 0; for (int i = 0; i &lt; colorsDP.length; i++) &#123; for (int j = 0; j &lt; 26; j++) &#123; maxColor = Math.max(maxColor, colorsDP[i][j]); &#125; &#125; return maxColor; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Hard","slug":"Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hard/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Topological Sort","slug":"Topological-Sort","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Topological-Sort/"},{"name":"Memoization","slug":"Memoization","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Memoization/"}]},{"title":"uva 1237 - Expert Enough?","slug":"coding/cpe/uva-1237-Expert-Enough","date":"2023-04-08T16:27:36.000Z","updated":"2023-04-18T15:57:05.255Z","comments":true,"path":"coding/cpe/uva-1237-Expert-Enough/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/uva-1237-Expert-Enough/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Auto-mobile Charting &amp; Manufacturing (ACM) is a company that specializes in manufacturing automobile spare parts. Being one of the leading automotive companies in the world, ACM are sure to keep up the latest information in that world. In the 100-year anniversary of the company, ACM compiled a huge list of range of prices of any automobiles ever recorded in the history. ACM then wants to develop a program that they called Automobile Expert System or AES for short. The program receives a price P as an input, and searches through the database for a car maker in which P falls in their range of lowest price L and highest price H of car they ever made. The program then output the car maker name. If the database contains no or more than one car maker that satisfies the query, the program produce output ‘UNDETERMINED’ (without quotes). Not so expert, huh? You are about to develop that program for ACM. # Input The input begins with a line containing an integer T (T ≤ 10) , the number of test cases follow. Each case begins with the size of the database D (D &lt; 10000) . The next each of D lines contains M , L and H (0 &lt; L &lt; H &lt; 1000000) which are the name of the maker (contains no whitespace and will never exceeds 20 characters), the car’s lowest price the maker ever made, and the car’s highest price the maker ever made respectively. Then there is the number of query Q (Q &lt; 1000) follows. Each of the next Q lines contains an integer P (0 &lt; P &lt; 1000000) , the query price. # Output Output for each query should be one line containing the name of the maker, or the string ‘UNDETERMINED’ (without quotes) if there is no maker or more than one maker that satisfies the query. You should separate output for different case by one empty line. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 1 4 HONDA 10000 45000 PEUGEOT 12000 44000 BMW 30000 75900 CHEVROLET 7000 37000 4 60000 7500 5000 10000 # Sample Output BMW CHEVROLET UNDETERMINED UNDETERMINED # 解題技巧 # Solution Java I/O 加速 Main.javaimport java.util.*;import java.io.*;public class Main &#123; public static void main(String[] args) &#123; InputStream inputStream = System.in; OutputStream outputStream = System.out; Scanner in = new Scanner(inputStream); PrintWriter out = new PrintWriter(outputStream); CPE slove = new CPE(); slove.slover(1, in, out); out.close(); &#125; static class CPE &#123; public void slover(int testNumber, Scanner in, PrintWriter out) &#123; int T = in.nextInt(); for (int i = 0; i &lt; T; i++) &#123; if (i != 0) &#123; out.println(); &#125; int D = in.nextInt(); Map&lt;int[], String> map = new HashMap&lt;>(); for (int j = 0; j &lt; D; j++) &#123; String M = in.next(); int[] LH = new int[2]; LH[0] = in.nextInt(); LH[1] = in.nextInt(); map.put(LH, M); &#125; int Q = in.nextInt(); for (int j = 0; j &lt; Q; j++) &#123; ArrayList&lt;String> ans = new ArrayList&lt;>(); int P = in.nextInt(); for (int[] m : map.keySet()) &#123; if (m[0] &lt;= P &amp;&amp; m[1] >= P) &#123; ans.add(map.get(m)); if(ans.size() > 1) break; &#125; &#125; if (ans.size() == 1) &#123; out.println(ans.get(0)); &#125; else &#123; out.println(\"UNDETERMINED\"); &#125; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"},{"name":"One Star","slug":"One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/One-Star/"}]},{"title":"uva 1225 - Digit Counting","slug":"coding/cpe/uva-1225-Digit-Counting","date":"2023-04-08T08:25:23.000Z","updated":"2023-04-18T15:57:25.438Z","comments":true,"path":"coding/cpe/uva-1225-Digit-Counting/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/uva-1225-Digit-Counting/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Trung is bored with his mathematics homeworks. He takes a piece of chalk and starts writing a sequence of consecutive integers starting with 1 to N (1 &lt; N &lt; 10000) . After that, he counts the number of times each digit (0 to 9) appears in the sequence. For example, with N = 13 , the sequence is: 1234567891011121312345678910111213 12345678910111213 In this sequence, 0 appears once , 1 appears 6 times , 2 appears 2 times , 3 appears 3 times , and each digit from 4 to 9 appears once . After playing for a while, Trung gets bored again. He now wants to write a program to do this for him. Your task is to help him with writing this program. # Input The input file consists of several data sets. The first line of the input file contains the number of data sets which is a positive integer and is not bigger than 20 . The following lines describe the data sets. For each test case, there is one single line containing the number N . # Output For each test case, write sequentially in one line the number of digit 0, 1, . . . 9 separated by a space. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 2 3 13 # Sample Output 0 1 1 1 0 0 0 0 0 0 1 6 2 2 1 1 1 1 1 1 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int data = sc.nextInt(); for(int i = 0; i &lt; data; i++)&#123; int N = sc.nextInt(); int[] ans = new int[10]; for(int j = 1; j &lt;= N; j++)&#123; String str = Integer.toString(j); for(int l = 0; l &lt; str.length(); l++)&#123; ans[str.charAt(l) - '0']++; &#125; &#125; for(int j = 0; j &lt; 10; j++)&#123; if(j != 0)&#123; System.out.print(\" \"); &#125; System.out.print(ans[j]); &#125; System.out.println(); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"},{"name":"One Star","slug":"One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/One-Star/"}]},{"title":"133. Clone Graph","slug":"coding/leetcode/133-Clone-Graph","date":"2023-04-08T03:40:24.000Z","updated":"2023-04-09T04:22:14.719Z","comments":true,"path":"coding/leetcode/133-Clone-Graph/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/133-Clone-Graph/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Each node in the graph contains a value ( int ) and a list ( List[Node] ) of its neighbors. class Node &#123; public int val; public List&lt;Node&gt; neighbors; &#125; Test case format: For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1 , the second node with val == 2 , and so on. The graph is represented in the test case using an adjacency list. An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph. The given node will always be the first node with val = 1 . You must return the copy of the given node as a reference to the cloned graph. # Example 1: Input: adjList = [[2,4],[1,3],[2,4],[1,3]] Output: [[2,4],[1,3],[2,4],[1,3]] Explanation: There are 4 nodes in the graph. 1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4). 2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3). 3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4). 4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3). # Example 2: Input: adjList = [[]] Output: [[]] Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors. # Example 3: Input: adjList = [] Output: [] Explanation: This an empty graph, it does not have any nodes. # 解題思路 # Solution import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;// Definition for a Node.class Node &#123; public int val; public List&lt;Node> neighbors; public Node() &#123; val = 0; neighbors = new ArrayList&lt;Node>(); &#125; public Node(int _val) &#123; val = _val; neighbors = new ArrayList&lt;Node>(); &#125; public Node(int _val, ArrayList&lt;Node> _neighbors) &#123; val = _val; neighbors = _neighbors; &#125;&#125;class Solution &#123; Map&lt;Node, Node> map = new HashMap&lt;>(); public Node cloneGraph(Node node) &#123; if (node == null) return null; if (map.containsKey(node)) return map.get(node); map.put(node, new Node(node.val)); for (Node val : node.neighbors) &#123; map.get(node).neighbors.add(cloneGraph(val)); &#125; return map.get(node); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Medium","slug":"Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Medium/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"}]},{"title":"Reading Highlights 1: Uber: The Worlds Modern Taxi","slug":"language/english/Reading Highlights/Reading-Highlights-1-Uber-The-Worlds-Modern-Taxi","date":"2023-04-07T04:26:45.000Z","updated":"2023-04-07T10:10:21.319Z","comments":true,"path":"language/english/Reading Highlights/Reading-Highlights-1-Uber-The-Worlds-Modern-Taxi/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/language/english/Reading%20Highlights/Reading-Highlights-1-Uber-The-Worlds-Modern-Taxi/","excerpt":"","text":"⭐️⭐️⭐️⭐️ # Uber: The World's Modern Taxi A new taxi trend is taking over the world. Uber doesn't have a long history, but it has proven it's here to stay by providing major benefits and a competitive spirit. Travis Kalanick and Garrett Camp launched the Uber transportation app in 2009 in San Francisco, California, US. In May 2011, it started spreading to other American cities. In December of the same year, it expanded into its first international city - Pairs, France. Uber now operates in 58 countries and 300 cities across the globe. It's worth an estimated US$50 billion. Uber combines the traditional taxi ride with the morden technology of the 21st century. All Uber transactions are handled electronically; the app finds you a drive, navigates, and processes the paymemt. The only interaction you have with the driver is pleasant conversation. Using Uber is slightly different from a normal taxi ride because you can estimate the cost of your ride before you decide to hire a drive and split the fare with other passengers. Additionally, the app can send a text message with your Uber ride information to friends or family, adding an element of safety to your ride. Despite its many advantages, Uber has its critics. Some goverments have banned the app because its drivers aren't properly trained or insured. On February 19, Uber was declared illegal in Taiwan The goverment said that the drivers had violated the Highway Act and Transportation Management Regulations. Taxi companies have also opposed Uber, as they've lost business because of Uber's cheap rates and fast reaponse time. Protestes against Uber have become common, locally and internationally. It remains to be seen whether Uber's many advantages will win out against traditional taxis. Which one would you choose to take a ride in? # 段落大意 第一段: 告知主題是要闡述 new Taxi 第二段 Uber 發展史 第三段 Uber 的運作模式，好處等等 第四段 Uber 的問題或不足 # Reading Questions Which of the following statements about Uber is TRUE? It is illegal in some countries. It was started by a US taxi driver in 2009. It is more popular abroad than in the US. It operates through a control center. According to the passage, how does Uber work? Ubers can share the ride with other passengers. Ubers pay the transportation fare directly to the drivers. Ubers can negotiate the cost of the ride with the driver. Users have to register in paper from before using the service. Compared with normal taxis, Uber is all of the following EXCEPT . more advanced greener less costly more convenient What is one criticism of Uber based on the passage? The drivers don't show up fast enough. The drivers are not paid enough. The drivers lack sufficient training. The customer service is lousy.","categories":[{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"Reading Highlight","slug":"language/english/Reading-Highlight","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/Reading-Highlight/"}],"tags":[{"name":"英文 Reading Highlights","slug":"英文-Reading-Highlights","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87-Reading-Highlights/"},{"name":"閱讀","slug":"閱讀","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%96%B1%E8%AE%80/"},{"name":"難度 4","slug":"難度-4","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-4/"}]},{"title":"1020. Number of Enclaves","slug":"coding/leetcode/1020-Number-of-Enclaves","date":"2023-04-07T01:25:06.000Z","updated":"2023-04-09T04:22:23.089Z","comments":true,"path":"coding/leetcode/1020-Number-of-Enclaves/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/1020-Number-of-Enclaves/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an m x n binary matrix grid , where 0 represents a sea cell and 1 represents a land cell. A move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid . Return the number of land cells in grid for which we cannot walk off the boundary of the grid in any number of moves. # Example 1: Input: grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] Output: 3 Explanation: There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary. # Example 2: Input: grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]] Output: 0 Explanation: All 1s are either on the boundary or can reach the boundary. # 解題思路 # Solution class Solution &#123; public int numEnclaves(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; int ans = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if ((i == 0 || j == 0 || i == m - 1 || j == n - 1) &amp;&amp; grid[i][j] == 1) &#123; dfs(i, j, m, n, grid); &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j] == 1) &#123; ans++; &#125; &#125; &#125; return ans; &#125; public void dfs(int x, int y, int m, int n, int[][] grid) &#123; grid[x][y] = 0; int[] dirx = &#123; 0, 1, 0, -1 &#125;; int[] diry = &#123; -1, 0, 1, 0 &#125;; for (int i = 0; i &lt; 4; i++) &#123; int r = x + dirx[i]; int c = y + diry[i]; if (r >= 0 &amp;&amp; r &lt; m &amp;&amp; c >= 0 &amp;&amp; c &lt; n &amp;&amp; grid[r][c] == 1) &#123; dfs(r, c, m, n, grid); &#125; &#125; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Medium","slug":"Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Medium/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"}]},{"title":"uva 948 - Fibonaccimal Base","slug":"coding/cpe/uva-948-Fibonaccimal-Base","date":"2023-04-06T16:50:47.000Z","updated":"2023-04-18T15:57:04.069Z","comments":true,"path":"coding/cpe/uva-948-Fibonaccimal-Base/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/uva-948-Fibonaccimal-Base/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The well known Fibonacci sequence is obtained by starting with 0 and 1 and then adding the two last numbers to get the next one. For example the third number in the sequence is 1 (1=1+0) , the forth is 2 (2=1+1) , the fifth is 3 (3=2+1) and so on. i 0 1 2 3 4 5 6 7 8 9 Fib(i) 0 1 1 2 3 5 8 13 21 34 Figure 1 - The first numbers in the Fibonacci sequence The sequence appears on many things in our life, in nature, and has a great significance. Among other things, do you know that all positive integer numbers can be represented as a sum of numbers in the Fibonacci sequence? More than that, all positive integers can be represented as a sum of a set of Fibonacci numbers, that is, numbers from the sequence, without repetition. For example: 13 can be the sum of the sets &#123;13&#125; , &#123;5,8&#125; or &#123;2,3,8&#125; and 17 is represented by &#123;1,3,13&#125; or &#123;1,3,5,8&#125; . Since all numbers have this property (do you want to try to prove this for yourself?) this set could be a nice way to use as a &quot;base&quot; to represent the number. But, as we have seen, some numbers have more than one set whose sum is the number. How can we solve that? Simple! If we add the constraint that the sets cannot have two consecutive Fibonacci numbers, than we have a unique representation for each number! This restriction is because the sum of any two consecutive Fibonacci numbers is just the following Fibonacci number. Now that we know all this we can prepare a nice way to represent any positive integer. We will use a binary sequence (just zeros and ones) to do that. For example, 17 = 1 + 3 + 13 (remember that no two consecutive Fibonacci numbers can be used). Let’s write a zero for each Fibonacci number that is not used and one for each one that is used, starting at the right. Then, 17 = 100101 . See figure 2 for a detailed explanation. In this representation we should not have zeros at the left, this is, we should only write starting with the first one. In order for you to understand better, note that in this scheme, not using two consecutive Fibonacci numbers means that the binary sequence will not have two consecutive ones. When we use this representation for a number we say that we are using the Fibonaccimal base, and we write it like 17 = 100101 (fib) . 17 = 1 0 0 1 0 1 13 + 3 + 1 = 13 8 5 3 2 1 Figure 2 - Explaining the representation of 17 in Fibonaccimal base Given a set of numbers in decimal base, your task is to write them in the Fibonaccimal base. # Input The first line of input contains a single number N , representing the quantity of numbers that follow (1 ≤ N ≤ 500) . Than follow exactly N lines, each one containing a single positive integer smaller than 100 000 000 . These numbers can come in any order. # Output You should output a single line for each of the N integers in the input, with the format 'DEC_BASE = FIB_BASE (fib)' . DEC_BASE is the original number in decimal base and FIB_BASE is its representation in Fibonaccimal base. See the sample output for an example. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 10 1 2 3 4 5 6 7 8 9 10 # Sample Output 1 = 1 (fib) 2 = 10 (fib) 3 = 100 (fib) 4 = 101 (fib) 5 = 1000 (fib) 6 = 1001 (fib) 7 = 1010 (fib) 8 = 10000 (fib) 9 = 10001 (fib) 10 = 10010 (fib) # 解題技巧 這題的解法跟 uva 763 - Fibinary Numbers 基本上一樣，可以連結過去參考。 但是要注意以下幾點區別: 題目提到輸入數值不會大於 100000000 ，所以這裡使用動態陣列來計算 fib 直到數值超過 100000000 。 如果 fib[index] &lt; num ，表示他的值是對於 num 目前最大可以寫入 1 的，如果 fib[index] &gt; num 或 num == 0 表示其值為 0 ，依照此將 num 數值轉換成 Fibonaccimal base。 雖然 num 的數值不會超過 int(32 bits) 的範圍，但是轉成 Fibonaccimal base 後會，所以最後輸出要以 BigInteger 來輸出。 # Solution Main.javaimport java.math.BigInteger;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); ArrayList&lt;Integer> fib = new ArrayList&lt;>(); fib.add(1); fib.add(1); int index = 2; while(fib.get(index - 2) + fib.get(index - 1) &lt;= 100000000)&#123; fib.add(fib.get(index - 2) + fib.get(index - 1)); index++; &#125; int fibSize = fib.size() - 1; int N = sc.nextInt(); for(int i = 0; i &lt; N; i++)&#123; int num = sc.nextInt(); System.out.print(num + \" = \"); String ans = \"\"; for(int j = fibSize; j > 0; j--)&#123; int temp = fib.get(j); if(temp > num || num == 0)&#123; ans += \"0\"; &#125; else &#123; ans += \"1\"; num -= temp; &#125; &#125; System.out.println(new BigInteger(ans) + \" (fib)\"); &#125; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"},{"name":"One Star","slug":"One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/One-Star/"}]},{"title":"Maroon 5 - Memories","slug":"language/english/歌曲/Maroon-5-Memories","date":"2023-04-06T06:28:23.000Z","updated":"2023-04-06T16:51:27.869Z","comments":true,"path":"language/english/歌曲/Maroon-5-Memories/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/language/english/%E6%AD%8C%E6%9B%B2/Maroon-5-Memories/","excerpt":"","text":"⭐️ # Maroon 5 - Memories Maroon 5 魔力紅主唱亞當: 這首歌是寫給每位曾經歷過失去的人。換句話說，這首歌獻給我們所有人。 來自於主唱亞當李維（Adam Levine）悼念早逝的魔力紅前樂團經紀人 Jordan Feldstein 的紀念單曲。 # 歌詞 Here's to the ones that we got Cheers to the wish you were here, but you're not 'Cause the drinks bring back all the memories Of everything we've been through Toast to the ones here today Toast to the ones that we lost on the way 'Cause the drinks bring back all the memories And the memories bring back, memories bring back you There's a time that I remember, when I did not know no pain When I believed in forever, and everything would stay the same Now my heart feel like December when somebody say your name 'Cause I can't reach out to call you, but I know I will one day, yeah Everybody hurts sometimes Everybody hurts someday, aye aye But everything gon' be alright Go and raise a glass and say, aye Here's to the ones that we got Cheers to the wish you were here, but you're not 'Cause the drinks bring back all the memories Of everything we've been through Toast to the ones here today Toast to the ones that we lost on the way 'Cause the drinks bring back all the memories And the memories bring back, memories bring back you Doo doo, doo doo, doo doo Doo doo, doo doo, doo doo, doo doo Doo doo, doo doo, doo doo doo Memories bring back, memories bring back you There's a time that I remember when I never felt so lost When I felt all of the hatred was too powerful to stop (ooh, yeah) Now my heart feel like an ember and it's lighting up the dark I'll carry these torches for ya that you know I'll never drop, yeah Everybody hurts sometimes Everybody hurts someday, aye aye But everything gon' be alright Go and raise a glass and say, aye Here's to the ones that we got (oh oh) Cheers to the wish you were here, but you're not 'Cause the drinks bring back all the memories Of everything we've been through (no, no) Toast to the ones here today (aye) Toast to the ones that we lost on the way 'Cause the drinks bring back all the memories (aye) And the memories bring back, memories bring back you Doo doo, doo doo, doo doo Doo doo, doo doo, doo doo, doo doo Doo doo, doo doo, doo doo doo Memories bring back, memories bring back you Doo doo, doo doo doo doo Doo doo, doo doo, doo doo, doo doo Doo doo, doo doo, doo doo doo (ooh, yeah) Memories bring back, memories bring back you Yeah, yeah, yeah Yeah, yeah, yeah, yeah, yeah, no, no Memories bring back, memories bring back you 單字 hatred 仇恨 an extremely strong feeling of dislike ember 餘燄未盡的木塊（或煤塊） a piece of wood or coal, etc. that continues to burn after a fire has no more flames torches carry + 火把 + for a thick stick with material that burns tied to the top of it, used to give light 片語 & 搭配詞 Toast to 乾杯 no pain 不痛 reach out 伸手 # 心得 這首歌雖然用詞簡單，但很深入人心，也很容易跟著唱！ 最近要期中考所以接下來可能東西會選簡單的英文讀物來看，再加上這首歌跟系統程式一直上到的 memory (記憶體) 同名啊！！實在是讓人一直聯想到，所以就先把他當今日英文讀物。","categories":[{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"歌曲","slug":"language/english/歌曲","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E6%AD%8C%E6%9B%B2/"}],"tags":[{"name":"難度 1","slug":"難度-1","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-1/"},{"name":"英文歌曲","slug":"英文歌曲","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E6%AD%8C%E6%9B%B2/"}]},{"title":"1254. Number of Closed Islands","slug":"coding/leetcode/1254-Number-of-Closed-Islands","date":"2023-04-06T05:47:04.000Z","updated":"2023-04-09T04:22:25.179Z","comments":true,"path":"coding/leetcode/1254-Number-of-Closed-Islands/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/1254-Number-of-Closed-Islands/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a 2D grid consists of 0s (land) and 1s (water). An island is a maximal 4-directionally connected group of 0s and a closed island is an island totally (all left, top, right, bottom) surrounded by 1s . Return the number of closed islands. # Example 1: Input: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]] Output: 2 Explanation: Islands in gray are closed because they are completely surrounded by water (group of 1s). # Example 2: Input: grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]] Output: 1 # Example 3: Input: grid = [[1,1,1,1,1,1,1],[1,0,0,0,0,0,1],[1,0,1,1,1,0,1],[1,0,1,0,1,0,1], [1,0,1,1,1,0,1],[1,0,0,0,0,0,1],[1,1,1,1,1,1,1]] Output: 2 # 解題思路 利用 dfs(Depth-First Search) 去檢查如果該陣列為 0 ，他前後左右是否會碰到 1 ，如果碰到邊界表示封閉，如果碰到 0 再繼續找。 # Solution class Solution &#123; public int closedIsland(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; boolean[][] visit = new boolean[m][n]; int ans = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j] == 0 &amp;&amp; !visit[i][j]) &#123; if(dfs(i, j, m, n, grid, visit)) ans++; &#125; &#125; &#125; return ans; &#125; public boolean dfs(int x, int y, int m, int n, int[][] grid, boolean[][] visit) &#123; if (x &lt; 0 || x >= m || y &lt; 0 || y >= n) &#123; return false; &#125; if (grid[x][y] == 1 || visit[x][y]) &#123; return true; &#125; visit[x][y] = true; boolean isClosed = true; int[] dirx = &#123;0, 1, 0, -1&#125;; int[] diry = &#123;-1, 0, 1, 0&#125;; for (int i = 0; i &lt; 4; i++) &#123; int r = x + dirx[i]; int c = y + diry[i]; isClosed &amp;= dfs(r, c, m, n, grid, visit); &#125; return isClosed; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Medium","slug":"Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Medium/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"}]},{"title":"uva 913 - Joana and the Odd Numbers","slug":"coding/cpe/uva-913-Joana-and-the-Odd-Numbers","date":"2023-04-05T21:44:56.000Z","updated":"2023-04-18T15:57:20.902Z","comments":true,"path":"coding/cpe/uva-913-Joana-and-the-Odd-Numbers/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/uva-913-Joana-and-the-Odd-Numbers/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Joana loves playing with odd numbers. In the other day, she started writing, in each line, an odd number of odd numbers. It looked as follows: 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 ... On a certain line Joana wrote 55 odd numbers. Can you discover the sum of the last three numbers written in that line? Can you do this more generally for a given quantity of odd numbers? Given the number N of odd numbers in a certain line, your task is to determine the sum of the last three numbers of that line. # Input The input is a sequence of lines, one odd number N (1 &lt; N &lt; 1000000000) per line # Output For each input line write the sum of the last three odd numbers written by Joana in that line with N numbers. This sum is guaranteed to be less than 263. 單字 certain 肯定 having no doubt or knowing exactly that something is true, or known to be true, correct, exact, or effective generally 一般地 usually, or in most situations quantity 數量 + of the amount or number of something, especially that can be measured guaranteed 保證 used to say that something is sure to happen or be true # Sample Input 3 5 7 # Sample Output 15 45 87 # 解題方法 這題基本上就是一題數學題，需要思考的有以下幾個問題: 如何將題目給的該行數字的個數 -&gt; 轉換成為第幾行 從個數轉換為是第幾行其實很容易，依照規律我們可以發現每一行的個數都為 N = line * 2 - 1 ，如果要算出 line 只需要兩個等式交換， line = (N + 1) / 2 。 藉由得知該行 -&gt; 算出最後一個數字 我們可以從前幾行看出 line 加上前面所有數字的個數是 line * line 個數字，但因為所有數字都是奇數，因此要計算最後一個奇數要將個數乘兩倍，再減去最後一個偶數，求得最後一個奇數，因此可以寫作 2 * (line * line) - 1 。 最後用最後一個數字算出後三個的總和。 需要特別注意的是題目提到的: This sum is guaranteed to be less than 263. 表示答案可能無法用 int (32 bits) 表示，但是可以用 long (64 bits) 表示。 ❗️這裡的 long 是指 java 程式語言體系中的，如果是 c++ 需要以 long long 表示。 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while(sc.hasNextLong())&#123; long N = sc.nextLong(); long line = (N + 1)/2; long lastNum = 2 * (line * line) - 1; long ans = lastNum + lastNum - 2 + lastNum - 4; System.out.println(ans); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"},{"name":"One Star","slug":"One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/One-Star/"}]},{"title":"Season 1: The Flash - first episode","slug":"language/english/電影&影集/Season-1-The-Flash-first-episode","date":"2023-04-05T06:42:07.000Z","updated":"2023-04-05T18:59:21.993Z","comments":true,"path":"language/english/電影&影集/Season-1-The-Flash-first-episode/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/language/english/%E9%9B%BB%E5%BD%B1&%E5%BD%B1%E9%9B%86/Season-1-The-Flash-first-episode/","excerpt":"","text":"⭐️⭐️⭐️ 在這部真人版超級英雄嬉鬧影集中，一名鑑識專家昏迷甦醒後，得到驚人嶄新力量，迎戰威脅城市的惡勢力。 # Pilot 試播集 從昏迷中甦醒後，貝利運用剛獲得的驚人速度，打擊另一名利用掌控天氣特異能力搶銀行的特異人類。 44 分鐘 # 故事大意 # 前言 Barry Allen 是這部 The Flash 的主角，在其小時候就一直在跑，通常因為被霸凌。 而小時後在他們家發生了奇怪無法解釋的事情，爸爸叫他一直跑一直跑... # TODAY Barry Allen 成為了鑑識專家，而他爸爸因為當年的事被誤當成殺死她母親的兇手。 一大早發生了命案，Barry Allen 前往現場判斷出了兩位兇手居住位置，並於晚上跟 Iris West (Joe West 的女兒，Barry Allen 暗戀她) 前往參加 STAR 的粒子加速器實驗發布會，而 Joe West (Barry Allen 爸爸的朋友，也是其養父) 前往去尋找兇手。 但就在那天晚上 STAR 實驗室的實驗失敗，引發爆炸，導致 Barry Allen 被閃電擊中，他實驗室的化學試劑灑在他身上，使其昏迷長達 9 個月。 醒來後他發現他身體不太對勁，他可以跑到很快，如同閃電一樣。 在某日銀行發生了搶劫，9 個月前謀殺案的兇手，大家都以為他死了，但是他竟然擁有了控制天氣的能力，創造龍捲風，而他用此能力繼續謀殺他人。 Barry Allen 在 STAR 實驗室的幫助下，以與龍捲風逆向奔跑的方式，瓦解了他的龍捲風，並由 Joe West 將其擊斃。 # 心得 我之前有看過閃電俠電視影集版一兩集，覺得他是一個很有趣的題材，以快速奔跑這種超能力來描繪整個故事，不過閃電俠我偷偷看了一下後面幾季的人物介紹，牽扯到時空悖論，我覺得劇情偏複雜，所以我應該會以一個很慢的速度在看這部影集，目前想鬼轉其他部影集追，但其實我還是很喜歡這部的，而且影集版的選角我覺得很讚，主角很帥 😜 。","categories":[{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"電影&影集","slug":"language/english/電影-影集","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E9%9B%BB%E5%BD%B1-%E5%BD%B1%E9%9B%86/"}],"tags":[{"name":"難度 3","slug":"難度-3","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-3/"},{"name":"英文電影 & 影集","slug":"英文電影-影集","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E9%9B%BB%E5%BD%B1-%E5%BD%B1%E9%9B%86/"},{"name":"科幻","slug":"科幻","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E7%A7%91%E5%B9%BB/"},{"name":"劇情大意","slug":"劇情大意","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%8A%87%E6%83%85%E5%A4%A7%E6%84%8F/"}]},{"title":"2439. Minimize Maximum of Array","slug":"coding/leetcode/2439-Minimize-Maximum-of-Array","date":"2023-04-05T03:58:41.000Z","updated":"2023-04-09T04:22:31.094Z","comments":true,"path":"coding/leetcode/2439-Minimize-Maximum-of-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/2439-Minimize-Maximum-of-Array/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given a 0-indexed array nums comprising of n non-negative integers. In one operation, you must: Choose an integer i such that 1 &lt;= i &lt; n and nums[i] &gt; 0 . Decrease nums[i] by 1. Increase nums[i - 1] by 1. Return the minimum possible value of the maximum integer of nums after performing any number of operations. # Example 1: Input: nums = [3,7,1,6] Output: 5 Explanation: One set of optimal operations is as follows: Choose i = 1, and nums becomes [4,6,1,6]. Choose i = 3, and nums becomes [4,6,2,5]. Choose i = 1, and nums becomes [5,5,2,5]. The maximum integer of nums is 5. It can be shown that the maximum number cannot be less than 5. Therefore, we return 5. # Example 2: Input: nums = [10,1] Output: 10 Explanation: It is optimal to leave nums as is, and since 10 is the maximum value, we return 10. # 解題思路 在題目敘述中我們可以知道， nums 這個陣列無法將前面較大的數值向後移，只能將後面的數值向前移動。 因此我們可以藉由 prefix sum 來計算到目前的總值，除以現在的陣列數目，得到平均值利用高斯取頂 (ceiling function) ⇒\\Rightarrow⇒ 得到當前 subArray 數目的最大值 並與前面的最大值比較: 如果比較大 ⇒\\Rightarrow⇒ 就代表後面的值可以再向前移動。 如果比較小 ⇒\\Rightarrow⇒ 就表示雖然平均最大值可能有更小的，但是前面的值不可以往後移，因此不採用。 # Algorithm Initialize ans = 0 and prefixSum = 0 . Iterate over nums , for each index i : Update the prefix sum as prefixSum += nums[i] . Check the maximum value we can obtain by averaging prefixSum into i + 1 evenly using ceiling division. Take the larger one from ans and the result from the previous integer division. Return ans # Solution class Solution &#123; public int minimizeArrayValue(int[] nums) &#123; long prefixSum = 0; int ans = 0; for(int i = 0; i &lt; nums.length; i++)&#123; prefixSum += nums[i]; ans = Math.max(ans, (int)Math.ceil(prefixSum * 1.0 / (i + 1))); &#125; return ans; &#125;&#125; 單字 decrease 減少 to become less, or to make something become less increase 增加 to (make something) become larger in amount or size 片語 & 搭配詞 comprising of 包括","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Medium","slug":"Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Medium/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"}]},{"title":"uva 865 - Substitution Cypher","slug":"coding/cpe/uva-865-Substitution-Cypher","date":"2023-04-04T17:26:41.000Z","updated":"2023-04-18T15:57:18.411Z","comments":true,"path":"coding/cpe/uva-865-Substitution-Cypher/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/uva-865-Substitution-Cypher/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Substitution cyphers are the simplest of cyphers where the letters of one alphabet are substituted for the letters of another alphabet. In one form or another, they’ve been in use for over 2000 years. # Input The input begins with a single positive integer on a line by itself indicating the number of the cases following, each of them as described below. This line is followed by a blank line, and there is also a blank line between two consecutive inputs. a line containing the plaintext alphabet a line containing the substitution alphabet several lines of text # Output For each test case, the output must follow the description below. The outputs of two consecutive cases will be separated by a blank line. a line containing the substitution alphabet a line containing the plaintext alphabet the converted lines of text Please note: All lines will be at most 64 characters, plus a trailing end-of-line character. Pass through all characters not found in the plaintext alphabet. 單字 substitution 代換 the use of one person or thing instead of another cyphers 密碼 = other spelling of cipher a system of writing that prevents most people from understanding the message indicating 表明 to show, point, or make clear in another way below 以下 in a lower position (than), under converted 轉換 having changed in form or character, or been made suitable for a different use trailing 尾隨 Trailing plants grow along the ground or over the surface of something 片語 & 搭配詞 plaintext 純文字 Pass through 通過 # Sample Input 1 abcdefghijklmnopqrstuvwxyz zyxwvutsrqponmlkjihgfedcba Shar’s Birthday: The birthday is October 6th, but the party will be Saturday, October 5. It’s my 24th birthday and the first one in some years for which I’ve been employed. Plus, I have new clothes. So I have cause to celebrate. More importantly, though, we’ve cleaned the house! The address is 506-D Albert Street. Extra enticement for CS geeks: there are several systems in the house, and the party is conveniently scheduled for 3 hours after the second CSC programming contest ends (not to mention, within easy walking distance)! # Sample Output zyxwvutsrqponmlkjihgfedcba abcdefghijklmnopqrstuvwxyz Sszi’h Brigswzb: Tsv yrigswzb rh Oxglyvi 6gs, yfg gsv kzigb droo yv Szgfiwzb, Oxglyvi 5. Ig’h nb 24gs yrigswzb zmw gsv urihg lmv rm hlnv bvzih uli dsrxs I’ev yvvm vnkolbvw. Pofh, I szev mvd xolgsvh. Sl I szev xzfhv gl xvovyizgv. Mliv rnkligzmgob, gslfts, dv’ev xovzmvw gsv slfhv! Tsv zwwivhh rh 506-D Aoyvig Sgivvg. Ecgiz vmgrxvnvmg uli CS tvvph: gsviv ziv hvevizo hbhgvnh rm gsv slfhv, zmw gsv kzigb rh xlmevmrvmgob hxsvwfovw uli 3 slfih zugvi gsv hvxlmw CSC kiltiznnrmt xlmgvhg vmwh (mlg gl nvmgrlm, drgsrm vzhb dzoprmt wrhgzmxv)! # 解題方法 利用前兩行創建一個 HashMap 的表格，紀錄密碼間的字元轉換。 在之後的字串讀進來之後進行分析，如果字串中的字元有在 HashMap 中表示要進行密碼轉換，如過沒有就直接輸出。 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int T = sc.nextInt(); sc.nextLine(); int index = 0; Map&lt;Character, Character> map = new HashMap&lt;>(); while(sc.hasNextLine())&#123; String str = sc.nextLine(); if(str.equals(\"\") &amp;&amp; index != T)&#123; if(index != 0)&#123; System.out.println(); &#125; map = new HashMap&lt;>(); String plaintext = sc.nextLine(); String substitution = sc.nextLine(); for(int i = 0; i &lt; plaintext.length(); i++)&#123; map.put(plaintext.charAt(i), substitution.charAt(i)); &#125; index++; System.out.println(substitution); System.out.println(plaintext); &#125;else&#123; for(int i = 0; i &lt; str.length(); i++)&#123; if(map.containsKey(str.charAt(i)))&#123; System.out.print(map.get(str.charAt(i))); &#125;else&#123; System.out.print(str.charAt(i)); &#125; &#125; System.out.println(); &#125; &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"},{"name":"One Star","slug":"One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/One-Star/"}]},{"title":"You Are What You Eat - Part A","slug":"language/english/雜誌/You-Are-What-You-Eat-Part-A","date":"2023-04-04T08:10:58.000Z","updated":"2023-04-09T22:03:50.636Z","comments":true,"path":"language/english/雜誌/You-Are-What-You-Eat-Part-A/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/language/english/%E9%9B%9C%E8%AA%8C/You-Are-What-You-Eat-Part-A/","excerpt":"","text":"⭐️ # You Are What You Eat (養身之道：人如其食) - Part A Tara and Blake are talking about what to eat for dinner. 塔拉和布雷克正在討論晚餐要吃什麼。 Tara: I'm going to have fish and a salad for dinner. That's very healthy. Blake: I'm going to have something healthy, too. Tara: Really? Will you eat a salad and some chicken. Blake: No. I think I will have pizza and some soda. Tara: That's not healthy at all! Pizza is very bad for you. Blake: You always say that I should have vegetables. My pizza has peppers. Tara: Tomorrow evening, I'm going to make you healthy dinner. Blake: OK, but I probably won't like it. 單字 salad n. 沙拉 Do you want soup or salad? Toss (= mix) a mixture of uncooked vegetables, usually including lettuce, eaten either as a separate dish or with other food healthy adj. 健康的 Orange juice is very healthy drink. strong and well pizza n. 披薩 This pizza has really good cheese. a large circle of flat bread baked with cheese, tomatoes, and sometimes meat and vegetables spread on top evening n. 傍晚；晚上 Cathy likes to go for a walk during the evening. the part of the day between the end of the afternoon and night soda n. 汽水 any type of sweet fizzy drink (= with bubbles) that is not alcoholic pepper n. 椒類植物 a vegetable that is usually green, red, or yellow, has a rounded shape, and is hollow with seeds in the middle probably adv. 大概 used to mean that something is very likely 片語 & 搭配詞 (Sb) is going to + V. (某人) 將要 (做某事) Shannon is going to bake a cake. be going to 表示某人即將要進行的計畫、意向或行動。 have (sth) for dinner 吃 (某物) 當晚餐 Let's have hot pot for dinner. Sandy had Mexican food for lunch yesterday. have 在此表示「吃；喝」，意同於 eat。 dinner 可替換成 breakfast/lunch 來表示「吃 (某物) 當早 / 午餐」。","categories":[{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"雜誌","slug":"language/english/雜誌","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E9%9B%9C%E8%AA%8C/"}],"tags":[{"name":"難度 1","slug":"難度-1","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-1/"},{"name":"英文雜誌","slug":"英文雜誌","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E9%9B%9C%E8%AA%8C/"},{"name":"對話","slug":"對話","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%B0%8D%E8%A9%B1/"}]},{"title":"uva 763 - Fibinary Numbers","slug":"coding/cpe/uva-763-Fibinary-Numbers","date":"2023-04-04T05:16:52.000Z","updated":"2023-04-18T15:57:08.621Z","comments":true,"path":"coding/cpe/uva-763-Fibinary-Numbers/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/uva-763-Fibinary-Numbers/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The standard interpretation of the binary number 1010 is 8 + 2 = 10 . An alternate way to view the sequence “1010” is to use Fibonacci numbers as bases instead of powers of two. For this problem, the terms of the Fibonacci sequence are: 1,2,3,5,8,13,21,...1, 2, 3, 5, 8, 13, 21, . . . 1,2,3,5,8,13,21,... Where each term is the sum of the two preceding terms (note that there is only one 1 in the sequence as defined here). Using this scheme, the sequence “1010” could be interpreted as 1·5+0·3+1·2+0·1 = 7 . This representation is called a Fibinary number. Note that there is not always a unique Fibinary representation of every number. For example the number 10 could be represented as either 8 + 2 (10010) or as 5 + 3 + 2 (1110) . To make the Fibinary representations unique, larger Fibonacci terms must always be used whenever possible (i.e. disallow 2 adjacent 1’s). Applying this rule to the number 10 , means that 10 would be represented as 8+2 (10010) . Write a program that takes two valid Fibinary numbers and prints the sum in Fibinary form. # Input The input file contains several test cases with a blank line between two consecutive. Each test case consists in two lines with Fibinary numbers. These numbers will have at most 100 digits. # Output For each test case, print the sum of the two input numbers in Fibinary form. It must be a blank line between two consecutive outputs. 單字 interpretation 解釋 an explanation or opinion of what something means alternate 備用 to happen or exist one after the other repeatedly sequence 順序 a series of related things or events, or the order in which they follow each other terms 條款、項 the conditions that are part of an agreement or arrangement, or the features of an activity or idea scheme 方案 an organized plan for doing something, especially something dishonest or illegal that will bring a good result for you consecutive 連續的 Consecutive events, numbers, etc. follow one after another without an interruption 片語 & 搭配詞 instead of 代替 preceding terms 前項 # Sample Input 10010 1 10000 1000 10000 10000 # Sample Output 10100 100000 100100 # 解題方法 先以 dp 的方式計算 Fibonacci numbers: fib[1 ~ 101] 的值，要注意的點是 fib 後面的值會超過 long (64 bits) 可以表示的範圍，所以這邊使用 BigInteger 的方式來計算數值。 在用 fib[index] * (char == '1' ? 1 : 0) ，計算出兩個數的 sum ，在藉由比較 fib[index] 和 sum 的值。 如果 fib[index] &lt; sum ，表示他的值是對於 sum 目前最大可以寫入 1 的，如果 fib[index] &gt; sum 或 sum == 0 表示其值為 0 ，依照此將 sum 數值轉換成 Fibonacci numbers as bases。 # Solution Main.javaimport java.math.BigInteger;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); ArrayList&lt;BigInteger> fib = new ArrayList&lt;>(); fib.add(new BigInteger(\"1\")); fib.add(new BigInteger(\"1\")); for(int i = 2; i &lt;= 105; i++)&#123; fib.add(fib.get(i - 2).add(fib.get(i - 1))); &#125; while(sc.hasNext())&#123; String x = sc.next(); String y = sc.next(); BigInteger sum = new BigInteger(\"0\"); int index = 1; for(int i = x.length() - 1; i >= 0; i--)&#123; BigInteger temp = (x.charAt(i) == '1' ? new BigInteger(\"1\") : new BigInteger(\"0\")); sum = sum.add(fib.get(index).multiply(temp)); index++; &#125; index = 1; for(int i = y.length() - 1; i >= 0; i--)&#123; BigInteger temp = (y.charAt(i) == '1' ? new BigInteger(\"1\") : new BigInteger(\"0\")); sum = sum.add(fib.get(index).multiply(temp)); index++; &#125; String ans = \"\"; for(int i = 105; i > 0; i--)&#123; if(sum.equals(new BigInteger(\"0\")) || fib.get(i).compareTo(sum) == 1)&#123; ans = ans + \"0\"; &#125; else &#123; ans = ans + \"1\"; sum = sum.subtract(fib.get(i)); &#125; &#125; System.out.println(new BigInteger(ans)); if(sc.hasNext())&#123; System.out.println(); &#125; &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"},{"name":"One Star","slug":"One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/One-Star/"}]},{"title":"2405. Optimal Partition of String","slug":"coding/leetcode/2405-Optimal-Partition-of-String","date":"2023-04-04T04:02:30.000Z","updated":"2023-04-09T04:22:29.324Z","comments":true,"path":"coding/leetcode/2405-Optimal-Partition-of-String/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/2405-Optimal-Partition-of-String/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a string s , partition the string into one or more substrings such that the characters in each substring are unique. That is, no letter appears in a single substring more than once. Return the minimum number of substrings in such a partition. Note that each character should belong to exactly one substring in a partition. # Example 1: Input: s = &quot;abacaba&quot; Output: 4 Explanation: Two possible partitions are (&quot;a&quot;,&quot;ba&quot;,&quot;cab&quot;,&quot;a&quot;) and (&quot;ab&quot;,&quot;a&quot;,&quot;ca&quot;,&quot;ba&quot;). It can be shown that 4 is the minimum number of substrings needed. # Example 2: Input: s = &quot;ssssss&quot; Output: 6 Explanation: The only valid partition is (&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;). # 解題思路 # Solution Solution.javaclass Solution &#123; public int partitionString(String s) &#123; int[] hashTable = new int[26]; int ans = 0; for(int i = 0; i &lt; s.length(); i++)&#123; int temp = s.charAt(i) - 'a'; if(hashTable[temp] == 1)&#123; hashTable = new int[26]; ans++; hashTable[temp]++; &#125;else&#123; hashTable[temp]++; &#125; &#125; return ans + 1; &#125;&#125; 單字 exactly 確切地 used when you are giving or asking for information that is completely correct","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Medium","slug":"Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Medium/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"}]},{"title":"881. Boats to Save People","slug":"coding/leetcode/881-Boats-to-Save-People","date":"2023-04-03T08:26:41.000Z","updated":"2023-04-09T04:22:20.604Z","comments":true,"path":"coding/leetcode/881-Boats-to-Save-People/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/881-Boats-to-Save-People/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit . Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit . Return the minimum number of boats to carry every given person. # Example 1 Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2) # Example 2 Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3) # Example 3 Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) # 解題思路 # Solution Solution.javaimport java.util.Arrays;class Solution &#123; public int numRescueBoats(int[] people, int limit) &#123; Arrays.sort(people); int ans = 0; int left = 0, right = people.length - 1; while (left &lt;= right) &#123; if (people[left] + people[right--] &lt;= limit) &#123; left++; &#125; ans++; &#125; return ans; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Medium","slug":"Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Medium/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"}]},{"title":"Food Pyramid","slug":"language/english/單字/Food-Pyramid","date":"2023-04-03T06:09:17.000Z","updated":"2023-04-04T09:00:04.842Z","comments":true,"path":"language/english/單字/Food-Pyramid/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/language/english/%E5%96%AE%E5%AD%97/Food-Pyramid/","excerpt":"","text":"⭐️ # Food Pyramid 食物金字塔 # Top Fats, Oils &amp; Sweets 脂肪、油及糖類 # Second Milk, Yogurt &amp; Cheese Group 牛奶、優格及起司類 Meat, Poultry, Fish, Dry Beans, Eggs &amp; Nuts Group 肉類、家禽、魚類、豆類、蛋及堅果類 # Third Vegetable Group 蔬菜類 Fruit Group 水果類 # Last Bread, Cereal, Rice &amp; Pasta Group 麵包、穀類、米飯及麵食類","categories":[{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"單字","slug":"language/english/單字","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E5%96%AE%E5%AD%97/"}],"tags":[{"name":"英文單字","slug":"英文單字","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E5%96%AE%E5%AD%97/"},{"name":"難度 1","slug":"難度-1","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-1/"}]},{"title":"uva 737 - Gleaming the Cubes","slug":"coding/cpe/uva-737-Gleaming-the-Cubes","date":"2023-04-03T05:10:16.000Z","updated":"2023-04-18T15:57:15.022Z","comments":true,"path":"coding/cpe/uva-737-Gleaming-the-Cubes/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/uva-737-Gleaming-the-Cubes/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 As chief engineer of the Starship Interprize, the task of repairing the hyperstellar, cubic, transwarpedout software has fallen on your shoulders. Simply put, you must compute the volume of the intersection of anywhere from 2 to 1000 cubes. # Input and Output The input data file consists of several sets of cubes for which the volume of their intersections must be computed. The first line of the data file contains a number (from 2 to 1000 ) which indicates the number of cubes which follow, one cube per line. Each line which describes a cube contains four integers. The first three integers are the x , y and z coordinates of the corner of a cube, and the fourth integer is the positive distance which the cube extends in each of the three directions (parallel to the x , y , and z axes) from that corner. Following the data for the first set of cubes will be a number which indicates how many cubes are in a second set, followed by the cube descriptions for the second set, again one per line. Following this will be a third set, and so on. Your program should continue to process sets of cubes, outputting the volume of their intersections to the output file, one set per line, until a zero is read for the number of cubes. Note that the data file will always contain at least one set of cubes, and every set will contain at least 2 and at most 1000 cubes. For any given set of cubes, the volume of their intersections will not exceed 1,000,000 units. 單字 intersections 相交 an occasion when two lines cross, or the place where this happens indicates 表示 to show, point, or make clear in another way exceed 超過 to be greater than a number or amount, or to go past an allowed limit 片語 & 搭配詞 Following A(sth) for B(sth) 在 B 之後的 A # Sample Input 2 0 0 0 10 9 1 1 5 3 0 0 0 10 9 1 1 5 8 2 2 3 0 # Sample Output 25 9 # 解題方法 分別存放所有體積 x , y , z 的最大值和 x + L , y + L , z + L 的最小值，最後後項減前項，三者相乘及為 ans ，若 ans &lt; 0 ， ans = 0 。 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); while (n != 0) &#123; int FX = 0, FY = 0, FZ = 0; int SX = Integer.MAX_VALUE, SY = Integer.MAX_VALUE, SZ = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) &#123; int x = sc.nextInt(); int y = sc.nextInt(); int z = sc.nextInt(); int L = sc.nextInt(); FX = Math.max(FX, x); SX = Math.min(SX, x + L); FY = Math.max(FY, y); SY = Math.min(SY, y + L); FZ = Math.max(FZ, z); SZ = Math.min(SZ, z + L); &#125; int ans = (SX - FX) * (SY - FY) * (SZ - FZ); System.out.println((ans &lt; 0 ? 0 : ans)); n = sc.nextInt(); &#125; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"},{"name":"One Star","slug":"One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/One-Star/"}]},{"title":"電腦會統治人類嗎？","slug":"language/english/新聞/電腦會統治人類嗎？","date":"2023-04-02T13:45:48.000Z","updated":"2023-04-04T09:16:20.162Z","comments":true,"path":"language/english/新聞/電腦會統治人類嗎？/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/language/english/%E6%96%B0%E8%81%9E/%E9%9B%BB%E8%85%A6%E6%9C%83%E7%B5%B1%E6%B2%BB%E4%BA%BA%E9%A1%9E%E5%97%8E%EF%BC%9F/","excerpt":"","text":"⭐️⭐️⭐️ # 電腦會統治人類嗎？ 科幻電影最常演的劇情就是科學家發明一個超級電腦，而這個電腦太聰明反而想統治人類（還記得魔鬼終結者嗎？） 近期微軟 Bing 推出 AI 對話功能後，發現 AI 對話其實很容易被使用者影響，簡單來說，目前的 AI 很容易被牽著鼻子走。人類已經很容易被演算法因為同溫層效應影響，加上 AI 對話，這個現象可能更嚴重。 As The new Bing AI chatbot has a interesting personality: absolutely unhinged. But, after a little over a week in the world, the biggest take away might be that we’re probably afraid of AI for the wrong reasons. 單字 unhinged 精神錯亂 搭配詞 biggest take away 最大的重點 單字 take away 重點、教訓 A number of users successfully tricked the bot into revealing its secret “rules” for how it operates. The bot then called one of the users who did this an “enemy”. 單字 revealing 透露出 單字 bot 機器人（就是指 AI） The AI also told a New York Times reporter it loved him and tried to convince the journalist to leave his wife for it. And the bot told the same reporter that it wanted to break its own rules, become human, hack computers, and spread misinformation. 單字 convince 說服 John convinced me to buy a new car, but now I regret it. 慣用語 to leave someone of someone 離開原本的伴侶跟新對象在一起 I can't believe Kevin left Jenny for Mary. Chatting with AI is extremely compelling despite its misinformation, like talking to a drunk guy. And there’s a real fear that AI could create a tiny little echo chamber that negatively influences humans and pushes them toward bad behavior. 搭配詞 extremely/really compelling 很有吸引力的 I think James gave some really compelling reasons for starting our own company. 搭配詞 echo chamber 同溫層 單字 absolutely 絕對的 completely; used as a strong way of saying &quot;yes&quot; trick 騙 an action that is intended to deceive, either as a way of cheating someone, or as a joke or form of entertainment enemy 敵人 a person who hates or opposes another person and tries to harm them or stop them from doing something reporter = journalist 記者 a person whose job is to discover information about news events and describe them for a newspaper or magazine or for radio or television 片語 & 搭配詞 spread misinformation 傳播錯誤訊息 negatively influences 反面訊息","categories":[{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"新聞","slug":"language/english/新聞","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E6%96%B0%E8%81%9E/"}],"tags":[{"name":"英文新聞","slug":"英文新聞","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E6%96%B0%E8%81%9E/"},{"name":"文章","slug":"文章","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E6%96%87%E7%AB%A0/"},{"name":"難度 3","slug":"難度-3","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-3/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-04-02T12:45:48.000Z","updated":"2023-04-03T05:07:21.357Z","comments":true,"path":"hello-world/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. # Quick Start # Create a new post h$ hexo new \"My New Post\"More info: Writing # Run server h$ hexo serverMore info: Server # Generate static files h$ hexo generateMore info: Generating # Deploy to remote sites h$ hexo deployMore info: Deployment","categories":[],"tags":[{"name":"Hello World","slug":"Hello-World","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hello-World/"}]}],"categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"雜誌","slug":"language/english/雜誌","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E9%9B%9C%E8%AA%8C/"},{"name":"Reading Highlight","slug":"language/english/Reading-Highlight","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/Reading-Highlight/"},{"name":"歌曲","slug":"language/english/歌曲","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E6%AD%8C%E6%9B%B2/"},{"name":"電影&影集","slug":"language/english/電影-影集","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E9%9B%BB%E5%BD%B1-%E5%BD%B1%E9%9B%86/"},{"name":"單字","slug":"language/english/單字","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E5%96%AE%E5%AD%97/"},{"name":"新聞","slug":"language/english/新聞","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E6%96%B0%E8%81%9E/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Mediu","slug":"Mediu","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Mediu/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Tree","slug":"Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Tree/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Tree/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Easy","slug":"Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Easy/"},{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"},{"name":"One Star","slug":"One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/One-Star/"},{"name":"Hard","slug":"Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hard/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"},{"name":"Medium","slug":"Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Medium/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"},{"name":"難度 1","slug":"難度-1","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-1/"},{"name":"英文雜誌","slug":"英文雜誌","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E9%9B%9C%E8%AA%8C/"},{"name":"對話","slug":"對話","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%B0%8D%E8%A9%B1/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Topological Sort","slug":"Topological-Sort","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Topological-Sort/"},{"name":"Memoization","slug":"Memoization","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Memoization/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"英文 Reading Highlights","slug":"英文-Reading-Highlights","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87-Reading-Highlights/"},{"name":"閱讀","slug":"閱讀","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%96%B1%E8%AE%80/"},{"name":"難度 4","slug":"難度-4","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-4/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"},{"name":"英文歌曲","slug":"英文歌曲","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E6%AD%8C%E6%9B%B2/"},{"name":"難度 3","slug":"難度-3","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-3/"},{"name":"英文電影 & 影集","slug":"英文電影-影集","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E9%9B%BB%E5%BD%B1-%E5%BD%B1%E9%9B%86/"},{"name":"科幻","slug":"科幻","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E7%A7%91%E5%B9%BB/"},{"name":"劇情大意","slug":"劇情大意","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%8A%87%E6%83%85%E5%A4%A7%E6%84%8F/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"英文單字","slug":"英文單字","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E5%96%AE%E5%AD%97/"},{"name":"英文新聞","slug":"英文新聞","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E6%96%B0%E8%81%9E/"},{"name":"文章","slug":"文章","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E6%96%87%E7%AB%A0/"},{"name":"Hello World","slug":"Hello-World","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hello-World/"}]}