{"meta":{"title":"","subtitle":"We are the dreamers. We make it happen 'cause we can see it.","description":"謝謝你來，謝謝你還在","author":"Hsing Yu","url":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io","root":"/"},"pages":[{"title":"Hello!","date":"2023-09-28T09:29:55.734Z","updated":"2023-09-28T09:29:55.734Z","comments":true,"path":"about/index.html","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/about/index.html","excerpt":"","text":"# Hsing Yu 陳幸妤 在努力學習各種技術，完成所有夢想與理想，成為自己的那曙光！ 路漫漫其修遠兮， 吾將上下而求索。 每日目標 leetcode 1 題 CPE 3 題 英文 1 篇 這個網站目前是為了督促我自己養成讀英文跟寫程式的習慣，之後會再寫一些整理的技術或我在學的一些東西。 # 簡介 性別：女 生日: 2003/02/12 星座：水瓶座 興趣：排球、美術設計、書法 專長：游泳、機器人、資訊工程 (人工智慧、網頁) # 經歷 國立彰化女子高級中學 國立台中教育大學 資訊工程學系 (特殊選材) # 比賽 &amp; 獎項 2018 全國智能車挑戰賽 2018-2019 FIRST 機器人大賽台灣選拔賽 — 研究品質獎全國第一名 (作品：太空中的家鄉味) 彰化縣 108 學年教育盃機器人競賽 — 高中競賽組佳作 2019 WRO 中南區賽高中競賽組 (機器人計分 / 計時賽) 2019 WRO 國際奧林匹亞機器人全國總決賽 — 高中創意組佳作 (作品：AI 智能交通小幫手) 台灣青年黑客松 6th — APP 組 (作品：防疫下的共享經濟) 2020 AI 智慧應用新世代人才培育計畫 高中職生 AI 扎根系列活動 AI 線上課程、AI 實作一日營 綜合表現卓越 (全台成績前 80) 高中職生 AI 扎根系列活動 AI 實作一日營 表現傑出 (實作 AWS DeepRacer 成績前 4) 2022 NCPC 全國大專電腦軟體設計競賽初賽 2022 國立台中教育大學 菁英獎 2023 TOPC - ICPC Asia Taiwan Online Programming Contest 2023 ITSA 初賽 # 各種檢定 2023 CPE: 4 題 # 專案經歷 2021 彰化縣資優生報考系統 2021 彰化高中學生會選舉投票系統 2021 國立馬祖高級中學網站 2021~ 至今 國教署 Q&amp;A 系統 2022~ 至今 台中教育大學資工系網站 =&gt; 主要負責網路管理 / 系統維護 2023.02~ 至今 進階程式設計課程自動評分系統 - 專案負責人 (撰寫程式中) =&gt; 整體專案 2023.06 MyJob 工作排成網站 2023.06~ 至今 即時通訊服務研析暨開發委託研究案 / 學校產學合作專案 (進行中) 2023.07 項目管理系統 # 參與團隊 2019~2020 國立彰化女子高級中學 電腦研習社 (機器人組與軟程組) - 社長 2019~ 至今 彰化資訊志工隊 - 隊員 2021~ 至今 國立台中教育大學空手道社 - 社員 2021~2023 國立台中教育大學資工系女子排球隊 - 副隊長 2023.07~2023.08 上海電腦軟體技術開發中心 - 軟體開發實習生 2023~ 至今 國立台中教育大學白帽社 - 社員 # 活動經歷 講師 2021 鹿鳴國中假日班 Webduino 課程 2021~2022 彰化女中學期課後程式加強課程 C++ 程式語言 2022 國立馬祖高中、桃園市立新屋高中 新興科技認知推廣計畫 - VR 體驗活動 2022 國立台中教育大學「程式戰鬥營」教學 C 程式語言 2023 國立南投高級商業職業學校 新興科技認知推廣計畫 - VR 體驗活動 主辦人 彰化女中 2019、2020 C++ 寒暑假研習課 (共 6 場)、學期課後程式加強課程 主辦人、課堂協助指導 2020 彰中彰女電研聯合寒訓 主辦人、課堂協助指導 2021 舉辦大成國中寒假資訊科學營隊 協助教導 2019、2020 國中生機器人學園 (共 2 場) 2021 草湖國中寒假營隊 2022 芬園國中寒假營隊 學習探討 2020 高中人才培育計畫交大人工智慧與深度學習 (學習 AI 和深度學習的演進，機器學習的定義，線性模型推廣淺層神經網路，如何訓練神經網路) 2020Ewant 高中自主學習 交大生活中的機器人科技 (學習機器人的發展及未來應用) 結業成績: 98 2020 高中職生 AI 扎根系列活動 (學習 AI 基礎知識與實作 AWS DeepRacer) 2020 教育部資訊安全人才培育計畫 (學習 Linux、基礎資安分析實務、基礎程式逆向工程) 參與活動 2020 SITCON 學生計算機年會 # 目標待完成 CPE: 7 題 托福 iBT 考試：達標 參加 ICPC 得名 參加 ITSA 全國大專程式設計極客挑戰 得名 出國讀書 # 待續..."}],"posts":[{"title":"905. Sort Array By Parity","slug":"coding/leetcode/Easy/905-Sort-Array-By-Parity","date":"2023-09-28T04:44:20.000Z","updated":"2023-09-28T08:18:58.460Z","comments":true,"path":"coding/leetcode/Easy/905-Sort-Array-By-Parity/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/905-Sort-Array-By-Parity/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer array nums , move all the even integers at the beginning of the array followed by all the odd integers. Return any array that satisfies this condition. # Example 1 Input: nums = [3,1,2,4] Output: [2,4,3,1] Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. # Example 2 Input: nums = [0] Output: [0] # 解題思路 用 for 迴圈遍歷 int[] nums 利用 deque 資料結構 若遇到數值為偶數的，利用 addFirst() 至於 deque 前面 若遇到數值為奇數的，利用 addLast() 至於 deque 後面 最後將 deque 轉成 int[] 輸出 註記: 將 LinkedList&lt;&gt; 轉成 int[] 陣列輸出為答案 list.stream().mapToInt(Integer::intValue).toArray(); queue.stream().mapToInt(Integer::intValue).toArray(); deque.stream().mapToInt(Integer::intValue).toArray(); # Solution import java.util.Deque;import java.util.LinkedList;class Solution &#123; public int[] sortArrayByParity(int[] nums) &#123; Deque&lt;Integer> dq = new LinkedList&lt;>(); for(int num : nums)&#123; if(num % 2 == 0)&#123; dq.addFirst(num); &#125;else&#123; dq.addLast(num); &#125; &#125; return dq.stream().mapToInt(Integer::intValue).toArray(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"}]},{"title":"458 - The Decoder","slug":"coding/cpe/One Star/458-The-Decoder","date":"2023-09-27T13:59:39.000Z","updated":"2023-09-27T17:17:07.168Z","comments":true,"path":"coding/cpe/One Star/458-The-Decoder/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/458-The-Decoder/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Write a complete program that will correctly decode a set of characters into a valid message. Your program should read a given file of a simple coded set of characters and print the exact message that the characters contain. The code key for this simple coding is a one for one character substitution based upon a single arithmetic manipulation of the printable portion of the ASCII character set. # Input &amp; Output For example: with the input file that contains: 1JKJ'pz'{ol'{yhklthyr'vm'{ol'Jvu{yvs'Kh{h'Jvywvyh{pvu5 1PIT'pz'h'{yhklthyr'vm'{ol'Pu{lyuh{pvuhs'I|zpulzz'Thjopul'Jvywvyh{pvu5 1KLJ'pz'{ol'{yhklthyr'vm'{ol'Kpnp{hs'Lx|pwtlu{'Jvywvyh{pvu5 your program should print the message: *CDC is the trademark of the Control Data Corporation. *IBM is a trademark of the International Business Machine Corporation. *DEC is the trademark of the Digital Equipment Corporation. Your program should accept all sets of characters that use the same encoding scheme and should print the actual message of each set of characters. # Sample Input 1JKJ'pz'{ol'{yhklthyr'vm'{ol'Jvu{yvs'Kh{h'Jvywvyh{pvu5 1PIT'pz'h'{yhklthyr'vm'{ol'Pu{lyuh{pvuhs'I|zpulzz'Thjopul'Jvywvyh{pvu5 1KLJ'pz'{ol'{yhklthyr'vm'{ol'Kpnp{hs'Lx|pwtlu{'Jvywvyh{pvu5 # Sample Output *CDC is the trademark of the Control Data Corporation. *IBM is a trademark of the International Business Machine Corporation. *DEC is the trademark of the Digital Equipment Corporation. # 解題技巧 這題也挺簡單的，相信直覺。 # Solution Main.c#include &lt;stdio.h>int main()&#123; char ch; while (scanf(\"%c\", &amp;ch) == 1)&#123; if (ch != '\\n') printf(\"%c\", ch - ('J' - 'C')); else printf(\"\\n\"); &#125; return 0;&#125; Main.cpp#include &lt;bits/stdc++.h>using namespace std;int main()&#123; string str; while(getline(cin, str))&#123; for(int i = 0; i &lt; str.length(); i++)&#123; cout &lt;&lt; (char)(str[i] - ('J' - 'C')); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; Main.javaimport java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;public class Main &#123; public static void main(String[] args) throws IOException &#123; DataInputStream in = new DataInputStream(System.in); DataOutputStream output = new DataOutputStream(System.out); int c; while ((c = in.read()) != -1) &#123; if (c == 10) &#123; output.write('\\n'); &#125; else &#123; output.write(c - 7); &#125; &#125; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"880. Decoded String at Index","slug":"coding/leetcode/Medium/880-Decoded-String-at-Index","date":"2023-09-27T13:00:06.000Z","updated":"2023-09-27T13:57:34.594Z","comments":true,"path":"coding/leetcode/Medium/880-Decoded-String-at-Index/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/880-Decoded-String-at-Index/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an encoded string s . To decode the string to a tape, the encoded string is read one character at a time and the following steps are taken: If the character read is a letter, that letter is written onto the tape. If the character read is a digit d , the entire current tape is repeatedly written d - 1 more times in total. Given an integer k , return the kth letter (1-indexed) in the decoded string. # Example 1 Input: s = &quot;leet2code3&quot;, k = 10 Output: &quot;o&quot; Explanation: The decoded string is &quot;leetleetcodeleetleetcodeleetleetcode&quot;. The 10th letter in the string is &quot;o&quot;. # Example 2 Input: s = &quot;ha22&quot;, k = 5 Output: &quot;h&quot; Explanation: The decoded string is &quot;hahahaha&quot;. The 5th letter is &quot;h&quot;. # Example 3 Input: s = &quot;a2345678999999999999999&quot;, k = 1 Output: &quot;a&quot; Explanation: The decoded string is &quot;a&quot; repeated 8301530446056247680 times. The 1st letter is &quot;a&quot;. # 解題思路 # Solution class Solution &#123; public String decodeAtIndex(String s, int k) &#123; long decodedLength = 0; for (char c : s.toCharArray()) &#123; if (Character.isDigit(c)) &#123; decodedLength *= (c - '0'); &#125; else &#123; decodedLength++; &#125; &#125; for (int i = s.length() - 1; i >= 0; i--) &#123; char currChar = s.charAt(i); if (Character.isDigit(currChar)) &#123; decodedLength /= (currChar - '0'); k %= decodedLength; &#125; else &#123; if (k == 0 || decodedLength == k) &#123; return String.valueOf(currChar); &#125; decodedLength--; &#125; &#125; return \"\"; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"}]},{"title":"455 - Periodic Strings","slug":"coding/cpe/One Star/455-Periodic-Strings","date":"2023-09-26T05:36:23.000Z","updated":"2023-09-26T08:08:37.817Z","comments":true,"path":"coding/cpe/One Star/455-Periodic-Strings/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/455-Periodic-Strings/","excerpt":"","text":"🌕🌗🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 A character string is said to have period k if it can be formed by concatenating one or more repetitions of another string of length k . For example, the string ”abcabcabcabc” has period 3 , since it is formed by 4 repetitions of the string ”abc” . It also has periods 6 (two repetitions of ”abcabc” ) and 12 (one repetition of ”abcabcabcabc” ). Write a program to read a character string and determine its smallest period. # Input The first line oif the input file will contain a single integer N indicating how many test case that your program will test followed by a blank line. Each test case will contain a single character string of up to 80 non-blank characters. Two consecutive input will separated by a blank line. # Output An integer denoting the smallest period of the input string for each input. Two consecutive output are separated by a blank line. # Sample Input 1 HoHoHo # Sample Output 2 # 解題技巧 暴力解，利用擷取 substring 然後再重新組裝 time = inputstring.length() / substring.length() 次，當 inputstring 與重新組裝的字串相同就表示 substring 為 inputstring 重複的字串，而 substring.length() 及為答案。 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); for (int i = 0; i &lt; N; i++) &#123; String str = sc.next(); if (i != 0) System.out.println(); int len = str.length(); for (int j = 0; j &lt; len; j++) &#123; int subLen = j + 1; if(len % subLen != 0) continue; String subStr = str.substring(0, subLen); int time = len / subLen; String compare = \"\"; for(int k = 0; k &lt; time; k++)&#123; compare += subStr; &#125; if(compare.equals(str))&#123; System.out.println(subLen); break; &#125; &#125; &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"316. Remove Duplicate Letters","slug":"coding/leetcode/Medium/316-Remove-Duplicate-Letters","date":"2023-09-26T03:48:36.000Z","updated":"2023-09-26T04:35:02.284Z","comments":true,"path":"coding/leetcode/Medium/316-Remove-Duplicate-Letters/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/316-Remove-Duplicate-Letters/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a string s , remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Lexicographically Smaller A string a is lexicographically smaller than a string b if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. If the first min(a.length, b.length) characters do not differ, then the shorter string is the lexicographically smaller one. # Example 1 Input: s = &quot;bcabc&quot; Output: &quot;abc&quot; # Example 2 Input: s = &quot;cbacdcbc&quot; Output: &quot;acdb&quot; # 解題思路 # Solution import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Set;import java.util.Stack;public class Solution &#123; public String removeDuplicateLetters(String s) &#123; Stack&lt;Character> stack = new Stack&lt;>(); Set&lt;Character> inStack = new HashSet&lt;>(); Map&lt;Character, Integer> lastCharIdx = new HashMap&lt;>(); for (int i = 0; i &lt; s.length(); i++) &#123; lastCharIdx.put(s.charAt(i), i); &#125; // get and save the last index with the char for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); if (!inStack.contains(c)) &#123; while (!stack.isEmpty() &amp;&amp; c &lt; stack.peek() &amp;&amp; i &lt; lastCharIdx.get(stack.peek())) &#123; inStack.remove(stack.pop()); &#125; // i &lt; lastCharIdx.get(stack.peek()) mean if stack.pop() value has next at behind we can remove that value. inStack.add(c); stack.push(c); &#125; &#125; StringBuilder ans = new StringBuilder(); for (char c : stack) &#123; ans.append(c); &#125; return ans.toString(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"},{"name":"Monotonic Stack","slug":"Monotonic-Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Monotonic-Stack/"}]},{"title":"389. Find the Difference","slug":"coding/leetcode/Easy/389-Find-the-Difference","date":"2023-09-25T15:09:56.000Z","updated":"2023-09-25T15:32:46.804Z","comments":true,"path":"coding/leetcode/Easy/389-Find-the-Difference/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/389-Find-the-Difference/","excerpt":"","text":"⭐️ # 題目敘述 You are given two strings s and t . String t is generated by random shuffling string s and then add one more letter at a random position. Return the letter that was added to t . # Example 1 Input: s = &quot;abcd&quot;, t = &quot;abcde&quot; Output: &quot;e&quot; Explanation: 'e' is the letter that was added. # Example 2 Input: s = &quot;&quot;, t = &quot;y&quot; Output: &quot;y&quot; # 解題思路 # Solution class Solution &#123; public char findTheDifference(String s, String t) &#123; char ans = 0; for(char c : s.toCharArray()) ans ^= c; for(char c : t.toCharArray()) ans ^= c; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bit-Manipulation/"}]},{"title":"409 - Excuses, Excuses!","slug":"coding/cpe/One Star/409-Excuses-Excuses","date":"2023-09-24T11:52:55.000Z","updated":"2023-09-27T14:14:29.120Z","comments":true,"path":"coding/cpe/One Star/409-Excuses-Excuses/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/409-Excuses-Excuses/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Judge Ito is having a problem with people subpoenaed for jury duty giving rather lame excuses in order to avoid serving. In order to reduce the amount of time required listening to goofy excuses, Judge Ito has asked that you write a program that will search for a list of keywords in a list of excuses identifying lame excuses. Keywords can be matched in an excuse regardless of case. # Input Input to your program will consist of multiple sets of data. Line 1 of each set will contain exactly two integers. The first number (1 ≤ K ≤ 20) defines the number of keywords to be used in the search. The second number (1 ≤ E ≤ 20) defines the number of excuses in the set to be searched. Lines 2 through K + 1 each contain exactly one keyword. Lines K + 2 through K + 1 + E each contain exactly one excuse. All keywords in the keyword list will contain only contiguous lower case alphabetic characters of length L(1 ≤ L ≤ 20) and will occupy columns 1 through L in the input line. All excuses can contain any upper or lower case alphanumeric character, a space, or any of the following punctuation marks [&quot;.,!?] not including the square brackets and will not exceed 70 characters in length. Excuses will contain at least 1 non-space character. # Output For each input set, you are to print the worst excuse(s) from the list. The worst excuse(s) is/are defined as the excuse(s) which contains the largest number of incidences of keywords. If a keyword occurs more than once in an excuse, each occurrance is considered a separate incidence. A keyword “occurs” in an excuse if and only if it exists in the string in contiguous form and is delimited by the beginning or end of the line or any non-alphabetic character or a space. For each set of input, you are to print a single line with the number of the set immediately after the string ‘Excuse Set #’ . (See the Sample Output). The following line(s) is/are to contain the worst excuse(s) one per line exactly as read in. If there is more than one worst excuse, you may print them in any order. After each set of output, you should print a blank line. # Sample Input 5 3 dog ate homework canary died My dog ate my homework. Can you believe my dog died after eating my canary... AND MY HOMEWORK? This excuse is so good that it contain 0 keywords. 6 5 superhighway crazy thermonuclear bedroom war building I am having a superhighway built in my bedroom. I am actually crazy. 1234567890.....,,,,,0987654321?????!!!!!! There was a thermonuclear war! I ate my dog, my canary, and my homework ... note outdated keywords? # Sample Output Excuse Set #1 Can you believe my dog died after eating my canary... AND MY HOMEWORK? Excuse Set #2 I am having a superhighway built in my bedroom. There was a thermonuclear war! # 解題技巧 map.put(count, map.getOrDefault(count, &quot;&quot;) + sentence + &quot;\\n&quot;); # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); int set = 0; while(sc.hasNextInt())&#123; int K = sc.nextInt(); int E = sc.nextInt(); ArrayList&lt;String> search = new ArrayList&lt;>(); Map&lt;Integer, String> map = new HashMap&lt;>(); int max = 0; for(int i = 0; i &lt; K; i++)&#123; String word = sc.next(); search.add(word.toLowerCase()); &#125; sc.nextLine(); for(int i = 0; i &lt; E; i++)&#123; String sentence = sc.nextLine(); String[] words = sentence.split(\"[^A-Za-z]\"); int count = 0; for(String word : words)&#123; if(search.contains(word.toLowerCase()))&#123; count++; &#125; &#125; map.put(count, map.getOrDefault(count, \"\") + sentence + \"\\n\"); // Online Judge Enter => \"\\n\" CPE Enter => \"\\r\\n\" max = Math.max(max, count); &#125; System.out.println(\"Excuse Set #\" + (++set)); System.out.println(map.get(max)); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"}]},{"title":"401 - Palindromes","slug":"coding/cpe/One Star/401-Palindromes","date":"2023-09-23T09:11:29.000Z","updated":"2023-09-27T14:14:21.471Z","comments":true,"path":"coding/cpe/One Star/401-Palindromes/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/401-Palindromes/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 A regular palindrome is a string of numbers or letters that is the same forward as backward. For example, the string “ABCDEDCBA” is a palindrome because it is the same when the string is read from left to right as when the string is read from right to left. A mirrored string is a string for which when each of the elements of the string is changed to its reverse (if it has a reverse) and the string is read backwards the result is the same as the original string. For example, the string “3AIAE” is a mirrored string because ‘A’ and ‘I’ are their own reverses, and ‘3’ and ‘E’ are each others’ reverses. A mirrored palindrome is a string that meets the criteria of a regular palindrome and the criteria of a mirrored string. The string “ATOYOTA” is a mirrored palindrome because if the string is read backwards, the string is the same as the original and because if each of the characters is replaced by its reverse and the result is read backwards, the result is the same as the original string. Of course, ‘A’ , ‘T’ , ‘O’ , and ‘Y’ are all their own reverses. A list of all valid characters and their reverses is as follows. Character Reverse Character Reverse Character Reverse A A M M Y Y B N Z 5 C O O 1 1 D P 2 S E 3 Q 3 E F R 4 G S 2 5 Z H H T T 6 I I U U 7 J L V V 8 8 K W W 9 L J X X Note that ‘0’ (zero) and ‘O’ (the letter) are considered the same character and therefore ONLY the letter ‘O’ is a valid character. # Input Input consists of strings (one per line) each of which will consist of one to twenty valid characters. There will be no invalid characters in any of the strings. Your program should read to the end of file. # Output For each input string, you should print the string starting in column 1 immediately followed by exactly one of the following strings. STRING CRITERIA ‘ -- is not a palindrome.’ if the string is not a palindrome and is not a mirrored string ‘ -- is a regular palindrome.’ if the string is a palindrome and is not a mirrored string ‘ -- is a mirrored string.’ if the string is not a palindrome and is a mirrored string ‘ -- is a mirrored palindrome.’ if the string is a palindrome and is a mirrored string Note that the output line is to include the ‘-’ s and spacing exactly as shown in the table above and demonstrated in the Sample Output below. In addition, after each output line, you must print an empty line. # Sample Input NOTAPALINDROME ISAPALINILAPASI 2A3MEAS ATOYOTA # Sample Output NOTAPALINDROME -- is not a palindrome. ISAPALINILAPASI -- is a regular palindrome. 2A3MEAS -- is a mirrored string. ATOYOTA -- is a mirrored palindrome. # 解題技巧 分別判斷是否為 palindrome 或 mirrored。 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); Map&lt;Character, Character> map = new HashMap&lt;>(); map.put('A', 'A'); map.put('E', '3'); map.put('H', 'H'); map.put('I', 'I'); map.put('J', 'L'); map.put('L', 'J'); map.put('M', 'M'); map.put('O', 'O'); map.put('S', '2'); map.put('T', 'T'); map.put('U', 'U'); map.put('V', 'V'); map.put('W', 'W'); map.put('X', 'X'); map.put('Y', 'Y'); map.put('Z', '5'); map.put('1', '1'); map.put('2', 'S'); map.put('3', 'E'); map.put('5', 'Z'); map.put('8', '8'); while (sc.hasNext()) &#123; String input = sc.next(); boolean isPalindrome = false; boolean isMirrored = true; StringBuilder sb = new StringBuilder(input); String reverseInput = sb.reverse().toString(); if (input.equals(reverseInput)) &#123; isPalindrome = true; &#125; for (int i = 0; i &lt;= input.length() / 2; i++) &#123; if (map.containsKey(input.charAt(i))) &#123; if (map.get(input.charAt(i)) != input.charAt(input.length() - i - 1)) &#123; isMirrored = false; break; &#125; &#125; else &#123; isMirrored = false; break; &#125; &#125; if (isPalindrome) &#123; if (isMirrored) &#123; System.out.println(input + \" -- is a mirrored palindrome.\"); &#125; else &#123; System.out.println(input + \" -- is a regular palindrome.\"); &#125; &#125; else &#123; if (isMirrored) &#123; System.out.println(input + \" -- is a mirrored string.\"); &#125; else &#123; System.out.println(input + \" -- is not a palindrome.\"); &#125; &#125; System.out.println(\"\"); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"}]},{"title":"389 - Basically Speaking","slug":"coding/cpe/One Star/389-Basically-Speaking","date":"2023-09-23T08:38:43.000Z","updated":"2023-09-23T09:15:09.129Z","comments":true,"path":"coding/cpe/One Star/389-Basically-Speaking/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/389-Basically-Speaking/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The Really Neato Calculator Company, Inc. has recently hired your team to help design their Super Neato Model I calculator. As a computer scientist you suggested to the company that it would be neato if this new calculator could convert among number bases. The company thought this was a stupendous idea and has asked your team to come up with the prototype program for doing base conversion. The project manager of the Super Neato Model I calculator has informed you that the calculator will have the following neato features: It will have a 7-digit display. Its buttons will include the capital letters A through F in addition to the digits 0 through 9 . It will support bases 2 through 16 . # Input The input for your prototype program will consist of one base conversion per line. There will be three numbers per line. The first number will be the number in the base you are converting from. It may have leading ‘0’ s. The second number is the base you are converting from. The third number is the base you are converting to. There will be one or more blanks surrounding (on either side of) the numbers. There are several lines of input and your program should continue to read until the end of file is reached. # Output The output will only be the converted number as it would appear on the display of the calculator. The number should be right justified in the 7-digit display. If the number is to large to appear on the display, then print ‘ERROR’ (without the quotes) right justified in the display. # Sample Input 1111000 2 10 1111000 2 16 2102101 3 10 2102101 3 15 12312 4 2 1A 15 2 ABCD 16 15 03 13 10 # Sample Output 120 78 1765 7CA ERROR 11001 D071 3 # 解題技巧 Java 可以利用 Integer 與 String 轉換來解決進位轉換的過程，可以說是超級的方便解這題，短短幾行解決。 String -&gt; Integer =&gt; Integer.parseInt(value, radix); Integer -&gt; String =&gt; Integer.toString(value, radix); # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); while(sc.hasNext())&#123; String input = sc.next(); int from = sc.nextInt(); int to = sc.nextInt(); String ans = (Integer.toString(Integer.parseInt(input, from), to)); System.out.printf(\"%7s\", (ans.length() > 7 ? \"ERROR\" : ans.toUpperCase())); System.out.println(); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"1048. Longest String Chain","slug":"coding/leetcode/Medium/1048-Longest-String-Chain","date":"2023-09-23T03:14:36.000Z","updated":"2023-09-23T04:02:38.770Z","comments":true,"path":"coding/leetcode/Medium/1048-Longest-String-Chain/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1048-Longest-String-Chain/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an array of words where each word consists of lowercase English letters. wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB . For example, &quot;abc&quot; is a predecessor of &quot;abac&quot; , while &quot;cba&quot; is not a predecessor of &quot;bcad&quot; . A word chain is a sequence of words [word1, word2, ..., wordk] with k &gt;= 1 , where word1 is a predecessor of word2 , word2 is a predecessor of word3 , and so on. A single word is trivially a word chain with k == 1 . Return the length of the longest possible word chain with words chosen from the given list of words . # Example 1 Input: words = [&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;] Output: 4 Explanation: One of the longest word chains is [&quot;a&quot;,&quot;ba&quot;,&quot;bda&quot;,&quot;bdca&quot;]. # Example 2 Input: words = [&quot;xbc&quot;,&quot;pcxbcf&quot;,&quot;xb&quot;,&quot;cxbc&quot;,&quot;pcxbc&quot;] Output: 5 Explanation: All the words can be put in a word chain [&quot;xb&quot;, &quot;xbc&quot;, &quot;cxbc&quot;, &quot;pcxbc&quot;, &quot;pcxbcf&quot;]. # Example 3 Input: words = [&quot;abcd&quot;,&quot;dbqca&quot;] Output: 1 Explanation: The trivial word chain [&quot;abcd&quot;] is one of the longest word chains. [&quot;abcd&quot;,&quot;dbqca&quot;] is not a valid word chain because the ordering of the letters is changed. # 解題思路 # Solution import java.util.Arrays;import java.util.HashMap;import java.util.Map;class Solution &#123; public int longestStrChain(String[] words) &#123; int ans = 0; Arrays.sort(words, (a, b) -> a.length() - b.length()); Map&lt;String, Integer> map = new HashMap&lt;>(); for(String word : words)&#123; map.put(word, 1); for(int i = 0; i &lt; word.length(); i++)&#123; String prev = word.substring(0, i) + word.substring(i + 1); if(map.containsKey(prev))&#123; map.put(word, Math.max(map.get(word), map.get(prev) + 1)); &#125; &#125; ans = Math.max(ans, map.get(word)); &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"}]},{"title":"386 - Perfect Cubes","slug":"coding/cpe/One Star/386-Perfect-Cubes","date":"2023-09-21T09:11:26.000Z","updated":"2023-09-23T08:39:32.006Z","comments":true,"path":"coding/cpe/One Star/386-Perfect-Cubes/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/386-Perfect-Cubes/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 For hundreds of years Fermat’s Last Theorem, which stated simply that for n &gt; 2 there exist no integers a, b, c &gt; 1 such that an=bn+cna^n = b^n + c^nan=bn+cn , has remained elusively unproven. (A recent proof is believed to be correct, though it is still undergoing scrutiny.) It is possible, however, to find integers greater than 1 that satisfy the “perfect cube” equation a3=b3+c3+d3a^3 = b^3 + c^3 + d^3a3=b3+c3+d3 (e.g. a quick calculation will show that the equation 123=63+83+10312^3 = 6^3 + 8^3 + 10^3123=63+83+103 is indeed true). This problem requires that you write a program to find all sets of numbers &#123;a, b, c, d&#125; which satisfy this equation for a ≤ 200 . # Output The output should be listed as shown below, one perfect cube per line, in non-decreasing order of a (i.e. the lines should be sorted by their a values). The values of b, c, and d should also be listed in non-decreasing order on the line itself. There do exist several values of a which can be produced from multiple distinct sets of b, c, and d triples. In these cases, the triples with the smaller b values should be listed first. The first part of the output is shown here: Cube = 6, Triple = (3,4,5) Cube = 12, Triple = (6,8,10) Cube = 18, Triple = (2,12,16) Cube = 18, Triple = (9,12,15) Cube = 19, Triple = (3,10,18) Cube = 20, Triple = (7,14,17) Cube = 24, Triple = (12,16,20) # 解題技巧 要避免掉 TLE，可以嘗試以 3 個 for 迴圈解題， cubeD = cubeA - cubeB - cubeC 來求出原本要跑第 4 次 for 迴圈的 cubeD ，來減少 time complexity。 # Solution Main.javapublic class Main &#123; public static void main(String[] args) &#123; for (int a = 2; a &lt;= 200; a++) &#123; int cubeA = (int) Math.pow(a, 3); for (int b = 2; b &lt; a; b++) &#123; int cubeB = (int) Math.pow(b, 3); for (int c = b + 1; c &lt; a; c++) &#123; int cubeC = (int) Math.pow(c, 3); int cubeD = cubeA - cubeB - cubeC; if(cubeC > cubeD)&#123; continue; &#125; int d = (int)Math.round(Math.pow(cubeD, 1.0/3)); if ((int)Math.pow(d, 3) == cubeD) &#123; System.out.println(\"Cube = \" + a + \", Triple = (\" + b + \",\" + c + \",\" + d + \")\"); &#125; &#125; &#125; &#125; &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"382 - Perfection","slug":"coding/cpe/One Star/382-Perfection","date":"2023-09-21T08:27:53.000Z","updated":"2023-09-21T09:09:17.209Z","comments":true,"path":"coding/cpe/One Star/382-Perfection/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/382-Perfection/","excerpt":"","text":"🌕🌗🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 From the article Number Theory in the 1994 Microsoft Encarta: “If a, b, c are integers such that a = bc, a is called a multiple of b or of c, and b or c is called a divisor or factor of a. If c is not ±1, b is called a proper divisor of a. Even integers, which include 0, are multiples of 2, for example, -4, 0, 2, 10; an odd integer is an integer that is not even, for example, -5, 1, 3, 9. A perfect number is a positive integer that is equal to the sum of all its positive, proper divisors; for example, 6, which equals 1 + 2 + 3, and 28, which equals 1 + 2 + 4 + 7 + 14, are perfect numbers. A positive number that is not perfect is imperfect and is deficient or abundant according to whether the sum of its positive, proper divisors is smaller or larger than the number itself. Thus, 9, with proper divisors 1, 3, is deficient; 12, with proper divisors 1, 2, 3, 4, 6, is abundant.” Your task is: Given a number, determine if it is perfect, abundant, or deficient. # Input A list of N positive integers (none greater than 60,000 ), with 1 &lt; N &lt; 100 . A ‘0’ will mark the end of the list. # Output The first line of output should read ‘PERFECTION OUTPUT’ . The next N lines of output should list for each input integer whether it is perfect, deficient, or abundant, as shown in the example below. Format counts: the echoed integers should be right justified within the first 5 spaces of the output line, followed by two blank spaces, followed by the description of the integer. The final line of output should read ‘END OF OUTPUT’ # Sample Input 15 28 6 56 60000 22 496 0 # Sample Output PERFECTION OUTPUT 15 DEFICIENT 28 PERFECT 6 PERFECT 56 ABUNDANT 60000 ABUNDANT 22 DEFICIENT 496 PERFECT END OF OUTPUT # 解題技巧 直覺解題，數論：整數分解的題目。 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); System.out.println(\"PERFECTION OUTPUT\"); while(n != 0)&#123; int sum = (n != 1 ? 1 : 0); for(int i = 2; i &lt;= Math.sqrt(n); i++)&#123; if(n % i == 0)&#123; int temp = n / i; sum += i; if(temp != i)&#123; sum += temp; &#125; &#125; &#125; if(sum > n)&#123; System.out.printf(\"%5d%s\", n, \" ABUNDANT\"); System.out.println(\"\"); &#125;else if(sum == n)&#123; System.out.printf(\"%5d%s\", n, \" PERFECT\"); System.out.println(\"\"); &#125;else&#123; System.out.printf(\"%5d%s\", n, \" DEFICIENT\"); System.out.println(\"\"); &#125; n = sc.nextInt(); &#125; System.out.println(\"END OF OUTPUT\"); sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"}]},{"title":"305 - Joseph","slug":"coding/cpe/One Star/305-Joseph","date":"2023-09-21T06:53:06.000Z","updated":"2023-09-21T08:24:16.469Z","comments":true,"path":"coding/cpe/One Star/305-Joseph/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/305-Joseph/","excerpt":"","text":"🌕🌗🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The Joseph’s problem is notoriously known. For those who are not familiar with the original problem: from among n people, numbered 1, 2, ..., n , standing in circle every m-th is going to be executed and only the life of the last remaining person will be saved. Joseph was smart enough to choose the position of the last remaining person, thus saving his life to give us the message about the incident. For example when n = 6 and m = 5 then the people will be executed in the order 5 , 4 , 6 , 2 , 3 and 1 will be saved. Suppose that there are k good guys and k bad guys. In the circle the first k are good guys and the last k bad guys. You have to determine such minimal m that all the bad guys will be executed before the first good guy. # Input The input file consists of separate lines containing k . The last line in the input file contains ‘0’ . You can suppose that 0 &lt; k &lt; 14 . # Output The output file will consist of separate lines containing m corresponding to k in the input file. # Sample Input 3 4 0 # Sample Output 5 30 # 解題技巧 理解題目，然後暴力解，小提示題目只有要求 0 &lt; k &lt; 14 可以在讀取輸入前先把答案存進陣列中，如果後面有重複輸入就不用再跑一次，避免 TLE。 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int[] arr = new int[15]; for (int k = 1; k &lt; 15; k++) &#123; int m = k + 1; while (true) &#123; int killed = -1; int group = k * 2; while (group > k) &#123; killed += m; killed %= group; if (killed &lt; k) &#123; break; &#125; killed--; group--; &#125; if(group == k)&#123; arr[k] = m; break; &#125; m++; &#125; &#125; int k = sc.nextInt(); while (k != 0) &#123; System.out.println(arr[k]); k = sc.nextInt(); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"299 - Train Swapping","slug":"coding/cpe/One Star/299-Train-Swapping","date":"2023-09-21T05:54:20.000Z","updated":"2023-09-21T06:53:17.871Z","comments":true,"path":"coding/cpe/One Star/299-Train-Swapping/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/299-Train-Swapping/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 At an old railway station, you may still encounter one of the last remaining “train swappers”. A train swapper is an employee of the railroad, whose sole job it is to rearrange the carriages of trains. Once the carriages are arranged in the optimal order, all the train driver has to do, is drop the carriages off, one by one, at the stations for which the load is meant. The title “train swapper” stems from the first person who performed this task, at a station close to a railway bridge. Instead of opening up vertically, the bridge rotated around a pillar in the center of the river. After rotating the bridge 90 degrees, boats could pass left or right. The first train swapper had discovered that the bridge could be operated with at most two carriages on it. By rotating the bridge 180 degrees, the carriages switched place, allowing him to rearrange the carriages (as a side effect, the carriages then faced the opposite direction, but train carriages can move either way, so who cares). Now that almost all train swappers have died out, the railway company would like to automate their operation. Part of the program to be developed, is a routine which decides for a given train the least number of swaps of two adjacent carriages necessary to order the train. Your assignment is to create that routine. # Input The input contains on the first line the number of test cases (N). Each test case consists of two input lines. The first line of a test case contains an integer L, determining the length of the train (0 ≤ L ≤ 50). The second line of a test case contains a permutation of the numbers 1 through L, indicating the current order of the carriages. The carriages should be ordered such that carriage 1 comes first, then 2, etc. with carriage L coming last. # Output For each test case output the sentence: ‘Optimal train swapping takes S swaps.’ where S is an integer. # Sample Input 3 3 1 3 2 4 4 3 2 1 2 2 1 # Sample Output Optimal train swapping takes 1 swaps. Optimal train swapping takes 6 swaps. Optimal train swapping takes 1 swaps. # 解題技巧 運用 sorting 演算法來解題，判斷要交換幾次可以解決。 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); for(int i = 0; i &lt; N; i++)&#123; int L = sc.nextInt(); int[] arr = new int[L]; int ans = 0; for(int j = 0; j &lt; L; j++)&#123; arr[j] = sc.nextInt(); &#125; for(int x = 0; x &lt; L; x++)&#123; for(int y = x + 1; y &lt; L; y++)&#123; if(arr[x] > arr[y])&#123; int temp = arr[x]; arr[x] = arr[y]; arr[y] = temp; ans++; &#125; &#125; &#125; System.out.println(\"Optimal train swapping takes \" + ans + \" swaps.\"); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"Sotring","slug":"Sotring","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sotring/"}]},{"title":"4. Median of Two Sorted Arrays","slug":"coding/leetcode/Hard/4-Median-of-Two-Sorted-Arrays","date":"2023-09-21T04:11:55.000Z","updated":"2023-09-21T05:34:06.343Z","comments":true,"path":"coding/leetcode/Hard/4-Median-of-Two-Sorted-Arrays/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/4-Median-of-Two-Sorted-Arrays/","excerpt":"","text":"⭐️⭐️⭐️⭐️ # 題目敘述 Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)) . # Example 1 Input: nums1 = [1,3], nums2 = [2] Output: 2.00000 Explanation: merged array = [1,2,3] and median is 2. # Example 2 Input: nums1 = [1,2], nums2 = [3,4] Output: 2.50000 Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5. # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int[] nums = new int[nums1.length + nums2.length]; int index = 0; for (int num : nums1) &#123; nums[index++] = num; &#125; for (int num : nums2) &#123; nums[index++] = num; &#125; Arrays.sort(nums); double ans = 0; int len = nums.length; if (len % 2 == 0) &#123; ans = (nums[len / 2 - 1] + nums[len / 2]) / 2.0; &#125; else &#123; ans = nums[len / 2]; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Divide-and-Conquer/"}]},{"title":"272 - TEX Quotes","slug":"coding/cpe/One Star/272-TEX-Quotes","date":"2023-09-20T14:48:20.000Z","updated":"2023-09-21T06:48:14.805Z","comments":true,"path":"coding/cpe/One Star/272-TEX-Quotes/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/272-TEX-Quotes/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 TEX is a typesetting language developed by Donald Knuth. It takes source text together with a few typesetting instructions and produces, one hopes, a beautiful document. Beautiful documents use “ and ” to delimit quotations, rather than the mundane &quot; which is what is provided by most keyboards. Keyboards typically do not have an oriented double-quote, but they do have a left-single-quote ` and a right-single-quote '. Check your keyboard now to locate the left-single-quote key ` (sometimes called the “backquote key”) and the right-single-quote key ' (sometimes called the “apostrophe” or just “quote”). Be careful not to confuse the left-single-quote ` with the “backslash” key . TEX lets the user type two left-single-quotes `` to create a left-double-quote “ and two right-single-quotes '' to create a right-double-quote ”. Most typists, however, are accustomed to delimiting their quotations with the un-oriented double-quote &quot;. If the source contained &quot;To be or not to be,&quot; quoth the bard, &quot;that is the question.&quot; then the typeset document produced by TEX would not contain the desired form: “To be or not to be,” quoth the bard, “that is the question.” In order to produce the desired form, the source file must contain the sequence: ``To be or not to be,'' quoth the bard, ``that is the question.'' You are to write a program which converts text containing double-quote (&quot;) characters into text that is identical except that double-quotes have been replaced by the two-character sequences required by TEX for delimiting quotations with oriented double-quotes. The double-quote (&quot;) characters should be replaced appropriately by either `` if the &quot; opens a quotation and by '' if the &quot; closes a quotation. Notice that the question of nested quotations does not arise: The first &quot; must be replaced by ``, the next by '', the next by ``, the next by '', the next by ``, the next by '', and so on. # Input Input will consist of several lines of text containing an even number of double-quote (&quot;) characters. Input is ended with an end-of-file character. # Output The text must be output exactly as it was input except that: the first &quot; in each pair is replaced by two ` characters: `` and the second &quot; in each pair is replaced by two ' characters: ''. # Sample Input &quot;To be or not to be,&quot; quoth the Bard, &quot;that is the question&quot;. The programming contestant replied: &quot;I must disagree. To `C' or not to `C', that is The Question!&quot; # Sample Output ``To be or not to be,' ' quoth the Bard, ``that is the question' '. The programming contestant replied: ``I must disagree. To `C' or not to `C', that is The Question!' ' # 解題技巧 運用讀取整行字串的方式解題，蠻直覺的題目。 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int count = 0; while(sc.hasNextLine())&#123; String str = sc.nextLine(); for(int i = 0; i &lt; str.length(); i++)&#123; if(str.charAt(i) != '\\\"')&#123; System.out.print(str.charAt(i)); &#125;else if(count == 0)&#123; System.out.print(\"``\"); count = 1; &#125;else&#123; System.out.print(\"\\'\\'\"); count = 0; &#125; &#125; System.out.println(); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"264 - Count on Cantor","slug":"coding/cpe/One Star/264-Count-on-Cantor","date":"2023-09-20T06:20:25.000Z","updated":"2023-09-21T06:48:11.150Z","comments":true,"path":"coding/cpe/One Star/264-Count-on-Cantor/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/264-Count-on-Cantor/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 One of the famous proofs of modern mathematics is Georg Cantor’s demonstration that the set of rational numbers is enumerable. The proof works by using an explicit enumeration of rational numbers as shown in the diagram below. In the above diagram, the first term is 1/1 , the second term is 1/2 , the third term is 2/1 , the fourth term is 3/1 , the fifth term is 2/2 , and so on. # Input and Output You are to write a program that will read a list of numbers in the range from 1 to 107 and will print for each number the corresponding term in Cantor’s enumeration as given below. No blank line should appear after the last number. The input list contains a single number per line and will be terminated by end-of-file. # Sample Input 3 14 7 # Sample Output TERM 3 IS 2/1 TERM 14 IS 2/4 TERM 7 IS 1/4 # 解題技巧 sqrt(10^7 * 2) &lt; 4500 利用陣列計算當行最大的 num 會是多少 分子分母可以分開用兩個 int 儲存計算 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int max[] = new int[4500]; // sqrt(10^7 * 2) &lt; 4500 max[1] = 1; for(int i = 2; i &lt; 4500; i++)&#123; max[i] = max[i - 1] + i; &#125; while(sc.hasNextInt())&#123; int num = sc.nextInt(); int line = 0; int up = 0, down = 0; for(int i = 1; i &lt; 4500; i++)&#123; if(num &lt;= max[i])&#123; line = i; break; &#125; &#125; for(int i = 1; i &lt;= num - max[line - 1]; i++)&#123; if(line % 2 == 0)&#123; up = i; down = line + 1 - i; &#125;else&#123; down = i; up = line + 1 - i; &#125; &#125; System.out.println(\"TERM \" + num + \" IS \" + up + \"/\" + down); &#125; &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"}]},{"title":"1658. Minimum Operations to Reduce X to Zero","slug":"coding/leetcode/Medium/1658-Minimum-Operations-to-Reduce-X-to-Zero","date":"2023-09-20T01:23:58.000Z","updated":"2023-09-20T03:41:32.544Z","comments":true,"path":"coding/leetcode/Medium/1658-Minimum-Operations-to-Reduce-X-to-Zero/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1658-Minimum-Operations-to-Reduce-X-to-Zero/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an integer array nums and an integer x . In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x . Note that this modifies the array for future operations. Return the minimum number of operations to reduce x to exactly 0 if it is possible, otherwise, return -1 . # Example 1 Input: nums = [1,1,4,2,3], x = 5 Output: 2 Explanation: The optimal solution is to remove the last two elements to reduce x to zero. # Example 2 Input: nums = [5,6,7,8,9], x = 4 Output: -1 # Example 3 Input: nums = [3,2,20,1,1,3], x = 10 Output: 5 Explanation: The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero. # 解題思路 # Solution public class Solution &#123; public int minOperations(int[] nums, int x) &#123; int total = 0; for (int num : nums) &#123; total += num; &#125; int target = total - x; int left = 0; int n = nums.length; int maxWindow = -1; int sum = 0; for (int right = 0; right &lt; n; right++) &#123; sum += nums[right]; while (sum > target &amp;&amp; left &lt;= right) &#123; sum -= nums[left]; left++; &#125; if (sum == target) &#123; maxWindow = Math.max(maxWindow, right - left + 1); &#125; &#125; return maxWindow != -1 ? n - maxWindow : -1; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"}]},{"title":"263 - Number Chains","slug":"coding/cpe/One Star/263-Number-Chains","date":"2023-09-19T12:47:27.000Z","updated":"2023-09-21T06:48:06.389Z","comments":true,"path":"coding/cpe/One Star/263-Number-Chains/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/263-Number-Chains/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Given a number, we can form a number chain by arranging its digits in descending order arranging its digits in ascending order subtracting the number obtained in (2) from the number obtained (1) to form a new number and repeat these steps unless the new number has already appeared in the chain Note that 0 is a permitted digit. The number of distinct numbers in the chain is the length of the chain. You are to write a program that reads numbers and outputs the number chain and the length of that chain for each number read. # Input The input consists of a sequence of positive numbers, all less than 10910^9109, each on its own line, terminated by ‘0’ . The input file contains at most 5000 numbers. # Output The output consists of the number chains generated by the input numbers, followed by their lengths exactly in the format indicated below. After each number chain and chain length, including the last one, there should be a blank line. No chain will contain more than 1000 distinct numbers. # Sample Input 123456789 1234 444 0 # Sample Output Original number was 123456789 987654321 - 123456789 = 864197532 987654321 - 123456789 = 864197532 Chain length 2 Original number was 1234 4321 - 1234 = 3087 8730 - 378 = 8352 8532 - 2358 = 6174 7641 - 1467 = 6174 Chain length 4 Original number was 444 444 - 444 = 0 0 - 0 = 0 Chain length 2 # 解題技巧 利用到各種字串技巧: String 轉 char []: char[] c = str.toCharArray(); char [] 排序: Arrays.sort(c); char [] 轉 String: String str = new String(c); String 倒轉: StringBuilder sb = new StringBuilder(str); String reverseStr = sb.reverse().toString(); String 轉 int: int reverseInt = Integer.parseInt(reverseStr); # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String s = sc.next(); Set&lt;String> set = new HashSet&lt;>(); while (!s.equals(\"0\")) &#123; int count = 0; System.out.println(\"Original number was \" + s); set = new HashSet&lt;>(); while (true) &#123; char[] c = s.toCharArray(); Arrays.sort(c); String asc = new String(c); StringBuilder sb = new StringBuilder(asc); String des = sb.reverse().toString(); int desInt = Integer.parseInt(des); int ascInt = Integer.parseInt(asc); int next = desInt - ascInt; s = Integer.toString(next); System.out.println(desInt + \" - \" + ascInt + \" = \" + next); count++; if(set.contains(s))&#123; break; &#125;else&#123; set.add(s); &#125; &#125; System.out.println(\"Chain length \" + count); System.out.println(\"\"); s = sc.next(); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"}]},{"title":"256 - Quirksome Squares","slug":"coding/cpe/One Star/256-Quirksome-Squares","date":"2023-09-19T05:20:02.000Z","updated":"2023-09-21T06:48:36.748Z","comments":true,"path":"coding/cpe/One Star/256-Quirksome-Squares/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/256-Quirksome-Squares/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The number 3025 has a remarkable quirk: if you split its decimal representation in two strings of equal length ( 30 and 25 ) and square the sum of the numbers so obtained, you obtain the original number: (30+25)2=3025(30 + 25)^2 = 3025 (30+25)2=3025 The problem is to determine all numbers with this property having a given even number of digits. For example, 4-digit numbers run from 0000 to 9999 . Note that leading zeroes should be taken into account. This means that 0001 which is equal to (00+01)2(00 + 01)^2(00+01)2 is a quirksome number of 4 digits. The number of digits may be 2 , 4 , 6 or 8 . Although maxint is only 32767 and numbers of eight digits are asked for, a well-versed programmer can keep his numbers in the range of the integers. However efficiency should be given a thought. # Input The input of your program is a textfile containing numbers of digits (taken from 2 , 4 , 6 , 8 ), each number on a line of its own. # Output The output is a textfile consisting of lines containing the quirksome numbers (ordered according to the input numbers and for each input number in increasing order). Warning: Please note that the number of digits in the output is equal to the number in the corresponding input line : leading zeroes may not be suppressed. # Sample Input 2 2 # Sample Output 00 01 81 00 01 81 # 解題技巧 利用運算解題，基本上就是直覺解。 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); Map&lt;Integer, ArrayList&lt;String>> map = new HashMap&lt;>(); for(int i = 2; i &lt;= 8; i = i + 2)&#123; int pow = (int)Math.pow(10, i / 2); ArrayList&lt;String> temp = new ArrayList&lt;>(); for(int a = 0; a &lt; pow; a++)&#123; for(int b = 0; b &lt; pow; b++)&#123; if(a * pow + b == Math.pow(a + b, 2))&#123; String t = Integer.toString(a * pow + b); while(t.length() &lt; i)&#123; t = \"0\" + t; &#125; temp.add(t); &#125; &#125; &#125; map.put(i, temp); &#125; while(sc.hasNextInt())&#123; int num = sc.nextInt(); ArrayList&lt;String> ans = map.get(num); for(String s : ans)&#123; System.out.println(s); &#125; &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"}]},{"title":"287. Find the Duplicate Number","slug":"coding/leetcode/Medium/287-Find-the-Duplicate-Number","date":"2023-09-19T04:37:41.000Z","updated":"2023-09-19T05:15:59.294Z","comments":true,"path":"coding/leetcode/Medium/287-Find-the-Duplicate-Number/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/287-Find-the-Duplicate-Number/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums , return this repeated number. You must solve the problem without modifying the array nums and uses only constant extra space. # Example 1 Input: nums = [1,3,4,2,2] Output: 2 # Example 2 Input: nums = [3,1,3,4,2] Output: 3 # 解題思路 利用 Set 資料結構來處理此題。 # Solution import java.util.HashSet;import java.util.Set;class Solution &#123; public int findDuplicate(int[] nums) &#123; Set&lt;Integer> set = new HashSet&lt;>(); for(int num : nums)&#123; if(set.contains(num))&#123; return num; &#125; set.add(num); &#125; return -1; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bit-Manipulation/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"}]},{"title":"1337. The K Weakest Rows in a Matrix","slug":"coding/leetcode/Easy/1337-The-K-Weakest-Rows-in-a-Matrix","date":"2023-09-18T04:03:18.000Z","updated":"2023-09-18T12:17:24.504Z","comments":true,"path":"coding/leetcode/Easy/1337-The-K-Weakest-Rows-in-a-Matrix/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1337-The-K-Weakest-Rows-in-a-Matrix/","excerpt":"","text":"⭐️ # 題目敘述 You are given an m x n binary matrix mat of 1 's (representing soldiers) and 0 's (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1 's will appear to the left of all the 0 's in each row. A row i is weaker than a row j if one of the following is true: The number of soldiers in row i is less than the number of soldiers in row j . Both rows have the same number of soldiers and i &lt; j . Return the indices of the k weakest rows in the matrix ordered from weakest to strongest. # Example 1 Input: mat = [[1,1,0,0,0], [1,1,1,1,0], [1,0,0,0,0], [1,1,0,0,0], [1,1,1,1,1]], k = 3 Output: [2,0,3] Explanation: The number of soldiers in each row is: Row 0: 2 Row 1: 4 Row 2: 1 Row 3: 2 Row 4: 5 The rows ordered from weakest to strongest are [2,0,3,1,4]. # Example 2 Input: mat = [[1,0,0,0], [1,1,1,1], [1,0,0,0], [1,0,0,0]], k = 2 Output: [0,2] Explanation: The number of soldiers in each row is: Row 0: 1 Row 1: 4 Row 2: 1 Row 3: 1 The rows ordered from weakest to strongest are [0,2,3,1]. # 解題思路 用 sorting 去完成。 # Solution import java.util.Arrays;class Solution &#123; public int[] kWeakestRows(int[][] mat, int k) &#123; int m = mat.length; int[][] rowAdd = new int[m][2]; for(int i = 0; i &lt; m; i++)&#123; int add = 0; for(int num : mat[i])&#123; add += num; &#125; rowAdd[i][0] = add; rowAdd[i][1] = i; &#125; Arrays.sort(rowAdd, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]); int[] ans = new int[k]; for(int i = 0; i &lt; k; i++)&#123; ans[i] = rowAdd[i][1]; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"}]},{"title":"145 - Gondwanaland Telecom","slug":"coding/cpe/One Star/145-Gondwanaland-Telecom","date":"2023-09-17T15:49:41.000Z","updated":"2023-09-21T06:48:52.149Z","comments":true,"path":"coding/cpe/One Star/145-Gondwanaland-Telecom/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/145-Gondwanaland-Telecom/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Gondwanaland Telecom makes charges for calls according to distance and time of day. The basis of the charging is contained in the following schedule, where the charging step is related to the distance: Charging Step (distance) Day Rate 8am to 6pm Evening Rate 6pm to 10pm Night Rate 10pm to 8am A 0.10 0.06 0.02 B 0.25 0.15 0.05 C 0.53 0.33 0.13 D 0.87 0.47 0.17 E 1.44 0.80 0.30 All charges are in dollars per minute of the call. Calls which straddle a rate boundary are charged according to the time spent in each section. Thus a call starting at 5:58 pm and terminating at 6:04 pm will be charged for 2 minutes at the day rate and for 4 minutes at the evening rate. Calls less than a minute are not recorded and no call may last more than 24 hours. Write a program that reads call details and calculates the corresponding charges. # Input Input lines will consist of the charging step (upper case letter ‘A’..‘E’), the number called (a string of 7 digits and a hyphen in the approved format) and the start and end times of the call, all separated by exactly one blank. Times are recorded as hours and minutes in the 24 hour clock, separated by one blank and with two digits for each number. Input will be terminated by a line consisting of a single ‘#’. # Output Output will consist of the called number, the time in minutes the call spent in each of the charge categories, the charging step and the total cost in the format shown below. Note: The first line of the Sample Output below in not a part of the output, but only to show the exact tabulation format it must follow. # Sample Input A 183-5724 17 58 18 04 # # Sample Output 10 16 22 28 31 39 183-5724 2 4 0 A 0.44 # 解題技巧 依舊可以暴力解，不過有小技巧可以讓程式更簡潔！ # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); char distance = sc.next().charAt(0); Map&lt;Character, double[]> rate = new HashMap&lt;>(); rate.put('A', new double[] &#123; 0.02, 0.1, 0.06, 0.02, 0.1, 0.06, 0.02 &#125;); rate.put('B', new double[] &#123; 0.05, 0.25, 0.15, 0.05, 0.25, 0.15, 0.05 &#125;); rate.put('C', new double[] &#123; 0.13, 0.53, 0.33, 0.13, 0.53, 0.33, 0.13 &#125;); rate.put('D', new double[] &#123; 0.17, 0.87, 0.47, 0.17, 0.87, 0.47, 0.17 &#125;); rate.put('E', new double[] &#123; 0.3, 1.44, 0.8, 0.3, 1.44, 0.8, 0.3 &#125;); int[] time = new int[] &#123; 480, 1080, 1320, 1920, 2520, 2760, 2880 &#125;; while (distance != '#') &#123; String plane = sc.next(); int startHr = sc.nextInt(); int startMin = sc.nextInt(); int endHr = sc.nextInt(); int endMin = sc.nextInt(); int start = startHr * 60 + startMin; int end = endHr * 60 + endMin; if (start >= end) &#123; end += 24 * 60; &#125; int[] ansTime = new int[7]; double cost = 0; for (int i = 0; i &lt; 7; i++) &#123; if (start &lt;= time[i]) &#123; if (end &lt;= time[i]) &#123; ansTime[i] = end - start; cost += rate.get(distance)[i] * ansTime[i]; break; &#125; else &#123; ansTime[i] = time[i] - start; start = time[i]; cost += rate.get(distance)[i] * ansTime[i]; &#125; &#125; &#125; System.out.printf(\"%10s%6d%6d%6d%3s%8.2f\\n\", plane, ansTime[1] + ansTime[4], ansTime[2] + ansTime[5], ansTime[0] + ansTime[3] + ansTime[6], distance, cost); distance = sc.next().charAt(0); &#125; &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"}]},{"title":"141 - The Spot Game","slug":"coding/cpe/One Star/141-The-Spot-Game","date":"2023-09-17T14:04:26.000Z","updated":"2023-09-20T15:28:30.391Z","comments":true,"path":"coding/cpe/One Star/141-The-Spot-Game/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/141-The-Spot-Game/","excerpt":"","text":"🌕🌗🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The game of Spot is played on an N × N board as shown below for N = 4 . During the game, alternate players may either place a black counter (spot) in an empty square or remove one from the board, thus producing a variety of patterns. If a board pattern (or its rotation by 90 degrees or 180 degrees ) is repeated during a game, the player producing that pattern loses and the other player wins. The game terminates in a draw after 2N moves if no duplicate pattern is produced before then. Consider the following patterns: If the first pattern had been produced earlier, then any of the following three patterns (plus one other not shown) would terminate the game, whereas the last one would not. # Input Input will consist of a series of games, each consisting of the size of the board, N (2 ≤ N ≤ 50) followed, on separate lines, by 2N moves, whether they are all necessary or not. Each move will consist of the coordinates of a square (integers in the range 1..N ) followed by a blank and a character ‘+’ or ‘-’ indicating the addition or removal of a spot respectively. You may assume that all moves are legal, that is there will never be an attempt to place a spot on an occupied square, nor to remove a non-existent spot. Input will be terminated by a zero (0) . # Output Output will consist of one line for each game indicating which player won and on which move, or that the game ended in a draw. See the Sample Output below for the exact format. # Sample Input 2 1 1 + 2 2 + 2 2 - 1 2 + 2 1 1 + 2 2 + 1 2 + 2 2 - 0 # Sample Output Player 2 wins on move 3 Draw # 解題技巧 運用到 StringBuffer : StringBuffer sb = new StringBuffer() or StringBuffer sb = new StringBuffer(string) sb.append(string) sb.setCharAt(index, char) # Solution Main.javaimport java.util.*;public class Main&#123; static StringBuffer str0; static StringBuffer str90; static StringBuffer str180; static StringBuffer str270; static Set&lt;String> map; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); while(N != 0)&#123; map = new HashSet&lt;>(); str0 = new StringBuffer(); int play = 0; boolean isDraw = true; for(int i = 0; i &lt; N * N; i++)&#123; str0.append(\"-\"); &#125; str90 = new StringBuffer(str0); str180 = new StringBuffer(str0); str270 = new StringBuffer(str0); for(int i = 1; i &lt;= 2 * N; i++)&#123; int x = sc.nextInt(); int y = sc.nextInt(); char doing = sc.next().charAt(0); if(!isDraw)&#123; continue; &#125; if(isWin(N, x - 1, y - 1, doing))&#123; isDraw = false; play = i; &#125; &#125; System.out.println((isDraw ? \"Draw\" : \"Player \" + (play % 2 + 1) + \" wins on move \" + play)); N = sc.nextInt(); &#125; sc.close(); &#125; public static boolean isWin(int n, int x, int y, char doing)&#123; str0.setCharAt(toOneArray(x, y, n), doing); str90.setCharAt(toOneArray(n - x - 1, y, n), doing); str180.setCharAt(toOneArray(n - x - 1, n - y - 1, n), doing); str270.setCharAt(toOneArray(x, n - y - 1, n), doing); if(map.contains(str0.toString()))&#123; return true; &#125; map.add(str0.toString()); map.add(str90.toString()); map.add(str180.toString()); map.add(str270.toString()); return false; &#125; public static int toOneArray(int x, int y, int n)&#123; return x * n + y; &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"847. Shortest Path Visiting All Nodes","slug":"coding/leetcode/Hard/847-Shortest-Path-Visiting-All-Nodes","date":"2023-09-17T02:39:53.000Z","updated":"2023-09-17T12:55:37.889Z","comments":true,"path":"coding/leetcode/Hard/847-Shortest-Path-Visiting-All-Nodes/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/847-Shortest-Path-Visiting-All-Nodes/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 You have an undirected, connected graph of n nodes labeled from 0 to n - 1 . You are given an array graph where graph[i] is a list of all the nodes connected with node i by an edge. Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges. # Example 1 Input: graph = [[1,2,3],[0],[0],[0]] Output: 4 Explanation: One possible path is [1,0,2,0,3] # Example 2 Input: graph = [[1],[0,2,4],[1,3,4],[2],[1,2]] Output: 4 Explanation: One possible path is [0,1,4,2,3] # 解題思路 Use BitMask + BFS 運算式介紹: allVisitedMask = (1 &lt;&lt; n) - 1 : 運算結果為 15 ，以二進位來查看為 1111 ，用於表示全部節點都走過了。 currMask : 表示當前 queue 中經過了那些節點。 newMask = currMask | (1 &lt;&lt; next) : 表示經過下一個 node ( next ) 後的所有經過節點， | 運算子稱作 OR ，運算方式如: 0011 | 0101 = 0111 。 BFS 結束條件: 如果經過相同 node ( newMask )，且下一個去向也是相同 node ( next )， visited[newMask][next] == true ，可以不用再跑下去。 如果 currMask == allVisitedMask 表示所有節點都走過了，而 currLen - 1 就是答案。 # Solution import java.util.Arrays;import java.util.LinkedList;import java.util.Queue;class Solution &#123; public int shortestPathLength(int[][] graph) &#123; int n = graph.length; int allVisitedMask = (1 &lt;&lt; n) - 1; Queue&lt;int[]> queue = new LinkedList&lt;>(); boolean[][] visited = new boolean[allVisitedMask + 1][n]; for (boolean[] v : visited) &#123; Arrays.fill(v, false); &#125; for (int currNode = 0; currNode &lt; n; currNode++) &#123; int initialMask = (1 &lt;&lt; currNode); queue.add(new int[] &#123; currNode, initialMask, 1 &#125;); visited[initialMask][currNode] = true; &#125; while (!queue.isEmpty()) &#123; int[] curr = queue.poll(); int currNode = curr[0]; int currMask = curr[1]; int currLen = curr[2]; if (currMask == allVisitedMask) &#123; return currLen - 1; &#125; for (int i = 0; i &lt; graph[currNode].length; i++) &#123; int next = graph[currNode][i]; int newMask = currMask | (1 &lt;&lt; next); if (visited[newMask][next]) &#123; continue; &#125; queue.add(new int[] &#123; next, newMask, currLen + 1 &#125;); visited[newMask][next] = true; &#125; &#125; return -1; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bit-Manipulation/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Bitmask","slug":"Bitmask","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bitmask/"}]},{"title":"136 - Ugly Numbers","slug":"coding/cpe/One Star/136-Ugly-Numbers","date":"2023-09-15T12:52:22.000Z","updated":"2023-09-20T15:29:16.481Z","comments":true,"path":"coding/cpe/One Star/136-Ugly-Numbers/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/136-Ugly-Numbers/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Ugly numbers are numbers whose only prime factors are 2 , 3 or 5 . The sequence 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, ...1,\\ \\ 2,\\ \\ 3,\\ \\ 4,\\ \\ 5,\\ \\ 6,\\ \\ 8,\\ \\ 9,\\ \\ 10,\\ \\ 12,\\ \\ 15,\\ \\ ... 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, ... shows the first 11 ugly numbers. By convention, 1 is included. Write a program to find and print the 1500’th ugly number. # Input There is no input to this program. # Output Output should consist of a single line as shown below, with ‘&lt;number&gt;’ replaced by the number computed. # Sample Output The 1500'th ugly number is &lt;number&gt;. # 解題技巧 # Solution Main.javapublic class Main &#123; public static void main(String[] args) &#123; int[] uglyNum = new int[1505]; int index2 = 1, index3 = 1, index5 = 1; uglyNum[1] = 1; for (int i = 2; i &lt;= 1500; i++) &#123; while (uglyNum[index2] * 2 &lt;= uglyNum[i - 1]) index2++; while (uglyNum[index3] * 3 &lt;= uglyNum[i - 1]) index3++; while (uglyNum[index5] * 5 &lt;= uglyNum[i - 1]) index5++; uglyNum[i] = Math.min(uglyNum[index2] * 2, uglyNum[index3] * 3); uglyNum[i] = Math.min(uglyNum[i], uglyNum[index5] * 5); &#125; System.out.println(\"The 1500'th ugly number is \" + uglyNum[1500] + \".\"); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"118 - Mutant Flatworld Explorers","slug":"coding/cpe/One Star/118-Mutant-Flatworld-Explorers","date":"2023-09-15T10:51:27.000Z","updated":"2023-09-20T15:30:30.805Z","comments":true,"path":"coding/cpe/One Star/118-Mutant-Flatworld-Explorers/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/118-Mutant-Flatworld-Explorers/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Robotics, robot motion planning, and machine learning are areas that cross the boundaries of many of the subdisciplines that comprise Computer Science: artificial intelligence, algorithms and complexity, electrical and mechanical engineering to name a few. In addition, robots as “turtles” (inspired by work by Papert, Abelson, and diSessa) and as “beeper-pickers” (inspired by work by Pattis) have been studied and used by students as an introduction to programming for many years. This problem involves determining the position of a robot exploring a pre-Columbian flat world. Given the dimensions of a rectangular grid and a sequence of robot positions and instructions, you are to write a program that determines for each sequence of robot positions and instructions the final position of the robot. A robot position consists of a grid coordinate (a pair of integers: x-coordinate followed by y-coordinate) and an orientation ( N , S , E , W for north, south, east, and west). A robot instruction is a string of the letters ‘L’ , ‘R’ , and ‘F’ which represent, respectively, the instructions: Left: the robot turns left 90 degrees and remains on the current grid point. Right: the robot turns right 90 degrees and remains on the current grid point. Forward: the robot moves forward one grid point in the direction of the current orientation and mantains the same orientation. The direction North corresponds to the direction from grid point (x, y) to grid point (x, y + 1) . Since the grid is rectangular and bounded, a robot that moves “off” an edge of the grid is lost forever. However, lost robots leave a robot “scent” that prohibits future robots from dropping off the world at the same grid point. The scent is left at the last grid position the robot occupied before disappearing over the edge. An instruction to move “off” the world from a grid point from which a robot has been previously lost is simply ignored by the current robot. # Input The first line of input is the upper-right coordinates of the rectangular world, the lower-left coordinates are assumed to be 0,0 . The remaining input consists of a sequence of robot positions and instructions (two lines per robot). A position consists of two integers specifying the initial coordinates of the robot and an orientation (N,S,E,W) , all separated by white space on one line. A robot instruction is a string of the letters ‘L’ , ‘R’ , and ‘F’ on one line. Each robot is processed sequentially, i.e., finishes executing the robot instructions before the next robot begins execution. Input is terminated by end-of-file. You may assume that all initial robot positions are within the bounds of the specified grid. The maximum value for any coordinate is 50 . All instruction strings will be less than 100 characters in length. # Output For each robot position/instruction in the input, the output should indicate the final grid position and orientation of the robot. If a robot falls off the edge of the grid the word ‘LOST’ should be printed after the position and orientation. # Sample Input 5 3 1 1 E RFRFRFRF 3 2 N FRRFLLFFRRFLL 0 3 W LLFFFLFLFL # Sample Output 1 1 E 3 3 N LOST 2 3 S # 解題技巧 基本上也是暴力解，不過有一些小技巧可以讓程式碼簡潔！ # Solution Main.javaimport java.util.*;public class Main&#123; public static int[] dx = &#123;0, 1, 0, -1&#125;; public static int[] dy = &#123;1, 0, -1, 0&#125;; public static Map&lt;String, Integer> toInt = new HashMap&lt;>(); public static Map&lt;Integer, String> toStr = new HashMap&lt;>(); public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); toInt.put(\"N\", 0); toStr.put(0, \"N\"); toInt.put(\"E\", 1); toStr.put(1, \"E\"); toInt.put(\"S\", 2); toStr.put(2, \"S\"); toInt.put(\"W\", 3); toStr.put(3, \"W\"); int x = sc.nextInt(); int y = sc.nextInt(); ArrayList&lt;String> scent = new ArrayList&lt;>(); while(sc.hasNextInt())&#123; int nowX = sc.nextInt(); int nowY = sc.nextInt(); String now = sc.next(); String walk = sc.next(); boolean lost = false; for(int i = 0; i &lt; walk.length(); i++)&#123; if(walk.charAt(i) == 'F')&#123; String temp = Integer.toString(nowX) + \" \" + Integer.toString(nowY); int X = dx[toInt.get(now)]; int Y = dy[toInt.get(now)]; lost = (nowX + X &lt; 0 || nowX + X > x || nowY + Y &lt; 0 || nowY + Y > y); if(!scent.contains(temp) &amp;&amp; lost)&#123; scent.add(temp); break; &#125; if(!(lost))&#123; nowX += X; nowY += Y; &#125; &#125;else if(walk.charAt(i) == 'L')&#123; now = toStr.get((toInt.get(now) + 4 - 1) % 4); &#125;else&#123; now = toStr.get((toInt.get(now) + 1) % 4); &#125; &#125; System.out.println(nowX + \" \" + nowY + \" \" + now + (lost ? \" LOST\" : \"\")); &#125; sc.close(); &#125;&#125; Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int x = sc.nextInt(); int y = sc.nextInt(); List&lt;String> Lost = new ArrayList&lt;>(); while (sc.hasNextInt()) &#123; int currX = sc.nextInt(); int currY = sc.nextInt(); char direction = sc.next().charAt(0); sc.nextLine(); String step = sc.nextLine(); // N E S W int[] nextX = &#123; 0, 1, 0, -1 &#125;; int[] nextY = &#123; 1, 0, -1, 0 &#125;; boolean lost = false; for (int i = 0; i &lt; step.length(); i++) &#123; if(step.charAt(i) == 'F')&#123; int tempX = currX + nextX[toInt(direction)]; int tempY = currY + nextY[toInt(direction)]; if(tempX >= 0 &amp;&amp; tempY >= 0 &amp;&amp; tempX &lt;= x &amp;&amp; tempY &lt;= y)&#123; currX = tempX; currY = tempY; &#125;else&#123; String temp = currX + \" \" + currY; if(!Lost.contains(temp))&#123; System.out.println(currX + \" \" + currY + \" \" + direction + \" LOST\"); Lost.add(temp); lost = true; break; &#125; &#125; &#125;else&#123; direction = nextDirection(direction, step.charAt(i)); &#125; &#125; if(!lost)&#123; System.out.println(currX + \" \" + currY + \" \" + direction); &#125; &#125; &#125; public static int toInt(char direction)&#123; switch(direction)&#123; case 'N': return 0; case 'E': return 1; case 'S': return 2; case 'W': return 3; &#125; return 0; &#125; public static char nextDirection(char direction, char step) &#123; switch (step) &#123; case 'L': switch (direction) &#123; case 'N': return 'W'; case 'E': return 'N'; case 'S': return 'E'; case 'W': return 'S'; &#125; break; case 'R': switch (direction) &#123; case 'N': return 'E'; case 'E': return 'S'; case 'S': return 'W'; case 'W': return 'N'; &#125; break; &#125; return ' '; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"108 - Maximum Sum","slug":"coding/cpe/One Star/108-Maximum-Sum","date":"2023-09-15T03:05:44.000Z","updated":"2023-09-20T15:30:21.021Z","comments":true,"path":"coding/cpe/One Star/108-Maximum-Sum/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/108-Maximum-Sum/","excerpt":"","text":"🌕🌗🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 A problem that is simple to solve in one dimension is often much more difficult to solve in more than one dimension. Consider satisfying a boolean expression in conjunctive normal form in which each conjunct consists of exactly 3 disjuncts. This problem (3-SAT) is NP-complete. The problem 2-SAT is solved quite efficiently, however. In contrast, some problems belong to the same complexity class regardless of the dimensionality of the problem. Given a 2-dimensional array of positive and negative integers, find the sub-rectangle with the largest sum. The sum of a rectangle is the sum of all the elements in that rectangle. In this problem the subrectangle with the largest sum is referred to as the maximal sub-rectangle. A sub-rectangle is any contiguous sub-array of size 1 × 1 or greater located within the whole array. As an example, the maximal sub-rectangle of the array: 0−2−7092−62−41−41−180−2\\begin {matrix} 0 &amp; −2 &amp; −7 &amp; 0\\\\9 &amp; 2 &amp; −6 &amp; 2\\\\−4 &amp; 1 &amp; −4 &amp; 1\\\\−1 &amp; 8 &amp; 0 &amp; −2 \\end {matrix}09−4−1​−2218​−7−6−40​021−2​ is in the lower-left-hand corner: 92−41−18\\begin {matrix} 9 &amp; 2\\\\−4 &amp; 1\\\\−1 &amp; 8 \\end {matrix}9−4−1​218​ and has the sum of 15. # Input The input consists of an N × N array of integers. The input begins with a single positive integer N on a line by itself indicating the size of the square two dimensional array. This is followed by N^2 integers separated by white-space (newlines and spaces). These N^2 integers make up the array in row-major order (i.e., all numbers on the first row, left-to-right, then all numbers on the second row, left-to-right, etc.). N may be as large as 100 . The numbers in the array will be in the range [−127, 127] . # Output The output is the sum of the maximal sub-rectangle. # Sample Input 4 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 # Sample Output 15 # 解題技巧 利用兩次 dp (Dynamic Programming) 來完成紀錄最大的子矩陣數值總數 第一個 dp 是用來記錄矩陣從左上角的矩陣開始，並固定開始位置，一路計算子矩陣數值到右下角。 第二個 dp 是由 Time Complexity O(n^4) 完成的，利用前面計算的陣列，並以下圖的方式解決中間子陣列的數值計算。 註：為了計算方便，我們將陣列大小設為 N + 1 避免判斷 i - 1 或 j - 1 小於 0 的可能性。 在計算第二個 dp 的時候每個數值來比大小，並記錄最大值，就為答案。 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); int[][] arr = new int[N + 1][N + 1]; int max = Integer.MIN_VALUE; for(int i = 1; i &lt; N + 1; i++)&#123; for(int j = 1; j &lt; N + 1; j++)&#123; int input = sc.nextInt(); arr[i][j] = arr[i - 1][j] + arr[i][j - 1] - arr[i - 1][j - 1] + input; &#125; &#125; for(int i = 1; i &lt; N + 1; i++)&#123; for(int j = 1; j &lt; N + 1; j++)&#123; for(int x = i; x &lt; N + 1; x++)&#123; for(int y = j; y &lt; N + 1; y++)&#123; int curr = arr[x][y] - arr[i - 1][y] - arr[x][j - 1] + arr[i - 1][j - 1]; max = Math.max(max, curr); &#125; &#125; &#125; &#125; System.out.println(max); sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"1584. Min Cost to Connect All Points","slug":"coding/leetcode/Medium/1584-Min-Cost-to-Connect-All-Points","date":"2023-09-15T01:28:00.000Z","updated":"2023-09-15T02:59:22.904Z","comments":true,"path":"coding/leetcode/Medium/1584-Min-Cost-to-Connect-All-Points/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1584-Min-Cost-to-Connect-All-Points/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi] . The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj| , where |val| denotes the absolute value of val . Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points. # Example 1 Input: points = [[0,0],[2,2],[3,10],[5,2],[7,0]] Output: 20 Explanation: We can connect the points as shown above to get the minimum cost of 20. Notice that there is a unique path between every pair of points. # Example 2 Input: points = [[3,12],[-2,5],[-4,1]] Output: 18 # 解題思路 先將 points[][] 中兩兩點連線，並運算其長度 (使用 manhattan distance)，將其存於 W[][] 中。 從第一個節點出發，也就是 W[0] 開始，將其與其他節點的值存於 distance[] 中。 接著就開始使用 MST (Minimum Spanning Trees) 演算法進行尋找最佳路徑。 # Solution class Solution &#123; public int minCostConnectPoints(int[][] points) &#123; int V = points.length; int ans = 0; int[] distance = new int[V]; int[][] W = new int[V][V]; for (int i = 0; i &lt; V; i++) &#123; for (int j = 0; j &lt; V; j++) &#123; if (i == j) &#123; W[i][j] = 0; &#125; else &#123; W[i][j] = Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1]); &#125; &#125; &#125; for (int i = 0; i &lt; V; i++) &#123; distance[i] = W[0][i]; &#125; return prim(distance, W, V); &#125; private int prim(int[] distance, int[][] W, int V) &#123; int res = 0; int count = 0; while (count &lt; V - 1) &#123; int min = Integer.MAX_VALUE; int vnear = 0; for (int i = 0; i &lt; V; i++) &#123; if (distance[i] > 0 &amp;&amp; distance[i] &lt; min) &#123; min = distance[i]; vnear = i; &#125; &#125; distance[vnear] = -1; for (int i = 0; i &lt; V; i++) &#123; if (W[i][vnear] &lt; distance[i]) &#123; distance[i] = W[i][vnear]; &#125; &#125; res += min; count++; &#125; return res; &#125;&#125; 單字 coordinates 座標 n. one of a pair of numbers and/or letters that show the exact position of a point on a map or graph X and y coordinates are the horizontal and vertical addresses of a point in any 2D space and help identify the exact location of a point. 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Minimum Spanning Tree","slug":"Minimum-Spanning-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Minimum-Spanning-Tree/"}]},{"title":"105 - The Skyline Problem","slug":"coding/cpe/One Star/105-The-Skyline-Problem","date":"2023-09-14T13:32:58.000Z","updated":"2023-09-20T15:30:23.791Z","comments":true,"path":"coding/cpe/One Star/105-The-Skyline-Problem/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/105-The-Skyline-Problem/","excerpt":"","text":"🌕🌗🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 With the advent of high speed graphics workstations, CAD (computer-aided design) and other areas (CAM, VLSI design) have made increasingly effective use of computers. One of the problems with drawing images is the elimination of hidden lines — lines obscured by other parts of a drawing. You are to design a program to assist an architect in drawing the skyline of a city given the locations of the buildings in the city. To make the problem tractable, all buildings are rectangular in shape and they share a common bottom (the city they are built in is very flat). The city is also viewed as twodimensional. A building is specified by an ordered triple (Li, Hi, Ri) where Li and Ri are the left and right coordinates, respectively, of building i (0 &lt; Li &lt; Ri) and Hi is the height of the building. In the diagram below buildings are shown on the left with triples (1,11,5),(2,6,7),(3,13,9),(12,7,16),(14,3,25),(19,18,22),(23,13,29),(24,4,28)(1, 11, 5),(2, 6, 7),(3, 13, 9),(12, 7, 16),(14, 3, 25),(19, 18, 22),(23, 13, 29),(24, 4, 28) (1,11,5),(2,6,7),(3,13,9),(12,7,16),(14,3,25),(19,18,22),(23,13,29),(24,4,28) the skyline, shown on the right, is represented by the sequence: (1,11,3,13,9,0,12,7,16,3,19,18,22,3,23,13,29,0)(1, 11, 3, 13, 9, 0, 12, 7, 16, 3, 19, 18, 22, 3, 23, 13, 29, 0) (1,11,3,13,9,0,12,7,16,3,19,18,22,3,23,13,29,0) # Input The input is a sequence of building triples. All coordinates of buildings are integers less than 10,000 and there will be at least one and at most 5,000 buildings in the input file. Each building triple is on a line by itself in the input file. All integers in a triple are separated by one or more spaces. The triples will be sorted by Li , the left x-coordinate of the building, so the building with the smallest left x-coordinate is first in the input file. # Output The output should consist of the vector that describes the skyline as shown in the example above. In the skyline vector (v1, v2, v3, . . . , vn−2, vn−1, vn) , the vi such that i is an even number represent a horizontal line (height). The vi such that i is an odd number represent a vertical line (x-coordinate). The skyline vector should represent the “path” taken, for example, by a bug starting at the minimum x-coordinate and traveling horizontally and vertically over all the lines that define the skyline. Thus the last entry in all skyline vectors will be a ‘0’ . # Sample Input 1 11 5 2 6 7 3 13 9 12 7 16 14 3 25 19 18 22 23 13 29 24 4 28 # Sample Output 1 11 3 13 9 0 12 7 16 3 19 18 22 3 23 13 29 0 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int[] build = new int[10005]; int buildingStart = Integer.MAX_VALUE, buildingEnd = 0, sameHigh = 0; while(sc.hasNextInt())&#123; int start = sc.nextInt(); int high = sc.nextInt(); int end = sc.nextInt(); buildingStart = Math.min(start, buildingStart); buildingEnd = Math.max(end, buildingEnd); for(; start &lt; end; start++)&#123; build[start] = Math.max(high, build[start]); &#125; &#125; for(int curr = buildingStart; curr &lt;= buildingEnd; curr++)&#123; if(sameHigh != build[curr])&#123; System.out.print(curr + \" \" + build[curr] + (curr != buildingEnd ? \" \" : \"\\n\")); sameHigh = build[curr]; &#125; &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"100 - The 3n + 1 problem","slug":"coding/cpe/One Star/100-The-3n-1-problem","date":"2023-09-13T00:01:00.000Z","updated":"2023-09-20T15:28:51.827Z","comments":true,"path":"coding/cpe/One Star/100-The-3n-1-problem/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/100-The-3n-1-problem/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Problems in Computer Science are often classified as belonging to a certain class of problems (e.g., NP, Unsolvable, Recursive). In this problem you will be analyzing a property of an algorithm whose classification is not known for all possible inputs. Consider the following algorithm: input n print n if n = 1 then STOP if n is odd then n ← 3n + 1 else n ← n/2 GOTO 2 Given the input 22, the following sequence of numbers will be printed 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1 22\\ \\ \\ 11\\ \\ \\ 34\\ \\ \\ 17\\ \\ \\ 52\\ \\ \\ 26\\ \\ \\ 13\\ \\ \\ 40\\ \\ \\ 20\\ \\ \\ 10\\ \\ \\ 5\\ \\ \\ 16\\ \\ \\ 8\\ \\ \\ 4\\ \\ \\ 2\\ \\ \\ 1\\ \\ \\ 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1 It is conjectured that the algorithm above will terminate (when a 1 is printed) for any integral input value. Despite the simplicity of the algorithm, it is unknown whether this conjecture is true. It has been verified, however, for all integers n such that 0 &lt; n &lt; 1, 000, 000 (and, in fact, for many more numbers than this.) Given an input n , it is possible to determine the number of numbers printed before and including the 1 is printed. For a given n this is called the cycle-length of n . In the example above, the cycle length of 22 is 16. For any two numbers i and j you are to determine the maximum cycle length over all numbers between and including both i and j . # Input The input will consist of a series of pairs of integers i and j , one pair of integers per line. All integers will be less than 10,000 and greater than 0 . You should process all pairs of integers and for each pair determine the maximum cycle length over all integers between and including i and j . You can assume that no operation overflows a 32-bit integer. # Output For each pair of input integers i and j you should output i , j , and the maximum cycle length for integers between and including i and j . These three numbers should be separated by at least one space with all three numbers on one line and with one line of output for each line of input. The integers i and j must appear in the output in the same order in which they appeared in the input and should be followed by the maximum cycle length (on the same line). # Sample Input 1 10 100 200 201 210 900 1000 # Sample Output 1 10 20 100 200 125 201 210 89 900 1000 174 # 解題技巧 沒什麼特別技巧，暴力解哈哈哈！ # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNextInt()) &#123; int i = sc.nextInt(); int j = sc.nextInt(); System.out.print(i + \" \" + j + \" \"); int maxCount = 0; for (int temp = Math.min(i, j); temp &lt;= Math.max(i, j); temp++) &#123; int count = 1; int curr = temp; while (curr != 1) &#123; curr = algorithm(curr); count++; &#125; maxCount = Math.max(maxCount, count); &#125; System.out.println(maxCount); &#125; &#125; public static int algorithm(int i) &#123; int res = 0; if (i % 2 == 1) &#123; res = 3 * i + 1; &#125; else &#123; res = i / 2; &#125; return res; &#125;&#125;單字 certain 肯定 adj. having no doubt or knowing exactly that something is true, or known to be true, correct, exact, or effective [ + (that) ] Are you absolutely certain (that) you gave them the right number? 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"1282. Group the People Given the Group Size They Belong To","slug":"coding/leetcode/Medium/1282-Group-the-People-Given-the-Group-Size-They-Belong-To","date":"2023-09-11T13:41:16.000Z","updated":"2023-09-11T17:13:00.746Z","comments":true,"path":"coding/leetcode/Medium/1282-Group-the-People-Given-the-Group-Size-They-Belong-To/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1282-Group-the-People-Given-the-Group-Size-They-Belong-To/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 There are n people that are split into some unknown number of groups. Each person is labeled with a unique ID from 0 to n - 1 . You are given an integer array groupSizes , where groupSizes[i] is the size of the group that person i is in. For example, if groupSizes[1] = 3 , then person 1 must be in a group of size 3 . Return a list of groups such that each person i is in a group of size groupSizes[i] . Each person should appear in exactly one group, and every person must be in a group. If there are multiple answers, return any of them. It is guaranteed that there will be at least one valid solution for the given input. # Example 1 Input: groupSizes = [3,3,3,3,3,1,3] Output: [[5],[0,1,2],[3,4,6]] Explanation: The first group is [5]. The size is 1, and groupSizes[5] = 1. The second group is [0,1,2]. The size is 3, and groupSizes[0] = groupSizes[1] = groupSizes[2] = 3. The third group is [3,4,6]. The size is 3, and groupSizes[3] = groupSizes[4] = groupSizes[6] = 3. Other possible solutions are [[2,1,6],[5],[0,4,3]] and [[5],[0,6,2],[4,3,1]]. # Example 2 Input: groupSizes = [2,1,3,3,3,2] Output: [[1],[0,5],[2,3,4]] # 解題思路 Map.computeIfAbsent(key, k -&gt; value) Map.values() List.subList # Solution import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;class Solution &#123; public List&lt;List&lt;Integer>> groupThePeople(int[] groupSizes) &#123; Map&lt;Integer, List&lt;Integer>> groupMap = new HashMap&lt;>(); List&lt;List&lt;Integer>> result = new ArrayList&lt;>(); for (int idx = 0; idx &lt; groupSizes.length; idx++) &#123; int size = groupSizes[idx]; // If groupMap didn't have the key of size then create new ArrayList with this size. groupMap.computeIfAbsent(size, k -> new ArrayList&lt;>()).add(idx); &#125; for (List&lt;Integer> group : groupMap.values()) &#123; int size = group.size(); for (int i = 0; i &lt; size; i += groupSizes[group.get(i)]) &#123; result.add(group.subList(i, i + groupSizes[group.get(i)])); &#125; &#125; return result; &#125;&#125; 片語 & 搭配詞 labeled with 標記為","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"}]},{"title":"403. Frog Jump","slug":"coding/leetcode/Hard/403-Frog-Jump","date":"2023-08-27T12:45:36.000Z","updated":"2023-08-27T15:40:17.227Z","comments":true,"path":"coding/leetcode/Hard/403-Frog-Jump/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/403-Frog-Jump/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water. Given a list of stones ' positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit. If the frog's last jump was k units, its next jump must be either k - 1 , k , or k + 1 units. The frog can only jump in the forward direction. # Example 1 Input: stones = [0,1,3,5,6,8,12,17] Output: true Explanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone. # Example 2 Input: stones = [0,1,2,3,4,8,9,11] Output: false Explanation: There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large. # 解題思路 # Solution import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Set;class Solution &#123; public boolean canCross(int[] stones) &#123; int n = stones.length; Map&lt;Integer, Set&lt;Integer>> dp = new HashMap&lt;>(); for (int stone : stones) &#123; dp.put(stone, new HashSet&lt;>()); &#125; dp.get(0).add(0); for (int i = 0; i &lt; n; i++) &#123; for (int k : dp.get(stones[i])) &#123; for (int step = k - 1; step &lt;= k + 1; step++) &#123; if (step != 0 &amp;&amp; dp.containsKey(stones[i] + step)) &#123; dp.get(stones[i] + step).add(step); &#125; &#125; &#125; &#125; return !dp.get(stones[n - 1]).isEmpty(); &#125;&#125; 單字 river 河 a natural wide flow of fresh water across the land into the sea, a lake, or another river We sailed slowly down the river. 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"}]},{"title":"542. 01 Matrix","slug":"coding/leetcode/Medium/542-01-Matrix","date":"2023-08-17T13:27:38.000Z","updated":"2023-08-17T13:59:16.051Z","comments":true,"path":"coding/leetcode/Medium/542-01-Matrix/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/542-01-Matrix/","excerpt":"","text":"⭐️⭐️⭐️⭐️ # 題目敘述 Given an m x n binary matrix mat , return the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1 . # Example 1 Input: mat = [[0,0,0],[0,1,0],[0,0,0]] Output: [[0,0,0],[0,1,0],[0,0,0]] # Example 2 Input: mat = [[0,0,0],[0,1,0],[1,1,1]] Output: [[0,0,0],[0,1,0],[1,2,1]] # 解題思路 # Solution import java.util.LinkedList;import java.util.Queue;class Solution &#123; public int[][] updateMatrix(int[][] mat) &#123; Queue&lt;int[]> q = new LinkedList&lt;>(); int rows = mat.length; int cols = mat[0].length; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; if (mat[i][j] == 0) &#123; q.offer(new int[]&#123;i, j&#125;); &#125; else &#123; mat[i][j] = -1; &#125; &#125; &#125; int[] dirX = &#123;1, -1, 0, 0&#125;; int[] dirY = &#123;0, 0, 1, -1&#125;; int length = 0; while (!q.isEmpty()) &#123; int size = q.size(); length++; while (size-- > 0) &#123; int[] front = q.poll(); int r = front[0]; int c = front[1]; for (int i = 0; i &lt; 4; i++) &#123; int newRow = r + dirX[i]; int newCol = c + dirY[i]; if (newRow &lt; 0 || newCol &lt; 0 || newRow >= rows || newCol >= cols || mat[newRow][newCol] >= 0) &#123; continue; &#125; mat[newRow][newCol] = length; q.offer(new int[]&#123;newRow, newCol&#125;); &#125; &#125; &#125; return mat; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"}]},{"title":"239. Sliding Window Maximum","slug":"coding/leetcode/Hard/239-Sliding-Window-Maximum","date":"2023-08-16T07:29:08.000Z","updated":"2023-08-16T08:38:01.361Z","comments":true,"path":"coding/leetcode/Hard/239-Sliding-Window-Maximum/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/239-Sliding-Window-Maximum/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 You are given an array of integers nums , there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. # Example 1 Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 # Example 2 Input: nums = [1], k = 1 Output: [1] # 解題思路 Use Deque name dq . Map k integer in the nums , and keep the high number in the dq first value. Adding dp first value in List name res which will become the answer. Making List&lt;Integer&gt; into int[] and return. # Solution import java.util.ArrayDeque;import java.util.ArrayList;import java.util.Deque;import java.util.List;class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; Deque&lt;Integer> dq = new ArrayDeque&lt;>(); List&lt;Integer> res = new ArrayList&lt;>(); for (int i = 0; i &lt; k; i++) &#123; while (!dq.isEmpty() &amp;&amp; nums[i] >= nums[dq.peekLast()]) &#123; dq.pollLast(); &#125; dq.offerLast(i); &#125; res.add(nums[dq.peekFirst()]); for (int i = k; i &lt; nums.length; i++) &#123; if (dq.peekFirst() == i - k) &#123; dq.pollFirst(); &#125; while (!dq.isEmpty() &amp;&amp; nums[i] >= nums[dq.peekLast()]) &#123; dq.pollLast(); &#125; dq.offerLast(i); res.add(nums[dq.peekFirst()]); &#125; return res.stream().mapToInt(Integer::intValue).toArray(); &#125;&#125; 單字 slide 滑動 v. to (cause to) move easily and without interruption over a surface sliding doors 片語 & 搭配詞 make sth into sth 把… 變成 make + 受詞 (物) + into + 受詞 (物) They’ve made the spare room into an office. 他們已把空置的房間改成辦公室。","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Queue","slug":"Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Queue/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"},{"name":"Monotonic Queue","slug":"Monotonic-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Monotonic-Queue/"}]},{"title":"動詞的現在簡單式","slug":"language/english/文法/動詞的現在簡單式","date":"2023-08-15T17:09:11.000Z","updated":"2023-08-16T07:27:58.326Z","comments":true,"path":"language/english/文法/動詞的現在簡單式/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/language/english/%E6%96%87%E6%B3%95/%E5%8B%95%E8%A9%9E%E7%9A%84%E7%8F%BE%E5%9C%A8%E7%B0%A1%E5%96%AE%E5%BC%8F/","excerpt":"","text":"⭐️⭐️ # 文法摘要 主詞是第三人稱單數 (he, she, it) 且為現在式，使用的動詞字尾上必須加 &quot;-s&quot; 或 &quot;-es&quot;，規則如下: 動詞規則改法 範例 動詞字尾加上 s hit - hits 動詞結尾是 e，加上 s hide - hides 動詞字尾是 s/o/x/z/ch/sh，加上 es catch - catches 動詞字尾為 「母音 + y」，只要加 s stay - stays 動詞字尾為 「子音 + y」，要去 y 加上 ies study - studies 表示現在或事實的動作與狀態：注意第三人稱單數的字尾 s/es/ies 變化: 例一: Mr. Smith lives in Taichung, but he works in Taipei. 史密斯先生住在台中，但他在台北工作。 例二: You look tired. Stop working and take a break. 你看起來很累，別工作了，休息一下吧。 表示不變的格言、真理和事實: 例一: The sun rises in the east and sets in the west. 太陽從東邊升起，西邊落下。 例二: There is no royal road to learning. 學習無坦途。 表示現在的習慣或反覆的動作，常與以下頻率副詞連用: always (總是) /frequently (頻繁地) /often (常常) /usually (通常) /sometime (有時) /seldom (不常) /never (絕不) every + 時間 次數 + a/an + 單數時間 例一: On Halloween, houses and yards in the U.S.A. are often lit up by jack-o'-lanterns. 萬聖節時，美國的房子和庭院常點著南瓜燈。 例二: Cindy studies math and English every day. 辛蒂每天讀數學和英文。 例三: He writes to his parents once a week. 他每週寫一次信給父母。 表示時間或條件的副詞子句，用現在式代替未來式 例一: If she comes here tomorrow, please give her this letter. 若她明天來到這，請給她這封信。 例二: Even when you are very old, your fingerprints will still look very much the way they do now. 即便當你非常老，你的指紋仍會看起來和現在非常像。 註：在副詞子句和名詞子句中，仍用未來式表示未來式 例一: Tell me where she will go next month. 告訴我她下個月會去那裡。 例二: I don't know the exact time when he will hand in the report. 我不知道他會繳交報告的確切時間。 單字 royal 皇家的 adj. belonging or connected to a king or queen or a member of their family the royal family # 精選試題 Bill never carries a bag or a wallet when shopping. Every time he has to pay, he takes out money from his pocket. Bill 買東西時從來不帶包包或皮夾。每次要付錢的時候，他就會從口袋裡拿出錢來。 Although Annie know fast food is not good for her health, she still eats it. 雖然 Annie 知道速食對健康不好，她還是繼續吃。 Somewhere along the road, there is a shop which sells things from foreign countries. 這條路上的某處，有家賣異國商品的店。","categories":[{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"文法","slug":"language/english/文法","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E6%96%87%E6%B3%95/"}],"tags":[{"name":"英文文法","slug":"英文文法","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95/"}]},{"title":"86. Partition List","slug":"coding/leetcode/Medium/86-Partition-List","date":"2023-08-15T15:59:54.000Z","updated":"2023-08-15T16:52:26.324Z","comments":true,"path":"coding/leetcode/Medium/86-Partition-List/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/86-Partition-List/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given the head of a linked list and a value x , partition it such that all nodes less than x come before nodes greater than or equal to x . You should preserve the original relative order of the nodes in each of the two partitions. # Example 1 Input: head = [1,4,3,2,5,2], x = 3 Output: [1,2,2,4,3,5] # Example 2 Input: head = [2,1], x = 2 Output: [1,2] # 解題思路 Use two ListNode , less and greater , to hold nodes with values less than x and which node greater than or equal to x . Linking two ListNode togother, attach the greater to the end of the less . # Solution // Definition for singly-linked list.public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125;class Solution &#123; public ListNode partition(ListNode head, int x) &#123; ListNode less = new ListNode(0); ListNode lessTail = less; ListNode greater = new ListNode(0); ListNode greaterTail = greater; while (head != null) &#123; if (head.val &lt; x) &#123; lessTail.next = new ListNode(head.val); lessTail = lessTail.next; &#125; else &#123; greaterTail.next = new ListNode(head.val); greaterTail = greaterTail.next; &#125; head = head.next; &#125; lessTail.next = greater.next; return less.next; &#125;&#125; 單字 preserve 保存 v. to keep something as it is, especially in order to prevent it from decaying or being damaged or destroyed to preserve the environment We want to preserve the character of the town while improving the facilities.","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Linked-List/"}]},{"title":"215. Kth Largest Element in an Array","slug":"coding/leetcode/Medium/215-Kth-Largest-Element-in-an-Array","date":"2023-08-14T13:56:51.000Z","updated":"2023-08-15T16:07:40.696Z","comments":true,"path":"coding/leetcode/Medium/215-Kth-Largest-Element-in-an-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/215-Kth-Largest-Element-in-an-Array/","excerpt":"","text":"⭐️⭐️ # 題目敘述 Given an integer array nums and an integer k , return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Can you solve it without sorting? # Example 1 Input: nums = [3,2,1,5,6,4], k = 2 Output: 5 # Example 2 Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 # 解題思路 Use the PriorityQueue which is a data structure. # Solution import java.util.Comparator;import java.util.PriorityQueue;class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; PriorityQueue&lt;Integer> PQ = new PriorityQueue&lt;>(new PQComparator()); for (int num : nums) &#123; PQ.add(num); &#125; int ans = 0; for (int i = 0; i &lt; k; i++) &#123; ans = PQ.poll(); &#125; return ans; &#125;&#125;class PQComparator implements Comparator&lt;Integer> &#123; @Override public int compare(Integer number1, Integer number2) &#123; int value = number1.compareTo(number2); // elements are sorted in reverse order if (value > 0) &#123; return -1; &#125; else if (value &lt; 0) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;&#125; 單字 distinct 清楚的 adj. There's a distinct smell of cigarettes in here. clearly noticeable; that certainly exists 片語 & 搭配詞 smell of + sth ... 的香味","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Divide-and-Conquer/"},{"name":"Quickselect","slug":"Quickselect","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Quickselect/"}]},{"title":"2369. Check if There is a Valid Partition For The Array","slug":"coding/leetcode/Medium/2369-Check-if-There-is-a-Valid-Partition-For-The-Array","date":"2023-08-13T11:59:37.000Z","updated":"2023-08-14T13:10:58.958Z","comments":true,"path":"coding/leetcode/Medium/2369-Check-if-There-is-a-Valid-Partition-For-The-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2369-Check-if-There-is-a-Valid-Partition-For-The-Array/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given a 0-indexed integer array nums . You have to partition the array into one or more contiguous subarrays. We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions: The subarray consists of exactly 2 equal elements. For example, the subarray [2,2] is good. The subarray consists of exactly 3 equal elements. For example, the subarray [4,4,4] is good. The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1 . For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not. Return true if the array has at least one valid partition. Otherwise, return false. # Example 1 Input: nums = [4,4,4,5,6] Output: true Explanation: The array can be partitioned into the subarrays [4,4] and [4,5,6]. This partition is valid, so we return true. # Example 2 Input: nums = [1,1,1,2] Output: false Explanation: There is no valid partition for this array. # 解題思路 # Solution import java.util.HashMap;import java.util.Map;class Solution &#123; Map&lt;Integer, Boolean> map = new HashMap&lt;>(); public boolean prefixIsValid(int[] nums, int i) &#123; if (map.containsKey(i)) &#123; return map.get(i); &#125; boolean ans = false; if (i > 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; ans |= prefixIsValid(nums, i - 2); &#125; if (i > 1 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; nums[i - 1] == nums[i - 2]) &#123; ans |= prefixIsValid(nums, i - 3); &#125; if (i > 1 &amp;&amp; nums[i] == nums[i - 1] + 1 &amp;&amp; nums[i - 1] == nums[i - 2] + 1) &#123; ans |= prefixIsValid(nums, i - 3); &#125; map.put(i, ans); return ans; &#125; public boolean validPartition(int[] nums) &#123; int n = nums.length; map.put(-1, true); return prefixIsValid(nums, n - 1); &#125;&#125; 單字 partition 分割、隔開 v. to divide one part of a room from another with a thin wall Why don't you partition that large room into a lounge and a dining-room? contiguous 連續的 adj. next to or touching another, usually similar, thing The two states are contiguous with/to each other, but the laws are quite different. valid 有效的 adj. based on truth or reason; able to be accepted My way of thinking might be different from yours, but it's equally valid. obtain 獲得 v. to get something, especially by asking for it, buying it, working for it, or producing it from something else First editions of these books are now almost impossible to obtain. satisfy 滿足 v. to please someone by giving them what they want or need Come on, satisfy my curiosity (= tell me what I want to know) - what happened last night? exactly 確切地 adv. used when you are giving or asking for information that is completely correct It tastes exactly the same as the real thing, but has half the fat. consecutive 連續的 adj. Consecutive events, numbers, etc. follow one after another without an interruption This is the fifth consecutive weekend that I've spent working. adjacent 鄰近的 adj. very near, next to, or touching They lived in a house adjacent to the railway. 片語 & 搭配詞 to obtain permission 獲得許可 satisfy conditions/needs/requirements 滿足條件 / 需求 / 要求 consists of 由... 組成","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"}]},{"title":"UML 實務手冊","slug":"computer-science/Note/UML-實務手冊","date":"2023-08-13T09:46:23.000Z","updated":"2023-08-13T09:49:44.898Z","comments":true,"path":"computer-science/Note/UML-實務手冊/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Note/UML-%E5%AF%A6%E5%8B%99%E6%89%8B%E5%86%8A/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 認識 UML # 統一建模語言 UML (Unified Modeling Language) 是建構模式 (model) 的專用語言。 在編寫程式碼前，開發人員會先經過分析設計的思考，並繪製一些圖形，再搭配一些文字，作為分析設計的產出，這份產出可稱之為軟體模式模型。 # UML 圖 UML 推出了十多款圖，不過並非每款圖都實用，在開發商用資訊系統時，最常用到的 UML 圖，包含有：類別圖、循序圖、使用案例圖、狀態圖 (state machine diagram) 和活動圖 (activity diagram)。 # 簡易的開發程序 實務上， 使用案例圖及敘述 、 類別圖 與 循序圖 三者之搭配，幾乎是 UML 專案的基本型，所以在分工或外包的設計文檔中，通常少不了這三款 UML 圖。 最常見的開發程序是，並行建構使用案例圖文與類別圖，接著才建構循序圖以及按圖編碼。 一個系統只有一個內部結構，而且系統對外提供的所有服務，都僅依賴這個系統穩定的內部結構所支撐。 然而，每一項服務的運作方式皆不同，所以雖然系統僅有一個靜態結構，卻可以有很多個動態行為。 因此，透過 UML 圖來呈現系統的狀況時，一個系統僅有一張呈現系統內部結構的類別圖，而且無論使用案例圖中有多少個使用案例。 但是，每一個使用案例至少對應一張循序圖，呈現出系統執行使用案例期間，其內部的一群物件互動的運作情況。 再者，類別圖通常不是一次就能夠設計完全，而是透過一個又一個的使用案例，以及一張又一張的循序圖，三者經過多次循環更新的歷程後，類別圖才能逐步形成且穩定下來。 # 類別圖 類別圖 (class diagram) 是最重要的 UML 圖。 主要功能: 用來呈現系統內部的靜態結構，而這樣的靜態結構通常可以用直接對應程式碼，因此，從程式設計師的角度來看，類別圖是最被關注的 UML 圖。 類別圖描述了系統的類別集合，類別的屬性和類別之間的關係。 矩形代表類別 (class)、類別內部記載屬性 (attribute) 與操作 (operation)。 類別之間有代表結合關係 (association relationship) 的實線、組合關係 (composition relationship) 的實心菱形實線、一般化關係 (generalization relationship) 的三角形實線。 類別圖符號分成兩種: 物件本身 物件與物件的關係 物件本身 + : public - : private # : protected 物件間的關係 association relationship 結合關係 # 使一個類別知道另一個類別屬性和方法。 // 通常含有「知道」、「了解」的含義。 (A knows B) dependency relationship 依賴關係 # 指在參數或回傳時有用到 (A uses B) Implementation relationship 實作關係 # 指的是一個 class 類別實現 interface 介面 (A implements B) generalization relationship 一般化關係 # 指的是父類別擁有子類別的共用功能，子類別可以視作父類別的特例。 # 描述 is-a 關係。 (A is a type of B) aggregation relationship 聚合關係 # 整體與部分的「弱」包含關係，部分類別可以單獨存在，也可以屬於多個整體物件。 # 描述 has-a 關係。 (A owns B) composition relationship 組合關係 # 整體與部分的「強」包含關係，部分類別無法單獨存在，其生命週期與整體相同。 # 描述 contains-a 關係。 (B is part of A) 多重性 (Multiplicity) | 指示符 | 意思 | | ------ | ------- | | 0...1 | 0 or 1 | | 1 | 1 | | 0...* | 0 or 多 | | 1...* | 1 or 多 | | * | 多 | # 循序圖 循序圖 (sequence diagram) 將類別圖部分更細節。 主要功能: 呈現類別圖操作之實作方法。 在類別圖中，未能提出操作之實作方法，這部分的細節設計，可藉由循序圖來呈現。雖然，我們可以從類別圖對應到程式中的類別、屬性、關係及操作之宣告，但也僅止於此，對於操作的實作方法，還要搭配循序圖才能獲得。 除了表達實作方法外，更重要的是，循序圖還能夠表達執行期間的一群物件，為了合力完成某一個目的，呼叫操作之互動情況。 ![image sequence diagram][reference link] # 使用案例圖 使用案例圖 (use case diagram) 是最與眾不同的 UML 圖。 主要功能: 獨特之處在於它適合用來表達系統的「外部」行為，其餘的 UML 圖都適用於呈現系統內部結構或行為。其餘的 UML 圖都是用於呈現系統的「內部」結構或行為。 橢圓形的使用案例圖示位於系統內部，代表系統將提供且支援這些使用案例，而參與者位於系統外部，代表使用案例的啟動者或支援者。 ![image use case diagram][reference link] # 狀態圖 狀態圖 (state machine diagram) 主要功能: 狀態圖可以讓我們聚焦在單一種類的物件本身，表達物件一生中可以出現的狀態 (state) 變化。 相較之下，狀態圖的觀點與循序圖的觀點全然不同，循序圖表達某一種物件與其他種物件之間的互動情況。 簡而言之，循序圖用以表達物件外部互動行為，而狀態圖表達物件內部的狀態變化。 ![image use case diagram][reference link] # 活動圖 活動圖 (activity diagram) 主要功能: 活動圖非常適合用來表達一連串的行動。 活動圖相當容易理解與使用，它跟我們隨手繪製的流程圖沒什麼不同，唯一需要講究的只有它特定的圖示。 在企業組織領域裡，我們經常用它來表達工作流程、企業流程或聯合服務等的活動流程。 至於資訊系統的應用上，遇到較為複雜的系統流程、整合流程及操作時，我們也會配合使用活動圖協助思考及設計。 其他時候，為了節省開發成本與縮短開發時程，可能僅採用循序圖來表達系統內部物件的互動情況。 ![image use case diagram][reference link] # UML 工具 StarUML IBM RSA Case Complete","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Note","slug":"computer-science/Note","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Note/"}],"tags":[]},{"title":"C Program 進階","slug":"computer-science/Program-Language/C Programming Language/C-Program-進階","date":"2023-08-13T09:15:16.000Z","updated":"2023-08-14T14:04:11.723Z","comments":true,"path":"computer-science/Program-Language/C Programming Language/C-Program-進階/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Program-Language/C%20Programming%20Language/C-Program-%E9%80%B2%E9%9A%8E/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # Array 變數可以幫我們存取一筆資料，但要存取多筆資料時就會顯得很麻煩。 比如我們要記錄三個學生的成績: # Declare Data type 變數名稱[陣列大小] = &#123;資料&#125;; # Array Input/Output # Two-dimensional Arrays 二維陣列 陣列裡面存放陣列 # Declare Data type 變數名稱[column][row] = &lt;!--swig￼1-->; # Two-dimensional Arrays Input/Output # String 字串 在 C programming language 中，沒有 string 的變數型態， 因此我們這邊提到的字串是以字元陣列的型態表示， 另一種是用 pointer 的型態來表示。 # Declare char 變數名稱[陣列大小] = &#123;‘資’, ‘料’&#125;; char 變數名稱[陣列大小] = “資料”; # Gets/Fgets/Puts 字串輸入 / 輸出 因為 gets 函式無法知道字元陣列的大小，而是依賴換行符號或 EOF 才會結束輸入，因此有可能引發緩衝區溢位的安全問題 。 # Scanf # String of function There are many important string functions defined in &quot;string.h&quot; library. # Strlen The strlen() function returns the length of the given string. It doesn't count null character '\\0' . # Strcpy The strcpy(destination, source) function copies the source string in destination. # Strcat The strcat(first_string, second_string) function concatenates two strings and result is returned to first_string. # Strcmp The strcmp(first_string, second_string) function compares two string and returns 0 if both strings are equal. # Strrev The strrev(string) function returns reverse of the given string. # Strlwr The strlwr(string) function returns string characters in lowercase. # Strupr The strupr(string) function returns string characters in uppercase. # Strstr strstr () 函數返回指向給定字符串中第一次出現的匹配字符串的指針。 它用於返回從第一個匹配到最後一個字符的子字符串。 # Function 函式 A function is a block of code which only runs when it is called. Functions are used to perform certain actions, and they are important for reusing code: Define the code once and use it many times. 我們可以簡單的將程式的函數分成兩種: 有回傳值的 無回傳值的 # Advantage 函式 (function) 是程序抽象化 (procedure abstraction) 的實踐方法: Reusability 重複利用性 Readability 易讀性 Reduce Coupling 降低耦合性 (耦合，指的是和其它程式碼「有」相關) Modularity of the program 模組化 # Syntax _ return value # Syntax _ without parameter # Syntax _ without return value # Function Function 可以把他想成某個功能的實現，用於簡化 main 中的程式，並妥善的將程式清楚區分功能，達到重用、降低耦合性，也讓寫思考程式功能更能分塊撰寫。 在這邊我們可以先不管 Function 內的程式是如何寫的，但是我們知道他可以實現他的功能；區分好後再開始分段思考，要如何撰寫 Function 內的程式可以達到我們所希望的樣子。 # Pointer # Recall Data type 變數名稱 = 資料; # Value # Pointer # Declare T* ptr ptr is pointed a T type object/value &amp;value get address of value *ptr Access data by an address # Pointer # Pointer in Pointer # Pointer and Array # Thinking 請問右邊程式執行後會輸出什麼呢？ # Struct 結構 (structure) 是一種複合型別 (derived data type)，用來表達由多個屬性組成的型別，而這些屬性可以是基本型別或是另一個複合型別所組成。 # 宣告結構 # 存取結構內屬性 # 內嵌在結構內的結構 # 儲存結構的陣列 # 存取結構指標的屬性 # Scope 主要是指我們的變數都有可以使用的範圍，通常一個可以用的範圍是其 “{} ” 內。 EX: 自訂 function 和 main function，其實是兩個不同括號 (“ {} ” ) 的兩段程式碼，所以它裡面的變數命名一樣是不會導致錯誤的，因為對程式來說它是兩塊不同的東西。 EX: main function 中 while/for 中所定義的變數，在 while/for 的 “{} ” 是無法被使用的。 # Argument Passing # Call by Value 利用 call by value 的方法去傳值時，因為 a, b 的記憶體和 swap function 內 a, b 的記憶體是分開的，所以不會互相干擾，但需要使用另外的兩個記憶體去儲存他們！ # Call by Address 使用了一個 swap function，它的功能是將 a 和 b 傳入的 address 進行交換，之後在 main 裡面利用 &amp; 符號傳入 address ，然後執行一遍就可以發現，交換前 a 的值為 1，b 的值為 0，交換後 a 的記憶體空間和 b 交換，所以各自代表的值也變成了 0 和 1。 # Algorithm 由有限步驟所構成的集合，可以用於解決某一個特定的問題。 其實演算法就是一種解決問題的邏輯思維！ Ex: 假設我們今天要解決的那一個特定問題是「把蘋果做成一杯蘋果汁」 可以透過以下幾個步驟來實現： 清洗蘋果 將蘋果削皮、去籽 將經過步驟 (2) 處理的蘋果放入果汁機 在果汁機中加入一定比例的水 按下果汁機啟動按鈕 將果汁機裡面的蘋果汁倒入玻璃杯中","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"program-language","slug":"computer-science/Program-Language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/"},{"name":"C Programming Language","slug":"computer-science/Program-Language/C-Programming-Language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/C-Programming-Language/"}],"tags":[]},{"title":"C Program 基礎","slug":"computer-science/Program-Language/C Programming Language/C-Program-基礎","date":"2023-08-13T08:44:47.000Z","updated":"2023-08-14T14:04:04.066Z","comments":true,"path":"computer-science/Program-Language/C Programming Language/C-Program-基礎/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Program-Language/C%20Programming%20Language/C-Program-%E5%9F%BA%E7%A4%8E/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # Get Start 前情提要 Program language C C++ Java JavaScript Python Source-code Editor VS code dev c++ Code::Block notepad++ Compiler # Introduction 介紹 雖然他是一個很古老的語言，也相較底層，但到如今還是一個相當熱門的語言。 他是很多語言的基礎，學習 C 語言後，在學習其他語言，會更加容易上手。 C 語言 與 UNIX 密切相關，因為它是為編寫 UNIX 作業系統而開發的。 C 語言 相較於其他語言來說，較為快速。 # Base 基本概念 Rule Left to Right, Up to Down ; at the end of each line of instructions return 0 ; end of program Use TAB &#123;&#125; content in structure Comment // … single line /* … */ multi-line # Syntax 語法 get start #include &lt;stdio.h>int main()&#123; ... return 0;&#125; 引入函式庫 Standard Library Header File 標準函式庫標頭檔 #include &lt;stdio.h&gt; : 內容大略為處理輸入和輸出對象 scanf / printf 給電腦字典 (標頭檔) 查詢程式內容意思 主函式 程式執行的主要內容，任何程式的切入點 備註：學到 function 後會更加清楚 # Variable 變數 簡單來說，就是它的數值會改變的數 Type 型態 Label 標籤 Data 資料 # Declare Data type 變數名稱 = 資料; # Data Type Primitive Data Types : int, float, char, bool, void Derived Data Types : function, array, pointer, reference Abstract or User-Defined Data Types : Class, Structure, Union, Enumeration, Typedef defined Datatype # Primitive Data Type These data types are built-in or predefined data types and can be used directly by the user to declare variables. Data Type byte Remark Int 整數 4 byte range from ≈ 10^9 Float 單精度浮點數 4 byte Double 雙經度浮點數 8 byte range from -128 to 127 or 0 to 255 Char 字元 1 byte True(1) or False(0) Bool 布林 1byte used for function which does not return a value Void 無 / 空 1byte == 8bits # Identifiers Can contain letters, digits and underscores Must begin with a letter or an underscore (_) case sensitive (myVar and myvar are different variables) Cannot contain whitespaces or special characters ( ! # % ……) Reserved words cannot be used (like C keywords, such as int) 名稱要有描述性且合理 少用縮寫，對於沒有參與這個專案、但在相關領域的人熟悉的縮寫字，可以使用 變數（包括函式的參數）的名稱一律小寫，單字之間用底線連接 命名規則 # Constants 常數 無法被更改的數值 cconst Data type 變數名稱 = 資料; # I/O # Printf 輸出 將資料輸出，顯示在螢幕上 輸出變數 將變數輸出，顯示在螢幕上 輸出變數於特定格式 將變數輸出成特定格式，顯示在螢幕上 # Escape \\ 跳脫字元 \\0 空字元 (NULL) \\t TAB \\n 換行 \\a 響鈴 (BEL) \\” 雙引號 \\’ 單引號 # Scanf 輸入 輸入資料，需要利用變數來放入輸入的資料 # Getchar/Putchar 字元輸入 / 輸出 如果輸入了兩個以上的字元，則 getchar 會取得第一個字元，並將第二個字元留在緩衝區中，直到再使用 getchar 或 scanf 取得輸入。 # Operator Arithmetic Operator Assignment Operator Relational Operator / Comparison Operator Logical Operator Unary Operator # Arithmetic Operators + 加法 - 減法 * 乘法 / 商數除法 % 餘數除法 # Assignment Operators = 指派 += 複合指派 # Relational Operators &gt; 大於 &gt;= 大於等於 &lt; 小於 &lt;= 小於等於 == 等於 != 不等於 = VS. == = 指派: a = b 將 b 的值存入 a 變數中 == 等於: a == b a 與 b 是否相等？True/False # Logical Operators &amp;&amp; AND 且 || OR 或 ! NOT 相反 # Unary Operators ++ / -- postfix-expression ++ ++ unary-expression # Challenge (B) (A) (A) (B) # Encoding Encoding is the process of converting information from one format to another. # ASCII American Standard Code for Information Interchange 字元編碼（Character encoding）total 128 Control character 33 Printable characters 95 ASCII 維基百科 大寫轉小寫 英文大寫 A 十進位表示方式: 65 英文小寫 a 十進位表示方式: 97 # 97–65=3297 – 65 = 3297–65=32 # 英文大小寫 十進位表示方式差 32 # Control flow Selection Statements 選擇語句 Iteration Statements 反覆語句 Jump Statements 跳轉語句 # Selection Statements 經由判斷條件是 TRUE 或是 FALSE，來選擇要執行哪段程式 If … else Switch case # Iteration Statements 重複執行單個或多個運算式，在每次執行前會先判斷條件式，若為 FALSE 或是 break，才會中斷。 While Do while For loop # Jump Statements Break 中斷 中斷並結束迴圈。 Continue 繼續 中斷當次迴圈循環，到開頭在執行一次。 # Selection Statements # If … else If _ Flow chart If _ Syntax If … else _ Flow chart If … else _ Syntax Shorthand if … else _ Syntax If … else if … else _ Flow chart If … else if … else _ Syntax Nested if _ Flow chart Nested if _ Syntax # Switch Switch _ Flow chart Switch _ Syntax # Thinking 請問右邊程式執行後會輸出什麼呢？ 中止條件: 一直執行到沒有 case 為止 當遇到 break 時，強制跳離 # Iteration Statements # While While _ Flow chart While _ Syntax # Do while Do while _ Flow chart Do while _ Syntax # For loop For loop _ Flow chart For loop_ Syntax statement 1 : initialization statement 2 : conditional statement 3 : update # Nested loop 巢狀是指東西如同鳥巢一樣，一層一層的包下去，而程式中的巢狀迴圈是， while/for 迴圈內包著 while/for 迴圈。 # Midway Challenge","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"program-language","slug":"computer-science/Program-Language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/"},{"name":"C Programming Language","slug":"computer-science/Program-Language/C-Programming-Language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/C-Programming-Language/"}],"tags":[]},{"title":"PHP 串接資料庫","slug":"computer-science/Program-Language/PHP/PHP-串接資料庫","date":"2023-08-13T08:10:47.000Z","updated":"2023-08-14T14:03:59.948Z","comments":true,"path":"computer-science/Program-Language/PHP/PHP-串接資料庫/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Program-Language/PHP/PHP-%E4%B8%B2%E6%8E%A5%E8%B3%87%E6%96%99%E5%BA%AB/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 與資料庫的結合運用 在 PHP 中連結資料庫 all.php&lt;?php require '../header.php'; ?>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', '帳號', '密碼');?>&lt;?php require '../footer.php'; ?>網頁沒有顯示錯誤訊息就表示連接成功。 # 利用 PDO 連接資料庫 在 PHP 中要連結資料庫，通常使用提供了 PHP 與資料庫間的連線機制的 PDO。 在 PHP 中，可以使用 類別 (Class) 來統整定義相關的變數與函式。 PDO 即是一種類別，裡面包含了操作資料庫時會使用到的變數與函式。 類別中的變數稱為 屬性 (property)，類別內的函式稱為 方法 (Method)。 要使用類別之前，一定要產生 instance。 # 產生 PDO 的 instance $pdo=new PDO(...); 用來識別資料庫的參數 (DSN) 'mysql:host=localhost;dbname=shop;charset=utf8' mysql 表示要連線到 MySQL。在冒號 (:) 之後列出連線資料庫所需的資料，並以分號 ( ; ) 分隔每項資料。 host=localhost 是指 MySQL 存在於 localhost。在此所用的 MySQL，是與 XAMPP 一起安裝在您手邊的電腦上，因此指定位置為 localhost。 dbname=shop 表示 shop 資料庫。 charset=utf8 則表示資料庫所用的文字編碼為 UTF-8。 登入的使用者名稱 'staff'第 2 個參數用來設定登入資料庫的使用者名稱。 這裡指定為建立 shop 資料庫時建立的使用者 staff。必須以單引號 (') 框住。 登入密碼 'password'第 3 個參數用來設定登入密碼。 這裡指定為建立使用者所設定的密碼 password。必須以單引號 (') 框住。 用 PHP 顯示 table 中資料 all2.php&lt;?php require '../header.php'; ?>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');foreach ($pdo->query('select * from product') as $row) &#123; echo '&lt;p>'; echo $row['id'], ':'; echo $row['name'], ':'; echo $row['price']; echo '&lt;/p>';&#125;?>&lt;?php require '../footer.php'; ?>all3.php&lt;?php require '../header.php'; ?>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');foreach ($pdo->query('select * from product') as $row) &#123; echo \"&lt;p>$row[id]:$row[name]:$row[price]&lt;/p>\";&#125;?>&lt;?php require '../footer.php'; ?>以雙引號框住的字串，具有可在字串之中插入變數值的功能。 # 執行 SQL 指令 PDO的變數->query('SQL指令')變數 PDO 名字是 $pdo $pdo->query('SQL指令')呼叫方法的程式寫法為 (變數 -&gt; 方法 ) # 取得資料欄內的資料 陣列名稱['資料欄名稱']利用 foreach 迴圈，就可將資料逐筆處理。 用 PHP 顯示 Table 中資料 all4.php&lt;?php require '../header.php'; ?>&lt;table>&lt;tr>&lt;th>商品編號&lt;/th>&lt;th>商品名稱&lt;/th>&lt;th>商品價格&lt;/th>&lt;/tr>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=pratice;charset=utf8', '帳號', '密碼');foreach ($pdo->query('select * from person') as $row) &#123; echo \"&lt;tr>&lt;td>$row[person_id]&lt;/td>&lt;td>$row[person_name]&lt;/td>&lt;td>$row[person_birth]&lt;/td>&lt;/tr>\"; echo \"\\n\";&#125;?>&lt;/table>&lt;?php require '../footer.php'; ?>以雙引號框住的字串，具有可在字串之中插入變數值的功能。 all5.php&lt;?php require '../header.php'; ?>&lt;table>&lt;tr>&lt;th>商品編號&lt;/th>&lt;th>商品名稱&lt;/th>&lt;th>商品價格&lt;/th>&lt;/tr>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');foreach ($pdo->query('select * from product') as $row) &#123; echo '&lt;tr>'; echo '&lt;td>', htmlspecialchars($row['id']), '&lt;/td>'; echo '&lt;td>', htmlspecialchars($row['name']), '&lt;/td>'; echo '&lt;td>', htmlspecialchars($row['price']), '&lt;/td>'; echo '&lt;/tr>'; echo \"\\n\";&#125;?>&lt;/table>&lt;?php require '../footer.php'; ?>資料中若有可能包含在 HTML 中有特殊意義的字，顯示前應先經 htmlspecialchars 函式處理。 # 函式的定義 PHP 不僅提供了許多現成的函式，程式設計師也可自行撰寫需要的函式。 function 函式名稱(傳入參數, ...)&#123; 執行的處理; ... return 回傳值;&#125;# 資料的搜尋 用欄位中的名稱搜尋資料 search-input.php&lt;?php require '../header.php'; ?>請輸入商品名稱：&lt;form action=\"search-output.php\" method=\"post\">&lt;input type=\"text\" name=\"keyword\">&lt;input type=\"submit\" value=\"搜尋\">&lt;/form>&lt;?php require '../footer.php'; ?>search-output.php&lt;?php require '../header.php'; ?>&lt;table>&lt;tr>&lt;th>商品編號&lt;/th>&lt;th>商品名稱&lt;/th>&lt;th>商品價格&lt;/th>&lt;/tr>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');$sql=$pdo->prepare('select * from product where name=?');$sql->execute([$_REQUEST['keyword']]);foreach ($sql->fetchAll() as $row) &#123; echo '&lt;tr>'; echo '&lt;td>', $row['id'], '&lt;/td>'; echo '&lt;td>', $row['name'], '&lt;/td>'; echo '&lt;td>', $row['price'], '&lt;/td>'; echo '&lt;/tr>'; echo \"\\n\";&#125;?>&lt;/table>&lt;?php require '../footer.php'; ?> # where 在 SQL 的 select 敘述中，用來指定搜尋條件，在他之後直接寫出條件式。 where 資料欄名稱 ='搜尋的鍵值'可以用？來代替之後才要代入的值。 select * from product where 資料欄名稱 =?# prepare 是用來進行 SQL 指令執行前的準備。 PDO的變數->prepare('SQL指令')prepare 方法在執行後，會回傳已設定好 SQL 指令的 PDOStatement 實例。 這個實例在之後執行 SQL 指令時還是會用到，因此要先將它指定給變數。 $sql=$pdo->prepare('select * from product where name=?'); # execute 要執行以傳入參數傳入 prepare 方法的 SQL 指令，必須利用 PHP 內建的 PDOStatement 類別的 execute 方法。 變數->execute(值)若指令中有多個 (?) 時，可以用 ( , ) 分隔多值。 [$_REQUEST['first_keyword'], $_REQUEST['second_keywork']]利用 prepare 方法預處理好 SQL 指令，要利用 execute 方法執行。 # fetchAll 利用 execute 方法執行 SQL 指令後，可再利用 PDOStatement 類別的 fetchAll 方法取的執行結果。 foreach(PDO的變數->fetchAll() as 要將取的結果代入的變數)foreach ($sql->fetchAll() as $row) &#123;# like 搜尋部分符合的商品 select * from product where name like ?;? =&gt; %word% 指就算 word 前後有其他字也符合條件 $sql=$pdo->prepare('select * from product where name like ?');$sql->execute(['%'.$_REQUEST['keyword'].'%']);# not like 找出不含搜尋關鍵字的資訊 select * from product where name not like ?;# like and not like select * from product where name like ? and name not like ?;# 在資料表內新增資料 insert-input.php&lt;?php require '../header.php'; ?>&lt;p>資料新增：&lt;/p>&lt;form action=\"insert-output.php\" method=\"post\">商品名稱&lt;input type=\"text\" name=\"name\">價格&lt;input type=\"text\" name=\"price\">&lt;input type=\"submit\" value=\"確定新增\">&lt;/form>&lt;?php require '../footer.php'; ?>insert-output.php&lt;?php require '../header.php'; ?>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');$sql=$pdo->prepare('insert into product values(null, ?, ?)');if ($sql->execute([$_REQUEST['name'], $_REQUEST['price']])) &#123; echo '新增成功。';&#125; else &#123; echo '新增失敗。';&#125;?>&lt;?php require '../footer.php'; ?>insert-output2.php&lt;?php require '../header.php'; ?>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');$sql=$pdo->prepare('insert into product values(null, ?, ?)');if (empty($_REQUEST['name'])) &#123; echo '請輸入商品名稱。';&#125; else if (!preg_match('/[0-9]+/', $_REQUEST['price'])) &#123; echo '請以整數輸入商品價格。';&#125; else if ($sql->execute( [htmlspecialchars($_REQUEST['name']), $_REQUEST['price']] )) &#123; echo '新增成功。'; &#125; else &#123; echo '新增失敗。'; &#125;?>&lt;?php require '../footer.php'; ?> # empty 在值為空時，回傳 TRUE。 empty(值)# 資料隱碼攻擊 (SQL injection) 說到要預防資料庫存入有問題的資料，就必須提到 資料隱碼攻擊 (SQL injection)。 資料隱碼攻擊 是指系統執行了非開發者撰寫的 SQL 指令，導致資料庫被非法存取的問題。 # 修改資料庫資料 update-input.php&lt;?php require '../header.php'; ?>&lt;table>&lt;tr>&lt;th>商品編號&lt;/th>&lt;th>商品名稱&lt;/th>&lt;th>商品價格&lt;/th>&lt;/tr>&lt;?php$pdo=new PDO( 'mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');foreach ($pdo->query('select * from product') as $row) &#123; echo '&lt;tr>&lt;form action=\"update-output.php\" method=\"post\">'; echo '&lt;input type=\"hidden\" name=\"id\" value=\"', $row['id'], '\">'; echo '&lt;td>', $row['id'], '&lt;/td>'; echo '&lt;td>'; echo '&lt;input type=\"text\" name=\"name\" value=\"', $row['name'], '\">'; echo '&lt;/td>'; echo '&lt;td>'; echo '&lt;input type=\"text\" name=\"price\" value=\"', $row['price'], '\">'; echo '&lt;/td>'; echo '&lt;td>&lt;input type=\"submit\" value=\"確定修改\">&lt;/td>'; echo '&lt;/form>&lt;/tr>'; echo \"\\n\";&#125;?>&lt;/table>&lt;?php require '../footer.php'; ?>update-output.php&lt;?php require '../header.php'; ?>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');$sql=$pdo->prepare('update product set name=?, price=? where id=?');if (empty($_REQUEST['name'])) &#123; echo '請輸入商品名稱。';&#125; elseif (!preg_match('/[0-9]+/', $_REQUEST['price'])) &#123; echo '請以整數輸入商品價格。';&#125; elseif ($sql->execute( [htmlspecialchars($_REQUEST['name']), $_REQUEST['price'], $_REQUEST['id']])) &#123; echo '修改成功。';&#125; else &#123; echo '修改失敗。';&#125;?>&lt;?php require '../footer.php'; ?> # 刪除資料庫資料 delete-input.php&lt;?php require '../header.php'; ?>&lt;table>&lt;tr>&lt;th>商品編號&lt;/th>&lt;th>商品名稱&lt;/th>&lt;th>商品價格&lt;/th>&lt;/tr>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');foreach ($pdo->query('select * from product') as $row) &#123; echo '&lt;tr>'; echo '&lt;td>', $row['id'], '&lt;/td>'; echo '&lt;td>', $row['name'], '&lt;/td>'; echo '&lt;td>', $row['price'], '&lt;/td>'; echo '&lt;td>'; echo '&lt;a href=\"delete-output.php?id=', $row['id'], '\">確定刪除&lt;/a>'; echo '&lt;/td>'; echo '&lt;/tr>'; echo \"\\n\";&#125;?>&lt;/table>&lt;?php require '../footer.php'; ?>delete-output.php&lt;?php require '../header.php'; ?>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');$sql=$pdo->prepare('delete from product where id=?');if ($sql->execute([$_REQUEST['id']])) &#123; echo '刪除成功。';&#125; else &#123; echo '刪除失敗。';&#125;?>&lt;?php require '../footer.php'; ?> # 含有 REQUEST 參數的連結 要開啟的檔案名稱?REQUEST參數名=值要開啟的檔案名稱?REQUEST參數名=值 &amp; REQUEST參數名=值 &amp;...echo '&lt;a href=\"delete-output.php?id=', $row['id'], '\">確定刪除&lt;/a>';# 整合新增、修改、刪除 edit3.php&lt;?php require '../header.php'; ?>&lt;table>&lt;tr>&lt;th>商品編號&lt;/th>&lt;th>商品名稱&lt;/th>&lt;th>價格&lt;/th>&lt;/tr>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');if (isset($_REQUEST['command'])) &#123; switch ($_REQUEST['command']) &#123; case 'insert': if (empty($_REQUEST['name']) || !preg_match('/[0-9]+/', $_REQUEST['price'])) break; $sql=$pdo->prepare('insert into product values(null,?,?)'); $sql->execute( [htmlspecialchars($_REQUEST['name']), $_REQUEST['price']]); break; case 'update': if (empty($_REQUEST['name']) || !preg_match('/[0-9]+/', $_REQUEST['price'])) break; $sql=$pdo->prepare( 'update product set name=?, price=? where id=?'); $sql->execute( [htmlspecialchars($_REQUEST['name']), $_REQUEST['price'], $_REQUEST['id']]); break; case 'delete': $sql=$pdo->prepare('delete from product where id=?'); $sql->execute([$_REQUEST['id']]); break; &#125;&#125;foreach ($pdo->query('select * from product') as $row) &#123; echo '&lt;tr>'; echo '&lt;form action=\"edit3.php\" method=\"post\">'; echo '&lt;input type=\"hidden\" name=\"command\" value=\"update\">'; echo '&lt;input type=\"hidden\" name=\"id\" value=\"', $row['id'], '\">'; echo '&lt;td>', $row['id'], '&lt;/td>'; echo '&lt;td>'; echo '&lt;input type=\"text\" name=\"name\" value=\"', $row['name'], '\">'; echo '&lt;/td>'; echo '&lt;td>'; echo '&lt;input type=\"text\" name=\"price\" value=\"', $row['price'], '\">'; echo '&lt;/td>'; echo '&lt;td>&lt;input type=\"submit\" value=\"確定修改\">&lt;/td>'; echo '&lt;/form>'; echo '&lt;form action=\"edit3.php\" method=\"post\">'; echo '&lt;input type=\"hidden\" name=\"command\" value=\"delete\">'; echo '&lt;input type=\"hidden\" name=\"id\" value=\"', $row['id'], '\">'; echo '&lt;td>&lt;input type=\"submit\" value=\"確定刪除\">&lt;/td>'; echo '&lt;/form>'; echo '&lt;/tr>'; echo \"\\n\";&#125;?>&lt;tr>&lt;form action=\"edit3.php\" method=\"post\">&lt;input type=\"hidden\" name=\"command\" value=\"insert\">&lt;td>&lt;/td>&lt;td>&lt;input type=\"text\" name=\"name\">&lt;/td>&lt;td>&lt;input type=\"text\" name=\"price\">&lt;/td>&lt;td>&lt;input type=\"submit\" value=\"確定新增\">&lt;/td>&lt;/form>&lt;/tr>&lt;/table>&lt;?php require '../footer.php'; ?> # 實用的 PHP 程式 - 以購物網站為例 # Session 是在網頁應用程式中用來放置各使用者資料的機制。 利用 Session 機制，就能管理每個使用者的個別資料。 在 PHP 中，可透過 $_SESSION 陣列存取 Session 資料。 # 網站上線的實務知識 # 限制錯誤訊息的顯示 error_reporting(級別);級別 常數 意義 0 隱藏所有錯誤訊息 E_ERROR 出現重大的執行錯誤時，中斷程式的執行 E_WARNING 執行時出現的警告不會中斷程式的執行 E_PARSE 解釋程式時出現錯誤。會在語法錯誤時發生 E_NOTICE 執行時出現注意。會在懷疑程式可能有誤發生時 E_ALL 顯示所有錯誤訊息 # 利用框架 (Framework) 框架 (Framework) 與函式庫一樣，都是用來支援應用程式開發的軟體。 但是框架提供的不是好用的函式與類別，而且用來規範應用程式的技術方式。 框架並不是用來提供應用程式會用到的部分功能，而是用來提供建構應用程式的整體框架。 因此和函式庫一樣，若能善用框架，就能在短時間開發出功能更好的應用程式。 此外，在多人同時開發應用程式時，利用框架就能統一應用程式的技術方式。 可以讓開發團隊更容易共享資訊，提高開發效率。 Laravel https://laravel.com/","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"program-language","slug":"computer-science/Program-Language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/"},{"name":"PHP","slug":"computer-science/Program-Language/PHP","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/PHP/"}],"tags":[]},{"title":"PHP 基本語法","slug":"computer-science/Program-Language/PHP/PHP-基本語法","date":"2023-08-13T06:49:13.000Z","updated":"2023-08-14T14:03:55.596Z","comments":true,"path":"computer-science/Program-Language/PHP/PHP-基本語法/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Program-Language/PHP/PHP-%E5%9F%BA%E6%9C%AC%E8%AA%9E%E6%B3%95/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # PHP 標籤與程式碼 &lt;?phpPHP 程式內容?> PHP 只會執行 &lt;?php 與 ?&gt; 所框住的內容。 # echo 用來顯示文字訊息 echo '文字訊息'; 以 ' 或 &quot; 框住的內容會被當作是字串。 請留意每行程式的最後，都會有一個分號 (😉。 有多個敘述並列時，將由上至下依序執行。 &lt;?phpecho Welcome;?> 未定義常數 Welcome，錯誤發生於 C:\\xampp\\htdocs\\php\\chapter3\\welcome-error.php 第 2 行 # print 用來顯示文字訊息 print '文字訊息'; echo 和 print 都可用來顯示文字訊息。 通常認為 echo 的處理速度較快 (執行到顯示出訊息所需的時間較短)。 echo 具有將多個字串、數值連接起來顯示的功能。 HTML 區塊: 用於顯示固定不變的內容。 PHP 區塊: 用於顯示會因情況而變動的內容。 &lt;?php echo '歡迎光臨'; ?>可以化簡為 &lt;?= '歡迎光臨'; ?> # require 在 PHP 中，要載入並執行放在其他檔案中的程式，必須使用 require 敘述。 require '檔案名稱'; 可將程式中重複使用的內容存為獨立檔案，再用 require 載入他。 節省反覆輸入重複內容的時間，讓程式看起來更簡潔。 要修改共通使用的部分時，不需在多支程式裡分別修改，只要修改單一檔案的內容即可。 user-input.php&lt;?php require '../header.php'; ?>&lt;p>請輸入姓名：&lt;/p>&lt;form action=\"user-output.php\" method=\"post\"> &lt;!-- post v.s. get --> &lt;input type=\"text\" name=\"user\"> &lt;!-- user 是用在 PHP 中接收的 REQUEST 參數名 --> &lt;input type=\"submit\" value=\"確定\">&lt;/form>&lt;?php require '../footer.php'; ?># request 取得表單回傳的參數 (字串) $_REQUEST['REQUEST參數名']user-output.php&lt;?php require '../header.php'; ?>&lt;?phpecho '午安，', $_REQUEST['user'], '您好。';?>&lt;?php require '../footer.php'; ?># 優化程式 避免出現 REQUEST 參數名 未被定義 (Undefined) 的情形，可以用以下寫法。 &lt;?php require '../header.php'; ?>&lt;?phpif (isset($_REQUEST['user'])) &#123; echo '午安，', $_REQUEST['user'], '您好。';&#125;?>&lt;?php require '../footer.php'; ?> 避免出現 輸入內容含有 HTML，並被執行 的情形，可以用以下寫法。 &lt;?php require '../header.php'; ?>&lt;?phpif (isset($_REQUEST['user'])) &#123; echo '午安，', htmlspecialchars($_REQUEST['user']), '您好。';&#125;?>&lt;?php require '../footer.php'; ?> # 算符 (或稱運算子 Operator) 進行計算的處理即稱為「運算」 算符 作用 ** 平方 ++ -- 加 1、減 1 ! 邏輯 (反值) * / % 乘法、除法、餘數 + - . 加法、減法、字串相連 &lt; &lt;= &gt; &gt;= 比較 (小於、小於等於、大於、大於等於) == != 比較 (等於、不等於) &amp;&amp; 邏輯 (AND) || 邏輯 (OR) = 指派 算符有優先順序之分 # 變數 是用來存放資料的機制 變數名稱的前面必須加上錢字號 ($)。 開頭第 1 個字必須為英文字母或底線 (_)。 除了第 1 個字之外，其他可用英文字母、數字、底線隨意組成。 英文字母的大小寫視為不同文字。 預先定義好的變數 自行定義的變數名稱不可與這些 PHP 預先定義的變數名稱相同 變數名稱 功能 $_REQUEST HTTP 的所有 REQUEST 參數 (無論是以 GET 或 POST 方式傳送) $_GET HTTP 以 GET 方式傳送的 REQUEST 參數 $_POST HTTP 以 POST 方式傳送的 REQUEST 參數 $_FILES 上傳檔案的資料 $_SESSION Session $_COOKIE Cookie # 指派 「=」被稱為指派算符，可將他右邊的值寫入左邊的變數。 變數=值# 變數之間的指派 變數A=變數B# 常數 一開始指派了常數的值之後，就不能再對值做變更。 const 常數名=值# 陣列 (Array) 陣列內區分為多個區塊，用來存放多個資料值，這些區塊稱為陣列的元素。 為了區隔個別元素，必須使用 索引 (index) 來存取。 陣列=[值A, 值B, 值C, ...];陣列=[ 值A, 值B, 值C, ...];陣列=[索引A => 值A,索引B => 值B,索引C => 值C,...];陣列=[ 索引A => 值A, 索引B => 值B, 索引C => 值C, ...];# 新增元素 陣列[]=新元素;# 流程控制 核取方塊 check-input.php&lt;?php require '../header.php'; ?>&lt;form action=\"check-output.php\" method=\"post\"> &lt;p>&lt;input type=\"checkbox\" name=\"mail\">訂閱特賣情報電子報&lt;/p> &lt;p>&lt;input type=\"submit\" value=\"確定\">&lt;/p>&lt;/form>&lt;?php require '../footer.php'; ?> check-output.php&lt;?php require '../header.php'; ?>&lt;?phpif (isset($_REQUEST['mail'])) &#123; echo '已訂閱特賣情報電子報。';&#125; else &#123; echo '未訂閱特賣情報電子報。';&#125;?>&lt;?php require '../footer.php'; ?> # if if 判斷式是 PHP 中用於條件分歧的語法之一。 if(條件)&#123; 條件成立時進行的處理;&#125;以真偽值代入 if 判斷式 if(條件)&#123; 條件為 TRUE 時執行的處理;&#125;# if-else 在條件成立時與條件不成立時，分別執行對應的處理。 if(條件)&#123; 條件成立時進行的處理;&#125; else&#123; 條件不成立時進行的處理;&#125;以真偽值代入 if-else 判斷式 if(條件)&#123; 條件為 TRUE 時執行的處理;&#125; else&#123; 條件為 FALSE 時執行的處理;&#125;# isset 檢查變數是否宣告， NULL 是用來表示變數內為空值的特殊值。 若變數中已代入值且其值不為 NULL 時，則回傳 TRUE 。 isset(變數)在 if 判斷式中使用 REQUEST 參數 if(isset(REQUEST 參數中的變數))&#123; 變數已宣告時要執行的處理;&#125;在 if-else 判斷式中使用 REQUEST 參數 if(isset(REQUEST 參數中的變數))&#123; 變數已宣告時要執行的處理;&#125; else&#123; 變數未宣告時要執行的處理;&#125;# 條件運算式 在 if 判斷式和 if-else 判斷式的條件中，也可使用運算式。 常數 + 算符 (運算子) + 常數 在 if 判斷式的條件中使用運算式 if(運算式)&#123; 當運算結果條件為 TRUE 時執行的處理;&#125;在 if-else 判斷式的條件中使用運算式 if(運算式)&#123; 當運算結果條件為 TRUE 時執行的處理;&#125; else&#123; 當運算結果條件為 FALSE 時執行的處理;&#125;省略大括號 &#123;&#125; 當 if 判斷式的 &#123;&#125; 中只有 1 行程式時，可省略 &#123;&#125; 。 但若 &#123;&#125; 有多行程式，則不可省略。 if(運算式) 當運算結果條件為 TRUE 時執行的處理;if(運算式) 當運算結果條件為 TRUE 時執行的處理; else 當運算結果條件為 FALSE 時執行的處理; 單選紐 radio-input.php&lt;?php require '../header.php'; ?>請選擇餐點：&lt;form action=\"radio-output.php\" method=\"post\"> &lt;p>&lt;input type=\"radio\" name=\"meal\" value=\"日式套餐\" checked>日式套餐&lt;/p> &lt;p>&lt;input type=\"radio\" name=\"meal\" value=\"西式套餐\">西式套餐&lt;/p> &lt;p>&lt;input type=\"radio\" name=\"meal\" value=\"中式套餐\">中式套餐&lt;/p> &lt;p>&lt;input type=\"submit\" value=\"確定\">&lt;/p>&lt;/form>&lt;?php require '../footer.php'; ?> radio-output.php&lt;?php require '../header.php'; ?>&lt;?phpswitch ($_REQUEST['meal']) &#123;case '日式套餐': echo '烤魚、燉菜、味噌湯、白飯、水果'; break;case '西式套餐': echo '果汁、水波蛋、薯餅、麵包、咖啡'; break;case '中式套餐': echo '春捲、煎餃、蛋花湯、炒飯、杏仁豆腐'; break;&#125;echo '將稍候送達';?>&lt;?php require '../footer.php'; ?> # switch 依照不同的輸入訊息顯示出不同訊息的程式，是常見將程式流程分成多段，再依使用者所選內容執行對應的流程。 switch (運算式) &#123;case 值A: 運算結果為 A 時應執行的處理; break;case 值B: 運算結果為 B 時應執行的處理; break;case 值C: 運算結果為 C 時應執行的處理; break;...&#125; 在 case 敘述的最後必須寫上 break 敘述，用來表示處理程序結果，跳出 switch 判斷式的區塊。請記得加上 break 敘述。 下拉式選單 select-input.php&lt;?php require '../header.php'; ?>&lt;p>請選擇座位類型：&lt;/p>&lt;form action=\"select-output.php\" method=\"post\"> &lt;select name=\"seat\"> &lt;option value=\"自由席\">自由席&lt;/option> &lt;option value=\"指定席\">指定席&lt;/option> &lt;option value=\"商務車廂\">商務車廂&lt;/option> &lt;/select> &lt;p>&lt;input type=\"submit\" value=\"確定\">&lt;/p>&lt;/form>&lt;?php require '../footer.php'; ?> select-output.php&lt;?php require '../header.php'; ?>&lt;?phpswitch ($_REQUEST['seat']) &#123;case '指定席': echo '需加付120元補票。'; break;case '商務車廂': echo '需加付250元補票。'; break;default: echo '不需補票。'; break;&#125;?>&lt;?php require '../footer.php'; ?> # default 以上皆非可以使用 default 敘述撰寫。 switch (條件運算式) &#123;case 值A: 運算結果為 A 時應執行的處理; break;case 值B: 運算結果為 B 時應執行的處理; break;default: 運算結果與所有 case 的值都不符合時應執行的處理; break;...&#125; 下拉式選單 select-for-input.php&lt;?php require '../header.php'; ?>&lt;p>請選擇訂購數量：&lt;/p>&lt;form action=\"select-for-output.php\" method=\"post\"> &lt;select name=\"count\"> &lt;option value=\"0\">0&lt;/option> &lt;option value=\"1\">1&lt;/option> &lt;option value=\"2\">2&lt;/option> &lt;option value=\"3\">3&lt;/option> &lt;option value=\"4\">4&lt;/option> &lt;option value=\"5\">5&lt;/option> &lt;option value=\"6\">6&lt;/option> &lt;option value=\"7\">7&lt;/option> &lt;option value=\"8\">8&lt;/option> &lt;option value=\"9\">9&lt;/option> &lt;/select> &lt;p>&lt;input type=\"submit\" value=\"確定\">&lt;/p>&lt;/form>&lt;?php require '../footer.php'; ?>select-for-input2.php&lt;?php require '../header.php'; ?>&lt;p>請選擇訂購數量：&lt;/p>&lt;form action=\"select-for-output.php\" method=\"post\"> &lt;select name=\"count\"> &lt;?php for ($i=0; $i&lt;10; $i++) &#123; echo '&lt;option value=\"', $i, '\">', $i, '&lt;/option>'; &#125; ?> &lt;/select> &lt;p>&lt;input type=\"submit\" value=\"確定\">&lt;/p>&lt;/form>&lt;?php require '../footer.php'; ?> select-for-output.php&lt;?php require '../header.php'; ?>&lt;?phpecho $_REQUEST['count'], '個商品放入購物車。';?>&lt;?php require '../footer.php'; ?> # for 用來進行重複處理的語法之一。 for(開始處理; 條件式; 更新處理)&#123; 重複執行的處理;&#125;# 比較算符 演算子 讀法 判斷結果為 TRUE 的情況 &lt; 小於 左邊值小於右邊 &gt; 大於 左邊值大於右邊 &lt;= 小於等於 左邊值小於等於右邊 (左邊值在右邊以下) &gt;= 大於等於 左邊值大於等於右邊 (左邊值在右邊以上) == 相等 左右相等 != 不相等 (! 為否定之意) 左右不相等 # while 用來進行重複處理的語法之一。 while(條件式)&#123; 重複執行的處理;&#125; for 迴圈與他最大的差異，在於 while 迴圈沒有開始處理和更新處理。 開始處理while(條件式)&#123; 重複執行的處理; 更新處理&#125;# foreach foreach(陣列 as 變數)&#123; 使用變數進行的處理;&#125;foreach($question as $item)&#123; echo '&lt;option value=\"', $item, '\">', $item, '&lt;/option>';&#125;foreach(陣列 as 索引鍵的變數 => 值的變數)&#123; 以索引鍵與值進行的處理;&#125;foreach($store as $key => $value)&#123; echo '&lt;option value=\"', $value, '\">', $key, '&lt;/option>';&#125;# 使用函式 # 呼叫函式 函式(傳入參數)函式(傳入參數1, 傳入參數2, ...)# 設定時區 date_default_timezone_set(地區)# 顯示日期時間 date 函式執行時，會先取得現在的日期時間，再依指定的格式將它當做字串回傳。 date(格式) 文字 說明 Y 年。4 位數 m 月。2 位數，無十位數時自動補 0 d 日。2 位數，無十位數時自動補 0 H 小時。2 位數，無十位數時自動補 0。24 小時制 i 分。2 位數，無十位數時自動補 0 s 秒。2 位數，無十位數時自動補 0 # rand 函式 用來隨機產生一組數值，如果未傳入任何參數，則會回傳 0 以上，亂數最大值以下的亂數回來。 rand()亂數最大值會依執行環境不同而有差異，利用 gettrandmax 函式就能取得最大值。 gettrandmax()rand(最小值, 最大值)# preg_match 函式 利用常規表達式檢查資料格式。 preg_match(模板, 輸入字串)當傳入參數中指定的模板與輸入字串的格式相符，則 preg_match 函式會回傳「1」、「TRUE」; 若格式不符，則回傳「0」、「FALSE」。 preg_match('/^[0-9]&#123;7&#125;$/', $postcode) ^ : 句首 [0-9] :0 ~ 9 的數字 1 個 &#123;7&#125; : 符合前項格式的文字 7 個 $ : 句尾 - : 連字號 (?=.*[a-z]) : 包含小寫英文字母 (a ~ z) (?=.*[A-Z]) : 包含大寫英文字母 (A ~ Z) (?=.*[0-9]) : 包含數字 (0 ~ 9) [a-zA-Z0-9] : 小寫英文字母、大寫英文字母、數字各 1 個 &#123;8,&#125; : 符合前項格式的文字 8 個以上 首先是「.」與「*」，「.」代表任意 1 字；「*」則代表它前面的文字重複 0 次以上。 兩者合一的「.*」，表示任意文字重複 0 次以上。 8 個字母 (包含) 以上，包含至少一個大寫字母、一個小寫字母、一個數字，正則表達式的含義如下： $pattern = '/^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])[a-zA-Z\\d]&#123;8,&#125;$/'; ^ 匹配字符串的開始位置 (?=.*[0-9]) 至少包含一個數字 (?=.*[a-z]) 至少包含一個小寫字母 (?=.*[A-Z]) 至少包含一個大寫字母 [a-zA-Z0-9]&#123;8,&#125; 由大小寫字母和數字組成的字符串，長度至少為 8 個字符 $ 匹配字符串的結束位置 # 將半形轉換成全形 mb_convert_kana(字串, 類型代碼)mb_convert_kana($_REQUEST['name'], 'R') // R 的代碼就表示將半形轉換成全形 類型代碼 意義 r 全形英文字母轉換成半形 R 半形英文字母轉換成全形 n 全形數字轉換成半形 N 半形數字轉換成全形 a 全形英數字轉換成半形 A 半形英數字轉換成全形 s 全形空格轉換成半形 S 半形空格轉換成全形 檔案讀寫 board-input.php&lt;?php require '../header.php'; ?>&lt;p>請輸入留言內容。&lt;/p>&lt;form action=\"board-output.php\" method=\"post\"> &lt;input type=\"text\" name=\"message\"> &lt;input type=\"submit\" value=\"送出\">&lt;/form>&lt;?php require '../footer.php'; ?> board-output.php&lt;?php require '../header.php'; ?>&lt;?php$file='board.txt';if (file_exists($file)) &#123; $board=json_decode(file_get_contents($file));&#125;$board[]=$_REQUEST['message'];file_put_contents($file, json_encode($board));foreach ($board as $message) &#123; echo '&lt;p>', $message, '&lt;/p>&lt;hr>';&#125;?>&lt;?php require '../footer.php'; ?> # 檔案存取 從檔案讀出所有留言清單 將新留言加入留言清單 將所有留言寫入檔案 顯示留言一覽 要與留言內容儲存到檔案，必須使用 JSON 格式。JSON 為 JSON JavaScript Object Notation 的縮寫。 JSON 是緣自於程式語言 JavaScript 的標記方式，除了 JavaScript，亦被運用在多種不同的程式語言。 在 PHP 中使用 JSON 的優點是可輕易地從檔案讀取、寫入字串與陣列等資料結構。 # 讀取檔案 指定的檔案 (資料夾) 存在時，會回傳 TRUE；若檔案 (資料夾) 不存在則回傳 FALSE。 file_exists(檔案名稱)讀取檔案 file_get_contents(檔案名稱)由於讀取檔案是以 JSON 格式儲存，必須先轉換成 PHP 可用的格式，此時使用可以用來進行 JSON 編碼的 json_decode 函式。 json_decode(字串)$board=json_decode(file_get_contents($file))將陣列轉換成 JSON 格式 json_encode(值)寫入檔案 file_put_contents(檔案名稱, 字串) 若要新增檔案不存在，則會新增一個檔案。 檔案上傳 upload-input.php&lt;?php require '../header.php'; ?>&lt;p>請選擇要上傳的檔案。&lt;/p>&lt;form action=\"upload-output.php\" method=\"post\" enctype=\"multipart/form-data\"> &lt;p>&lt;input type=\"file\" name=\"file\">&lt;/p> &lt;p>&lt;input type=\"submit\" value=\"開始上傳\">&lt;/p>&lt;/form>&lt;?php require '../footer.php'; ?> upload-output.php&lt;?php require '../header.php'; ?>&lt;?phpif (is_uploaded_file($_FILES['file']['tmp_name'])) &#123; if (!file_exists('upload')) &#123; mkdir('upload'); &#125; $file='upload/'.basename($_FILES['file']['name']); if (move_uploaded_file($_FILES['file']['tmp_name'], $file)) &#123; echo $file, '上傳成功。'; echo '&lt;p>&lt;img src=\"', $file, '\">&lt;/p>'; &#125; else &#123; echo '上傳失敗。'; &#125;&#125; else &#123; echo '請選擇檔案。';&#125;?>&lt;?php require '../footer.php'; ?> # 取得暫存檔的檔名 $_FILES['檔案選擇按鈕的名稱']['tmp_name'] tmp_name : 取得暫存檔檔名 name : 取得原檔名 # 檢查是否是輸入畫面所上傳的檔案 is_uploaded_file(檔案名稱)# 建立資料夾 mkdir(資料夾名稱)# 只抽取出檔案名 basename(路徑)# 儲存暫存檔 將上傳後產生的暫存檔移動到儲存上傳檔的位置。 move_uploaded_file(暫存檔的檔名, 儲存用的檔名)# 時間戳 # 時間參數 參數 說明 範例 Y 年，四位元數字 “1999″ y 年，二位元數字 “99″ m 月份，若不足二位元則在前面補零 “01″ 至 “12″ n 月份 “1″ 至 “12″ F 月份，英文全名 “January&quot; M 月份，三個英文字母 “Jan&quot; d 幾日，若不足二位元則前面補零 “01″ 至 “31″ j 幾日，二位元數字 “1″ 至 “31″ S 字尾加英文序數，二個英文字母 “th&quot;，&quot;nd&quot; w 星期幾，數字型 “0″ (星期日) 至 “6″ (星期六) l 星期幾，英文全名 “Friday&quot; D 星期幾，三個英文字母 “Fri&quot; A 上下午 “AM&quot;或是 “PM&quot; a 上下午 “am&quot;或是 “pm&quot; h 12 小時制的小時，若不足二位元則前面補零 “01″ 至 “12″ g 12 小時制的小時 “1″ 至 12″ H 24 小時制的小時，若不足二位元則前面補零 “00″ 至 “23″ G 24 小時制的小時 “0″ 至 “23″ i 分鐘 “00″ 至 “59″ s 秒 “00″ 至 “59″ v 毫秒 (PHP 7.0.0 以後) “654″ u 微秒，000000 (PHP 5.2.2 以後，DateTime::format () 才支援) “654321″ z 一年中的第幾天 “0″ 至 “365″ W 一年中的第幾週 “42″ t 該月份的天數 “28″ 至 “31″ U 總秒數 (1970-01-01 00:00:00 開始計算) 可參考 time () 函數","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"program-language","slug":"computer-science/Program-Language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/"},{"name":"PHP","slug":"computer-science/Program-Language/PHP","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/PHP/"}],"tags":[]},{"title":"PHP infomation","slug":"computer-science/Program-Language/PHP/PHP-infomation","date":"2023-08-13T06:18:21.000Z","updated":"2023-08-14T14:03:51.401Z","comments":true,"path":"computer-science/Program-Language/PHP/PHP-infomation/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Program-Language/PHP/PHP-infomation/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # PHP 的用途概要 PHP 主要用於製作網頁應用程式 (Web Application) HTML 無法做到的依 Request 內容變化處理，但是 PHP 程式可以製作。 JavaScript 程式更擅長在瀏覽器上就能解決的處理。 程式語言與程式 網頁應用程式示意圖 透過瀏覽器與網站伺服器使用網頁應用程式 Request 與 Response 網頁應用程式需進行的處理 # 建立開發環境 安裝之後你的電腦就是伺服器，具備了開發網頁應用程式時必備的網站伺服器和資料庫管理系統等軟體。 裡用 XAMPP 可一次建構好網站伺服器與資料庫 XAMPP 所包含的軟體 Apache MariaDB (MySQL) PHP 套件 Perl 套件 可以支援 Windows、Linux、Mac OS X 等作業系統。 LAMP Linux Apache MySQL PHP / Perl / Python 除 XAMPP 之外，LAMP 也是常指開發環境，LAMP 原本常用來建置網站伺服器的軟體合稱。 # 下載 XAMPP XAMPP 官方網站 https://www.apachefriends.org/zh_tw/index.html XAMPP 下載網頁 https://www.apachefriends.org/zh_tw/download.html # 安裝 XAMPP 執行安裝檔 選擇要安裝的軟體 選擇安裝路徑 開始安裝 # 啟動 XAMPP 控制面板 XAMPP Control Panel # 啟動 Apache # 確認 Apache 是否啟動 利用瀏覽器開啟下列 URL，確認 Apache 是否正常啟動。 http://localhost/ http://localhost/dashboard/ # 執行 PHP 程式 在檔案總管中開啟 C 磁碟機中 xampp 資料夾下的 htdocs 資料夾，即路徑 C:\\xampp\\htdocs。 這個 htdocs 資料夾內就是用來放置 PHP 程式和 HTML 等檔案。 請務必記住 http://localhost 與 C:\\xampp\\htdocs\\ 的對應關係。 要執行 PHP 程式時，必須輸入程式的對應 URL。 # 顯示執行結果 # 沒有正常顯示？ Apache 沒有啟動 檔案存放的位置不正確","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"program-language","slug":"computer-science/Program-Language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/"},{"name":"PHP","slug":"computer-science/Program-Language/PHP","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/PHP/"}],"tags":[]},{"title":"What is API?","slug":"computer-science/Note/What-is-API","date":"2023-08-13T06:10:53.000Z","updated":"2023-08-14T13:26:10.377Z","comments":true,"path":"computer-science/Note/What-is-API/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Note/What-is-API/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # API 介紹: https://www.hububble.co/blog/api 引用文 https://aws.amazon.com/tw/what-is/api/ # 什麼是 API？ API 是使用一組定義和協定讓兩個軟體元件彼此通訊的機制。舉例來說，氣象局的軟體系統包含有每日的天氣資料。您手機中的天氣應用程式會透過 API 與此系統「交談」並且在您的手機顯示每日天氣的最新消息。 # API 代表什麼意思？ API 代表應用程式開發介面。在 API 的內容中，應用程式一詞指的是具有不同功能的任何軟體。可以將介面看作是兩個應用程式之間的服務合約。這份合約定義了兩者如何使用要求與回應彼此進行通訊。它們的 API 文件包含有關開發人員如何構建這些要求與回應的資訊。 # API 如何運作？ API 架構通常會藉由用戶端和伺服器來說明。傳送要求的應用程式稱為用戶端，傳送回應的應用程式則稱為伺服器。因此在天氣的例子當中，氣象局的天氣資料庫是伺服器，行動應用程式是用戶端。 API 有四種不同方式可以運作，具體取決於它們建立的時機以及原因為何。 SOAP API 這些 API 使用簡單物件存取協定 (Simple Object Access Protocol)。用戶端和伺服器使用 XML 交換訊息。這是過去較為常用，但是較不具有彈性的 API。 RPC API 這些 API 稱為遠端程序呼叫 (Remote Procedure Call)。用戶端在伺服器上完成功能 (或程序)，伺服器則將輸出傳回用戶端。 WebSocket API WebSocket API 是使用 JSON 物件傳遞資料的另一個現代 Web API 開發。WebSocket API 可支援用戶端應用程式以及伺服器之間的雙向通訊。伺服器可將回呼訊息傳送至連接的用戶端，使得它與 REST API 更有效率。 REST API 這是現今在 Web 上可以找到最常用以及最彈性的 API。用戶端傳送要求至伺服器作為資料。伺服器使用此用戶端輸入來啟動內部功能，並且將輸出資料傳回用戶端。讓我們在下面更詳細地看看 REST API。 # 什麼是 API 整合？ API 整合是會自動更新用戶端與伺服器之間資料的軟體元件。API 整合的一些例子是當自動資料從手機的圖片庫同步至雲端，或是當您前往其他時區時，時間與日期自動地在您的筆記型電腦上同步。企業可以使用它們有效地自動化許多系統功能。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Note","slug":"computer-science/Note","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Note/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Web/"}]},{"title":"Maven - create project","slug":"computer-science/Note/Maven-create-project","date":"2023-08-13T05:56:45.000Z","updated":"2023-08-13T06:54:38.054Z","comments":true,"path":"computer-science/Note/Maven-create-project/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Note/Maven-create-project/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # Maven download https://maven.apache.org/download.cgi # 環境變數設定 ![](https://i.imgur.com/AWZuYAJ.png =400x) # 確認有安裝好 Maven mvn -v mvn -version # Create Project Cmd mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false powershell 珍惜生命，學習 Java 請少用 PowerShell 當成你主要的 Shell 環境 mvn archetype:generate '-DgroupId=com.mycompany.app' -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart '-DarchetypeVersion=1.4' -DinteractiveMode=false Git Bash mvn archetype:generate \\ -DgroupId=com.mycompany.app -DartifactId=my-app \\ -DarchetypeArtifactId=maven-archetype-quickstart \\ -DarchetypeVersion=1.4 -DinteractiveMode=false \\ 換行只有 bash 以上皆無法 mvn archetype:generate 並選取以下功能 # Add exec-maven-plugin &lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!-- 其他 plugins ... --&gt; &lt;!--===== 加入這段 =====--&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;java&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;mainClass&gt;com.mycompany.app.App&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!--===== 加入這段 =====--&gt; &lt;!-- 其他 plugins ... --&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;jar.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;name&gt;my-app&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt;&lt;!--設定Goal的執行方式--&gt; &lt;goals&gt; &lt;goal&gt;java&lt;/goal&gt; &lt;!--要設定的goal--&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;mainClass&gt;jar.App&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; # 清除 target mvn clean # 產生執行檔 Compile: 通常只下這行就可以執行了 mvn compile Building: 會完整的建構整個專案，並把專案打包成.jar 檔，供別人下載執行。但會產出較多檔案，且耗費較多時間 mvn package # 執行 Execute mvn exec:java","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Note","slug":"computer-science/Note","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Note/"}],"tags":[]},{"title":"Java spring boot 串接資料庫","slug":"computer-science/Program-Language/Framework/Java-Spring-boot/Java-spring-boot-串接資料庫","date":"2023-07-10T06:09:52.000Z","updated":"2023-09-21T05:37:24.486Z","comments":true,"path":"computer-science/Program-Language/Framework/Java-Spring-boot/Java-spring-boot-串接資料庫/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Program-Language/Framework/Java-Spring-boot/Java-spring-boot-%E4%B8%B2%E6%8E%A5%E8%B3%87%E6%96%99%E5%BA%AB/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 資料庫串接檔案配置 檔案路徑: ruoyi-admin/src/main/resources/application.yml ruoyi-admin/src/main/resources/application-druid.yml # 資料庫搜尋 開始撰寫前，記得檢查資料庫配置文件是否修改正確！ # 信息操作處理 檔案路徑: ruoyi-admin/src/main/java/com.ruoyi/web/controller/system 創建檔案: ExerciseController ExerciseController.javapackage com.ruoyi.web.controller.system;import com.ruoyi.common.core.controller.BaseController;import com.ruoyi.system.domain.Exercise;import com.ruoyi.system.service.IExerciseService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;/** * 参数配置 信息操作处理 * * @author ruoyi */@RestController@RequestMapping(\"/system/exercise\")public class ExerciseController extends BaseController&#123; @Autowired private IExerciseService exerciseService; @GetMapping(\"/List\") public List&lt;Exercise> selectExerciseList()&#123; return exerciseService.selectExerciseList(); &#125;;&#125;# 參數配置表 檔案路徑: ruoyi-system/src/main/java/com.ruoyi.system/domain 創建檔案: Exercise.java Exercise.javapackage com.ruoyi.system.domain;import com.ruoyi.common.core.domain.BaseEntity;/** * 参数配置表 exercise * * @author ruoyi */public class Exercise extends BaseEntity&#123; private static final long serialVersionUID = 1L; private Integer id; private String exercise1; private String exercise2; private String exercise3; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getExercise1() &#123; return exercise1; &#125; public void setExercise1(String exercise1) &#123; this.exercise1 = exercise1; &#125; public String getExercise2() &#123; return exercise2; &#125; public void setExercise2(String exercise2) &#123; this.exercise2 = exercise2; &#125; public String getExercise3() &#123; return exercise3; &#125; public void setExercise3(String exercise3) &#123; this.exercise3 = exercise3; &#125;&#125;# 數據層 檔案路徑: ruoyi-system/src/main/java/com.ruoyi.system/mapper 創建檔案: ExerciseMapper.java ExerciseMapper.javapackage com.ruoyi.system.mapper;import com.ruoyi.system.domain.Exercise;import java.util.List;/** * 参数配置 数据层 * * @author ruoyi */public interface ExerciseMapper&#123; public List&lt;Exercise> selectExerciseList();&#125;# 服務層 檔案路徑: ruoyi-system/src/main/java/com.ruoyi.system/service/impl 創建檔案: ExerciseServiceImpl.java ExerciseServiceImpl.javapackage com.ruoyi.system.service.impl;import com.ruoyi.common.core.redis.RedisCache;import com.ruoyi.system.domain.Exercise;import com.ruoyi.system.mapper.ExerciseMapper;import com.ruoyi.system.service.IExerciseService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * 参数配置 服务层实现 * * @author ruoyi */@Servicepublic class ExerciseServiceImpl implements IExerciseService&#123; @Autowired private ExerciseMapper exerciseMapper; @Autowired private RedisCache redisCache; public List&lt;Exercise> selectExerciseList()&#123; return exerciseMapper.selectExerciseList(); &#125;;&#125; 檔案路徑: ruoyi-system/src/main/java/com.ruoyi.system/service 創建檔案: IExerciseService.java IExerciseService.javapackage com.ruoyi.system.service;import com.ruoyi.system.domain.Exercise;import java.util.List;/** * 参数配置 服务层 * * @author ruoyi */public interface IExerciseService&#123; public List&lt;Exercise> selectExerciseList();&#125;# SQL 內容 檔案路徑: ruoyi-system/src/main/resources/mapper.system 創建檔案: ExerciseMapper.xml ExerciseMapper.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">&lt;mapper namespace=\"com.ruoyi.system.mapper.ExerciseMapper\"> &lt;resultMap type=\"Exercise\" id=\"ExerciseResult\"> &lt;id property=\"id\" column=\"id\" /> &lt;result property=\"exercise1\" column=\"exercise_1\" /> &lt;result property=\"exercise2\" column=\"exercise_2\" /> &lt;result property=\"exercise3\" column=\"exercise_3\" /> &lt;/resultMap> &lt;sql id=\"selectExerciseVo\"> select * from exercise &lt;/sql> &lt;select id=\"selectExerciseList\" resultMap=\"ExerciseResult\"> &lt;include refid=\"selectExerciseVo\"/> &lt;/select>&lt;/mapper># 資料庫新增","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"program-language","slug":"computer-science/Program-Language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/"},{"name":"Framework","slug":"computer-science/Program-Language/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/Framework/"},{"name":"Java Spring Boot","slug":"computer-science/Program-Language/Framework/Java-Spring-Boot","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/Framework/Java-Spring-Boot/"}],"tags":[]},{"title":"Java spring boot 框架概念","slug":"computer-science/Program-Language/Framework/Java-Spring-boot/Java-spring-boot-框架概念","date":"2023-07-10T06:08:58.000Z","updated":"2023-09-21T05:37:33.250Z","comments":true,"path":"computer-science/Program-Language/Framework/Java-Spring-boot/Java-spring-boot-框架概念/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Program-Language/Framework/Java-Spring-boot/Java-spring-boot-%E6%A1%86%E6%9E%B6%E6%A6%82%E5%BF%B5/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 利用若依管理系統程式內容進行延伸撰寫，可以先 clone 若依管理系統的程式，方便跟上後面描述 (待附上連接) IDE: intellij API 測試工具: Postman (與 swagger 差異待比較) SQL Sever: MySQL/Xampp phpmyadmin # 檔案結構","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"program-language","slug":"computer-science/Program-Language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/"},{"name":"Framework","slug":"computer-science/Program-Language/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/Framework/"},{"name":"Java Spring Boot","slug":"computer-science/Program-Language/Framework/Java-Spring-Boot","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/Framework/Java-Spring-Boot/"}],"tags":[]},{"title":"111. Minimum Depth of Binary Tree","slug":"coding/leetcode/Easy/111-Minimum-Depth-of-Binary-Tree","date":"2023-07-10T01:36:40.000Z","updated":"2023-07-10T03:21:42.946Z","comments":true,"path":"coding/leetcode/Easy/111-Minimum-Depth-of-Binary-Tree/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/111-Minimum-Depth-of-Binary-Tree/","excerpt":"","text":"⭐️ # 題目敘述 Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. # Example 1 Input: root = [3,9,20,null,null,15,7] Output: 2 # Example 2 Input: root = [2,null,3,null,4,null,5,null,6] Output: 5 # 解題思路 # Solution DFS// Definition for a binary tree node.public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode() &#123;&#125; TreeNode(int val) &#123; this.val = val; &#125; TreeNode(int val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125;&#125;class Solution &#123; public int minDepth(TreeNode root) &#123; return dfs(root); &#125; private int dfs(TreeNode root)&#123; if(root == null) return 0; if(root.left == null &amp;&amp; root.right == null) return 1; if(root.left == null) return 1 + dfs(root.right); if(root.right == null) return 1 + dfs(root.left); return 1 + Math.min(dfs(root.left), dfs(root.right)); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Tree","slug":"Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Tree/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Tree/"}]},{"title":"2024. Maximize the Confusion of an Exam","slug":"coding/leetcode/Medium/2024-Maximize-the-Confusion-of-an-Exam","date":"2023-07-07T01:40:57.000Z","updated":"2023-07-07T06:45:10.432Z","comments":true,"path":"coding/leetcode/Medium/2024-Maximize-the-Confusion-of-an-Exam/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2024-Maximize-the-Confusion-of-an-Exam/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 A teacher is writing a test with n true/false questions, with 'T' denoting true and 'F' denoting false. He wants to confuse the students by maximizing the number of consecutive questions with the same answer (multiple trues or multiple falses in a row). You are given a string answerKey , where answerKey[i] is the original answer to the ith question. In addition, you are given an integer k , the maximum number of times you may perform the following operation: Change the answer key for any question to 'T' or 'F' (i.e., set answerKey[i] to 'T' or 'F' ). Return the maximum number of consecutive 'T' s or 'F' s in the answer key after performing the operation at most k times. # Example 1 Input: answerKey = &quot;TTFF&quot;, k = 2 Output: 4 Explanation: We can replace both the 'F's with 'T's to make answerKey = &quot;TTTT&quot;. There are four consecutive 'T's. # Example 2 Input: answerKey = &quot;TFFT&quot;, k = 1 Output: 3 Explanation: We can replace the first 'T' with an 'F' to make answerKey = &quot;FFFT&quot;. Alternatively, we can replace the second 'T' with an 'F' to make answerKey = &quot;TFFF&quot;. In both cases, there are three consecutive 'F's. # Example 3 Input: answerKey = &quot;TTFTTFTT&quot;, k = 1 Output: 5 Explanation: We can replace the first 'F' to make answerKey = &quot;TTTTTFTT&quot; Alternatively, we can replace the second 'F' to make answerKey = &quot;TTFTTTTT&quot;. In both cases, there are five consecutive 'T's. # 解題思路 # Solution import java.util.HashMap;import java.util.Map;class Solution &#123; public int maxConsecutiveAnswers(String answerKey, int k) &#123; int n = answerKey.length(); int left = k, right = n; while (left &lt; right) &#123; int mid = (left + right + 1) / 2; if (isValid(answerKey, mid, k)) &#123; left = mid; &#125; else &#123; right = mid - 1; &#125; &#125; return left; &#125; public boolean isValid(String answerKey, int size, int k) &#123; int n = answerKey.length(); Map&lt;Character, Integer> counter = new HashMap&lt;>(); for (int i = 0; i &lt; size; i++) &#123; char c = answerKey.charAt(i); counter.put(c, counter.getOrDefault(c, 0) + 1); &#125; if (Math.min(counter.getOrDefault('T', 0), counter.getOrDefault('F', 0)) &lt;= k) &#123; return true; &#125; for (int i = size; i &lt; n; i++) &#123; char c1 = answerKey.charAt(i); counter.put(c1, counter.getOrDefault(c1, 0) + 1); char c2 = answerKey.charAt(i - size); counter.put(c2, counter.getOrDefault(c2, 0) - 1); if (Math.min(counter.getOrDefault('T', 0), counter.getOrDefault('F', 0)) &lt;= k) &#123; return true; &#125; &#125; return false; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"}]},{"title":"1493. Longest Subarray of 1's After Deleting One Element","slug":"coding/leetcode/Medium/1493-Longest-Subarray-of-1-s-After-Deleting-One-Element","date":"2023-07-05T04:09:53.000Z","updated":"2023-07-06T01:25:54.769Z","comments":true,"path":"coding/leetcode/Medium/1493-Longest-Subarray-of-1-s-After-Deleting-One-Element/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1493-Longest-Subarray-of-1-s-After-Deleting-One-Element/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a binary array nums , you should delete one element from it. Return the size of the longest non-empty subarray containing only 1 's in the resulting array. Return 0 if there is no such subarray. # Example 1 Input: nums = [1,1,0,1] Output: 3 Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's. # Example 2 Input: nums = [0,1,1,1,0,1,1,0,1] Output: 5 Explanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1]. # Example 3 Input: nums = [1,1,1] Output: 2 Explanation: You must delete one element. # 解題思路 # Solution class Solution &#123; public int longestSubarray(int[] nums) &#123; int n = nums.length; int left = 0; int zeros = 0; int ans = 0; for (int right = 0; right &lt; n; right++) &#123; if (nums[right] == 0) &#123; zeros++; &#125; while (zeros > 1) &#123; if (nums[left] == 0) &#123; zeros--; &#125; left++; &#125; ans = Math.max(ans, right - left + 1 - zeros); &#125; return (ans == n) ? ans - 1 : ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"}]},{"title":"上海實習 GoGo","slug":"上海實習-GoGo","date":"2023-07-04T04:32:49.000Z","updated":"2023-08-13T05:26:56.149Z","comments":true,"path":"上海實習-GoGo/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/%E4%B8%8A%E6%B5%B7%E5%AF%A6%E7%BF%92-GoGo/","excerpt":"","text":"# 2023.07.02 (日) 行程 8:00 ~ 10:00 立榮航空飛機 台北松山 (TSA) - 上海浦東 (PVG) 12:00 ~ 13:00 前往如家酒店.neo (上海火車站店)/ 午餐 14:00 ~ 16:00 辦理電話卡 16:00 ~ 19:00 吃晚餐 # 紀錄 日記 第一天抵達上海，沒想到天氣還蠻熱的，今天還沒開始實習，下午由上海市科協的老師帶我們去申辦電話卡，因為我們人蠻多的，所以了一些時間，不過其實整個辦理的流程很快，接下來就是吃完餐了，但因為今天一大早就搭飛機，5:00 就到松山機場，前一天基本上也沒睡，所以我吃飯到後面的時候基本都在打嗑睡，吃的差不多的時候發現外面下大雷雨，本來想說等雨小一點再去搭地鐵，但是依舊很大，我們就分別叫車回去，不過下雨天的滴滴真的不好叫，最後我坐上海市科協老師的車回酒店的，回酒店一洗完澡直接開始睡覺，本來想做一些事情，但是完全抵擋不住睡意。 # 2023.07.03 (一) 行程 7:00 ~ 8:00 起床洗漱 8:00 ~ 8:30 地鐵 1 號線 + 528 公交 → 區塊鏈生態谷 8:40 抵達公司 上海计算机软件技术开发中心 - 大数据与区块链技术研究所 9:00 ~ 9:30 介紹一下公司環境 9:30 ~ 10:00 辦理手續 / 安排工位 10:00 ~ 11:20 需求分析培訓 / 撰寫功能清單 11:20 ~ 12:00 吃飯 12:00 ~ 13:30 跟胡晨路上海銀行辦理銀行卡 (沒有成功) 13:30 ~ 17:00 撰寫功能清單 17:00 ~ 17:30 下班 跟吳小麗掃碼自行車 + 地鐵 18:30 ~ 19:30 吃晚餐 # 紀錄 學習項目 今天主要做的事為需求分析培訓，講解了基本的需求分析流程，從概念、目標、非功能性的需求、產出進行闡述，並詳細說明功能性需求與非功能性需求兩個的差異，接著了解需求分析的項目實踐，包含項目介紹、需求分析過程 (需求調研、梳理功能、需求規格說明書)。 之前有就大致了解需求分析的相關概念，也實際參與過幾次專案的需求分析，所以在這方面我相對比較熟練，不過在這邊需求分析過程中的梳理功能，是我之前沒有嘗試過的，但我覺得這個方式蠻好的，利用功能清單可以更加明確、有條理的呈現所有需求，方便在撰寫需求規格說明書時，更加快速釐清所有功能性需求；在需求調研的部分是利用原型的方式進行，我藉由查閱原型完成功能清單。 日記 今天是正式實習的第一天，由於前一天實在太早睡了，我大概 6:30 左右就很有精神，本來以為是 9:00 上班想說不要壓線到，再加上我有點怕迷路，所以早早就出門，結果是 9:00 ~ 9:30 是上班時間，在 9:30 前到就好了，最後不小心太早到，整間公司基本上是暗的，第一次進公司默默地就跟一個人進去了，之後綜合辦來看到我超驚訝，想說我怎麼這麼早到，問我叫什麼名字時，拿了張紙讓我寫起來，但我只會寫繁體字，一下就被認出是台灣人。 接下來是我的指導老師來接我，他其實也蠻早到的，大家好像都叫他戴老師或戴所，學歷感覺蠻猛的，然後他就帶著我逛了一下公司，介紹了一下超宏偉的一樓，我覺得一樓感覺很高級，此外也稍微介紹了一下這邊的情況，說了許多人的名字，大概會有那些人會帶我，但實在是說太多人了，以至於我誰都沒記住哈哈哈，我記名字超爛，我記得小胡，這個稱呼，但我感覺我實在不是適合這樣叫他們，畢竟我應該是這裡最嫩的，啥都不會。 早上是由顧老師帶著我簡單的進行了需求分析的培訓，基本上 20 分鐘內就解決了，非常的快速，但其實這是我一整天的工作安排，所以我就開始做明天的，撰寫功能清單 (項目管理系統)，不過需求分析給的原型其實列的蠻清楚的，所以功能清單的文件其實寫得算很快，今天剩下最後一個小功能沒描述完，所以我把它帶回酒店寫一寫，順便把繁體字翻譯成簡體字。 中午的時候我與另一個大二實習生一起去吃飯，我們因為年紀一樣，所以聊起來比較多是校內課程，我們比較了一下課程名稱，基本每科名稱都不太一樣，後來我跟小胡一起去上海銀行辦卡，因為其實銀行下午一點才開始，所以我們就微微的聊一下天，感覺我們公司的人都蠻好的，微微聊了一下兩邊大學的內容，聊了一些偶像、遊戲跟動漫，感覺比想像中的還更加親切。 下班的時候因為公交車稍微遠了一點，所以由小麗老師帶我騎掃碼自行車，我一直覺得我腳踏車騎的應該還不錯，但是我騎上掃碼自行車後，我覺得它絕對是我今天最累的行程，那個龍頭超鬆的，手微微抖一下，方向就轉了，從後面看我一定在蛇行，真的很難控制，感覺整台車沒有摩擦力，我手把握的超緊的，回家收超酸。 # 2023.07.04 (二) 行程 8:00 ~ 8:30 起床洗漱 8:30 ~ 8:40 地鐵 1 號線 9:00 ~ 9:30 跟小劉一起坐北市上海園區公交 9:40 ~ 10:10 匯報昨天的功能清單 10:10 ~ 10:40 修改匯報時出現的問題 10:40 ~ 11:20 開始撰寫需求規格說明書 11:20 ~ 12:00 跟高悅一起吃自助餐 12:00 ~ 13:00 中午午休 / 寫 leetcode 13:00 ~ 17:00 勤奮工作 17:20 ~ 17:50 528 公交 + 地鐵 1 號線 18:40 ~ 19:30 買 + 吃晚餐 (東北千層餅 + 酸奶) 20:00 ~ 21:00 洗澡 + 休息 # 紀錄 學習項目 今天匯報了昨天完成的功能清單，第一次寫比較不確定，其實顧老師叫我說一下自己寫的內容的時候，我有點傻住了，還好我在報告上應該算是蠻擅長的，就開是報告了起來，但是因為只有我一個人報告，沒有比較的東西，所以我也不是很確定我這樣是不是還可以，不過老師沒有提出什麼問題，感覺應該還不錯，他建議我修改一些層級，把功能再區分成子功能，更方便釐清，確實這樣改我一下就更清楚所有功能。 因為功能清單原本是今天要完成的，就感覺下午在交就可以了，不過我昨天就用好，所以我一大早就先交出去了，因此接下來做的事情是三天的安排，撰寫需求規格說明書，包括項目概述、系統分析 (系統的初步調查)、產品概述 (營運可行性、技術可行性、開發的軟件可行性)、系統功能設計 (系統功能模塊圖、系統功能模塊詳細描述)、系統性能需求 (性能需求、系統兼容性和用戶體驗要求)，我今天先把項目的一些描述寫了一下，但由於我剛了解這個項目，所以寫起來還是比較卡的，不過老師說這份文件專注在寫功能設計及性能即可，因此我的項目概述就大致寫了一下我了解的項目內容。 日記 今天是第二天上班，跟小劉約一起座上海園區公交上班，準確來說是因為我不會搭，小劉帶著我搭，人也蠻好的，感覺很開朗，在車上我們稍微聊了一下上海可以遊玩的地方，他超認真的在介紹，但是我實在記不住這麼多，不過我有記住可以去陸家嘴騎自行車，感覺蠻不錯的。 今天座在工位上的時間比較多，一大早稍微拍了一下工位的樣子，發現我坐在研發部，感覺是個會禿頭的部門哈哈哈，今天早上先匯報了昨天完成的功能清單，就開始撰寫需求規格說明書，依舊還是撰寫文件，打字打到後面還是會很想睡覺，於是我戴上耳機，幫助自己提高專注力。 我午餐跟高悅一起去吃自助餐，感覺就跟陸劇場景一樣，不過我們是自己打飯菜，沒有手抖的食堂大媽，可惜的是我忘記拍照了，高悅是個很可愛的姊姊，非常的照顧我，基本上都會問我意見，只不過我對吃的真的就不是很在乎，所以我的回答就是都可以啊！感覺好爛，我下次努力有點想法，爭取不要讓大家尷尬。 下班回家的時候，因為小麗姐姐很忙，所以我是自己坐公交車回家的，我們的下班時間其實跟公交好像對不太上，所以都要等一陣子，回到飯店就稍微比較晚了，今天晚餐的時候，因為其他同學在他們上班的地方吃了，所以我是自己出去吃的，為了避免我支付寶不能用，所以我給樓下超商的阿姨 200 元，請他把錢轉到我的支付寶錢包裡，因為他好像比較常用微信支付，所已支付寶裡只有 200 元，所以我只能先存 200 了，不過應該可以撐幾天。 當然有支付寶了我就非常方便，可以自己吃飯，不用寄生於別人，結果第一次使用支付寶好像有蠻多優惠的，我的晚餐雖然計 11 元，但是因為支付寶優惠，最後其實不用錢，好爽，然後我再去買了很想喝的酸奶，想說上次來的時候幾乎天天喝，結果這次來就基本上找不到，找到也是常溫的，我覺得酸奶就是要冰的啊！ # 2023.07.05 (三) 行程 8:10 ~ 8:40 起床洗漱 8:45 ~ 8:55 地鐵 1 號線 9:00 ~ 9:30 坐北市上海園區公交 9:40 ~ 11:20 撰寫需求規格說明書 11:20 ~ 12:00 跟 4 位同事一起吃自助餐 12:00 ~ 13:00 中午午休 13:00 ~ 13:30 去上海銀行辦銀行卡 (成功) 13:30 ~ 14:30 匯報需求規格說明書 v1.0 14:30 ~ 17:00 修改匯報時遇到的問題 17:20 ~ 17:50 528 公交 + 地鐵 1 號線 18:40 ~ 20:30 叫外賣 (黃燜雞飯) + 吃 21:00 ~ 23:00 討論周末行程 23:00 ~ 23:30 洗澡 + 休息 # 紀錄 學習項目 今天早上把昨天的需求規格說明書整理一下後，畫了一些模組圖、流程圖，下午進行了匯報，雖然依舊無法進行比較，但顧老師提出了一些問題，包括詳細程度與文字排版的問題。 排版上因為我其實有一點找不到我 Word 的目錄修改在哪邊，所以這個我也當場問了一下，後來發現其實蠻好找的，老師也說了不用全部一個功能的描述全部寫一起，還是可以分段的，確實分段後更好閱讀，更容易專注於某個描述。 至於詳細程度了話，因為我之前基本就是把功能清單的說明加入到功能的說明中，當時寫得雖然已經蠻詳細的，不過確實有描述可以更清楚以及完整，我也近一步完善了這部分。 日記 今天是第三天上班，工作依舊是整理需求，撰寫需求規格說明書，但生活上還是有一些變化的，今天是我獨自搭北市園區的公交車，算是正式獨立上班了，午餐跟坐我附近的一些實習生一起吃，這次都是男生，討論了一些很有趣的事情，話題包括學校、結婚跟台灣是用什麼錢，他們還說我的位置很難摸魚，有一個男生說他原本坐我這，但因為太難摸魚了所以換了...，不考慮換回來嗎？其實我有發現，因為我的位置簡直就是交通樞紐，裝水、電梯、廁所全都要經過我，我真的會謝哈哈哈，不過我還是會聽歌來輔助我打字，不然真的好想睡。 中午回來我就跟小胡去上海銀行辦銀行卡，這次有實習證明相對就比較順利，但是還是卡了一下子，不過往好處想我至少辦成功了，在台灣的中國信託銀行都沒辦成功，在這辦成功了，而且就算因為我是台灣人比較麻煩，但是流程還是比中國信託銀行快了至少半天，我覺得中國信託銀行要檢討檢討，真的是做蠻爛的，一個上午只開了四個戶頭... 做事效率堪憂，重點我等了這麼久不給辦，好啦～～這是題外話，我就像嘴一下台灣的中國信託銀行，我只能說他是我前進的動力，我一定要搞垮中國信託銀行，之後我成功了有一半一定要感謝那些曾經看不起我的人。 然後辦完確認一下銀行卡可以用，我跟小胡回公司了，我們確認可以用的方法讓我覺得小胡真的是太好了，之前的飲料錢，我有支付寶後他也不跟我收，為了測試我的銀行可不可以轉錢，他直接轉了錢給我，我跟他說我在還給他，結果他不要，真的是讓我很手足無措啊！因為支付寶一定要對方同意顯示支付條碼才可以，不可以像台灣一樣阿嬤式塞錢法，還有前一天小麗姐姐用支付寶幫我用掃碼自行車，他也說不用沒關係，天啊！我真的是有被驚訝到。 晚餐因為有了銀行卡，所以我就試試看點了外賣，第一次用也太爽了，超多優惠，不過不確定是不是因為第一次用啦！有很多現金折抵的優惠，我的晚餐一下子變得很多有不太貴，甚至我吃不完。 # 2023.07.06 (四) 行程 8:20 ~ 8:40 起床洗漱 8:45 ~ 8:55 地鐵 1 號線 9:00 ~ 9:30 坐北市上海園區公交 9:40 ~ 11:20 撰寫需求規格說明書 11:20 ~ 12:00 跟 5 位同事一起吃自助餐 12:00 ~ 13:00 中午午休 / 打羽球、乒乓球 13:30 ~ 14:00 撰寫需求規格說明書 14:00 ~ 15:00 戴老師帶著我們了解公司的項目 16:30 ~ 17:15 最終匯報需求階段文件 17:20 ~ 18:00 走路 + 地鐵 1 號線 18:40 ~ 21:30 叫 + 吃外賣 (小龍蝦 + 喜茶) 21:30 ~ 00:00 休息 00:00 ~ 00:50 洗澡 # 紀錄 學習項目 今天繼續把昨天的需求規格說明書完善，從 14 頁直接暴增到 31 頁啊！兩倍啊啊啊啊！好多，總共 1 萬 4 千多字，還好我是用繁體打字，不然我大概要打一個禮拜吧，完全不會拼音的人，我直接用爛翻譯，繁體轉簡體，還被關注了一下我在做什麼，我快笑死。 因為我有一點超前進度了，所以我在今天向我的實習指導老師匯報了這週的工作內容，也是蠻突然的，完全沒有準備啊！不過整理狀況還是蠻好的，老師說整體做的還是蠻細緻的，指導我坐需求規格說明書的老師說，整體效率很快，交代的事情一下子就解決了，還不錯，不過到今天為止都還在我很熟練的部分，所以暫時都沒甚麼問題，只不過有一些方式我們用的不太一樣，但都很不錯值得使用。 日記 今天就是一個忙碌的一天，由於我前幾天就將需求規格說明書寫得差不多了，今天剩下排版、字型和繁體字轉簡體字等，簡單來說就是過了一下整份文件，然後就突然超多事，我的實習導師帶我去了解公司，之後他去見了一下客戶，我就開啟了匯報工作，真的是挺突然的。 晚上叫了我們小龍蝦，體驗了一下電視劇上面看起來很好吃的東西，確實真的蠻不錯的，不過感覺可以再吃辣一點，我們點十三香，下次可以試試其他口味，我們還叫了喜茶喝，真的不錯喝哈哈哈，什麼廢話，我是點芝芝玫影，下次想喝鴨喜香檸打茶。 # 2023.07.07 (五) 行程 8:20 ~ 8:40 起床洗漱 8:45 ~ 8:55 地鐵 1 號線 9:00 ~ 9:30 坐北市上海園區公交 9:40 ~ 11:20 上班？ 11:20 ~ 12:45 叫 + 吃外送酸菜魚 13:30 ~ 14:00 上班？ 15:30 ~ 16:00 聽了一下 spring boot 框架 16:00 ~ 17:00 上班？ 17:20 ~ 18:00 公交車 + 地鐵 1 號線 18:00 ~ 19:00 吃澆油麵 20:30 ~ 01:00 酒吧喝酒 01:20 ~ 01:25 參觀夜店... 哈哈哈 02:00 ~ 03:00 洗澡 # 紀錄 學習項目 今天簡單的了解了一下 java spring boot 框架，但由於大家今天有很多會議，上科院的領導也來了，好像還有客戶，所以大家其實今天沒什麼時間管我，所以我今天確實沒有很忙。 日記 今天撇除掉工作，我們下班還是很瘋的，一群人大概 10 個左右去了酒吧喝酒，因為坐卡座，低消 3000，貴到爛，但我們大概 8 點多，一路喝到 1 點左右，裡面有個小姐姐唱歌唱很多台灣歌手的歌，結果小萬 (我們這群的其中一位) 超級嗨，我快笑死，他還一直說我都不嗨，沒有喝很多，但其實我也喝了 6 ~ 7 杯左右了，第一次喝這麼多威士忌，聞起來真的很苦，我的小祕訣是喝酒前喝酸奶，感覺完全沒有醉的感覺，如果不想喝醉可以學學，但是隔天肚子超痛哈哈哈。 然後我們上廁所的時候認識了一個貴州的小姊姊，來上海讀大學跟實習，帶著一個約他一起出來玩的高學歷帥哥，結果我們最後拼在一起玩，我個人表示好扯，喝酒喝到拐走別人的小姐姐，最後連帥哥都一起了，後來我們還有去夜店玩，但是我真的是受不了煙味，那裏簡直煙霧瀰漫，所以我就進去了一下就出來了，感覺差點窒息在夜店裡，好可怕，聽說夜店這樣很正常，再也不去了嗚嗚嗚，出來手還好養。","categories":[],"tags":[]},{"title":"137. Single Number II","slug":"coding/leetcode/Medium/137-Single-Number-II","date":"2023-07-04T02:26:24.000Z","updated":"2023-07-04T04:50:02.007Z","comments":true,"path":"coding/leetcode/Medium/137-Single-Number-II/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/137-Single-Number-II/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it. You must implement a solution with a linear runtime complexity and use only constant extra space. # Example 1 Input: nums = [2,2,3,2] Output: 3 # Example 2 Input: nums = [0,1,0,1,0,1,99] Output: 99 # 解題思路 # Solution class Solution &#123; public int singleNumber(int[] nums) &#123; int once = 0, twice = 0; for(int num : nums)&#123; once = (num ^ once) &amp; (~twice); twice = (num ^ twice) &amp; (~once); &#125; return once; &#125;&#125; import java.util.HashMap;import java.util.Map;class Solution &#123; public int singleNumber(int[] nums) &#123; Map&lt;Integer, Integer> mp = new HashMap&lt;>(); for(int i = 0; i &lt; nums.length; i++)&#123; mp.put(nums[i], mp.getOrDefault(nums[i], 0) + 1); if(mp.get(nums[i]) == 3)&#123; mp.remove(nums[i]); &#125; &#125; int ans = 0; for(int m : mp.keySet())&#123; ans = m; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bit-Manipulation/"}]},{"title":"859. Buddy Strings","slug":"coding/leetcode/Easy/859-Buddy-Strings","date":"2023-07-03T14:43:19.000Z","updated":"2023-07-03T16:25:00.140Z","comments":true,"path":"coding/leetcode/Easy/859-Buddy-Strings/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/859-Buddy-Strings/","excerpt":"","text":"⭐️ # 題目敘述 Given two strings s and goal , return true if you can swap two letters in s so the result is equal to goal , otherwise, return false . Swapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j] . For example, swapping at indices 0 and 2 in &quot;abcd&quot; results in &quot;cbad&quot; . # Example 1 Input: s = &quot;ab&quot;, goal = &quot;ba&quot; Output: true Explanation: You can swap s[0] = 'a' and s[1] = 'b' to get &quot;ba&quot;, which is equal to goal. # Example 2 Input: s = &quot;ab&quot;, goal = &quot;ab&quot; Output: false Explanation: The only letters you can swap are s[0] = 'a' and s[1] = 'b', which results in &quot;ba&quot; != goal. # Example 3 Input: s = &quot;aa&quot;, goal = &quot;aa&quot; Output: true Explanation: You can swap s[0] = 'a' and s[1] = 'a' to get &quot;aa&quot;, which is equal to goal. # 解題思路 # Solution import java.util.HashSet;import java.util.Set;class Solution &#123; public boolean buddyStrings(String s, String goal) &#123; int n = s.length(); if (s.equals(goal)) &#123; Set&lt;Character> temp = new HashSet&lt;>(); for (char c : s.toCharArray()) &#123; temp.add(c); &#125; return temp.size() &lt; goal.length(); // Swapping same characters &#125; // two string equal int i = 0; int j = n - 1; while (i &lt; j &amp;&amp; s.charAt(i) == goal.charAt(i)) &#123; i++; &#125; while (j >= 0 &amp;&amp; s.charAt(j) == goal.charAt(j)) &#123; j--; &#125; if (i &lt; j) &#123; char[] clone = s.toCharArray(); char temp = clone[i]; clone[i] = clone[j]; clone[j] = temp; s = new String(clone); &#125; // Find two letter to swap, when two letter on deference string in same index isn't equal return s.equals(goal); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"}]},{"title":"Vue 指令","slug":"computer-science/Program-Language/Framework/Vue/Vue-指令","date":"2023-06-29T17:45:03.000Z","updated":"2023-09-21T05:38:08.469Z","comments":true,"path":"computer-science/Program-Language/Framework/Vue/Vue-指令/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Program-Language/Framework/Vue/Vue-%E6%8C%87%E4%BB%A4/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # Text Interpolation Using the &quot;Mustache&quot; syntax (double curly braces 兩個大括號 &#123;&#123; &#125;&#125; ) &lt;p> &#123;&#123; value &#125;&#125; &lt;/p>But Mustaches cannot be used inside HTML attributes. # v-bind 用法 &lt;div v-bind:[attribute]=\"[Vue data]\">&lt;/div># v-if 、 v-else-if 、 v-else 用法 &lt;p v-if=\"score >= 80\">Perfect&lt;/p>&lt;p v-else-if=\"scroe > 60\">Good&lt;/p>&lt;p v-else>Poor&lt;/p> A condition, or &quot;if-statement&quot;, is something that is either true or false . A condition is often a comparison check between two values like in the example above to see if one value is greater than the other. We use comparison operators like &lt; , &gt;= or !== to do such checks. Comparison checks can also be combined with logical operators such as &amp;&amp; or || . &lt;script>export default &#123; data() &#123; return &#123; text: 'I like taco, pizza, Thai beef salad, pho soup and tagine.' &#125; &#125;&#125;&lt;/script>&lt;template> &lt;p v-if=\"text.includes('pizza')\">The text includes the word 'pizza'&lt;/p> &lt;p v-else>The word 'pizza' is not found in the text&lt;/p>&lt;/template># v-show 當條件為 false 時，該指令通過將 CSS display 屬性值設置為 none 來隱藏元素。 &lt;script>export default &#123; data() &#123; return &#123; showDiv: true &#125; &#125;&#125;&lt;/script>&lt;template> &lt;div v-show=\"showDiv\">This div tag can be hidden&lt;/div>&lt;/template># 參考 / 學習文章 官方文件 w3school 維基百科 MDN web docs Vue.js 30 天隨身包系列","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"program-language","slug":"computer-science/Program-Language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/"},{"name":"Framework","slug":"computer-science/Program-Language/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/Framework/"},{"name":"Vue","slug":"computer-science/Program-Language/Framework/Vue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/Framework/Vue/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}]},{"title":"Vue 基本介紹","slug":"computer-science/Program-Language/Framework/Vue/Vue-基本介紹","date":"2023-06-29T12:51:20.000Z","updated":"2023-09-21T05:38:18.930Z","comments":true,"path":"computer-science/Program-Language/Framework/Vue/Vue-基本介紹/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Program-Language/Framework/Vue/Vue-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 專案結構 tree /f > structure.txt有整理過的 structure.txtvue-project│ .gitignore│ env.d.ts│ index.html│ output.txt│ package-lock.json│ package.json│ README.md│ tsconfig.app.json│ tsconfig.json│ tsconfig.node.json│ vite.config.ts│ ├─.vscode│ extensions.json│ ├─public│ favicon.ico│ └─src │ App.vue │ main.ts │ ├─assets │ base.css │ logo.svg │ main.css │ └─components │ HelloWorld.vue │ └─icons IconCommunity.vue public ：這個資料夾包含了所有發布的靜態檔案，這些檔案在建置過程不會經過 Webpack 加工。（但是有一個例外： index.html 會有一些處理）。 favicon.ico ：這是應用程式的 favicon。目前是 Vue 的標誌。 index.html ：這是應用程式的模板。你的 Vue 應用程式會透過這個 HTML 頁面來運行，你也可以使用 lodash 樣板語言在這個頁面穿插一些值。 src ：這個資料夾是 Vue 專案的核心。 main.js ：這是應用程式的進入點。目前，這個檔案會初始化你的 Vue 應用程式並定義要將應用掛載到 index.html 檔案中的哪個 HTML 元素。通常還會在這個檔案註冊全域性元件或載入其他 Vue 函式庫。 App.vue ：這是 Vue 應用程式的根節點元件。往下看可以了解更多關於 Vue 元件的說明。 components ：你可以把你的元件放在這個資料夾。目前它只有放一個範例元件。 assets ：這個資料夾是用來放一些靜態檔案像是 CSS 和圖片。因為這些檔案在來源目錄下，它們可以透過 Webpack 加工處理。這表示你可以使用一些預處理器，像是 Sass / SCSS 或是 Stylus 。 # Web 元件化系統 Vue.js 嚮往的就是先建立好根實體 (Vue Instance)，再開發好底下每個小元件 (Components)，慢慢往上組合成一個完整頁面，最後全部搭建起來成為一個完整專案。 通常一個元件包含 html、css、js，而 Vue 會將其全部寫在一個 .vue 為副檔名的檔案當中，vue-loader 會編譯這個 .vue 的檔案，將結果顯示出來。 # Vue Instance 根實體 (Vue Instance) 是樹狀結構中最上面的那個點。 每個 Vue App 都是從創建一個 vue instance 開始，Vue Instance 是透過 Vue Constructor (建構式) 所產生。 在實體化時，可傳入一個選項物件 (Options)，此物件包含這個 vue instance 需要用到的屬性，像是掛載點 (el)、資料 (data)、方法 (methods)、模板 (template)、** 生命週期鉤子 (hooks)** 等等。 var vm = new Vue (&#123; // options&#125;) # .vue 檔案（單一檔案元件） Vue 讓你把模板、相關指令碼和 CSS 整合在一起放在以 .vue 結尾的檔案裡。這些檔案會被 JS 的打包工具（像是 Webpack ）加以處理，這也代表你可以在你的專案裡使用一些建置工具，像是 Babel 、 TypeScript 、 SCSS 等工具來創造更複雜的元件。 # App.vue 在創建專案時，你可以在 src 資料夾中，看到第一個 .vue 檔案。 由三個部分組成： &lt;template&gt; 、 &lt;script&gt; 以及 &lt;style&gt; ，分別包含了元件的模板、指令碼和樣式資訊。 所有的單一檔案元件都是使用這種基本架構。 App.vue&lt;script setup lang=\"ts\"> &#123;/* javascript */&#125;import HelloWorld from './components/HelloWorld.vue'import TheWelcome from './components/TheWelcome.vue'&lt;/script>&lt;template> &#123;/* html */&#125; &lt;header> &lt;img alt=\"Vue logo\" class=\"logo\" src=\"./assets/logo.svg\" width=\"125\" height=\"125\" /> &lt;div class=\"wrapper\"> &lt;HelloWorld msg=\"You did it!\" /> &lt;/div> &lt;/header> &lt;main> &lt;TheWelcome /> &lt;/main>&lt;/template>&lt;style scoped> &#123;/* css */&#125;header &#123; line-height: 1.5;&#125;.logo &#123; display: block; margin: 0 auto 2rem;&#125;&lt;/style> &lt;template&gt; 元件的模板: 包含所有的標記結構以及元件的呈現邏輯。 模板可以包含任何有效的 HTML，以及一些 Vue 特定的語法。 在 &lt;template&gt; 標籤上設定 lang 屬性。例如設置 &lt;template lang=&quot;pug&quot;&gt; ，你就可以使用 Pug 樣板語法來取代標準的 HTML 。在本教學中我們會使用標準 HTML ，但還是值得知道有這個方法。 &lt;script&gt; 指令碼: 包含元件中所有非顯示的邏輯。最重要的是， &lt;script&gt; 標籤必須輸出一個 JS 物件。 這個物件是在本地端註冊的元件，包含定義屬性、處理本地狀態、定義方法等等。 如果想要使用 TypeScript 語法，必須把 &lt;script&gt; 標籤的 lang 屬性設定成 &lt;script lang=&quot;ts&quot;&gt; 來告訴編譯器你要使用 TypeScript 。 &lt;style&gt; 樣式: 是撰寫元件的 CSS 的地方。 如果加上 scoped 屬性，例如 &lt;style scoped&gt; ， Vue 會把樣式的範圍限制在這個單一檔案元件裡。這類似 CSS-in-JS 的解決方案，但是它允許你寫單純的 CSS 。 如果在使用 CLI 創建專案時有選擇 CSS 預處理器，就可以在 &lt;style&gt; 標籤上添加 lang 屬性，這些內容在建置的時候將會被 Webpack 處理。舉例來說， &lt;style lang=&quot;scss&quot;&gt; 允許在樣式資訊中使用 SCSS 語法。 # Lifecycle Hooks 這 8 個 hook 的資料型態皆為 function: beforeCreate 在初始化 vue instance 並開啟整個 Lifecycle 後，資料綁定與事件配置之前。 目前階段還無法調用 $data 。 應用場景：loading 進頁面的事件 created vue instance 創建完成 $data 已可以取得，屬性與事件也已綁定好。 目前階段尚未掛載 el ，DOM 也尚未生成。 beforeMount 在掛載 el 開始之前。 目前階段是相關 render 函式首次被調用，尚未被 DOM 給綁定。 mounted el 被剛創建好的 vm.$el 替換取代，並且掛載到 vm 上。 目前階段已被 DOM 綁定。 應用場景：對後端發出請求或讀取新資料 beforeUpdate 在資料更新時調用，Virtual DOM 重新 render 與 patch 之前，可以在這個階段變更資料狀態。 目前階段還不會繪製 view。 updated 資料更新後會使 Virtual DOM 重新 render 頁面。 目前階段會繪製出正確的 view。 beforeDestroy 在 vue instance 被銷毀前調用。 目前階段還可以完全使用這個 vue instance。 destroyed vue instance 銷毀後可以調用 調用後這個 vue instance 底下的資料與樣板會解除綁定，事件會取消監聽，所有子元件也會被銷毀。 # Example var vm = new Vue(&#123; data: &#123; name: 'Eva', &#125;, beforeCreate: function() &#123; //vue instance 尚未創建完成，還不能讀取到資料 console.log('beforeCreate: My name is ' + this.name); &#125;, created: function() &#123; //vue instance 創建完成，資料已綁定 console.log('created: My name is ' + this.name); &#125;, beforeMount: function() &#123; // 尚未掛載 el 與綁定 DOM console.log('beforeMount: My name is ' + this.name); &#125;, mounted: function() &#123; // 綁定 DOM 之後 console.log('mounted: My name is ' + this.name); &#125;, beforeUpdate: function() &#123; // 資料更新時調用，尚未更新 DOM console.log('beforeUpdate: My name is ' + this.name); &#125;, updated: function() &#123; // 因為資料更新而更新 DOM console.log('updated: My name is ' + this.name); &#125;, beforeDestroy: function() &#123; // 銷毀整個 vue instance 之前 console.log('beforeDestroy'); &#125;, destroyed: function() &#123; // 銷毀整個 vue instance 之後 console.log('destroyed'); &#125;,&#125;);# 第一階段：beforeCreate /created 在綁定 el 之前，beforeCreate 階段還不能讀取資料 # 第二階段：beforeMount /mounted 加入 el 屬性在物件裡 # 第三階段：beforeUpdate /updated 因為要變更資料才會觸發這兩個 function，這邊我們使用強制變更資料 # 第四階段：beforeDestroy /destroyed 因為上面第三階段強制變更資料的方法會導致一直執行更新資料，所以先將剛剛新增的 vm.$beforeUpdate(); 刪掉，加入 destroy 的方法 # 參考 / 學習文章 官方文件 w3school 維基百科 MDN web docs Vue.js 30 天隨身包系列","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"program-language","slug":"computer-science/Program-Language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/"},{"name":"Framework","slug":"computer-science/Program-Language/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/Framework/"},{"name":"Vue","slug":"computer-science/Program-Language/Framework/Vue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/Framework/Vue/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}]},{"title":"創建 Vue.js Project","slug":"computer-science/Program-Language/Framework/Vue/創建-Vue-js-Project","date":"2023-06-28T18:06:32.000Z","updated":"2023-09-21T05:38:02.219Z","comments":true,"path":"computer-science/Program-Language/Framework/Vue/創建-Vue-js-Project/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Program-Language/Framework/Vue/%E5%89%B5%E5%BB%BA-Vue-js-Project/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 創建的項目將使用基於 Vite 的構建設置，並允許我們使用 Vue 的單文件組件 (SFC)。 請先確認是否安裝 Node.js，可運用以下指令測試 node -v 。 # 創建 Vue Project npm vue 版本 npm init vue@latest# 設定 Vue Project # 運行 Vue Project 在第一次創建或是更新 package 內容時，記得要輸入 npm install ，安裝內容所需。 npm run dev終端機會出現類似以下的訊息: > vue-project@0.0.0 dev> vite VITE v4.3.9 ready in 801 ms ➜ Local: http://localhost:5173/ ➜ Network: use --host to expose ➜ press h to show help 可以在瀏覽器輸入 http://localhost:5173/ 來查看專案樣式 # 建構 Vue Project npm run build 此命令會在 ./dist 文件夾中為你的應用創建一個生產環境的構建版本。 # 參考 / 學習文章 官方文件 w3school 維基百科 MDN web docs Vue.js 30 天隨身包系列","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"program-language","slug":"computer-science/Program-Language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/"},{"name":"Framework","slug":"computer-science/Program-Language/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/Framework/"},{"name":"Vue","slug":"computer-science/Program-Language/Framework/Vue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/Framework/Vue/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}]},{"title":"什麼是Vue?","slug":"computer-science/Program-Language/Framework/Vue/什麼是Vue","date":"2023-06-28T06:57:21.000Z","updated":"2023-09-21T05:37:54.122Z","comments":true,"path":"computer-science/Program-Language/Framework/Vue/什麼是Vue/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Program-Language/Framework/Vue/%E4%BB%80%E9%BA%BC%E6%98%AFVue/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 先備知識 HTML CSS JavaScript # What is Vue? Evan You 是一名使用 AngularJS 的 Google 員工，於 2013 年開始開發 Vue。 Vue 1.0 版本於 2015 年發布。 Vue（發音為 /vjuː/，如 view）是一個用於構建用戶界面的 JavaScript 框架。 與 Vue 類似的框架有 React 和 Angular，但 Vue 更輕量級，更容易上手。 構建在標準 HTML、CSS 和 JavaScript 之上，提供聲明性和基於組件的程式模型，幫助您高效地開發用戶界面，無論是簡單的還是複雜的。 它提供了很多有用的功能來達到漸進增強（ progressive enhancement ）的策略。 與其他的框架不同的是，你可以把 Vue 和既有的 HTML 做整合，這讓你可以像使用插入性替換的函式庫一樣來使用 Vue。 # 優勢 簡單易用。 能夠處理簡單和復雜的項目。 其日益普及和開源社區的支持。 在普通 JavaScript 中，我們需要編寫 HTML 和 JavaScript 如何連接，但在 Vue 中，我們只需要確保存在連接，然後讓 Vue 處理其餘的事情。 通過基於模板的語法、雙向數據綁定和集中狀態管理實現更高效的開發過程。 Vue 所關注的核心是 MVC 模式中的視圖層，同時，它也能方便地取得資料更新，並通過組件內部特定的方法實現視圖與模型的互動。 # 特性 組件 (Components) 為了更好地管理一個大型的應用程式，往往需要將應用切割為小而獨立、具有復用性的組件。 在 Vue 中，組件是基礎 HTML 元素的拓展，可方便地自訂其資料與行為。 模板 (Templates) 回應式設計 (Reactivity) 回應式是指 MVC 模型中的視圖隨著模型變化而變化。 在 Vue 中，開發者只需將視圖與對應的模型進行繫結，Vue 便能自動觀測模型的變動，並重繪視圖。 這一特性使得 Vue 的狀態管理變得相當簡單直觀。 過渡效果 (Transitions) 單檔案組件 (SFC) 為了更好地適應複雜的專案，Vue 支援以 .vue 為副檔名的檔案來定義一個完整組件，用以替代使用 Vue.component 註冊組件的方式。 # Chose which API? 在 Vue 中編寫代碼有兩種不同的方式：The Options API 和 The Composition API。 基本概念是相同的，因此在學習其中一個 API 後，可以輕鬆切換到另一個。 建議可以先學習 The Options API，相對比較好上手。 # 選項式 API (Options API) 使用選項式 API，我們可以用包含多個選項的對象來描述組件的邏輯，例如 data 、 methods 和 mounted 。選項所定義的屬性都會暴露在函數內部的 this 上，它會指向當前的組件實例。 Vue (Options API)&lt;script>export default &#123; //data () 返回的属性将会成为响应式的状态 // 并且暴露在 `this` 上 data() &#123; return &#123; count: 0 &#125; &#125;, //methods 是一些用来更改状态与触发更新的函数 // 它们可以在模板中作为事件处理器绑定 methods: &#123; increment() &#123; this.count++ &#125; &#125;, // 生命周期钩子会在组件生命周期的各个不同阶段被调用 // 例如这个函数就会在组件挂载完成后被调用 mounted() &#123; console.log(`The initial count is $&#123;this.count&#125;.`) &#125;&#125;&lt;/script>&lt;template> &lt;button @click=\"increment\">Count is: &lt;!--swig￼1-->&lt;/button>&lt;/template># 組合式 API (Composition API) 通過組合式 API，我們可以使用導入的 API 函數來描述組件邏輯。在單文件組件中，組合式 API 通常會與 &lt;script setup&gt; 搭配使用。這個 setup attribute 是一個標識，告訴 Vue 需要在編譯時進行一些處理，讓我們可以更簡潔地使用組合式 API。比如， &lt;script setup&gt; 中的導入和頂層變量 / 函數都能夠在模板中直接使用。 下面是使用了組合式 API 與 &lt;script setup&gt; 改造後和上面的模板完全一樣的組件： Vue (Composition API)&lt;script setup>import &#123; ref, onMounted &#125; from 'vue'// 响应式状态const count = ref(0)// 用来修改状态、触发更新的函数function increment() &#123; count.value++&#125;// 生命周期钩子onMounted(() => &#123; console.log(`The initial count is $&#123;count.value&#125;.`)&#125;)&lt;/script>&lt;template> &lt;button @click=\"increment\">Count is: &lt;!--swig￼2-->&lt;/button>&lt;/template># 參考 / 學習文章 官方文件 w3school 維基百科 MDN web docs Vue.js 30 天隨身包系列","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"program-language","slug":"computer-science/Program-Language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/"},{"name":"Framework","slug":"computer-science/Program-Language/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/Framework/"},{"name":"Vue","slug":"computer-science/Program-Language/Framework/Vue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/Framework/Vue/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}]},{"title":"1514. Path with Maximum Probability","slug":"coding/leetcode/Medium/1514-Path-with-Maximum-Probability","date":"2023-06-28T05:02:53.000Z","updated":"2023-06-28T06:56:37.516Z","comments":true,"path":"coding/leetcode/Medium/1514-Path-with-Maximum-Probability/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1514-Path-with-Maximum-Probability/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an undirected weighted graph of n nodes (0-indexed), represented by an edge list where edges[i] = [a, b] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb[i] . Given two nodes start and end , find the path with the maximum probability of success to go from start to end and return its success probability. If there is no path from start to end , return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5. # Example 1 Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2 Output: 0.25000 Explanation: There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25. # Example 2 Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2 Output: 0.30000 # Example 3 Input: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2 Output: 0.00000 Explanation: There is no path between 0 and 2. # 解題思路 # Solution class Solution &#123; public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) &#123; double[] maxProb = new double[n]; maxProb[start] = 1.0; for (int i = 0; i &lt; n - 1; i++) &#123; boolean hasUpdate = false; for (int j = 0; j &lt; edges.length; j++) &#123; int u = edges[j][0]; int v = edges[j][1]; double pathProb = succProb[j]; if (maxProb[u] * pathProb > maxProb[v]) &#123; maxProb[v] = maxProb[u] * pathProb; hasUpdate = true; &#125; if (maxProb[v] * pathProb > maxProb[u]) &#123; maxProb[u] = maxProb[v] * pathProb; hasUpdate = true; &#125; &#125; if (!hasUpdate) &#123; break; &#125; &#125; return maxProb[end]; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Shortest Path","slug":"Shortest-Path","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Shortest-Path/"}]},{"title":"373. Find K Pairs with Smallest Sums","slug":"coding/leetcode/Medium/373-Find-K-Pairs-with-Smallest-Sums","date":"2023-06-27T15:01:24.000Z","updated":"2023-06-27T16:47:57.307Z","comments":true,"path":"coding/leetcode/Medium/373-Find-K-Pairs-with-Smallest-Sums/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/373-Find-K-Pairs-with-Smallest-Sums/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k . Define a pair (u, v) which consists of one element from the first array and one element from the second array. Return the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums. # Example 1 Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 Output: [[1,2],[1,4],[1,6]] Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] # Example 2 Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2 Output: [[1,1],[1,1]] Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] # Example 3 Input: nums1 = [1,2], nums2 = [3], k = 3 Output: [[1,3],[2,3]] Explanation: All possible pairs are returned from the sequence: [1,3],[2,3] # 解題思路 # Solution import java.util.ArrayList;import java.util.HashSet;import java.util.List;import java.util.PriorityQueue;import java.util.Set;class Solution &#123; public List&lt;List&lt;Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) &#123; int m = nums1.length; int n = nums2.length; List&lt;List&lt;Integer>> ans = new ArrayList&lt;>(); Set&lt;Pair&lt;Integer, Integer>> visited = new HashSet&lt;>(); PriorityQueue&lt;int[]> minHeap = new PriorityQueue&lt;>((a, b)->(a[0] - b[0])); minHeap.offer(new int[]&#123;nums1[0] + nums2[0], 0, 0&#125;); visited.add(new Pair&lt;Integer, Integer>(0, 0)); while (k-- > 0 &amp;&amp; !minHeap.isEmpty()) &#123; int[] top = minHeap.poll(); int i = top[1]; int j = top[2]; ans.add(List.of(nums1[i], nums2[j])); if (i + 1 &lt; m &amp;&amp; !visited.contains(new Pair&lt;Integer, Integer>(i + 1, j))) &#123; minHeap.offer(new int[]&#123;nums1[i + 1] + nums2[j], i + 1, j&#125;); visited.add(new Pair&lt;Integer, Integer>(i + 1, j)); &#125; if (j + 1 &lt; n &amp;&amp; !visited.contains(new Pair&lt;Integer, Integer>(i, j + 1))) &#123; minHeap.offer(new int[]&#123;nums1[i] + nums2[j + 1], i, j + 1&#125;); visited.add(new Pair&lt;Integer, Integer>(i, j + 1)); &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"}]},{"title":"2462. Total Cost to Hire K Workers","slug":"coding/leetcode/Medium/2462-Total-Cost-to-Hire-K-Workers","date":"2023-06-26T05:17:30.000Z","updated":"2023-06-26T14:30:13.448Z","comments":true,"path":"coding/leetcode/Medium/2462-Total-Cost-to-Hire-K-Workers/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2462-Total-Cost-to-Hire-K-Workers/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the ith worker. You are also given two integers k and candidates . We want to hire exactly k workers according to the following rules: You will run k sessions and hire exactly one worker in each session. In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers. Break the tie by the smallest index. For example, if costs = [3,2,7,7,1,2] and candidates = 2 , then in the first hiring session, we will choose the 4th worker because they have the lowest cost [3,2,7,7,1,2] . In the second hiring session, we will choose 1st worker because they have the same lowest cost as 4th worker but they have the smallest index [3,2,7,7,2] . Please note that the indexing may be changed in the process. If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index. A worker can only be chosen once. Return the total cost to hire exactly k workers. # Example 1 Input: costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4 Output: 11 Explanation: We hire 3 workers in total. The total cost is initially 0. In the first hiring round we choose the worker from [17,12,10,2,7,2,11,20,8]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2. In the second hiring round we choose the worker from [17,12,10,7,2,11,20,8]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4. In the third hiring round we choose the worker from [17,12,10,7,11,20,8]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers. The total hiring cost is 11. # Example 2 Input: costs = [1,2,4,1], k = 3, candidates = 3 Output: 4 Explanation: We hire 3 workers in total. The total cost is initially 0. In the first hiring round we choose the worker from [1,2,4,1]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers. In the second hiring round we choose the worker from [2,4,1]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2. In the third hiring round there are less than three candidates. We choose the worker from the remaining workers [2,4]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4. The total hiring cost is 4. # 解題思路 # Solution import java.util.PriorityQueue;class Solution &#123; public long totalCost(int[] costs, int k, int candidates) &#123; PriorityQueue&lt;int[]> pq = new PriorityQueue&lt;>((a, b) -> &#123; if (a[0] == b[0]) &#123; return a[1] - b[1]; &#125; return a[0] - b[0]; &#125;); for (int i = 0; i &lt; candidates; i++) &#123; pq.offer(new int[] &#123; costs[i], 0 &#125;); &#125; for (int i = Math.max(candidates, costs.length - candidates); i &lt; costs.length; i++) &#123; pq.offer(new int[] &#123; costs[i], 1 &#125;); &#125; long answer = 0; int nextHead = candidates; int nextTail = costs.length - candidates - 1; for (int i = 0; i &lt; k; i++) &#123; int[] currWorker = pq.poll(); int currCost = currWorker[0], currSectionId = currWorker[1]; answer += currCost; if (nextHead &lt;= nextTail) &#123; if (currSectionId == 0) &#123; pq.offer(new int[] &#123; costs[nextHead], 0 &#125;); nextHead++; &#125; else &#123; pq.offer(new int[] &#123; costs[nextTail], 1 &#125;); nextTail--; &#125; &#125; &#125; return answer; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"}]},{"title":"956. Tallest Billboard","slug":"coding/leetcode/Hard/956-Tallest-Billboard","date":"2023-06-24T03:43:15.000Z","updated":"2023-06-24T15:48:45.787Z","comments":true,"path":"coding/leetcode/Hard/956-Tallest-Billboard/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/956-Tallest-Billboard/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height. You are given a collection of rods that can be welded together. For example, if you have rods of lengths 1 , 2 , and 3 , you can weld them together to make a support of length 6 . Return the largest possible height of your billboard installation. If you cannot support the billboard, return 0 . # Example 1 Input: rods = [1,2,3,6] Output: 6 Explanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6. # Example 2 Input: rods = [1,2,3,4,5,6] Output: 10 Explanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10. # Example 3 Input: rods = [1,2] Output: 0 Explanation: The billboard cannot be supported, so we return 0. # 解題思路 # Solution import java.util.Arrays;public class Solution &#123; public int tallestBillboard(int[] rods) &#123; int maxSize = 0; for(int rod : rods)&#123; maxSize += rod; &#125; int[] dp = new int[maxSize + 1]; Arrays.fill(dp, -1); dp[0] = 0; for(int rod : rods)&#123; int[] dpCopy = dp.clone(); for (int i = 0; i &lt;= maxSize - rod; i++) &#123; if (dpCopy[i] &lt; 0) continue; dp[i + rod] = Math.max(dp[i + rod], dpCopy[i]); dp[Math.abs(i - rod)] = Math.max(dp[Math.abs(i - rod)], dpCopy[i] + Math.min(i, rod)); &#125; &#125; return dp[0]; &#125;&#125; 單字 installing 安裝 v. (READY TO USE) to put furniture, a machine, or a piece of equipment into position and make it ready to use to put a computer program onto a computer so that the computer can use it billboard 廣告牌 n. a very large board on which advertisements are shown, especially at the side of a road steel 鋼 n. a strong metal that is a mixture of iron and carbon, used for making things that need a strong structure, especially vehicles and buildings support 支持 v. to agree with and give encouragement to someone or something because you want him, her, or it to succeedn 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"}]},{"title":"1027. Longest Arithmetic Subsequence","slug":"coding/leetcode/Medium/1027-Longest-Arithmetic-Subsequence","date":"2023-06-23T08:25:06.000Z","updated":"2023-06-24T03:49:50.072Z","comments":true,"path":"coding/leetcode/Medium/1027-Longest-Arithmetic-Subsequence/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1027-Longest-Arithmetic-Subsequence/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given an array nums of integers, return the length of the longest arithmetic subsequence in nums . Note that: A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. A sequence seq is arithmetic if seq[i + 1] - seq[i] are all the same value (for 0 &lt;= i &lt; seq.length - 1 ). # Example 1 Input: nums = [3,6,9,12] Output: 4 Explanation: The whole array is an arithmetic sequence with steps of length = 3. # Example 2 Input: nums = [9,4,7,2,10] Output: 3 Explanation: The longest arithmetic subsequence is [4,7,10]. # Example 3 Input: nums = [20,1,15,3,10,5,8] Output: 4 Explanation: The longest arithmetic subsequence is [20,15,10,5]. # 解題思路 # Solution import java.util.HashMap;import java.util.Map;class Solution &#123; public int longestArithSeqLength(int[] nums) &#123; Map&lt;Integer, Integer>[] dp = new HashMap[nums.length]; int longest = 2; for(int i = 0; i &lt; nums.length; i++)&#123; dp[i] = new HashMap&lt;>(); for(int j = 0; j &lt; i; j++)&#123; int diff = nums[i] - nums[j]; dp[j].put(diff, dp[i].getOrDefault(diff, 1) + 1); longest = Math.max(longest, dp[j].get(diff)); &#125; &#125; return longest; &#125;&#125; 單字 arithmetic 算數 n. the part of mathematics that involves the adding and multiplying, etc. of numbers subsequence 子序列 n. something that follows something else 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"}]},{"title":"714. Best Time to Buy and Sell Stock with Transaction Fee","slug":"coding/leetcode/Medium/714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee","date":"2023-06-22T07:22:26.000Z","updated":"2023-06-23T08:24:16.320Z","comments":true,"path":"coding/leetcode/Medium/714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee. Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). # Example 1 Input: prices = [1,3,2,8,4,9], fee = 2 Output: 8 Explanation: The maximum profit can be achieved by: Buying at prices[0] = 1 Selling at prices[3] = 8 Buying at prices[4] = 4 Selling at prices[5] = 9 The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8. # Example 2 Input: prices = [1,3,7,5,10,3], fee = 3 Output: 6 # 解題思路 # Solution class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; int ans = 0; int buy = -prices[0]; for (int price : prices) &#123; int temp = buy; buy = Math.max(buy, ans - price); ans = Math.max(ans, temp + price - fee); &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"}]},{"title":"2448. Minimum Cost to Make Array Equal","slug":"coding/leetcode/Hard/2448-Minimum-Cost-to-Make-Array-Equal","date":"2023-06-21T17:05:34.000Z","updated":"2023-06-21T19:20:50.119Z","comments":true,"path":"coding/leetcode/Hard/2448-Minimum-Cost-to-Make-Array-Equal/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/2448-Minimum-Cost-to-Make-Array-Equal/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 You are given two 0-indexed arrays nums and cost consisting each of n positive integers. You can do the following operation any number of times: Increase or decrease any element of the array nums by 1 . The cost of doing one operation on the ith element is cost[i] . Return the minimum total cost such that all the elements of the array nums become equal. # Example 1 Input: nums = [1,3,5,2], cost = [2,3,1,14] Output: 8 Explanation: We can make all the elements equal to 2 in the following way: Increase the 0th element one time. The cost is 2. Decrease the 1st element one time. The cost is 3. Decrease the 2nd element three times. The cost is 1 + 1 + 1 = 3. The total cost is 2 + 3 + 3 = 8. It can be shown that we cannot make the array equal with a smaller cost. # Example 2 Input: nums = [2,2,2,2,2], cost = [4,2,8,1,3] Output: 0 Explanation: All the elements are already equal, so no operations are needed. # 解題思路 # Solution class Solution &#123; public long minCost(int[] nums, int[] cost) &#123; int left = nums[0]; int right = nums[0]; for (int num : nums) &#123; left = Math.min(left, num); right = Math.max(right, num); &#125; // Find the min and max in nums[] array long ans = 0; while (left &lt; right) &#123; int mid = (left + right) / 2; long cost1 = helper(nums, cost, mid); long cost2 = helper(nums, cost, mid + 1); if (cost1 > cost2) &#123; left = mid + 1; ans = cost2; &#125; else &#123; right = mid; ans = cost1; &#125; &#125; return ans; &#125; public long helper(int[] nums, int[] cost, int all) &#123; long totalCost = 0L; for (int i = 0; i &lt; nums.length; i++) &#123; totalCost += 1L * Math.abs(nums[i] - all) * cost[i]; &#125; return totalCost; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"}]},{"title":"What is CI/CD?","slug":"computer-science/DevOps/What-is-CI-CD","date":"2023-06-20T15:23:34.000Z","updated":"2023-06-28T07:00:13.665Z","comments":true,"path":"computer-science/DevOps/What-is-CI-CD/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/What-is-CI-CD/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 從測試、建置到部署一次自動化 # What is CI/CD? CI/CD 工具也是為了 DevOps 概念而產生的自動化工具，透過持續整合、持續部署的方式，在開發階段就自動協助開發人員偵測程式碼問題，並部署至伺服器。 # CI（Continuous Integration）持續整合 當開發人員完成一個階段性的程式碼後就經由自動化工具測試、驗證，協助偵測程式碼問題，並建置出即將部署的版本（Build）。 # CD（Continuous Deployment）持續部署 可以說是 CI 的下一階段，經過 CI 測試後所構建的程式碼可以透過 CD 工具部署至伺服器，減少人工部署的時間。 # CI/CD 工具 - GitLab GitLab 主要的服務是提供 git 版本控制系統，其 CI/CD Pipeline 功能簡單又實用，使用者只需要設定於專案根目錄下的「.gitlab-ci.yml」檔，便可以開始驅動各種 Pipeline 協助您完成自動化測試及部署。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"}],"tags":[]},{"title":"What is DevOps?","slug":"computer-science/DevOps/What-is-DevOps","date":"2023-06-20T14:40:23.000Z","updated":"2023-06-28T07:00:17.716Z","comments":true,"path":"computer-science/DevOps/What-is-DevOps/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/What-is-DevOps/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # What is DevOps? DevOps 拆開來就是 Development + Operations ，也就是開發與維運。 更準確的說可以是「開發」「測試」「維運」三者的結合，是一種軟體開發和部署的方法論。 DevOps 主要促進開發和 IT 運營兩個團隊的結合與運作，提升團隊之間的協作和溝通。 DevOps 的目的是通過協調和自動化開發、測試和部署來實現更快的產品交付速度、更高的品質及提升工作效率。 生命週期的每個階段：從初始軟體規劃到程式碼、建構、測試和發佈階段，再到部署、作業與持續監控。 這種關係推動了進一步改善、開發、測試及部署的持續客戶回饋循環。可能可以更快速地持續發佈必要的功能變更或新增項目。 # DevOps 核心五個概念 - CALMS Culture 文化： DevOps 不是一個工具而是代表一個 IT 文化轉型的概念，藉由同理心與換位思考讓開發與營運人員合作更加順暢。 Automation 自動化： 自動化流程提高效率，有助於建立敏捷的團隊，產出品質優良的產品。 Lean 精實： DevOps 希望能建立敏捷開發的團隊，因此精實生產過程也非常重要，包含了減少浪費、盡快交付、延遲做決定等原則，延遲做決定是指領導者可以等接收到完整的資訊後再做決策。 Measurement 測量： 利用數據判斷決策是否正確，若數字一旦有所異常即可隨時改變策略，使團隊保持敏捷性。 Sharing 分享： 藉由團隊間共享資訊，可以提升解決問題的效率。 # 生命週期 持續開發：這項實務做法涵蓋了 DevOps 開發維運生命週期的規劃與編碼階段。其中可能涉及版本控制機制。 持續測試：這項實務做法可以在正在編寫或更新應用程式的程式碼時納入預先排定的持續自動化程式碼測試。這類測試可以加快將程式碼交付至正式作業的速度。 持續整合 (CI)：這項實務做法可以將組態管理 (CM) 工具和其他測試與開發工具結合，以追蹤正在開發的程式碼有多少已準備就緒可供正式作業使用。其中涉及在測試與開發之間快速提供意見反應，以便迅速識別並解決程式碼問題。 持續交付：這項實務做法可以在測試後，自動將程式碼變更傳送至正式作業前或接移環境。然後，員工可以決定是否要將這類程式碼變更推廣至正式作業環境。 持續部署 (CD)：與持續交付類似，這項實務做法可以自動將新程式碼或變更後的程式碼發佈至正式作業環境。執行持續部署的公司每天可以發佈數次程式碼或功能變更。使用 Docker 和 Kubernetes 等 Container 技術有助於在不同的部署平台和環境中維持程式碼的一致性，進而實現持續部署。 持續監控：這項實務做法包括持續監控運作中的程式碼以及支援該程式碼的底層基礎架構。回報錯誤或問題的回饋循環隨後又會回到開發階段。 基礎架構即程式碼：這項實務做法可在各種 DevOps 開發維運階段中使用，以自動化軟體版本所需的基礎架構資源配置。開發人員可從其現有的開發工具中新增基礎架構「程式碼」。例如，開發人員可以視需求從 Docker、Kubernetes 或 OpenShift 建立儲存 Volume。這項實務做法也可讓營運團隊監控環境組態、追蹤變更，並簡化組態的復原作業。 # 工具 規劃：此階段有助於定義商業價值與需求。範例工具包括 Jira 或 Git，可協助追蹤已知問題並執行專案管理。 程式碼：此階段涉及軟體設計及軟體程式碼的建立。範例工具包括 GitHub、GitLab、BitBucket 或 Stash。 建置：在此階段，您將管理軟體建置與版本，並使用自動化工具來協助編譯及封裝程式碼，以供將來發佈到正式作業環境。您使用的原始碼程式碼儲存庫或套件儲存庫也會「封裝」產品發佈所需的基礎架構。範例工具包括 Docker、Ansible、Puppet、Chef、Gradle、Maven 或 JFrog Artifactory。 測試：此階段包括持續測試（手動或自動），以確保最佳的程式碼品質。範例工具包括 JUnit、Codeception、Selenium、Vagrant、TestNG 或 BlazeMeter。 部署：此階段可以包含有助於管理、協調、排程和自動將產品發佈至正式作業環境的工具。範例工具包括 Puppet、Chef、Ansible、Jenkins、Kubernetes、OpenShift、OpenStack、Docker 或 Jira。 操作：此階段可在正式作業期間管理軟體。範例工具包括 Ansible、Puppet、PowerShell、Chef、Salt 或 Otter。 監督：此階段包括識別及收集有關正式作業中特定軟體版本問題的資訊。範例工具包括 New Relic、Datadog、Grafana、Wireshark、Splunk、Nagios 或 Slack。 # 優勢 更快、更好地交付產品 更快地解決問題並降低複雜度 更高的擴充性與可用度 更穩定的作業環境 更佳的資源使用率 更優異的自動化功能 更清楚地掌握系統成果 更高程度的創新","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"}],"tags":[]},{"title":"2090. K Radius Subarray Averages","slug":"coding/leetcode/Medium/2090-K-Radius-Subarray-Averages","date":"2023-06-20T04:38:59.000Z","updated":"2023-06-26T16:57:05.905Z","comments":true,"path":"coding/leetcode/Medium/2090-K-Radius-Subarray-Averages/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2090-K-Radius-Subarray-Averages/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given a 0-indexed array nums of n integers, and an integer k . The k-radius average for a subarray of nums centered at some index i with the radius k is the average of all elements in nums between the indices i - k and i + k (inclusive). If there are less than k elements before or after the index i , then the k-radius average is -1 . Build and return an array avgs of length n where avgs[i] is the k-radius average for the subarray centered at index i . The average of x elements is the sum of the x elements divided by x , using integer division. The integer division truncates toward zero, which means losing its fractional part. For example, the average of four elements 2 , 3 , 1 , and 5 is (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75 , which truncates to 2 . # Example 1 Input: nums = [7,4,3,9,1,8,5,2,6], k = 3 Output: [-1,-1,-1,5,4,4,-1,-1,-1] Explanation: avg[0], avg[1], and avg[2] are -1 because there are less than k elements before each index. The sum of the subarray centered at index 3 with radius 3 is: 7 + 4 + 3 + 9 + 1 + 8 + 5 = 37. Using integer division, avg[3] = 37 / 7 = 5. For the subarray centered at index 4, avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4. For the subarray centered at index 5, avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4. avg[6], avg[7], and avg[8] are -1 because there are less than k elements after each index. # Example 2 Input: nums = [100000], k = 0 Output: [100000] Explanation: The sum of the subarray centered at index 0 with radius 0 is: 100000. avg[0] = 100000 / 1 = 100000. # Example 3 Input: nums = [8], k = 100000 Output: [-1] Explanation: avg[0] is -1 because there are less than k elements before and after index 0. # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public int[] getAverages(int[] nums, int k) &#123; int n = nums.length; int windows = 2 * k + 1; int[] ans = new int[n]; Arrays.fill(ans, -1); if(n &lt; windows)&#123; return ans; &#125; long[] sum = new long[n + 1]; for(int i = 0; i &lt; n; i++)&#123; sum[i + 1] = sum[i] + nums[i]; &#125; for(int i = k; i &lt; n - k; i++)&#123; ans[i] = (int) ((sum[i + k + 1] - sum[i - k]) / windows); &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"}]},{"title":"1732. Find the Highest Altitude","slug":"coding/leetcode/Easy/1732-Find-the-Highest-Altitude","date":"2023-06-19T06:31:22.000Z","updated":"2023-06-20T04:39:55.465Z","comments":true,"path":"coding/leetcode/Easy/1732-Find-the-Highest-Altitude/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1732-Find-the-Highest-Altitude/","excerpt":"","text":"⭐️ # 題目敘述 There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0 . You are given an integer array gain of length n where gain[i] is the net gain in altitude between points i ​​​​​​ and i + 1 for all (0 &lt;= i &lt; n) . Return the highest altitude of a point. # Example 1 Input: gain = [-5,1,5,0,-7] Output: 1 Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1. # Example 2 Input: gain = [-4,-3,-2,-1,4,3,2] Output: 0 Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0. # 解題思路 # Solution class Solution &#123; public int largestAltitude(int[] gain) &#123; int curr = 0; int ans = curr; for(int i = 0; i &lt; gain.length; i++)&#123; curr += gain[i]; ans = Math.max(ans, curr); &#125; return ans; &#125;&#125; 單字 altitudes 海拔，海拔高度 height above sea level 片語 & 搭配詞 consist of 由... 組成 [主動] 群體 + consist of + 部分 The committee consists of doctors and nurses. 該委員會由醫生和護士組成。 →「群體」committee 當主詞，consist of + 「部分」 doctors and nurses consist 必須搭配 of，consist of 只能用主動語態。 「群體」當主詞，consist of + 「部分」。 be composed of 由... 組成 [被動] 群體 + be composed of + 部分 Water is composed of hydrogen and oxygen. 水由氫和氧組成。 →「群體」water 當主詞，is composed of + 「部分」hydrogen and oxygen compose 當組成意思時，使用被動語態，必須搭配 of，用 be composed of。 「群體」當主詞，be composed of + 「部分」。 comprise 由... 組成 [主動] 群體 + comprise + 部分 The country comprises 22 cities. 該國由 22 個城市組成。 →「群體」the country 當主詞，comprise + 「部分」22 cities [主動] 部分 + comprise + 群體 Semiconductor chips and oil comprises the imports of this country. 該國的進口物有半導體晶片和石油。 →「部分」semiconductor chips and oil 當主詞，comprise + 「整體」the imports of this country [被動] 群體 + is comprised of + 部分 The basketball school team is comprised of 12 players. 籃球校隊由 12 名球員組成。 →「群體」the basketball school team 當主詞，is comprised of + 「部分」12 players comprise 的用法比較特別，在主動語態時，可以用「群體當主詞 + comprise + 組成部分」，或「組成部分當組詞 + comprise + 群體」。 在被動語態時，用群體當「主詞 + is comprised of + 組成部分」。 make up 由... 組成 [主動] 部分 + make up + 群體 Plasma, platelets, and blood cells make up blood. 血漿、血小板和血細胞構成血液。 →「部分」plasma, platelets, and blood cells 當主詞，make up + 「整體」blood [被動] 群體 + is made up of + 部分 The model plane is made up of 200 pieces of bricks. 模型飛機由 200 塊積木組成。 →「群體」the model plane 當主詞，is made up of + 「部分」200 pieces of bricks make up 意思是「組成」，用主詞語態時，以「部分」當主詞 + make up + 「群體」。 用被動語態時，「群體」當主詞，be made up of + 「部分」。","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"}]},{"title":"介紹 Java Script Boot","slug":"computer-science/Program-Language/Framework/Java-Spring-boot/介紹-Java-Script-Boot","date":"2023-06-17T07:11:23.000Z","updated":"2023-09-21T05:37:01.053Z","comments":true,"path":"computer-science/Program-Language/Framework/Java-Spring-boot/介紹-Java-Script-Boot/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Program-Language/Framework/Java-Spring-boot/%E4%BB%8B%E7%B4%B9-Java-Script-Boot/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 淺淺介紹一下 Java JAVA 彈性且方便使用者使用，是開發人員建置多種應用程式時的最愛，舉凡社交媒體、Web 和遊戲應用程式及網路與企業應用程式，無所不在。 # Spring vs. Spring Boot Spring Spring Boot Info 以 JAVA 為基礎的開放原始碼 Web 應用程式架構。 在 Spring 架構上建置的延伸模組或模組。 Feature 使用預先建置程式碼的工具和程式庫，提供彈性且完全可設定的環境，以建立自訂、鬆散結合的 Web 應用程式。 提供建立獨立 Spring 應用程式的功能，這些應用程式只要立即執行，不需要註解、XML 設定或撰寫大量其他程式碼。 # Spring Boot 是什麼？ Spring Boot 是由 Pivotal 團隊在 2013 年開始研發、2014 年 4 月發布第一個版本。 它基於 Spring4.0 設計，不僅繼承了 Spring 框架原有的優秀特性，而且還通過簡化配置來進一步簡化了 Spring 應用的整個搭建和開發過程。 JAVA Spring Boot 提供的核心功能，除了 Spring 架構之外。 Spring Boot 提供更輕鬆、更快速的路徑來設定、設定及執行應用程式。 這會消除設定大多數 Spring 型應用程式所需的大量設定。 開發人員無需學習基礎 Spring 架構，就能直接加入並使用 Spring Boot。 Spring Boot 可以說是在 Java 中開發基於 REST Web 應用程序的最快方法之一。 Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can &quot;just run&quot;. We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need minimal Spring configuration. # 主要功能 創建獨立的 Spring 應用程序 直接嵌入 Tomcat、Jetty 或 Undertow（無需部署 WAR 文件） 提供自以為是的 “入門” 依賴項以簡化您的構建配置 盡可能自動配置 Spring 和 3rd 方庫 提供生產就緒的功能，例如指標、健康檢查和外部化配置 絕對沒有代碼生成，也不需要 XML 配置 # 參考連結 Spring Boot 官方網站","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"program-language","slug":"computer-science/Program-Language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/"},{"name":"Framework","slug":"computer-science/Program-Language/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/Framework/"},{"name":"Java Spring Boot","slug":"computer-science/Program-Language/Framework/Java-Spring-Boot","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/Framework/Java-Spring-Boot/"}],"tags":[]},{"title":"什麼是框架?","slug":"computer-science/Program-Language/Framework/什麼是框架","date":"2023-05-28T17:05:57.000Z","updated":"2023-09-21T05:37:43.187Z","comments":true,"path":"computer-science/Program-Language/Framework/什麼是框架/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Program-Language/Framework/%E4%BB%80%E9%BA%BC%E6%98%AF%E6%A1%86%E6%9E%B6/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 軟體框架 (Software Framework) 為軟體開發提供了一個基礎的架構、地基，去實現更複雜的軟體或是邏輯，使開發更有效率的進行，他扮演著規範和定義的角色。 框架本身無法自行運作，開發者必須將自己的程式搭配框架才是一個完整的應用程式。 運用框架其實就像把別人已經做好的零件拿來使用，就像要製作一台機器人，總不可能從製作螺絲開始吧！螺絲通常是像他人購買，而我們專注於完成機器人的整體。 而軟體架構就是如此，他提供了別人事先寫好的函式庫（Library）或類別庫（Class Library），提供軟體開發的便利性，加速了開發過程。 # 提供的好處 圖片來源 https://docs.f5ezcode.in/cs-basic/di-ba-zhang-gong-cheng-de-gong-ju/8.2-cheng-shi-yan-de-kuang-jia # 常見程式語言框架 CSS – bootstrap PHP - Laravel JavaScript – JQuery、Vue.js、React.js、Angular.js、Svelte.js、Express.js Java – Spring MVC、Spring boot Python – Django C# – .NET framework 接下來的系列文章會介紹我學習過的框架且在使用的框架，當然這裡還是以學習筆記的方式呈現，我會盡量整理的有閱讀順序啦～～ 有的框架我不是很熟，但是我會盡量與同類型的進行比較，有時間專研後，再寫筆記。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"program-language","slug":"computer-science/Program-Language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/"},{"name":"Framework","slug":"computer-science/Program-Language/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/Framework/"}],"tags":[]},{"title":"2627. Debounce","slug":"coding/leetcode/Medium/2627-Debounce","date":"2023-05-19T05:19:53.000Z","updated":"2023-05-28T17:14:48.054Z","comments":true,"path":"coding/leetcode/Medium/2627-Debounce/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2627-Debounce/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a function fn and a time in milliseconds t, return a debounced version of that function. A debounced function is a function whose execution is delayed by t milliseconds and whose execution is cancelled if it is called again within that window of time. The debounced function should also recieve the passed parameters. For example, let's say t = 50ms, and the function was called at 30ms, 60ms, and 100ms. The first 2 function calls would be cancelled, and the 3rd function call would be executed at 150ms. If instead t = 35ms, The 1st call would be cancelled, the 2nd would be executed at 95ms, and the 3rd would be executed at 135ms. The above diagram shows how debounce will transform events. Each rectangle represents 100ms and the debounce time is 400ms. Each color represents a different set of inputs. Please solve it without using lodash's _.debounce() function. # Example 1: Input: t = 50 calls = [ {&quot;t&quot;: 50, inputs: [1]}, {&quot;t&quot;: 75, inputs: [2]} ] Output: [{&quot;t&quot;: 125, inputs: [2]}] Explanation: let start = Date.now(); function log(...inputs) { console.log([Date.now() - start, inputs ]) } const dlog = debounce(log, 50); setTimeout(() =&gt; dlog(1), 50); setTimeout(() =&gt; dlog(2), 75); The 1st call is cancelled by the 2nd call because the 2nd call occurred before 100ms The 2nd call is delayed by 50ms and executed at 125ms. The inputs were (2). # Example 2: Input: t = 20 calls = [ {&quot;t&quot;: 50, inputs: [1]}, {&quot;t&quot;: 100, inputs: [2]} ] Output: [{&quot;t&quot;: 70, inputs: [1]}, {&quot;t&quot;: 120, inputs: [2]}] Explanation: The 1st call is delayed until 70ms. The inputs were (1). The 2nd call is delayed until 120ms. The inputs were (2). # Example 3: Input: t = 150 calls = [ {&quot;t&quot;: 50, inputs: [1, 2]}, {&quot;t&quot;: 300, inputs: [3, 4]}, {&quot;t&quot;: 300, inputs: [5, 6]} ] Output: [{&quot;t&quot;: 200, inputs: [1,2]}, {&quot;t&quot;: 450, inputs: [5, 6]}] Explanation: The 1st call is delayed by 150ms and ran at 200ms. The inputs were (1, 2). The 2nd call is cancelled by the 3rd call The 3rd call is delayed by 150ms and ran at 450ms. The inputs were (5, 6). # 解題思路 # Solution /** * @param &#123;Function&#125; fn * @param &#123;number&#125; t milliseconds * @return &#123;Function&#125; */var debounce = function(fn, t) &#123; let timeout; return function(...args) &#123; clearTimeout(timeout); timeout = setTimeout(function()&#123; fn(...args); &#125;, t); &#125;&#125;;/** * const log = debounce(console.log, 100); * log('Hello'); // cancelled * log('Hello'); // cancelled * log('Hello'); // Logged at t=100ms */ type F = (...p: any[]) => anyfunction debounce(fn: F, t: number): F &#123; let timeout: any; return function(...args) &#123; clearTimeout(timeout); timeout = setTimeout(function()&#123; fn(...args); &#125;, t); &#125;&#125;;/** * const log = debounce(console.log, 100); * log('Hello'); // cancelled * log('Hello'); // cancelled * log('Hello'); // Logged at t=100ms */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"785. Is Graph Bipartite?","slug":"coding/leetcode/Medium/785-Is-Graph-Bipartite","date":"2023-05-19T04:30:34.000Z","updated":"2023-05-28T17:13:53.473Z","comments":true,"path":"coding/leetcode/Medium/785-Is-Graph-Bipartite/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/785-Is-Graph-Bipartite/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1 . You are given a 2D array graph , where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u] , there is an undirected edge between node u and node v . The graph has the following properties: There are no self-edges ( graph[u] does not contain u ). There are no parallel edges ( graph[u] does not contain duplicate values). If v is in graph[u] , then u is in graph[v] (the graph is undirected). The graph may not be connected, meaning there may be two nodes u and v such that there is no path between them. A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B . Return true if and only if it is bipartite. # Example 1: Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]] Output: false Explanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other. # Example 2: Input: graph = [[1,3],[0,2],[1,3],[0,2]] Output: true Explanation: We can partition the nodes into two sets: {0, 2} and {1, 3}. # 解題思路 # Solution class Solution &#123; public boolean isBipartite(int[][] graph) &#123; int n = graph.length; int[] remeber = new int[n]; // remeber graph index in which group, group A = 1, group B = -1 for (int i = 0; i &lt; n; i++) &#123; if (remeber[i] == 0 &amp;&amp; !dfs(graph, remeber, i, 1)) return false; &#125; return true; &#125; public boolean dfs(int[][] graph, int[] remeber, int node, int group) &#123; if (remeber[node] != 0) return remeber[node] == group; remeber[node] = group; for (int neighbor : graph[node]) &#123; if (!dfs(graph, remeber, neighbor, -group)) return false; &#125; // if neighbor node is not in same group, mean it can divide to two group. return true; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"}]},{"title":"Git 進階指令","slug":"computer-science/DevOps/Git/Git 進階指令","date":"2023-05-18T09:36:07.000Z","updated":"2023-06-20T14:43:22.320Z","comments":true,"path":"computer-science/DevOps/Git/Git 進階指令/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Git/Git%20%E9%80%B2%E9%9A%8E%E6%8C%87%E4%BB%A4/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 版本退回 引用文: https://gitbook.tw/chapters/using-git/reset-commit git log 檢視提交的歷史記錄。 git log --oneline 目前的 Git 紀錄。 git reset [版本 id] 版本退回","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"}],"tags":[]},{"title":"Work Flow","slug":"computer-science/DevOps/Git/Work-Flow","date":"2023-05-18T07:34:08.000Z","updated":"2023-06-20T14:43:44.971Z","comments":true,"path":"computer-science/DevOps/Git/Work-Flow/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Git/Work-Flow/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 當大家一起開發專案時，專案撰寫的內容越來越多，Git Commit 內容增加，就很容易有 Git Graph 非常雜亂的問題，對某一個功能重複撰寫等等。 這個時候就非常需要工作流程 (Work Flow)，讓大家有規劃，更效率地開發。 # 常見 Work Flow Git Flow GitHub Flow GitLab Flow # 定義部署的環境 開發環境（工程師的電腦） 測試環境（讓審核人員測試使用，像是 QA 測試） 展示環境（讓早期用戶或是驗收使用） 產品環境（正式讓所有用戶使用） # Git Flow Git Flow 是上述三種 Work Flow 中最早出現的。 master 負責管理發布的狀態。當準備好發佈指定版本時，最後的提交會給予一個發布版本標籤。 develop Develop 分支是針對日常開發的分支。所有新功能開發最終都會合併到這裡。 feature 這個分支是新功能的開發或修復錯誤的時候從 develop 分支分開出來的。 release Release 分支是為了發布而準備的。通常這種分支的名稱最前面會加上 &quot;release-&quot;。 hotfit Hot fix 分支是在發布的產品需要緊急修改時，從 master 分支建立的分支。 通常會在分支名稱的最前面會加上 &quot;hotfix-&quot;。 # 開發過程 從 master 分支拉出一條分支 develop 進行日常開發。 要開發新功能 / 修復錯誤時，從 develop 分支拉取一條 feature 分支。 開發完成後，將 feature 分支合入到 develop 分支，並進行開發環境的驗證。 確認完成後，從 develop 分支拉取一條 release 分支，到測試環境進行 SIT/UAT 測試。 測試完成後，可將 release 分支合入 master 分支並將現在內容給回 develop 分支。 版本部屬時，直接將 master 分支程式碼部署到最終環境。 優點: 每個分支都有明確的定義，嚴格按照 Git Flow 管理專案程式碼的話，很難出現程式碼混亂 缺點: 如果 feature 分支過多的話很容易造成程式碼衝突，從而提高了合入的成本 由於每次提交都涉及多個分支，所以 Git Flow 也太不適合提交頻率較高的項目 # GitHub Flow &amp; GitLab Flow By 因為我還沒研究過 GitHub Flow &amp; GitLab Flow，所以這裡提供我覺得寫得很不錯的文章給大家參考 文章 medium.com/@trylovetom 讓我們來了解 GitHub Flow 吧！除了會 Git 你還需要 Work Flow medium.com/i-think-so-i-live Git上的三種工作流程","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"}],"tags":[]},{"title":"Git Branch","slug":"computer-science/DevOps/Git/Git-Branch","date":"2023-05-18T07:31:13.000Z","updated":"2023-06-20T14:43:36.000Z","comments":true,"path":"computer-science/DevOps/Git/Git-Branch/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Git/Git-Branch/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 什麼是 branch? 在開發軟體時，可能同時會有多人在開發同一功能或修復錯誤，也可能會有多個發佈版本的存在，並且需要針對每個版本進行維護，同一個數據庫可以同時進行多個修改。 現在最常用來管理 Git 分支的方法: master develop feature release hotfix # 分支常用指令 git branch# 查看分支。git branch [BRANCH_NAME]# 建立分支。git checkout [BRANCH_NAME]# 取出指定的分支。git checkout -b [BRANCH_NAME]# 建立並跳到該分支。git branch -D [BRANCH_NAME]# 強制刪除指定分支 (須先切換至其他分支再做刪除)。git branch -m [OLD_BRANCH_NAME] [NEW_BRANCH_NAME]# 修改分支名稱。git merge [要合併的分支]# 切換到合併後的分支，再合併分支 合併分支: 例：把 release-1.0 分支的修改合併到 master。 先將分支切換到 mastergit checkout master 合併 release-1.0 分支git merge release-v1.0 # 分支命名和標記 如果可能，請創建不包含特殊字符的分支和標記名稱，因為這些字符需要轉義。用於分支名稱和標記名稱的安全默認字符集為： 英文字母 （a-z 和 A-Z） 數字 (0-9) 有限的標點字符集： 句點 (.) 連字符 (-) 下劃線 (_) 正斜杠 (/) 為避免混淆，分支名稱應以字母開頭。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"}],"tags":[]},{"title":"Git commit specification","slug":"computer-science/DevOps/Git/Git-commit-specification","date":"2023-05-18T07:02:09.000Z","updated":"2023-06-20T14:43:38.826Z","comments":true,"path":"computer-science/DevOps/Git/Git-commit-specification/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Git/Git-commit-specification/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 建議提交格式 建議以這種形式填寫提交訊息 Header: &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; type: 代表 commit 的類別：feat, fix, docs, style, refactor, test, chore，必要欄位。 scope 代表 commit 影響的範圍，例如資料庫、控制層、模板層等等，視專案不同而不同，為可選欄位。 subject 代表此 commit 的簡短描述，不要超過 50 個字元，結尾不要加句號，為必要欄位。 Body: 72-character wrapped. This should answer: Body 部份是對本次 Commit 的詳細描述，可以分成多行，每一行不要超過 72 個字元。 說明程式碼變動的項目與原因，還有與先前行為的對比。 Footer: 填寫任務編號（如果有的話）. BREAKING CHANGE（可忽略），記錄不兼容的變動， 以 BREAKING CHANGE: 開頭，後面是對變動的描述、以及變動原因和遷移方法。 # git commit Header feat: 新增 / 修改功能 (feature)。 fix: 修補 bug (bug fix)。 docs: 文件 (documentation)。 style: 格式 (不影響程式碼運行的變動 white-space, formatting, missing semi colons, etc)。 refactor: 重構 (既不是新增功能，也不是修補 bug 的程式碼變動)。 perf: 改善效能 (A code change that improves performance)。 test: 增加測試 (when adding missing tests)。 chore: 建構程序或輔助工具的變動 (maintain)。 revert: 撤銷回覆先前的 commit 例如：revert: type (scope): subject (回覆版本：xxxx)。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"}],"tags":[]},{"title":"Git 基本指令與觀念","slug":"computer-science/DevOps/Git/Git-基本指令與觀念","date":"2023-05-18T06:59:43.000Z","updated":"2023-06-20T14:43:33.574Z","comments":true,"path":"computer-science/DevOps/Git/Git-基本指令與觀念/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Git/Git-%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4%E8%88%87%E8%A7%80%E5%BF%B5/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 基本指令與觀念 提交訊息是查看其他人提交的修改內容或自己檢查歷史記錄時重要的資料。 所以要用心填寫讓人容易理解的提交訊息。 Git 的標準提交 (commit) 訊息： 第 1 行：提交時修改內容的摘要 第 2 行：空行 第 3 行以後：修改的理由 建議以這種形式填寫提交訊息，詳細可以參考 Git commit specification # 基本指令 git init# 建立新的本地端儲存庫 (Repository)git clone [URL]# 複製遠端的 Repository 檔案到本地端。git status# 檢查本地端檔案異動狀態。 沒事常用 git status 檢查 git 的情況 clone v.s. download clone 可以做 git 後續的一些指令，但 download 無法。 # 常用指令 # add git add [檔案或資料夾]# 將指定的檔案 (或資料夾) 加入版本控制。用 git add . 可加入全部。# commit git commit -m \"[修改內容]\"# 提交 (commit) 目前的異動並透過 -m 參數設定摘要說明文字。git commit# 提交 (commit) 目前的異動，可以打超過一行的 commit information。# push git push# 將本地端 Repository 的 commit 發佈到遠端。git push origin [BRANCH_NAME]# 發佈至遠端指定的分支 (Branch)。# pull git pull# 檔案抓取下來到自己的本地端。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"}],"tags":[]},{"title":"Git 安裝","slug":"computer-science/DevOps/Git/Git-安裝","date":"2023-05-18T06:55:23.000Z","updated":"2023-06-20T14:43:29.523Z","comments":true,"path":"computer-science/DevOps/Git/Git-安裝/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Git/Git-%E5%AE%89%E8%A3%9D/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 安裝 git - Windows git 官網: https://git-scm.com/download/win 然後開啟 Git Bash # 設定 git 識別資料 在你安裝 Git 後首先應該做的事是設定使用者名稱及電子郵件。 這一點非常重要，因為每次 Git 的提交會使用這些資訊，而且提交後不能再被修改。 git config --global user.name \"[使用者名字]\"git config --global user.email \"[電子信箱]\"若你有傳遞 --global 參數，只需要做這工作一次，因為在此系統，不論 Git 做任何事都會採用此資訊。 # 檢查讀者的設定 git config --list# 建立全新的儲存庫 echo \"# test\" >> README.mdgit initgit add README.mdgit commit –m “first commit”git remote add origin [github_repository URL]git push –u origin main","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Windows/"}]},{"title":"Git Information","slug":"computer-science/DevOps/Git/Git-Information","date":"2023-05-18T06:15:06.000Z","updated":"2023-06-20T14:43:41.261Z","comments":true,"path":"computer-science/DevOps/Git/Git-Information/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Git/Git-Information/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 前言 版本控制系統：對軟體開發過程中程式碼、文件、文檔等，發生的變更進行管理的系统，它可以幫助團隊更好的溝通協作，從而更好的進行交付。 常見的版本控制系統分為: 集中式版本控制系統，如: SVN 用主從式架構的作法 需要網路才可以工作，版本在中央服務器上 分布式版本控制系統 distributed version control，如: Git 它允許軟體開發者可以共同參與一個軟體開發專案，但是不必在相同的網路系統下工作 用對等網路的作法來處理版本控制 版本存在自己的 host 上，同時動到一個檔案時，互相給對方看，因此衍伸出遠端數據庫 前情提要: 這章主要在介紹 git 是什麼，以及其的用法，並介紹 github 一個遠端數據庫。也會概述一下 git 分支，可以如何使用。 # Git 是什麼？ Git 是一個軟體，可藉由它產生一個數據庫（repository），並且做到分散式版本控制。 以下幾個功能讓協同開發變得容易，例如: 多處放置同一份程式碼 歷史紀錄追蹤與回朔 版本控制系統 (Version Control System) – 管理你的程式碼版本反悔了回得去、合併了能處理、多人協作互不干擾 # GitHub 是什麼？ GitHub 是一個遠端數據庫，可用於檔案存放，並紀錄檔案版本，將本地端的數據庫存於遠端，達到共同開發的目的。 常見遠端數據庫 GitHub GitLab BitBucket # Git vs. GitHub? 一個是工具，一個是網站，GitHub 的本體是一個 Git Server。 # 沒有 Git? 當你好不容易寫完程式碼，卻被你的好同事 gank。😢","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"}],"tags":[]},{"title":"2622. Cache With Time Limit","slug":"coding/leetcode/Medium/2622-Cache-With-Time-Limit","date":"2023-05-18T02:45:47.000Z","updated":"2023-05-28T17:14:43.090Z","comments":true,"path":"coding/leetcode/Medium/2622-Cache-With-Time-Limit/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2622-Cache-With-Time-Limit/","excerpt":"","text":"⭐️⭐️⭐️⭐️ # 題目敘述 Write a class that allows getting and setting key-value pairs, however a time until expiration is associated with each key. The class has three public methods: set(key, value, duration) : accepts an integer key , an integer value , and a duration in milliseconds. Once the duration has elapsed, the key should be inaccessible. The method should return true if the same un-expired key already exists and false otherwise. Both the value and duration should be overwritten if the key already exists. get(key) : if an un-expired key exists, it should return the associated value. Otherwise it should return -1 . count() : returns the count of un-expired keys. # Example 1: Input: [&quot;TimeLimitedCache&quot;, &quot;set&quot;, &quot;get&quot;, &quot;count&quot;, &quot;get&quot;] [[], [1, 42, 100], [1], [], [1]] [0, 0, 50, 50, 150] Output: [null, false, 42, 1, -1] Explanation: At t=0, the cache is constructed. At t=0, a key-value pair (1: 42) is added with a time limit of 100ms. The value doesn't exist so false is returned. At t=50, key=1 is requested and the value of 42 is returned. At t=50, count() is called and there is one active key in the cache. At t=100, key=1 expires. At t=150, get(1) is called but -1 is returned because the cache is empty. # Example 2: Input: [&quot;TimeLimitedCache&quot;, &quot;set&quot;, &quot;set&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;, &quot;count&quot;] [[], [1, 42, 50], [1, 50, 100], [1], [1], [1], []] [0, 0, 40, 50, 120, 200, 250] Output: [null, false, true, 50, 50, -1] Explanation: At t=0, the cache is constructed. At t=0, a key-value pair (1: 42) is added with a time limit of 50ms. The value doesn't exist so false is returned. At t=40, a key-value pair (1: 50) is added with a time limit of 100ms. A non-expired value already existed so true is returned and the old value was overwritten. At t=50, get(1) is called which returned 50. At t=120, get(1) is called which returned 50. At t=140, key=1 expires. At t=200, get(1) is called but the cache is empty so -1 is returned. At t=250, count() returns 0 because the cache is empty. # 解題思路 # Solution var TimeLimitedCache = function() &#123; this.cache = new Map();&#125;;/** * @param &#123;number&#125; key * @param &#123;number&#125; value * @param &#123;number&#125; time until expiration in ms * @return &#123;boolean&#125; if un-expired key already existed */TimeLimitedCache.prototype.set = function(key, value, duration) &#123; const val = this.cache.get(key); if(val)&#123; clearTimeout(val.timeout); &#125; const timeout = setTimeout(() => this.cache.delete(key), duration); this.cache.set(key, &#123;value, timeout&#125;); return Boolean(val);&#125;;/** * @param &#123;number&#125; key * @return &#123;number&#125; value associated with key */TimeLimitedCache.prototype.get = function(key) &#123; return this.cache.has(key) ? this.cache.get(key).value : -1;&#125;;/** * @return &#123;number&#125; count of non-expired keys */TimeLimitedCache.prototype.count = function() &#123; return this.cache.size;&#125;;/** * Your TimeLimitedCache object will be instantiated and called as such: * var obj = new TimeLimitedCache() * obj.set(1, 42, 1000); // false * obj.get(1) // 42 * obj.count() // 1 */ class TimeLimitedCache &#123; cache: Map&lt;any, any>; constructor() &#123; this.cache = new Map(); &#125; set(key: number, value: number, duration: number): boolean &#123; const val: any = this.cache.get(key); if (val) &#123; clearTimeout(val.timeout); &#125; const timeout = setTimeout((): Boolean => this.cache.delete(key), duration); this.cache.set(key, &#123; value, timeout &#125;); return Boolean(val); &#125; get(key: number): number &#123; return this.cache.has(key) ? this.cache.get(key).value : -1; &#125; count(): number &#123; return this.cache.size; &#125;&#125;/** * Your TimeLimitedCache object will be instantiated and called as such: * var obj = new TimeLimitedCache() * obj.set(1, 42, 1000); // false * obj.get(1) // 42 * obj.count() // 1 */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"1557. Minimum Number of Vertices to Reach All Nodes","slug":"coding/leetcode/Medium/1557-Minimum-Number-of-Vertices-to-Reach-All-Nodes","date":"2023-05-18T01:57:45.000Z","updated":"2023-05-28T17:14:21.558Z","comments":true,"path":"coding/leetcode/Medium/1557-Minimum-Number-of-Vertices-to-Reach-All-Nodes/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1557-Minimum-Number-of-Vertices-to-Reach-All-Nodes/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a directed acyclic graph, with n vertices numbered from 0 to n - 1 , and an array edges where edges[i] = [fromi, toi] represents a directed edge from node fromi to node toi . Find the smallest set of vertices from which all nodes in the graph are reachable. It's guaranteed that a unique solution exists. Notice that you can return the vertices in any order. # Example 1: Input: n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]] Output: [0,3] Explanation: It's not possible to reach all the nodes from a single vertex. From 0 we can reach [0,1,2,5]. From 3 we can reach [3,4,2,5]. So we output [0,3]. # Example 2: Input: n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]] Output: [0,2,3] Explanation: Notice that vertices 0, 3 and 2 are not reachable from any other node, so we must include them. Also any of these vertices can reach nodes 1 and 4. # 解題思路 # Solution import java.util.ArrayList;import java.util.HashSet;import java.util.List;import java.util.Set;class Solution &#123; public List&lt;Integer> findSmallestSetOfVertices(int n, List&lt;List&lt;Integer>> edges) &#123; Set&lt;Integer> link = new HashSet&lt;>(); for (List&lt;Integer> edge : edges) &#123; link.add(edge.get(1)); &#125; List&lt;Integer> ans = new ArrayList&lt;>(); for (int i = 0; i &lt; n; i++) &#123; if (!link.contains(i)) &#123; ans.add(i); &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"}]},{"title":"2636. Promise Pool","slug":"coding/leetcode/Medium/2636-Promise-Pool","date":"2023-05-17T01:55:36.000Z","updated":"2023-05-28T17:14:50.972Z","comments":true,"path":"coding/leetcode/Medium/2636-Promise-Pool/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2636-Promise-Pool/","excerpt":"","text":"⭐️ # 題目敘述 Given an array of asyncronous functions functions and a pool limit n , return an asyncronous function promisePool . It should return a promise that resolves when all the input functions resolve. Pool limit is defined as the maximum number promises that can be pending at once. promisePool should begin execution of as many functions as possible and continue executing new functions when old promises resolve. promisePool should execute functions[i] then functions[i + 1] then functions[i + 2] , etc. When the last promise resolves, promisePool should also resolve. For example, if n = 1 , promisePool will execute one function at a time in series. However, if n = 2 , it first executes two functions. When either of the two functions resolve, a 3rd function should be executed (if available), and so on until there are no functions left to execute. You can assume all functions never reject. It is acceptable for promisePool to return a promise that resolves any value. # Example 1: Input: functions = [ () =&gt; new Promise(res =&gt; setTimeout(res, 300)), () =&gt; new Promise(res =&gt; setTimeout(res, 400)), () =&gt; new Promise(res =&gt; setTimeout(res, 200)) ] n = 2 Output: [[300,400,500],500] Explanation: Three functions are passed in. They sleep for 300ms, 400ms, and 200ms respectively. They resolve at 300ms, 400ms, and 500ms respectively. The returned promise resolves at 500ms. At t=0, the first 2 functions are executed. The pool size limit of 2 is reached. At t=300, the 1st function resolves, and the 3rd function is executed. Pool size is 2. At t=400, the 2nd function resolves. There is nothing left to execute. Pool size is 1. At t=500, the 3rd function resolves. Pool size is zero so the returned promise also resolves. # Example 2: Input: functions = [ () =&gt; new Promise(res =&gt; setTimeout(res, 300)), () =&gt; new Promise(res =&gt; setTimeout(res, 400)), () =&gt; new Promise(res =&gt; setTimeout(res, 200)) ] n = 5 Output: [[300,400,200],400] Explanation: The three input promises resolve at 300ms, 400ms, and 200ms respectively. The returned promise resolves at 400ms. At t=0, all 3 functions are executed. The pool limit of 5 is never met. At t=200, the 3rd function resolves. Pool size is 2. At t=300, the 1st function resolved. Pool size is 1. At t=400, the 2nd function resolves. Pool size is 0, so the returned promise also resolves. # Example 3: Input: functions = [ () =&gt; new Promise(res =&gt; setTimeout(res, 300)), () =&gt; new Promise(res =&gt; setTimeout(res, 400)), () =&gt; new Promise(res =&gt; setTimeout(res, 200)) ] n = 1 Output: [[300,700,900],900] Explanation: The three input promises resolve at 300ms, 700ms, and 900ms respectively. The returned promise resolves at 900ms. At t=0, the 1st function is executed. Pool size is 1. At t=300, the 1st function resolves and the 2nd function is executed. Pool size is 1. At t=700, the 2nd function resolves and the 3rd function is executed. Pool size is 1. At t=900, the 3rd function resolves. Pool size is 0 so the returned promise resolves. # 解題思路 # Solution /** * @param &#123;Function[]&#125; functions * @param &#123;number&#125; n * @return &#123;Function&#125; */var promisePool = async function (functions, n) &#123; const nextPromise = async function next() &#123; if (functions.length == 0)&#123; return ; &#125; const fn = functions.shift(); await fn(); await next(); &#125; const ans = Array(n).fill(null).map(nextPromise); return await Promise.all(ans);&#125;;/** * const sleep = (t) => new Promise(res => setTimeout(res, t)); * promisePool([() => sleep(500), () => sleep(400)], 1) * .then(console.log) // After 900ms */ type F = () => Promise&lt;any>;function promisePool(functions: F[], n: number): Promise&lt;any> &#123; const nextPromise = async function next():Promise&lt;any> &#123; if(functions.length == 0)&#123; return ; &#125; const fn: Function = functions.shift(); await fn(); await next(); &#125; const ans: Promise&lt;any>[] = Array(n).fill(null).map(nextPromise); return Promise.all(ans);&#125;;/** * const sleep = (t) => new Promise(res => setTimeout(res, t)); * promisePool([() => sleep(500), () => sleep(400)], 1) * .then(console.log) // After 900ms */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"2130. Maximum Twin Sum of a Linked List","slug":"coding/leetcode/Medium/2130-Maximum-Twin-Sum-of-a-Linked-List","date":"2023-05-17T01:29:29.000Z","updated":"2023-05-28T17:14:27.773Z","comments":true,"path":"coding/leetcode/Medium/2130-Maximum-Twin-Sum-of-a-Linked-List/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2130-Maximum-Twin-Sum-of-a-Linked-List/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 In a linked list of size n , where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 &lt;= i &lt;= (n / 2) - 1 . For example, if n = 4 , then node 0 is the twin of node 3 , and node 1 is the twin of node 2 . These are the only nodes with twins for n = 4 . The twin sum is defined as the sum of a node and its twin. Given the head of a linked list with even length, return the maximum twin sum of the linked list. # Example 1: Input: head = [5,4,2,1] Output: 6 Explanation: Nodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6. There are no other nodes with twins in the linked list. Thus, the maximum twin sum of the linked list is 6. # Example 2: Input: head = [4,2,2,3] Output: 7 Explanation: The nodes with twins present in this linked list are: Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7. Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4. Thus, the maximum twin sum of the linked list is max(7, 4) = 7. # Example 3: ![](https://assets.leetcode.com/uploads/2021/12/03/eg3drawio.png =300x) Input: head = [1,100000] Output: 100001 Explanation: There is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001. # 解題思路 # Solution // Definition for singly-linked list.import java.util.Deque;import java.util.LinkedList;public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; class Solution &#123; public int pairSum(ListNode head) &#123; Deque&lt;Integer> dq = new LinkedList&lt;>(); ListNode curr = new ListNode(); curr = head; while(curr != null)&#123; dq.add(curr.val); curr = curr.next; &#125; int max = Integer.MIN_VALUE; while(!dq.isEmpty() &amp;&amp; dq.size() >= 2)&#123; max = Math.max(max, dq.pollFirst() + dq.pollLast()); &#125; return max; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Linked-List/"}]},{"title":"Docker Practise - 2","slug":"computer-science/DevOps/Docker/Docker-Practise-2","date":"2023-05-16T11:41:31.000Z","updated":"2023-06-20T14:43:02.611Z","comments":true,"path":"computer-science/DevOps/Docker/Docker-Practise-2/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/Docker-Practise-2/","excerpt":"","text":"# 實作說明 在前一個實作中我們先創建了一個 images ubuntu ，在裡面安裝 nginx ，但其實我們只需要使用 nginx 而已，並不需要 ubuntu 這個作業系統。 所以接下來我們要實作撰寫一個 Dockerfile，在自己的專案中，run Dockerfile 進行部屬，而且不包含 ubuntu。 # 撰寫一個 Project 當然要現在馬上生出一個 project 有點費時，所以如果手邊沒有撰寫好的 project 也沒關係，接下來分兩部分來說: 已經有可以實作的 project 這個就很簡單，先進入 project 的資料夾。 沒有可實作的 project 這個其實也不難，創建一個新資料夾，名稱隨意，如果想不到可以用: [docker-test]，在裡面撰寫一個 index.html 。 以下是個簡單的 html 可以參考: index.html&lt;h1>My Project&lt;/h1> # 撰寫 nignx.conf 這個其實沒寫也沒關係，沒有寫就是原本 nignx.conf 的預設，寫了可以更改其原本預設。 server&#123; listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; index index.html; charset utf-8; access_log /var/log/nginx/access_log; error_log /var/log/nginx/error_log; &#125; 內容細節說明可以去看 docker practise - 1，那邊有稍微說明一下內容涵意。 # 創建一個 Dockerfile 的檔案 創建一個 Dockerfile 檔，沒有副檔名，純檔案。 Dockerfile 內容如下: FROM nginxMAINTAINER HsingYu# 複製一整個在根目錄專案的檔案進去COPY / /usr/share/nginx/html# 如果只有一個檔案，如: index.html 可以寫 # COPY index.html /usr/share/nginx/html# 把 nignx.conf 加入預設 conf 裡面COPY nginx.conf /etc/nginx/conf.d/default.conf# 容器對外連接 80 portEXPOSE 80這樣就完成撰寫 Dockerfile 了。 # 利用 Dockerfile 建立 images docker bulid -t [&quot;images name&quot;] . -t : 後面接為 images 命名的名稱，注意不可以是大寫字母，要是小寫喔～～ . : 指在這個地方下的 Dockerfile 建立完成會如下圖: # 執行建立的 images docker run -p 80:80 [&quot;images name&quot;] -p : 後面寫通信的 port 80:80 : 為了方便區分冒號 (:) 前後 port 代表的不同意思，接下來會以 8080:80 來解釋，容器將在端口 8080 上的主機上可用，但它與端口 80 上的容器（和應用程序）通信，簡單來說就是在 bowser 中輸入容器運行所在的 Docker 主機的 DNS 名稱或者 IP 位址，並在後面加上 port 8080，例如: localhost:8080 執行成功會如下圖: localhost port 80 不用特別寫，localhost:80 =&gt; localhost","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"}]},{"title":"Docker Practise - 1","slug":"computer-science/DevOps/Docker/Docker-Practise-1","date":"2023-05-16T11:32:34.000Z","updated":"2023-06-20T14:42:59.535Z","comments":true,"path":"computer-science/DevOps/Docker/Docker-Practise-1/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/Docker-Practise-1/","excerpt":"","text":"# 實作說明 當一個軟體完成後要進行發布網站，我們並不會使用絕對路徑，顯示檔案位置，會使用取得主機（hosting）和網域名稱（domain name）的方式來達到。 而他人只需要訪問你的 hosting IP 或為其申請的 domain name 來 request 資料。 而常見的有兩種工具來做: Apache nginx 舉個大家比較熟悉的例子就是 xampp， 可以將檔案丟進去，訪問 localhost 進行訪問。 但是因為 xampp 是一個類似於 LAMP 的環境， 他除了 Apache 以外，還包含了 phpmyadmin、PHP、Perl 等其他東西， 如果不需要用到 php 等東西，就會比較沒有必要。 # 創建一個 docker images ubuntudocker run -it -p 80:80 ubuntu:focal bash # 更新 apt apt update # 下載 nginx apt install nginx # 開啟 nginx nginx -s reload # 可能出現錯誤資訊: nginx: [error] open() &quot;/var/run/nginx.pid&quot; failed (2: No such file or directory) 解決方法: 輸入以下指令 nginx -c /etc/nginx/nginx.conf 查看 /etc/nginx/nginx.conf 修改內容 nano /etc/nginx/nginx.conf 將其中內容修改成下方 pid /var/run/nginx.pid; #pid /run/nginx.pid; pid /var/run/nginx.pid; 再試一次 nginx -s reload # 網頁連接設定 nano /etc/nginx/sites-available/default port 連接設定 根目錄檔案位置 預先載入檔案 server_name 用於設定 DNS 域名 # 最後將 APP 檔案加入根目錄檔案位置 原本顯示完整檔案位置 經過修改剩下 locolhost = 127.0.0.1 ^D = exit : 離開 container 如果在 Terminal 無法離開 container 再開起一個 Terminal docker ps : 檢查還未關閉的 container docker stop [container ID] : 這裡 container ID 可以打前兩個字就好","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"}]},{"title":"Docker Compose","slug":"computer-science/DevOps/Docker/Docker-Compose","date":"2023-05-16T11:29:28.000Z","updated":"2023-06-20T14:42:52.556Z","comments":true,"path":"computer-science/DevOps/Docker/Docker-Compose/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/Docker-Compose/","excerpt":"","text":"# Docker Compose # 為什麼要用 Docker Compose? 之前有介紹過使用 docker run 指令就可以把 Docker Container 啟動起來，但是如果我們要啟動很多個 Docker Container 時，就需要輸入很多次 docker run 指令。 另外 container 和 container 之間要做關聯的話也要記得它們之間要如何的連結 (link) Container，這樣在要啟動多個 Container 的情況下，就會顯得比較麻煩。 # 如何運作？ Docker-Compose: 寫一個 docker-compose.yml ，把所有要使用 Docker Image 寫上去，也可以把 Container 之間的關係連結 (link) 起來。 最後只要下 docker-compose up 指令，就可以把所有的 Docker Container 執行起來，這樣就可以很快速和方便的啟動多個 container。 # Docker Compose 常用指令 # 啟動所有的 Docker Container $ docker-compose up # 查看 Docker Container 的執行狀態 $ docker-compose ps # 看執行的 log $ docker-compose logs # 停止 docker-compose 執行的所有 Container $ docker-compose stop # 刪除 docker-compose 的所有 Container $ docker-compose rm # Docker Compose 實作 實作的部份主要就是要把 Docker-Compose 安裝起來 然後撰寫一個 docker-compose.yml 並且使用 docker-compose up ，指令把所有的 Docker Container 啟動起來 # 安裝 Docker-Compose # cd /usr/bin # wget https://github.com/docker/compose/releases/download/1.18.0/docker-compose-Linux-x86_64 # mv docker-compose-Linux-x86_64 docker-compose # chmod 755 docker-compose # 撰寫 docker-compose.yml version: '2' services: db: image: mysql environment: MYSQL_ROOT_PASSWORD: 123456 admin: image: adminer ports: - 8080:8080 主要的功能是要啟動 2 個 Docker Container，一個是 mysql 的 Container，另外一個是 admin 管理 mysql Web UI 的 container MYSQL_ROOT_PASSWORD 的環境變數用來設定登入 mysql 的密碼 參考網站: https://hub.docker.com/_/mysql/ # 啟動所有的 Docker Container $ docker-compose up -d -d 參數代表要執行在背景的方式 # 查看 Docker Container 的執行狀態 $ docker-compose ps # admin 執行 http://localhost:8080 其他指令可以參考官方網站: https://docs.docker.com/compose/compose-file/compose-file-v2/ # 參考文章 iT邦幫忙/@yangj26952 使用 Docker-Compose 啟動多個 Docker Container","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"}]},{"title":"Dockerfile","slug":"computer-science/DevOps/Docker/Docker_file","date":"2023-05-16T11:11:57.000Z","updated":"2023-06-20T14:42:49.497Z","comments":true,"path":"computer-science/DevOps/Docker/Docker_file/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/Docker_file/","excerpt":"","text":"# Dockerfile Dockerfile 由一行行命令語句組成，並且支援以 # 開頭的註解行。 Dockerfile 分為四部分： 基底映像檔資訊 維護者資訊 映像檔操作指令 容器啟動時執行指令。 # This dockerfile uses the ubuntu image # VERSION 2 - EDITION 1 # Author: docker_user # Command format: Instruction [arguments / command] .. # 基本映像檔，必須是第一個指令 FROM ubuntu# 維護者： docker_user &lt;docker_user at email.com> (@docker_user) MAINTAINER docker_user docker_user@email.com # 更新映像檔的指令 RUN echo \"deb http://archive.ubuntu.com/ubuntu/ raring main universe\" >> /etc/apt/sources.list RUN apt-get update &amp;&amp; apt-get install -y nginx RUN echo \"\\ndaemon off;\" >> /etc/nginx/nginx.conf # 建立新容器時要執行的指令 CMD /usr/sbin/nginx# Dockerfile 基本語法 # Example FROM centos:7MAINTAINER jackRUN yum install -y wgetRUN cd /ADD jdk-8u152-linux-x64.tar.gz /RUN wget http://apache.stu.edu.tw/tomcat/tomcat-7/v7.0.82/bin/apache-tomcat-7.0.82.tar.gzRUN tar zxvf apache-tomcat-7.0.82.tar.gzENV JAVA_HOME=/jdk1.8.0_152ENV PATH=$PATH:/jdk1.8.0_152/binCMD [\"/apache-tomcat-7.0.82/bin/catalina.sh\", \"run\"] FROM： 使用到的 Docker Image 名稱，今天使用 CentOS MAINTAINER： 用來說明，撰寫和維護這個 Dockerfile 的人是誰，也可以給 E-mail 的資訊 RUN： RUN 指令後面放 Linux 指令，用來執行安裝和設定這個 Image 需要的東西 ADD： 把 Local 的檔案複製到 Image 裡，如果是 tar.gz 檔複製進去 Image 時會順便自動解壓縮。Dockerfile 另外還有一個複製檔案的指令 COPY 未來還會再介紹 ENV： 用來設定環境變數 CMD： 在指行 docker run 的指令時會直接呼叫開啟 Tomcat Service # Dockerfile 實作 已經體驗過使用 Docker 的指令，把 Docker Image Pull 到 local，並且執行 container，然後在 container 上安裝 HTTP Service，就類似是在使用 VM。 直接進入 Docker Container 裡面下一些指令安裝程式和改設定檔，不夠自動化，可能需要常常的重覆在做同一件事，這樣會很沒效率。 寫 Dockerfile，只要下 docker build 的指令就可以把 Docker Image 建構起來，未來要使用就直接 Run 此 Image。 # 實作目標: 要做到在 Dockerfile 裡面，撰寫安裝 Java 和 Tomcat 的指令，包成 Docker Image， 之後只要呼叫到 docker run 指令，就可以把 Tomcat Service 啟動起來。 主要目的用來體驗如何撰寫 Dockerfile 和 Build Image 以及執行 Docker container。 記住要使用 WSL2 此虛擬機 來實作 Docker 可參考前面 安裝 Windows，或以下訊息 Docker 並非是一个通用的容器工具，它依賴於已存在並運行的 Linux 内核環境。 在 Windows 上部署 Docker 的方法都是先安装一个虛擬機，並在安装 Linux 系統的的虛擬機中運行 Docker。 # 第一步: 建立 Dockerfile 建立寫 Dockerfile 會用到的資料夾，指令如下 $ mkdir docker-test $ cd docker-test 下載 JDK 的安裝檔放在 docker-test 資料夾裡，使用的版本是 jdk-19.0.2 下載連結 https://download.java.net/java/GA/jdk19.0.2/fdb695a9d9064ad6b064dc6df578380c/7/GPL/openjdk-19.0.2_linux-x64_bin.tar.gz sudo apt install 將檔案移至路徑 \\wsl$\\Ubuntu\\home\\[user name]\\docker-test 撰寫 Dockerfile $ vi Dockerfile Dockerfile 的內容如下 FROM centos:7MAINTAINER HsingYu# 安裝 wget，yum 是 centos 的安裝指令RUN yum install -y wgetRUN cd /# 加入 jdk-19.0.2 壓縮檔案，加入後會自動解壓縮ADD openjdk-19.0.2_linux-x64_bin.tar.gz /# 下載 apache-tomcat-10.1.7.tar.gzRUN wget --no-check-certificate https://dlcdn.apache.org/tomcat/tomcat-10/v10.1.7/bin/apache-tomcat-10.1.7.tar.gz# 解壓縮 apache-tomcat-10.1.7.tar.gzRUN tar zxvf apache-tomcat-10.1.7.tar.gz# 設置 java 的環境變數ENV JAVA_HOME=/jdk-19.0.2ENV PATH=$PATH:/jdk-19.0.2/binCMD [\"/apache-tomcat-10.1.7/bin/catalina.sh\", \"run\"] 撰寫完 Dockerfile 之後資料夾的結構如下圖 或者將下載 jdk19.0.2 也寫入 Dockerfile FROM centos:7MAINTAINER HsingYuRUN yum install -y wgetRUN cd /RUN wget https://download.java.net/java/GA/jdk19.0.2/fdb695a9d9064ad6b064dc6df578380c/7/GPL/openjdk-19.0.2_linux-x64_bin.tar.gzRUN tar zxvf openjdk-19.0.2_linux-x64_bin.tar.gzRUN wget --no-check-certificate https://dlcdn.apache.org/tomcat/tomcat-10/v10.1.7/bin/apache-tomcat-10.1.7.tar.gzRUN tar zxvf apache-tomcat-10.1.7.tar.gzENV JAVA_HOME=/jdk-19.0.2ENV PATH=$PATH:/jdk-19.0.2/binCMD [\"/apache-tomcat-10.1.7/bin/catalina.sh\", \"run\"] # 第二步: Build Docker Image 預設在和 Dockerfile 檔案同層的資料夾底下輸入， docker build 指令，如下 $ docker build -t mytomcat . --no-cache 使用 --no-cache 的主要原因，是避免在 Build Docker image 時被 cache 住，而造成沒有 build 到修改過的 Dockerfile。 Build 完的結果如下圖： Build 完 Docker Image 之後，使用 docker images 指令查看是否有 build 成功如下圖 # 第三步: 在 Build 完 Docker Image 之後就可以執行 Docker Container，這時 Tomcat 的 Service 也會跟者被執行起來，指令如下 在瀏覽器跑 $ docker run -p 8080:8080 mytomcat 在虛擬機跑 $ docker run mytomcat Tomcat Service 會被執行起來的主要原因是在 Dockerfile 裡面有寫 CMD 指令，呼叫啟動 Tomcat Service # 第四步: 打開 Browser 確認 要打開 Browser 確認 Tomcat Service 有沒有被執行起來時，發現我們不知道 Docker Container 的 IP，這時侯只能使用 docker exec 進入 docker container 查詢 IP 。 要使用 docker exec 指令之前需要先知道 Container 的 ID 所以需要先使用 docker ps 指令查詢 Container ID，如下圖： 有了 IP 之後就可以打開 Browser 輸入 http://172.17.0.2:8080 URL 的位置，確認 Tomcat Service 是否有啟動，如下圖： 直接進入 Docker Container 去看 IP 的位址其實有點麻煩，會故意這樣 Daemon 主要的原因，是讓大家了解到我們把 Docker Container 執行啟來時並不會知道它的 IP 位址在哪，這需要透過設定有關於 Docker 的 Network 來解決這個問題。 目前使用最簡單的方法，就是在 run docker container 時用 Port 的 Mapping 來解決此問題，重新再一次 run docker container，指令如下： $ docker run -p 8080:8080 mytomcat Container 的 8080 port mapping 到 localhost 的 8080 port ，這樣只要輸入 http://localhost:8080 就可以看到 tomcat service 的 WebUI 畫面了。 # 參考文章 iT邦幫忙/@yangj26952 實作撰寫第一個 Dockerfile","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"}]},{"title":"基礎指令","slug":"computer-science/DevOps/Docker/基礎指令","date":"2023-05-16T10:57:42.000Z","updated":"2023-06-20T14:42:37.079Z","comments":true,"path":"computer-science/DevOps/Docker/基礎指令/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/%E5%9F%BA%E7%A4%8E%E6%8C%87%E4%BB%A4/","excerpt":"","text":"# 基礎指令 # Image 映像檔 常用指令 指令 說明 範例 search 搜尋 docker search [image_name] pull 下載 docker pull [image_name] images 查看目前 images (列表) docker images run 執行 docker run [-ti] [centos] [/bin/bash] rmi [image ID] 刪除 docker rmi [615cb40d5d19] build 建立 docker build [-t project .] login 登入 docker login [docker.okborn.com] push 上傳 docker push # Container 容器 常用指令 # Registry 倉庫 常用指令 # 基礎指令實作 # 實作目標： 先從 Docker Hub 上把 Ubuntu OS 的 image pull 到 local， 有了 image 之後就可以把 Docker container 執行起來， 然後進入到 container 裡面安裝和啟動 Apache 的 HTTP Service， 並且寫一個有 HelloWorld 字串的 HTML 檔案。 最後使用 Browser 連到 Docker Container 裡面的 HTTP Service， 確認 HelloWorld 的字串能正常的顯示出來。 # 實作的流程如下： 從 Docker Hub 下載 Docker Image 到 local 使用 Docker Image 啟動 Docker Container 並進入 Docker Container 的 terminal 在 Docker Container 裡面安裝 Apache 的 HTTP Service，並且寫一個 helloworld 的 html 檔 使用 Browser 連到 helloworld.html 確認 Docker Container 有成功的被啟動起來 # 第一步: 從 Docker Hub 下載 Docker Image 到 local 要下載 Docker Image 之前需要先搜尋一下，Docker Image 的 Name 是什麼，指令如下： $ docker search ubuntu -f is-official=true is-official=true 表示要搜尋是官方的 Docker image 就選擇星星數最多的 Name 為 ubuntu 找到了 ubuntu 的 Docker Image Name 之後，就可以把此 image pull 下來，指令如下： $ docker pull ubuntu 執行結果如下圖 要再一次確認 ubuntu 的 docker image 有沒有下載下來，可以使用以下的指令 $ docker images 執行結果如下圖 # 第二步: 有了 Docker Image 之後就可以把 container 執行起來了，並且進入 Docker Container 的 terminal 裡面 指令如下 $ docker run -it -p 8000:80 ubuntu /bin/bash 使用以上的指令就可以進入了 docker container 裡面的 terminal 可以再打開另外一個 terminal 視窗，輸入以下指令 $ docker ps -a 確認 docker container 有正常的執行，如下圖： 在要離開 docker container 的 terminal 時有一個坑。就是如果輸入 exit 指令時，container 會被關閉，如下圖： 如果不要停止 container 而要退出 docker container 的 terminal 需要輸入 ctrl + p 之後再輸入 ctrl + q 的按鍵，就不會把 container 關閉。 # 第三步: 在 docker container 裡面安裝和啟動 apache 的 http service，指令如下: root@a03f4fc98ea2:/# apt-get update root@a03f4fc98ea2:/# apt-get install -y apache2 root@a03f4fc98ea2:/# service apache2 start if it is success will show 簡單寫一個 hellowolrd.html 檔案放在 /var/www/html 的路徑下，指令如下: root@a03f4fc98ea2:/# echo &quot;HelloWorld&quot; &gt; /var/www/html/helloworld.html 使用 cat /etc/hosts 指令查看 docker container 的 IP 如下圖： 如果想要使用 ifconfig 指令，需要安裝 net-tools 工具指令如下: root@a03f4fc98ea2:/# apt-get install -y net-tools # 第四步: 使用 Linux 虛擬機 GUI browser 輸入 http://172.17.0.2/helloworld.html 的 URL 查看 helloworld.html 的檔案是否能正常的顯示。 使用 Window 本機的 browser 輸入 http://localhost:8000/helloworld.html 的 URL 查看 helloworld.html 的檔案是否能正常的顯示，畫面如下： # 參考文章 iT邦幫忙/@yangj26952 用簡單的例子來說明如何使用 Docker 指令","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"}]},{"title":"Docker-安裝","slug":"computer-science/DevOps/Docker/Docker-安裝","date":"2023-05-16T10:33:53.000Z","updated":"2023-06-20T14:44:05.007Z","comments":true,"path":"computer-science/DevOps/Docker/Docker-安裝/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/Docker-%E5%AE%89%E8%A3%9D/","excerpt":"","text":"# Windows Docker 並非是一个通用的容器工具，它依賴於已存在並運行的 Linux 内核環境。 在 Windows 上部署 Docker 的方法都是先安装一个虛擬機，並在安装 Linux 系統的的虛擬機中運行 Docker。 # 使用 WSL 在 Windows 上安裝 Linux 開發人員可以在 Windows 電腦上同時存取 Windows 和 Linux 的功能。 Windows 子系統 Linux 版 (WSL) 可讓開發人員直接在 Windows 上安裝 Linux 散發套件， (例如 Ubuntu、OpenSUSE、Type、Debian、Arch Linux 等) 並使用 Linux 應用程式、公用程式和 Bash 命令列工具，不需要傳統虛擬機器或雙佈設定的額外負荷。 # 必要條件 您必須 Windows 10 版本 2004 和更新版本執行， (組建 19041 和更新版本) 或 Windows 11。 檢查更新。 # 安裝 WSL 命令 開啟 PowerShell 或 Windows 命令提示字元 (cmd)，輸入命令，然後重新開機電腦。 wsl --install 啟用選用的 WSL 和虛擬機器平台元件 下載並安裝最新的 Linux 核心 將 WSL 2 設定為預設值 可能需要下載並安裝 Ubuntu Linux 發行版本 (重新開機) 您必須在此安裝程式期間重新開機電腦 若已有其他版本，可以以此指令來下載 Ubuntu wsl --install -d Ubuntu # 檢查 WSL 狀態 wsl --status 使用 wsl --install 命令安裝的新 Linux 安裝預設會設定為 WSL 2。 # 開啟 WSL wsl.exe # 設定 Linux 使用者名稱和密碼 系統會要求您為 Linux 發行版本建立使用者名稱和密碼。 此使用者名稱和密碼是每個各自 Linux 發行版本專屬，不會影響您的 Windows 使用者名稱。 請注意，在輸入 密碼時，畫面上不會顯示任何專案。 這稱為盲目輸入。 您不會看到您輸入的內容，這完全正常。 一旦您建立使用者名稱和密碼，帳戶就會是您散發套件的預設使用者，而且會在啟動時自動登入。 此帳戶將會被視為 Linux 系統管理員，並且能夠執行 sudo (超級使用者執行) 系統管理命令。 在 WSL 上執行的每個 Linux 發行版本都有自己的 Linux 使用者帳戶和密碼。 每當您新增散發套件、重新安裝或重設時，都必須設定 Linux 使用者帳戶。 若要變更或重設密碼，請開啟 Linux 發行版本，然後輸入命令： passwd 。 系統會要求您輸入目前的密碼，然後要求您輸入新密碼，然後確認您的新密碼。 # 使用 Docker 設定遠端開發容器 使用 WSL 2 (Windows 子系統 Linux 版 版本 2) 設定適用于 Windows 的 Docker Desktop。 # 必要條件 安裝 WSL，並為在 WSL 2 中執行的 Linux 發行版本設定使用者名稱和密碼。 安裝 Visual Studio Code (選擇性)。 這會提供最佳體驗，包括能夠在遠端 Docker 容器內撰寫程式碼和偵錯，並聯機到您的 Linux 散發套件。 安裝 Windows 終端機 (選擇性)。 這可提供最佳體驗，包括在同一個介面中自訂和開啟多個終端機的能力， (包括 Ubuntu、Debian、PowerShell、Azure CLI，或任何您想要使用)。 在 Docker Hub 註冊 Docker 識別碼， (選擇性)。 # 安裝 Docker Desktop 請先到 Docker 官網 https://www.docker.com/docker-windows 在 cmd 上輸入以下指令可以確認是否下載成功 開啟 Docker Desktop 確定已核取 [設定&gt; 一般] 中的 [使用 WSL 2 型引擎]。 移至 [設定&gt; 資源 &gt; WSL 整合]，從您想要啟用 Docker 整合的已安裝 WSL 2 散發套件中選取。 若要確認已安裝 Docker，請開啟 WSL 散發套件 (例如 Ubuntu) ，並輸入下列命令來顯示版本和組建編號： docker --version # 使用下列方式執行簡單的內建 Docker 映射，以測試您的安裝是否正常運作： docker run hello-world # 尋找 Docker 映射儲存體資料夾 Docker 會建立兩個散發資料夾來儲存資料： \\wsl$\\docker-desktop \\wsl$\\docker-desktop-data 您可以開啟 WSL Linux 發行版本並輸入： explorer.exe . 在 Windows 檔案總管中檢視資料夾，以找到這些資料夾。 輸入： \\\\wsl$","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Windows/"}]},{"title":"虛擬化技術","slug":"computer-science/DevOps/Docker/虛擬化技術","date":"2023-05-16T08:52:42.000Z","updated":"2023-06-20T14:42:43.555Z","comments":true,"path":"computer-science/DevOps/Docker/虛擬化技術/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/%E8%99%9B%E6%93%AC%E5%8C%96%E6%8A%80%E8%A1%93/","excerpt":"","text":"# 虛擬化技術 虛擬化要解決的問題是:「當我寫了一個程式，在我電腦上可以執行，但在別人電腦上就不行」。 # But why? 作業系統不同 硬體配置不同 簡單來說：我的程式可能剛好只跟我的電腦的環境相容。😢 # 何謂虛擬化技術？ 而虛擬化要做的就是模擬出一個環境，讓程式可以在不同硬體或作業系統上執行時，都以為自己在同一個環境中執行，以此來避免前面所述的問題。 目前常見用來比較的虛擬化技術有兩種: 在系統層級的虛擬化技術，稱虛擬機器（Virtual machine） 例如 : Virtual Box 。 在作業系統層級技術，此稱容器（Container） 例如 : Docker 。 # 虛擬機器 以作業系統為中心 傳統虛擬化的目標： 將一個應用程式所需的執行環境打包起來，建立一個獨立環境，方便在不同的硬體中移動。 虛擬機器是在系統層上虛擬化， 簡單來說， Virtual Box 就是一個可以讓你在作業系統（Host OS）上面再裝一個作業系統（Guest OS），然後讓兩個作業系統彼此不會打架的平台。 # 容器 以應用程式為中心 容器化的目標： 改善虛擬機器因為需要裝 Guest OS 導致啟動慢、佔較大記憶體的問題。 容器是在作業系統層上虛擬化， 透過 Container Manager 直接將一個應用程式所需的程式碼、函式庫打包， 建立資源控管機制隔離各個容器，並分配 Host OS 上的系統資源。 透過容器，應用程式不需要再另外安裝作業系統（Guest OS）也可以執行。 # VM vs. CONTAINER","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[]},{"title":"Docker Information","slug":"computer-science/DevOps/Docker/Docker-Information","date":"2023-05-16T07:52:43.000Z","updated":"2023-06-20T14:42:56.141Z","comments":true,"path":"computer-science/DevOps/Docker/Docker-Information/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/Docker-Information/","excerpt":"","text":"# 簡介 # 什麼是 Docker? Docker 是一個開源軟體，出現於 2013 年初，最初是 Dotcloud 公司內部的 Side-Project。 它基於 Google 公司推出的 Go 語言實作。(Dotcloud 公司後來改名為 Docker) # 為什麼要使用 Docker? 更有效率的利用資源 統一環境 對於 DevOps 的好處 使開發高效且可以預測 消除了重複的、平凡的配置任務，在整個開發生命週期中用於快速、簡單和可移植的應用程序開發。 Docker 想解決的問題: 改善傳統虛擬機器因為需要額外安裝作業系統（Guest OS），導致啟動慢、佔較大記憶體的問題。 Docker 要提供的解法： 以應用程式為核心虛擬化，取代傳統需要 Guest OS 的虛擬化技術。 # 概念 Docker 是一種工具，可用來建立、部署及執行使用容器的應用程式。 容器可讓開發人員封裝含有其所需全部元件 (程式庫、架構、相依性等) 的應用程式，且全部以一個套件的形式出貨。 使用容器可確保應用程式會以相同的方式執行，而不管任何自訂的設定或先前在執行該應用程式的電腦 (可能與用來撰寫和測試應用程式程式碼的電腦不同) 上安裝的程式庫。 這可讓開發人員專注於撰寫程式碼，而不需擔心程式碼將在其上執行的系統。 # Docker 三元素 要使用 Docker 時最重要的三個元素： 映像檔 (Image)、 容器 (Container)、 倉庫 (Repository)。 用一個簡單的比喻來解釋 : 如果映像檔是一個做蛋糕的模具，容器則是用該模具烤出來的蛋糕，而倉庫是用來集中放置模具們的收納櫃。 # Image 映像檔為一個唯獨的模板。 內可包含完整的 ubuntu 作業系統環境。 映像檔可用來快速生產 Docker 容器，並可重複產生。 映像檔可以透過 (撰寫由命令行構成的) Dockerfile 建立，或是開放公開下載的地方取得。 舉例來說，如果我今天想要一個 node.js 的執行環境跑我寫好的程式，我可以直接到上 Docker Hub 找到相對應的 node.js 映像檔 ，而不需要自己想辦法打包一個執行環境。 它是 Docker 的映像檔主要是一個唯讀的檔案， 是啟動 Docker container 要使用到的檔案。 另外 Docker 的 image 可以像是堆積木一樣， 一層一層的把 Docker image 堆起來。 如右圖： # Container 容器是由映像檔建立出來的實例。 Docker 即是利用容器來執行關鍵技術。 容器可以被啟動、開始、停止、刪除。 且容器與容器之間是相互隔離、保證安全的。 可以把容器看做是一個執行的應用程式加上執行它的簡易版 Linux 環境（包括 root 使用者權限、程式空間、使用者空間和網路空間等） Docker Container 是透過 Docker image 執行起來的 Process，同一個 Docker image 可以啟動多個 Docker Container。 Docker container 和 Docker container 之間的環境是隔離開離來的，不會發生 container1 開 8080 的 port，container2 開 8080 的 port 有衝到的問題 # Repository 倉庫是集中存放映像檔檔案的場所，每個倉庫中又包含了多個映像檔。 每個映像檔有不同的標籤（tag）。 倉庫分為公開倉庫（Public）和私有倉庫（Private）兩種形式 而最大的公開倉庫為 Docker Hub，裡面存放了大量的現成、實用映像檔供使用者下載。 而 Docker 倉庫註冊伺服器的概念就跟 Github 類似，你可以在上面建立多個倉庫，然後透過 push、pull 的方式上傳、存取。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[]},{"title":"2637. Promise Time Limit","slug":"coding/leetcode/Easy/2637-Promise-Time-Limit","date":"2023-05-16T07:21:24.000Z","updated":"2023-05-28T17:12:05.518Z","comments":true,"path":"coding/leetcode/Easy/2637-Promise-Time-Limit/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2637-Promise-Time-Limit/","excerpt":"","text":"⭐️ # 題目敘述 Given an asyncronous function fn and a time t in milliseconds, return a new time limited version of the input function. A time limited function is a function that is identical to the original unless it takes longer than t milliseconds to fullfill. In that case, it will reject with &quot;Time Limit Exceeded&quot; . Note that it should reject with a string, not an Error . # Example 1 Input: fn = async (n) =&gt; { await new Promise(res =&gt; setTimeout(res, 100)); return n * n; } inputs = [5] t = 50 Output: {&quot;rejected&quot;:&quot;Time Limit Exceeded&quot;,&quot;time&quot;:50} Explanation: The provided function is set to resolve after 100ms. However, the time limit is set to 50ms. It rejects at t=50ms because the time limit was reached. # Example 2 Input: fn = async (n) =&gt; { await new Promise(res =&gt; setTimeout(res, 100)); return n * n; } inputs = [5] t = 150 Output: {&quot;resolved&quot;:25,&quot;time&quot;:100} Explanation: The function resolved 5 * 5 = 25 at t=100ms. The time limit is never reached. # Example 3 Input: fn = async (a, b) =&gt; { await new Promise(res =&gt; setTimeout(res, 120)); return a + b; } inputs = [5,10] t = 150 Output: {&quot;resolved&quot;:15,&quot;time&quot;:120} Explanation: The function resolved 5 + 10 = 15 at t=120ms. The time limit is never reached. # Example 4 Input: fn = async () =&gt; { throw &quot;Error&quot;; } inputs = [] t = 1000 Output: {&quot;rejected&quot;:&quot;Error&quot;,&quot;time&quot;:0} Explanation: The function immediately throws an error. # 解題思路 Promise.race([arr]); : race 中的陣列哪一個 Function 先跑完，return 該 Function。 # Solution /** * @param &#123;Function&#125; fn * @param &#123;number&#125; t * @return &#123;Function&#125; */var timeLimit = function(fn, t) &#123; return async function(...args) &#123; const timeout = new Promise((resolved, reject) => &#123; setTimeout(() => reject(\"Time Limit Exceeded\"), t); &#125;); return Promise.race([fn(...args), timeout]); &#125;&#125;;/** * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100); * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms */ type Fn = (...params: any[]) => Promise&lt;any>;function timeLimit(fn: Fn, t: number): Fn &#123; return async function(...args) &#123; const timeout: Promise&lt;any> = new Promise((resolved: any, reject: any) => &#123; setTimeout(() => reject(\"Time Limit Exceeded\"), t); &#125;); return Promise.race([fn(...args), timeout]); &#125;&#125;;/** * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100); * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"24. Swap Nodes in Pairs","slug":"coding/leetcode/Medium/24-Swap-Nodes-in-Pairs","date":"2023-05-16T06:38:14.000Z","updated":"2023-05-28T17:13:19.789Z","comments":true,"path":"coding/leetcode/Medium/24-Swap-Nodes-in-Pairs/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/24-Swap-Nodes-in-Pairs/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.) # Example 1 Input: head = [1,2,3,4] Output: [2,1,4,3] # Example 2 Input: head = [] Output: [] # Example 3 Input: head = [1] Output: [1] # 解題思路 # Solution // Definition for singly-linked list.public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode ans = new ListNode(0); ans.next = head; ListNode curr = ans; while (curr.next != null &amp;&amp; curr.next.next != null) &#123; ListNode first = curr.next; ListNode second = curr.next.next; curr.next = second; first.next = second.next; second.next = first; curr = curr.next.next; &#125; return ans.next; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Linked List","slug":"Linked-List","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Linked-List/"},{"name":"Recursion","slug":"Recursion","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Recursion/"}]},{"title":"2621. Sleep","slug":"coding/leetcode/Easy/2621-Sleep","date":"2023-05-15T02:35:00.000Z","updated":"2023-05-28T17:11:46.917Z","comments":true,"path":"coding/leetcode/Easy/2621-Sleep/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2621-Sleep/","excerpt":"","text":"⭐️ # 題目敘述 Given a positive integer millis , write an asyncronous function that sleeps for millis milliseconds. It can resolve any value. # Example 1 Input: millis = 100 Output: 100 Explanation: It should return a promise that resolves after 100ms. let t = Date.now(); sleep(100).then(() =&gt; { console.log(Date.now() - t); // 100 }); # Example 2 Input: millis = 200 Output: 200 Explanation: It should return a promise that resolves after 200ms. # 解題思路 # Solution /** * @param &#123;number&#125; millis */async function sleep(millis) &#123; return new Promise(function(val)&#123; return setTimeout(val, millis); &#125;);&#125;/** * let t = Date.now() * sleep(100).then(() => console.log(Date.now() - t)) // 100 */ async function sleep(millis: number): Promise&lt;void> &#123; return new Promise(function(val: any): any&#123; return setTimeout(val, millis); &#125;);&#125;/** * let t = Date.now() * sleep(100).then(() => console.log(Date.now() - t)) // 100 */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"1721. Swapping Nodes in a Linked List","slug":"coding/leetcode/Medium/1721-Swapping-Nodes-in-a-Linked-List","date":"2023-05-15T01:48:06.000Z","updated":"2023-05-28T17:14:24.520Z","comments":true,"path":"coding/leetcode/Medium/1721-Swapping-Nodes-in-a-Linked-List/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1721-Swapping-Nodes-in-a-Linked-List/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given the head of a linked list, and an integer k . Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed). # Example 1 Input: head = [1,2,3,4,5], k = 2 Output: [1,4,3,2,5] # Example 2 Input: head = [7,9,6,6,7,8,3,0,9,5], k = 5 Output: [7,9,6,6,8,7,3,0,9,5] # 解題思路 # Solution // Definition for singly-linked list.public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; class Solution &#123; public ListNode swapNodes(ListNode head, int k) &#123; ListNode start = head, end = head; for (int i = 1; i &lt; k; i++) &#123; start = start.next; &#125; ListNode curr = start; while (curr.next != null) &#123; curr = curr.next; end = end.next; &#125; int temp = start.val; start.val = end.val; end.val = temp; return head; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Linked-List/"}]},{"title":"2666. Allow One Function Call","slug":"coding/leetcode/Easy/2666-Allow-One-Function-Call","date":"2023-05-12T03:26:20.000Z","updated":"2023-05-28T17:12:13.981Z","comments":true,"path":"coding/leetcode/Easy/2666-Allow-One-Function-Call/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2666-Allow-One-Function-Call/","excerpt":"","text":"⭐️ # 題目敘述 Given a function fn , return a new function that is identical to the original function except that it ensures fn is called at most once. The first time the returned function is called, it should return the same result as fn . Every subsequent time it is called, it should return undefined . # Example 1 Input: fn = (a,b,c) =&gt; (a + b + c), calls = [[1,2,3],[2,3,6]] Output: [{&quot;calls&quot;:1,&quot;value&quot;:6}] Explanation: const onceFn = once(fn); onceFn(1, 2, 3); // 6 onceFn(2, 3, 6); // undefined, fn was not called # Example 2 Input: fn = (a,b,c) =&gt; (a * b * c), calls = [[5,7,4],[2,3,6],[4,6,8]] Output: [{&quot;calls&quot;:1,&quot;value&quot;:140}] Explanation: const onceFn = once(fn); onceFn(5, 7, 4); // 140 onceFn(2, 3, 6); // undefined, fn was not called onceFn(4, 6, 8); // undefined, fn was not called # 解題思路 # Solution /** * @param &#123;Function&#125; fn * @return &#123;Function&#125; */var once = function(fn) &#123; let isCall = false; return function(...args)&#123; if(!isCall)&#123; isCall = true; return fn(...args); &#125; &#125;&#125;;/** * let fn = (a,b,c) => (a + b + c) * let onceFn = once(fn) * * onceFn(1,2,3); // 6 * onceFn(2,3,6); // returns undefined without calling fn */ function once&lt;T extends (...args: any[]) => any>(fn: T): ((...args: Parameters&lt;T>) => ReturnType&lt;T> | undefined) &#123; let isCall: Boolean = false; return function (...args) &#123; if(!isCall)&#123; isCall = true; return fn(...args); &#125; &#125;;&#125;/** * let fn = (a,b,c) => (a + b + c) * let onceFn = once(fn) * * onceFn(1,2,3); // 6 * onceFn(2,3,6); // returns undefined without calling fn */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"2140. Solving Questions With Brainpower","slug":"coding/leetcode/Medium/2140-Solving-Questions-With-Brainpower","date":"2023-05-12T02:48:50.000Z","updated":"2023-05-28T17:14:30.477Z","comments":true,"path":"coding/leetcode/Medium/2140-Solving-Questions-With-Brainpower/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2140-Solving-Questions-With-Brainpower/","excerpt":"","text":"⭐️ # 題目敘述 You are given a 0-indexed 2D integer array questions where questions[i] = [pointsi, brainpoweri] . The array describes the questions of an exam, where you have to process the questions in order (i.e., starting from question 0 ) and make a decision whether to solve or skip each question. Solving question i will earn you pointsi points but you will be unable to solve each of the next brainpoweri questions. If you skip question i , you get to make the decision on the next question. For example, given questions = [[3, 2], [4, 3], [4, 4], [2, 5]] : If question 0 is solved, you will earn 3 points but you will be unable to solve questions 1 and 2 . If instead, question 0 is skipped and question 1 is solved, you will earn 4 points but you will be unable to solve questions 2 and 3 . Return the maximum points you can earn for the exam. # Example 1: Input: questions = [[3,2],[4,3],[4,4],[2,5]] Output: 5 Explanation: The maximum points can be earned by solving questions 0 and 3. Solve question 0: Earn 3 points, will be unable to solve the next 2 questions Unable to solve questions 1 and 2 Solve question 3: Earn 2 points Total points earned: 3 + 2 = 5. There is no other way to earn 5 or more points. # Example 2: Input: questions = [[1,1],[2,2],[3,3],[4,4],[5,5]] Output: 7 Explanation: The maximum points can be earned by solving questions 1 and 4. Skip question 0 Solve question 1: Earn 2 points, will be unable to solve the next 2 questions Unable to solve questions 2 and 3 Solve question 4: Earn 5 points Total points earned: 2 + 5 = 7. There is no other way to earn 7 or more points. # 解題思路 # Solution class Solution &#123; public long mostPoints(int[][] questions) &#123; int n = questions.length; long[] dp = new long[n]; dp[n - 1] = questions[n - 1][0]; for (int i = n - 2; i >= 0; --i) &#123; dp[i] = questions[i][0]; int skip = questions[i][1]; if (i + skip + 1 &lt; n) &#123; dp[i] += dp[i + skip + 1]; &#125; // dp[i] = max(solve it, skip it) dp[i] = Math.max(dp[i], dp[i + 1]); &#125; return dp[0]; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"}]},{"title":"2629. Function Composition","slug":"coding/leetcode/Easy/2629-Function-Composition","date":"2023-05-11T01:58:09.000Z","updated":"2023-05-28T17:11:53.699Z","comments":true,"path":"coding/leetcode/Easy/2629-Function-Composition/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2629-Function-Composition/","excerpt":"","text":"⭐️ # 題目敘述 Given an array of functions [f1, f2, f3, ..., fn] , return a new function fn that is the function composition of the array of functions. The function composition of [f(x), g(x), h(x)] is fn(x) = f(g(h(x))) . The function composition of an empty list of functions is the identity function f(x) = x . You may assume each function in the array accepts one integer as input and returns one integer as output. # Example 1 Input: functions = [x =&gt; x + 1, x =&gt; x * x, x =&gt; 2 * x], x = 4 Output: 65 Explanation: Evaluating from right to left ... Starting with x = 4. 2 * (4) = 8 (8) * (8) = 64 (64) + 1 = 65 # Example 2 Input: functions = [x =&gt; 10 * x, x =&gt; 10 * x, x =&gt; 10 * x], x = 1 Output: 1000 Explanation: Evaluating from right to left ... 10 * (1) = 10 10 * (10) = 100 10 * (100) = 1000 # Example 3 Input: functions = [], x = 42 Output: 42 Explanation: The composition of zero functions is the identity function # 解題思路 # Solution /** * @param &#123;Function[]&#125; functions * @return &#123;Function&#125; */var compose = function(functions) &#123; return function(x) &#123; functions.reverse().foreach(fn => &#123; x = fn(x) &#125;); return x; &#125;&#125;;/** * const fn = compose([x => x + 1, x => 2 * x]) * fn(4) // 9 */ type F = (x: number) => number;function compose(functions: F[]): F &#123; return function(x): number &#123; functions.reverse().forEach((fn: F) => &#123; x = fn(x); &#125;); return x; &#125;&#125;;/** * const fn = compose([x => x + 1, x => 2 * x]) * fn(4) // 9 */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"1035. Uncrossed Lines","slug":"coding/leetcode/Medium/1035-Uncrossed-Lines","date":"2023-05-11T01:31:10.000Z","updated":"2023-05-28T17:14:03.411Z","comments":true,"path":"coding/leetcode/Medium/1035-Uncrossed-Lines/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1035-Uncrossed-Lines/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given two integer arrays nums1 and nums2 . We write the integers of nums1 and nums2 (in the order they are given) on two separate horizontal lines. We may draw connecting lines: a straight line connecting two numbers nums1[i] and nums2[j] such that: nums1[i] == nums2[j] , and the line we draw does not intersect any other connecting (non-horizontal) line. Note that a connecting line cannot intersect even at the endpoints (i.e., each number can only belong to one connecting line). Return the maximum number of connecting lines we can draw in this way. # Example 1: ![](https://hackmd.io/_uploads/rkIjNpKN3.png =400x) Input: nums1 = [1,4,2], nums2 = [1,2,4] Output: 2 Explanation: We can draw 2 uncrossed lines as in the diagram. We cannot draw 3 uncrossed lines, because the line from nums1[1] = 4 to nums2[2] = 4 will intersect the line from nums1[2]=2 to nums2[1]=2. # Example 2: Input: nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2] Output: 3 # Example 3: Input: nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1] Output: 2 # 解題思路 # Solution class Solution &#123; public int maxUncrossedLines(int[] nums1, int[] nums2) &#123; int n = nums1.length, m = nums2.length; int[][] dp = new int[n + 1][m + 1]; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; dp[i][j] = (nums1[i - 1] == nums2[j - 1] ? 1 + dp[i - 1][j - 1] : Math.max(dp[i][j - 1], dp[i - 1][j])); &#125; &#125; return dp[n][m]; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"}]},{"title":"2626. Array Reduce Transformation","slug":"coding/leetcode/Easy/2626-Array-Reduce-Transformation","date":"2023-05-10T01:49:13.000Z","updated":"2023-05-28T17:11:50.011Z","comments":true,"path":"coding/leetcode/Easy/2626-Array-Reduce-Transformation/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2626-Array-Reduce-Transformation/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer array nums , a reducer function fn , and an initial value init , return a reduced array. A reduced array is created by applying the following operation: val = fn(init, nums[0]) , val = fn(val, nums[1]) , val = fn(val, nums[2]) , ... until every element in the array has been processed. The final value of val is returned. If the length of the array is 0, it should return init . Please solve it without using the built-in Array.reduce method. # Example 1 Input: nums = [1,2,3,4] fn = function sum(accum, curr) { return accum + curr; } init = 0 Output: 10 Explanation: initially, the value is init=0. (0) + nums[0] = 1 (1) + nums[1] = 3 (3) + nums[2] = 6 (6) + nums[3] = 10 The final answer is 10. # Example 2: Input: nums = [1,2,3,4] fn = function sum(accum, curr) { return accum + curr * curr; } init = 100 Output: 130 Explanation: initially, the value is init=100. (100) + nums[0]^2 = 101 (101) + nums[1]^2 = 105 (105) + nums[2]^2 = 114 (114) + nums[3]^2 = 130 The final answer is 130. # Example 3: Input: nums = [] fn = function sum(accum, curr) { return 0; } init = 25 Output: 25 Explanation: For empty arrays, the answer is always init. # 解題思路 # Solution /** * @param &#123;number[]&#125; nums * @param &#123;Function&#125; fn * @param &#123;number&#125; init * @return &#123;number&#125; */var reduce = function(nums, fn, init) &#123; nums.forEach(function(num)&#123; init = fn(init, num); &#125;); return init;&#125;; type Fn = (accum: number, curr: number) => numberfunction reduce(nums: number[], fn: Fn, init: number): number &#123; nums.forEach(function(num)&#123; init = fn(init, num); &#125;); return init;&#125;; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"59. Spiral Matrix II","slug":"coding/leetcode/Medium/59-Spiral-Matrix-II","date":"2023-05-10T01:32:58.000Z","updated":"2023-05-28T17:13:26.635Z","comments":true,"path":"coding/leetcode/Medium/59-Spiral-Matrix-II/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/59-Spiral-Matrix-II/","excerpt":"","text":"⭐️ # 題目敘述 Given a positive integer n , generate an n x n matrix filled with elements from 1 to n^2 in spiral order. # Example 1: Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]] # Example 2: Input: n = 1 Output: [[1]] # 解題思路 # Solution class Solution &#123; public int[][] generateMatrix(int n) &#123; int[][] ans = new int[n][n]; int count = 1; int left = 0, right = n - 1, top = 0, bottom = n - 1; while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123; for (int i = left; i &lt;= right; i++) &#123; ans[top][i] = count++; &#125; top++; for (int i = top; i &lt;= bottom; i++) &#123; ans[i][right] = count++; &#125; right--; if (top &lt;= bottom) &#123; for (int i = right; i >= left; i--) &#123; ans[bottom][i] = count++; &#125; bottom--; &#125; if (left &lt;= right) &#123; for (int i = bottom; i >= top; i--) &#123; ans[i][left] = count++; &#125; left++; &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"}]},{"title":"2634. Filter Elements from Array","slug":"coding/leetcode/Easy/2634-Filter-Elements-from-Array","date":"2023-05-09T05:25:29.000Z","updated":"2023-05-28T17:11:57.691Z","comments":true,"path":"coding/leetcode/Easy/2634-Filter-Elements-from-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2634-Filter-Elements-from-Array/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer array arr and a filtering function fn , return a new array with a fewer or equal number of elements. The returned array should only contain elements where fn(arr[i], i) evaluated to a truthy value. Please solve it without the built-in Array.filter method. # Example 1: Input: arr = [0,10,20,30], fn = function greaterThan10(n) { return n &gt; 10; } Output: [20,30] Explanation: const newArray = filter(arr, fn); // [20, 30] The function filters out values that are not greater than 10 # Example 2: Input: arr = [1,2,3], fn = function firstIndex(n, i) { return i === 0; } Output: [1] Explanation: fn can also accept the index of each element In this case, the function removes elements not at index 0 # Example 3: Input: arr = [-2,-1,0,1,2], fn = function plusOne(n) { return n + 1 } Output: [-2,0,1,2] Explanation: Falsey values such as 0 should be filtered out # 解題思路 # Solution /** * @param &#123;number[]&#125; arr * @param &#123;Function&#125; fn * @return &#123;number[]&#125; */var filter = function(arr, fn) &#123; let ans = []; for (let i=0; i&lt;arr.length; i++) &#123; if (fn(arr[i], i))&#123; ans.push(arr[i]); &#125; &#125; return ans;&#125;; function filter(arr: number[], fn: (n: number, i: number) => any): number[] &#123; const ans: number[] = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (fn(arr[i], i))&#123; ans.push(arr[i]); &#125; &#125; return ans;&#125;; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"54. Spiral Matrix","slug":"coding/leetcode/Medium/54-Spiral-Matrix","date":"2023-05-09T04:53:03.000Z","updated":"2023-05-28T17:13:23.733Z","comments":true,"path":"coding/leetcode/Medium/54-Spiral-Matrix/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/54-Spiral-Matrix/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given an m x n matrix , return all elements of the matrix in spiral order. # Example 1: Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [1,2,3,6,9,8,7,4,5] # Example 2: Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] Output: [1,2,3,4,8,12,11,10,9,5,6,7] # 解題思路 # Solution import java.util.ArrayList;import java.util.List;class Solution &#123; public List&lt;Integer> spiralOrder(int[][] matrix) &#123; int rows = matrix.length; int cols = matrix[0].length; List&lt;Integer> ans = new ArrayList&lt;>(); if (rows == 0) &#123; return ans; &#125; int left = 0, right = cols - 1, top = 0, bottom = rows - 1; while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123; for (int i = left; i &lt;= right; i++) &#123; ans.add(matrix[top][i]); &#125; top++; for (int i = top; i &lt;= bottom; i++) &#123; ans.add(matrix[i][right]); &#125; right--; if (top &lt;= bottom) &#123; for (int i = right; i >= left; i--) &#123; ans.add(matrix[bottom][i]); &#125; bottom--; &#125; if (left &lt;= right) &#123; for (int i = bottom; i >= top; i--) &#123; ans.add(matrix[i][left]); &#125; left++; &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"}]},{"title":"2635. Apply Transform Over Each Element in Array","slug":"coding/leetcode/Easy/2635-Apply-Transform-Over-Each-Element-in-Array","date":"2023-05-08T02:04:46.000Z","updated":"2023-05-28T17:12:01.500Z","comments":true,"path":"coding/leetcode/Easy/2635-Apply-Transform-Over-Each-Element-in-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2635-Apply-Transform-Over-Each-Element-in-Array/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer array arr and a mapping function fn , return a new array with a transformation applied to each element. The returned array should be created such that returnedArray[i] = fn(arr[i], i) . Please solve it without the built-in Array.map method. # Example 1: Input: arr = [1,2,3], fn = function plusone(n) { return n + 1; } Output: [2,3,4] Explanation: const newArray = map(arr, plusone); // [2,3,4] The function increases each value in the array by one. # Example 2: Input: arr = [1,2,3], fn = function plusI(n, i) { return n + i; } Output: [1,3,5] Explanation: The function increases each value by the index it resides in. # Example 3: Input: arr = [10,20,30], fn = function constant() { return 42; } Output: [42,42,42] Explanation: The function always returns 42. # 解題思路 # Solution /** * @param &#123;number[]&#125; arr * @param &#123;Function&#125; fn * @return &#123;number[]&#125; */var map = function(arr, fn) &#123; return arr.map((val, index) => val = fn(val, index));&#125;; function map(arr: number[], fn: (n: number, i: number) => number): number[] &#123; return arr.map((val: number, idx: number) => val = fn(val, idx));&#125;; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"1572. Matrix Diagonal Sum","slug":"coding/leetcode/Easy/1572-Matrix-Diagonal-Sum","date":"2023-05-08T01:28:16.000Z","updated":"2023-05-28T17:11:33.541Z","comments":true,"path":"coding/leetcode/Easy/1572-Matrix-Diagonal-Sum/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1572-Matrix-Diagonal-Sum/","excerpt":"","text":"⭐️⭐️ # 題目敘述 Given a square matrix mat , return the sum of the matrix diagonals. Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal. # Example 1: Input: mat = [[1,2,3], [4,5,6], [7,8,9]] Output: 25 Explanation: Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25 Notice that element mat[1][1] = 5 is counted only once. # Example 2: Input: mat = [[1,1,1,1], [1,1,1,1], [1,1,1,1], [1,1,1,1]] Output: 8 # Example 3: Input: mat = [[5]] Output: 5 # 解題思路 # Solution class Solution &#123; public int diagonalSum(int[][] mat) &#123; int m = mat.length - 1; int ans = 0; for(int i = 0; i &lt;= m; i++)&#123; ans += mat[i][i]; ans += mat[i][m - i]; &#125; if(m % 2 == 0)&#123; ans -= mat[m / 2][m / 2]; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"}]},{"title":"2665. Counter II","slug":"coding/leetcode/Easy/2665-Counter-II","date":"2023-05-07T12:04:22.000Z","updated":"2023-05-28T17:12:09.382Z","comments":true,"path":"coding/leetcode/Easy/2665-Counter-II/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2665-Counter-II/","excerpt":"","text":"⭐️ # 題目敘述 Write a function createCounter . It should accept an initial integer init . It should return an object with three functions. The three functions are: increment() increases the current value by 1 and then returns it. decrement() reduces the current value by 1 and then returns it. reset() sets the current value to init and then returns it. # Example 1: Input: init = 5, calls = [&quot;increment&quot;,&quot;reset&quot;,&quot;decrement&quot;] Output: [6,5,4] Explanation: const counter = createCounter(5); counter.increment(); // 6 counter.reset(); // 5 counter.decrement(); // 4 # Example 2: Input: init = 0, calls = [&quot;increment&quot;,&quot;increment&quot;,&quot;decrement&quot;,&quot;reset&quot;,&quot;reset&quot;] Output: [1,2,1,0,0] Explanation: const counter = createCounter(0); counter.increment(); // 1 counter.increment(); // 2 counter.decrement(); // 1 counter.reset(); // 0 counter.reset(); // 0 # 解題思路 # Solution /** * @param &#123;integer&#125; init * @return &#123; increment: Function, decrement: Function, reset: Function &#125; */var createCounter = function(init) &#123; let counter = init; const increment = () => counter += 1; const decrement = () => counter -= 1; const reset = () => counter = init; return&#123;increment, decrement, reset&#125;;&#125;;/** * const counter = createCounter(5) * counter.increment(); // 6 * counter.reset(); // 5 * counter.decrement(); // 4 */ type ReturnObj = &#123; increment: () => number, decrement: () => number, reset: () => number,&#125;function createCounter(init: number): ReturnObj &#123; let counter: number = init; const increment = (): number => counter += 1; const decrement = (): number => counter -= 1; const reset = (): number => counter = init; return &#123;increment, decrement, reset&#125;;&#125;;/** * const counter = createCounter(5) * counter.increment(); // 6 * counter.reset(); // 5 * counter.decrement(); // 4 */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"1964. Find the Longest Valid Obstacle Course at Each Position","slug":"coding/leetcode/Hard/1964-Find-the-Longest-Valid-Obstacle-Course-at-Each-Position","date":"2023-05-07T08:40:52.000Z","updated":"2023-05-28T17:13:04.635Z","comments":true,"path":"coding/leetcode/Hard/1964-Find-the-Longest-Valid-Obstacle-Course-at-Each-Position/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/1964-Find-the-Longest-Valid-Obstacle-Course-at-Each-Position/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 You want to build some obstacle courses. You are given a 0-indexed integer array obstacles of length n , where obstacles[i] describes the height of the ith obstacle. For every index i between 0 and n - 1 (inclusive), find the length of the longest obstacle course in obstacles such that: You choose any number of obstacles between 0 and i inclusive. You must include the ith obstacle in the course. You must put the chosen obstacles in the same order as they appear in obstacles . Every obstacle (except the first) is taller than or the same height as the obstacle immediately before it. Return an array ans of length n , where ans[i] is the length of the longest obstacle course for index i as described above. # Example 1: Input: obstacles = [1,2,3,2] Output: [1,2,3,3] Explanation: The longest valid obstacle course at each position is: i = 0: [1], [1] has length 1. i = 1: [1,2], [1,2] has length 2. i = 2: [1,2,3], [1,2,3] has length 3. i = 3: [1,2,3,2], [1,2,2] has length 3. # Example 2: Input: obstacles = [2,2,1] Output: [1,2,1] Explanation: The longest valid obstacle course at each position is: i = 0: [2], [2] has length 1. i = 1: [2,2], [2,2] has length 2. i = 2: [2,2,1], [1] has length 1. # Example 3: Input: obstacles = [3,1,5,6,4,2] Output: [1,1,2,3,2,2] Explanation: The longest valid obstacle course at each position is: i = 0: [3], [3] has length 1. i = 1: [3,1], [1] has length 1. i = 2: [3,1,5], [3,5] has length 2. [1,5] is also valid. i = 3: [3,1,5,6], [3,5,6] has length 3. [1,5,6] is also valid. i = 4: [3,1,5,6,4], [3,4] has length 2. [1,4] is also valid. i = 5: [3,1,5,6,4,2], [1,2] has length 2. # 解題思路 # Solution class Solution &#123; public int[] longestObstacleCourseAtEachPosition(int[] obstacles) &#123; int n = obstacles.length; int length = 0; int[] result = new int[n]; int[] sub = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; int left = 0, right = length; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (sub[mid] &lt;= obstacles[i]) left = mid + 1; else right = mid; &#125; result[i] = left + 1; if (length == left) length++; sub[left] = obstacles[i]; &#125; return result; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Binary Indexed Tree","slug":"Binary-Indexed-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Indexed-Tree/"}]},{"title":"1498. Number of Subsequences That Satisfy the Given Sum Condition","slug":"coding/leetcode/Medium/1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition","date":"2023-05-06T05:21:16.000Z","updated":"2023-05-28T17:14:16.976Z","comments":true,"path":"coding/leetcode/Medium/1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an array of integers nums and an integer target . Return the number of non-empty subsequences of nums such that the sum of the minimum and maximum element on it is less or equal to target . Since the answer may be too large, return it modulo 10^9 + 7 . # Example 1: Input: nums = [3,5,6,7], target = 9 Output: 4 Explanation: There are 4 subsequences that satisfy the condition. [3] -&gt; Min value + max value &lt;= target (3 + 3 &lt;= 9) [3,5] -&gt; (3 + 5 &lt;= 9) [3,5,6] -&gt; (3 + 6 &lt;= 9) [3,6] -&gt; (3 + 6 &lt;= 9) # Example 2: Input: nums = [3,3,6,8], target = 10 Output: 6 Explanation: There are 6 subsequences that satisfy the condition. (nums can have repeated numbers). [3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6] # Example 3: Input: nums = [2,3,3,4,6,7], target = 12 Output: 61 Explanation: There are 63 non-empty subsequences, two of them do not satisfy the condition ([6,7], [7]). Number of valid subsequences (63 - 2 = 61). # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public int numSubseq(int[] nums, int target) &#123; int n = nums.length; int mod = 1000000007; int ans = 0; Arrays.sort(nums); int[] count = new int[n]; count[0] = 1; for (int i = 1; i &lt; n; i++) &#123; count[i] = (count[i - 1] * 2) % mod; &#125; int left = 0, right = n - 1; while (left &lt;= right) &#123; if (nums[left] + nums[right] &lt;= target) &#123; ans = (ans + count[right - left]) % mod; left++; &#125; else &#123; right--; &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"}]},{"title":"2620. Counter","slug":"coding/leetcode/Easy/2620-Counter","date":"2023-05-06T03:23:28.000Z","updated":"2023-05-28T17:11:43.153Z","comments":true,"path":"coding/leetcode/Easy/2620-Counter/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2620-Counter/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer n , return a counter function. This counter function initially returns n and then returns 1 more than the previous value every subsequent time it is called ( n , n + 1 , n + 2 , etc). # Example 1: Input: n = 10 [&quot;call&quot;,&quot;call&quot;,&quot;call&quot;] Output: [10,11,12] Explanation: counter() = 10 // The first time counter() is called, it returns n. counter() = 11 // Returns 1 more than the previous time. counter() = 12 // Returns 1 more than the previous time. # Example 2: Input: n = -2 [&quot;call&quot;,&quot;call&quot;,&quot;call&quot;,&quot;call&quot;,&quot;call&quot;] Output: [-2,-1,0,1,2] Explanation: counter() initially returns -2. Then increases after each sebsequent call. # 解題思路 # Solution /** * @param &#123;number&#125; n * @return &#123;Function&#125; counter */var createCounter = function(n) &#123; let counter = n - 1; return function() &#123; counter += 1; return counter; &#125;;&#125;;/** * const counter = createCounter(10) * counter() // 10 * counter() // 11 * counter() // 12 */ function createCounter(n: number): () => number &#123; let counter = n - 1; return function() &#123; counter += 1; return counter; &#125;&#125;/** * const counter = createCounter(10) * counter() // 10 * counter() // 11 * counter() // 12 */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"1456. Maximum Number of Vowels in a Substring of Given Length","slug":"coding/leetcode/Medium/1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length","date":"2023-05-05T02:32:53.000Z","updated":"2023-05-28T17:14:14.097Z","comments":true,"path":"coding/leetcode/Medium/1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length/","excerpt":"","text":"⭐️⭐️ # 題目敘述 Given a string s and an integer k , return the maximum number of vowel letters in any substring of s with length k . Vowel letters in English are 'a' , 'e' , 'i' , 'o' , and 'u' . # Example 1: Input: s = &quot;abciiidef&quot;, k = 3 Output: 3 Explanation: The substring &quot;iii&quot; contains 3 vowel letters. # Example 2: Input: s = &quot;aeiou&quot;, k = 2 Output: 2 Explanation: Any substring of length 2 contains 2 vowels. # Example 3: Input: s = &quot;leetcode&quot;, k = 3 Output: 2 Explanation: &quot;lee&quot;, &quot;eet&quot; and &quot;ode&quot; contain 2 vowels. # 解題思路 # Solution class Solution &#123; public int maxVowels(String s, int k) &#123; int ans = 0; String temp = s.substring(0, k); for (char t : temp.toCharArray()) &#123; if (isVowel(t))&#123; ans++; &#125; &#125; int cur = ans; for (int i = k; i &lt; s.length(); i++) &#123; if (isVowel(s.charAt(i))) cur++; if (isVowel(s.charAt(i - k))) cur--; ans = Math.max(ans, cur); &#125; return ans; &#125; public boolean isVowel(char c) &#123; if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') return true; return false; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"}]},{"title":"2667. Create Hello World Function","slug":"coding/leetcode/Easy/2667-Create-Hello-World-Function","date":"2023-05-05T01:26:51.000Z","updated":"2023-05-28T17:12:17.463Z","comments":true,"path":"coding/leetcode/Easy/2667-Create-Hello-World-Function/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2667-Create-Hello-World-Function/","excerpt":"","text":"⭐️ # 題目敘述 Write a function createHelloWorld . It should return a new function that always returns &quot;Hello World&quot; . # Example 1: Input: args = [] Output: &quot;Hello World&quot; Explanation: const f = createHelloWorld(); f(); // &quot;Hello World&quot; The function returned by createHelloWorld should always return &quot;Hello World&quot;. # Example 2: Input: args = [{},null,42] Output: &quot;Hello World&quot; Explanation: const f = createHelloWorld(); f({}, null, 42); // &quot;Hello World&quot; Any arguments could be passed to the function but it should still always return &quot;Hello World&quot;. # 解題思路 # Solution /** * @return &#123;Function&#125; */var createHelloWorld = function() &#123; return function(...args) &#123; return \"Hello World\"; &#125;&#125;;/** * const f = createHelloWorld(); * f(); // \"Hello World\" */ function createHelloWorld() &#123; return function(...args): string &#123; return \"Hello World\"; &#125;;&#125;;/** * const f = createHelloWorld(); * f(); // \"Hello World\" */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"649. Dota2 Senate","slug":"coding/leetcode/Medium/649-Dota2-Senate","date":"2023-05-04T01:30:30.000Z","updated":"2023-05-28T17:13:43.680Z","comments":true,"path":"coding/leetcode/Medium/649-Dota2-Senate/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/649-Dota2-Senate/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 In the world of Dota2, there are two parties: the Radiant and the Dire. The Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights: Ban one senator's right: A senator can make another senator lose all his rights in this and all the following rounds. Announce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game. Given a string senate representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party. Then if there are n senators, the size of the given string will be n . The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure. Suppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be &quot;Radiant&quot; or &quot;Dire&quot; . # Example 1: Input: senate = &quot;RD&quot; Output: &quot;Radiant&quot; Explanation: The first senator comes from Radiant and he can just ban the next senator's right in round 1. And the second senator can't exercise any rights anymore since his right has been banned. And in round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote. # Example 2: Input: senate = &quot;RDD&quot; Output: &quot;Dire&quot; Explanation: The first senator comes from Radiant and he can just ban the next senator's right in round 1. And the second senator can't exercise any rights anymore since his right has been banned. And the third senator comes from Dire and he can ban the first senator's right in round 1. And in round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote. # 解題思路 # Solution import java.util.LinkedList;import java.util.Queue;class Solution &#123; public String predictPartyVictory(String senate) &#123; int n = senate.length(); Queue&lt;Integer> rQueue = new LinkedList&lt;>(); Queue&lt;Integer> dQueue = new LinkedList&lt;>(); for (int i = 0; i &lt; n; i++) &#123; if (senate.charAt(i) == 'R') &#123; rQueue.add(i); &#125; else &#123; dQueue.add(i); &#125; &#125; while (!rQueue.isEmpty() &amp;&amp; !dQueue.isEmpty()) &#123; int rTurn = rQueue.poll(); int dTurn = dQueue.poll(); if (dTurn &lt; rTurn) &#123; dQueue.add(dTurn + n); &#125; else &#123; rQueue.add(rTurn + n); &#125; &#125; return rQueue.isEmpty() ? \"Dire\" : \"Radiant\"; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Queue","slug":"Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Queue/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"}]},{"title":"2215. Find the Difference of Two Arrays","slug":"coding/leetcode/Easy/2215-Find-the-Difference-of-Two-Arrays","date":"2023-05-03T01:24:55.000Z","updated":"2023-05-28T17:11:40.373Z","comments":true,"path":"coding/leetcode/Easy/2215-Find-the-Difference-of-Two-Arrays/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2215-Find-the-Difference-of-Two-Arrays/","excerpt":"","text":"⭐️ # 題目敘述 Given two 0-indexed integer arrays nums1 and nums2 , return a list answer of size 2 where: answer[0] is a list of all distinct integers in nums1 which are not present in nums2 . answer[1] is a list of all distinct integers in nums2 which are not present in nums1 . Note that the integers in the lists may be returned in any order. # Example 1: Input: nums1 = [1,2,3], nums2 = [2,4,6] Output: [[1,3],[4,6]] Explanation: For nums1, nums1[1] = 2 is present at index 0 of nums2, whereas nums1[0] = 1 and nums1[2] = 3 are not present in nums2. Therefore, answer[0] = [1,3]. For nums2, nums2[0] = 2 is present at index 1 of nums1, whereas nums2[1] = 4 and nums2[2] = 6 are not present in nums2. Therefore, answer[1] = [4,6]. # Example 2: Input: nums1 = [1,2,3,3], nums2 = [1,1,2,2] Output: [[3],[]] Explanation: For nums1, nums1[2] and nums1[3] are not present in nums2. Since nums1[2] == nums1[3], their value is only included once and answer[0] = [3]. Every integer in nums2 is present in nums1. Therefore, answer[1] = []. # 解題思路 # Solution import java.util.ArrayList;import java.util.List;class Solution &#123; public List&lt;List&lt;Integer>> findDifference(int[] nums1, int[] nums2) &#123; List&lt;List&lt;Integer>> ans = new ArrayList&lt;>(); List&lt;Integer> map1 = new ArrayList&lt;>(), map2 = new ArrayList&lt;>(); for(int n : nums1) map1.add(n); for(int n : nums2) map2.add(n); List&lt;Integer> temp1 = new ArrayList&lt;>(); for(int n : nums1)&#123; if(!map2.contains(n) &amp;&amp; !temp1.contains(n))&#123; temp1.add(n); &#125; &#125; ans.add(temp1); List&lt;Integer> temp2 = new ArrayList&lt;>(); for(int n : nums2)&#123; if(!map1.contains(n) &amp;&amp; !temp2.contains(n))&#123; temp2.add(n); &#125; &#125; ans.add(temp2); return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"}]},{"title":"1822. Sign of the Product of an Array","slug":"coding/leetcode/Easy/1822-Sign-of-the-Product-of-an-Array","date":"2023-05-02T04:00:20.000Z","updated":"2023-05-28T17:11:36.435Z","comments":true,"path":"coding/leetcode/Easy/1822-Sign-of-the-Product-of-an-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1822-Sign-of-the-Product-of-an-Array/","excerpt":"","text":"⭐️ # 題目敘述 There is a function signFunc(x) that returns: 1 if x is positive. -1 if x is negative. 0 if x is equal to 0 . You are given an integer array nums . Let product be the product of all values in the array nums . Return signFunc(product) . # Example 1: Input: nums = [-1,-2,-3,-4,3,2,1] Output: 1 Explanation: The product of all values in the array is 144, and signFunc(144) = 1 # Example 2: Input: nums = [1,5,0,2,-3] Output: 0 Explanation: The product of all values in the array is 0, and signFunc(0) = 0 # Example 3: Input: nums = [-1,1,-1,1,-1] Output: -1 Explanation: The product of all values in the array is -1, and signFunc(-1) = -1 # 解題思路 # Solution class Solution &#123; public int arraySign(int[] nums) &#123; int sign = 1; for(int num : nums)&#123; if(num == 0) return 0; if(num &lt; 0) sign *= -1; &#125; return sign; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"}]},{"title":"1491. Average Salary Excluding the Minimum and Maximum Salary","slug":"coding/leetcode/Easy/1491-Average-Salary-Excluding-the-Minimum-and-Maximum-Salary","date":"2023-05-01T05:46:14.000Z","updated":"2023-05-28T17:11:30.154Z","comments":true,"path":"coding/leetcode/Easy/1491-Average-Salary-Excluding-the-Minimum-and-Maximum-Salary/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1491-Average-Salary-Excluding-the-Minimum-and-Maximum-Salary/","excerpt":"","text":"⭐️ # 題目敘述 You are given an array of unique integers salary where salary[i] is the salary of the ith employee. Return the average salary of employees excluding the minimum and maximum salary. Answers within 10-5 of the actual answer will be accepted. # Example 1: Input: salary = [4000,3000,1000,2000] Output: 2500.00000 Explanation: Minimum salary and maximum salary are 1000 and 4000 respectively. Average salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500 # Example 2: Input: salary = [1000,2000,3000] Output: 2000.00000 Explanation: Minimum salary and maximum salary are 1000 and 3000 respectively. Average salary excluding minimum and maximum salary is (2000) / 1 = 2000 # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public double average(int[] salary) &#123; Arrays.sort(salary); long sum = 0; for(int i = 1; i &lt; salary.length - 1; i++)&#123; sum += salary[i]; &#125; return sum / (salary.length - 2 * 1.0); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"}]},{"title":"1579. Remove Max Number of Edges to Keep Graph Fully Traversable","slug":"coding/leetcode/Hard/1579-Remove-Max-Number-of-Edges-to-Keep-Graph-Fully-Traversable","date":"2023-04-30T03:18:16.000Z","updated":"2023-05-28T17:12:53.476Z","comments":true,"path":"coding/leetcode/Hard/1579-Remove-Max-Number-of-Edges-to-Keep-Graph-Fully-Traversable/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/1579-Remove-Max-Number-of-Edges-to-Keep-Graph-Fully-Traversable/","excerpt":"","text":"⭐️ # 題目敘述 Alice and Bob have an undirected graph of n nodes and three types of edges: Type 1: Can be traversed by Alice only. Type 2: Can be traversed by Bob only. Type 3: Can be traversed by both Alice and Bob. Given an array edges where edges[i] = [typei, ui, vi] represents a bidirectional edge of type typei between nodes ui and vi , find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes. Return the maximum number of edges you can remove, or return -1 if Alice and Bob cannot fully traverse the graph. # Example 1: Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]] Output: 2 Explanation: If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2. # Example 2: Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]] Output: 0 Explanation: Notice that removing any edge will not make the graph fully traversable by Alice and Bob. # Example 3: Input: n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]] Output: -1 Explanation: In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable. # 解題思路 # Solution 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"}]},{"title":"1697. Checking Existence of Edge Length Limited Paths","slug":"coding/leetcode/Hard/1697-Checking-Existence-of-Edge-Length-Limited-Paths","date":"2023-04-29T06:04:59.000Z","updated":"2023-05-28T17:12:56.399Z","comments":true,"path":"coding/leetcode/Hard/1697-Checking-Existence-of-Edge-Length-Limited-Paths/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/1697-Checking-Existence-of-Edge-Length-Limited-Paths/","excerpt":"","text":"⭐️ # 題目敘述 An undirected graph of n nodes is defined by edgeList , where edgeList[i] = [ui, vi, disi] denotes an edge between nodes ui and vi with distance disi . Note that there may be multiple edges between two nodes. Given an array queries , where queries[j] = [pj, qj, limitj] , your task is to determine for each queries[j] whether there is a path between pj and qj such that each edge on the path has a distance strictly less than limitj . Return a boolean array answer , where answer.length == queries.length and the jth value of answer is true if there is a path for queries[j] is true , and false otherwise. # Example 1: Input: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]] Output: [false,true] Explanation: The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16. For the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query. For the second query, there is a path (0 -&gt; 1 -&gt; 2) of two edges with distances less than 5, thus we return true for this query. # Example 2: Input: n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]] Output: [true,false] Exaplanation: The above figure shows the given graph. # 解題思路 # Solution 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"}]},{"title":"839. Similar String Groups","slug":"coding/leetcode/Hard/839-Similar-String-Groups","date":"2023-04-28T01:29:37.000Z","updated":"2023-05-28T17:12:46.778Z","comments":true,"path":"coding/leetcode/Hard/839-Similar-String-Groups/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/839-Similar-String-Groups/","excerpt":"","text":"⭐️ # 題目敘述 Two strings X and Y are similar if we can swap two letters (in different positions) of X , so that it equals Y . Also two strings X and Y are similar if they are equal. For example, &quot;tars&quot; and &quot;rats&quot; are similar (swapping at positions 0 and 2 ), and &quot;rats&quot; and &quot;arts&quot; are similar, but &quot;star&quot; is not similar to &quot;tars&quot; , &quot;rats&quot; , or &quot;arts&quot; . Together, these form two connected groups by similarity: &#123;&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;&#125; and &#123;&quot;star&quot;&#125; . Notice that &quot;tars&quot; and &quot;arts&quot; are in the same group even though they are not similar. Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group. We are given a list strs of strings where every string in strs is an anagram of every other string in strs . How many groups are there? # Example 1: Input: strs = [&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;] Output: 2 # Example 2: Input: strs = [&quot;omv&quot;,&quot;ovm&quot;] Output: 1 # 解題思路 # Solution 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"}]},{"title":"319. Bulb Switcher","slug":"coding/leetcode/Medium/319-Bulb-Switcher","date":"2023-04-27T01:54:17.000Z","updated":"2023-05-28T17:13:35.713Z","comments":true,"path":"coding/leetcode/Medium/319-Bulb-Switcher/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/319-Bulb-Switcher/","excerpt":"","text":"⭐️ # 題目敘述 There are n bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Return the number of bulbs that are on after n rounds. # Example 1: Input: n = 3 Output: 1 Explanation: At first, the three bulbs are [off, off, off]. After the first round, the three bulbs are [on, on, on]. After the second round, the three bulbs are [on, off, on]. After the third round, the three bulbs are [on, off, off]. So you should return 1 because there is only one bulb is on. # Example 2: Input: n = 0 Output: 0 # Example 3: Input: n = 1 Output: 1 # 解題思路 # Solution class Solution &#123; public int bulbSwitch(int n) &#123; return (int)Math.sqrt(n); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"},{"name":"Brainteaser","slug":"Brainteaser","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Brainteaser/"}]},{"title":"258. Add Digits","slug":"coding/leetcode/Easy/258-Add-Digits","date":"2023-04-26T01:27:56.000Z","updated":"2023-05-28T17:11:19.669Z","comments":true,"path":"coding/leetcode/Easy/258-Add-Digits/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/258-Add-Digits/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer num , repeatedly add all its digits until the result has only one digit, and return it. # Example 1: Input: num = 38 Output: 2 Explanation: The process is 38 --&gt; 3 + 8 --&gt; 11 11 --&gt; 1 + 1 --&gt; 2 Since 2 has only one digit, return it. # Example 2: Input: num = 0 Output: 0 # 解題思路 # Solution class Solution &#123; public int addDigits(int num) &#123; while(num >= 10)&#123; String str = Integer.toString(num); num = 0; for(int i = 0; i &lt; str.length(); i++)&#123; num += Integer.parseInt(str.substring(i, i + 1)); &#125; &#125; return num; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Number-Theory/"}]},{"title":"2336. Smallest Number in Infinite Set","slug":"coding/leetcode/Medium/2336-Smallest-Number-in-Infinite-Set","date":"2023-04-25T02:20:39.000Z","updated":"2023-05-28T17:14:33.343Z","comments":true,"path":"coding/leetcode/Medium/2336-Smallest-Number-in-Infinite-Set/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2336-Smallest-Number-in-Infinite-Set/","excerpt":"","text":"⭐️⭐️ # 題目敘述 You have a set which contains all positive integers [1, 2, 3, 4, 5, ...] . Implement the SmallestInfiniteSet class: SmallestInfiniteSet() Initializes the SmallestInfiniteSet object to contain all positive integers. int popSmallest() Removes and returns the smallest integer contained in the infinite set. void addBack(int num) Adds a positive integer num back into the infinite set, if it is not already in the infinite set. # Example 1: Input [&quot;SmallestInfiniteSet&quot;, &quot;addBack&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;, &quot;addBack&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;] [[], [2], [], [], [], [1], [], [], []] Output [null, null, 1, 2, 3, null, 1, 4, 5] Explanation SmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet(); smallestInfiniteSet.addBack(2); // 2 is already in the set, so no change is made. smallestInfiniteSet.popSmallest(); // return 1, since 1 is the smallest number, and remove it from the set. smallestInfiniteSet.popSmallest(); // return 2, and remove it from the set. smallestInfiniteSet.popSmallest(); // return 3, and remove it from the set. smallestInfiniteSet.addBack(1); // 1 is added back to the set. smallestInfiniteSet.popSmallest(); // return 1, since 1 was added back to the set and // is the smallest number, and remove it from the set. smallestInfiniteSet.popSmallest(); // return 4, and remove it from the set. smallestInfiniteSet.popSmallest(); // return 5, and remove it from the set. # 解題思路 # Solution import java.util.PriorityQueue;class SmallestInfiniteSet &#123; PriorityQueue&lt;Integer> pQ; public SmallestInfiniteSet() &#123; pQ = new PriorityQueue&lt;>(); for(int i = 1; i &lt;= 1000; i++)&#123; pQ.add(i); &#125; &#125; public int popSmallest() &#123; int num = pQ.poll(); return num; &#125; public void addBack(int num) &#123; if(!pQ.contains(num))&#123; pQ.add(num); &#125; &#125;&#125;/** * Your SmallestInfiniteSet object will be instantiated and called as such: * SmallestInfiniteSet obj = new SmallestInfiniteSet(); * int param_1 = obj.popSmallest(); * obj.addBack(num); */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Design","slug":"Design","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Design/"}]},{"title":"1046. Last Stone Weight","slug":"coding/leetcode/Easy/1046-Last-Stone-Weight","date":"2023-04-24T02:48:10.000Z","updated":"2023-05-28T17:11:24.051Z","comments":true,"path":"coding/leetcode/Easy/1046-Last-Stone-Weight/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1046-Last-Stone-Weight/","excerpt":"","text":"⭐️ # 題目敘述 You are given an array of integers stones where stones[i] is the weight of the ith stone. We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x &lt;= y . The result of this smash is: If x == y , both stones are destroyed, and If x != y , the stone of weight x is destroyed, and the stone of weight y has new weight y - x . At the end of the game, there is at most one stone left. Return the weight of the last remaining stone. If there are no stones left, return 0 . # Example 1: Input: stones = [2,7,4,1,8,1] Output: 1 Explanation: We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then, we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then, we combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone. # Example 2: Input: stones = [1] Output: 1 # 解題思路 # Solution import java.util.Comparator;import java.util.PriorityQueue;class Solution &#123; public int lastStoneWeight(int[] stones) &#123; if(stones.length == 0) return 0; PriorityQueue&lt;Integer> pQ = new PriorityQueue&lt;>(Comparator.reverseOrder()); for(int s : stones)&#123; pQ.add(s); &#125; while(pQ.size() >= 2)&#123; int first = pQ.poll(); int second = pQ.poll(); pQ.add(first - second); &#125; return pQ.peek(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"}]},{"title":"879. Profitable Schemes","slug":"coding/leetcode/Hard/879-Profitable-Schemes","date":"2023-04-21T01:21:14.000Z","updated":"2023-05-28T17:12:50.593Z","comments":true,"path":"coding/leetcode/Hard/879-Profitable-Schemes/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/879-Profitable-Schemes/","excerpt":"","text":"⭐️ # 題目敘述 There is a group of n members, and a list of various crimes they could commit. The ith crime generates a profit[i] and requires group[i] members to participate in it. If a member participates in one crime, that member can't participate in another crime. Let's call a profitable scheme any subset of these crimes that generates at least minProfit profit, and the total number of members participating in that subset of crimes is at most n . Return the number of schemes that can be chosen. Since the answer may be very large, return it modulo 10^9 + 7 . # Example 1: Input: n = 5, minProfit = 3, group = [2,2], profit = [2,3] Output: 2 Explanation: To make a profit of at least 3, the group could either commit crimes 0 and 1, or just crime 1. In total, there are 2 schemes. # Example 2: Input: n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8] Output: 7 Explanation: To make a profit of at least 5, the group could commit any crimes, as long as they commit one. There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2). # 解題思路 # Solution class Solution &#123; public int mod = (int) 1e9 + 7; public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) &#123; int[][] dp = new int[n + 1][minProfit + 1]; dp[0][0] = 1; for (int k = 1; k &lt;= group.length; k++) &#123; int g = group[k - 1]; int p = profit[k - 1]; for (int i = n; i >= g; i--) &#123; for (int j = minProfit; j >= 0; j--) &#123; dp[i][j] = (dp[i][j] + dp[i - g][Math.max(0, j - p)]) % mod; &#125; &#125; &#125; int sum = 0; for (int i = 0; i &lt;= n; i++) &#123; sum = (sum + dp[i][minProfit]) % mod; &#125; return sum; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"}]},{"title":"662. Maximum Width of Binary Tree","slug":"coding/leetcode/Medium/662-Maximum-Width-of-Binary-Tree","date":"2023-04-20T01:23:38.000Z","updated":"2023-05-28T17:13:46.976Z","comments":true,"path":"coding/leetcode/Medium/662-Maximum-Width-of-Binary-Tree/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/662-Maximum-Width-of-Binary-Tree/","excerpt":"","text":"⭐️⭐️ # 題目敘述 Given the root of a binary tree, return the maximum width of the given tree. The maximum width of a tree is the maximum width among all levels. The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation. It is guaranteed that the answer will in the range of a 32-bit signed integer. # Example 1: Input: root = [1,3,2,5,3,null,9] Output: 4 Explanation: The maximum width exists in the third level with length 4 (5,3,null,9). # Example 2: Input: root = [1,3,2,5,null,null,9,6,null,7] Output: 7 Explanation: The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7). # Example 3: Input: root = [1,3,2,5] Output: 2 Explanation: The maximum width exists in the second level with length 2 (3,2). # 解題思路 # Solution import javafx.util.Pair;import java.util.ArrayDeque;import java.util.Deque;// Definition for a binary tree node.public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode() &#123;&#125; TreeNode(int val) &#123; this.val = val; &#125; TreeNode(int val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125;&#125;class Solution &#123; public int widthOfBinaryTree(TreeNode root) &#123; if(root == null) return 0; int ans = 0; Deque&lt;Pair&lt;TreeNode, Integer>> deque = new ArrayDeque&lt;>(); deque.add(new Pair&lt;>(root, 0)); while(!deque.isEmpty())&#123; int len = deque.size(); int start = deque.peekFirst().getValue(); int end = deque.peekLast().getValue(); ans = Math.max(ans, end - start + 1); for(int i = 0; i &lt; len; i++)&#123; Pair&lt;TreeNode, Integer> node = deque.pop(); TreeNode curr = node.getKey(); int index = node.getValue(); if(curr.left != null) deque.add(new Pair&lt;>(curr.left, 2 * index)); if(curr.right != null) deque.add(new Pair&lt;>(curr.right, 2 * index + 1)); &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Tree","slug":"Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Tree/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Tree/"}]},{"title":"1372. Longest ZigZag Path in a Binary Tree","slug":"coding/leetcode/Medium/1372-Longest-ZigZag-Path-in-a-Binary-Tree","date":"2023-04-19T01:58:24.000Z","updated":"2023-05-28T17:14:11.429Z","comments":true,"path":"coding/leetcode/Medium/1372-Longest-ZigZag-Path-in-a-Binary-Tree/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1372-Longest-ZigZag-Path-in-a-Binary-Tree/","excerpt":"","text":"⭐️⭐️ # 題目敘述 You are given the root of a binary tree. A ZigZag path for a binary tree is defined as follow: Choose any node in the binary tree and a direction (right or left). If the current direction is right, move to the right child of the current node; otherwise, move to the left child. Change the direction from right to left or from left to right. Repeat the second and third steps until you can't move in the tree. Zigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0). Return the longest ZigZag path contained in that tree. # Example 1 Input: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1] Output: 3 Explanation: Longest ZigZag path in blue nodes (right -&gt; left -&gt; right). # Example 2 Input: root = [1,1,1,null,1,null,null,1,1,null,1] Output: 4 Explanation: Longest ZigZag path in blue nodes (left -&gt; right -&gt; left -&gt; right). # Example 3: Input: root = [1] Output: 0 # 解題思路 # Solution class Solution &#123; int ans = 0; public int longestZigZag(TreeNode root) &#123; dfs(root, false, 0); dfs(root, true, 0); return ans; &#125; public void dfs(TreeNode node, boolean goLeft, int steps) &#123; if (node == null) &#123; return ; &#125; ans = Math.max(ans, steps); if (goLeft) &#123; dfs(node.left, false, steps + 1); dfs(node.right, true, 1); &#125; else &#123; dfs(node.left, false, 1); dfs(node.right, true, steps + 1); &#125; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Tree","slug":"Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Tree/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Tree/"}]},{"title":"1431. Kids With the Greatest Number of Candies","slug":"coding/leetcode/Easy/1431-Kids-With-the-Greatest-Number-of-Candies","date":"2023-04-17T01:49:25.000Z","updated":"2023-05-28T17:11:27.510Z","comments":true,"path":"coding/leetcode/Easy/1431-Kids-With-the-Greatest-Number-of-Candies/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1431-Kids-With-the-Greatest-Number-of-Candies/","excerpt":"","text":"⭐️ # 題目敘述 There are n kids with candies. You are given an integer array candies , where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies , denoting the number of extra candies that you have. Return a boolean array result of length n , where result[i] is true if, after giving the ith kid all the extraCandies , they will have the greatest number of candies among all the kids, or false otherwise. Note that multiple kids can have the greatest number of candies. # Example 1: Input: candies = [2,3,5,1,3], extraCandies = 3 Output: [true,true,true,false,true] Explanation: If you give all extraCandies to: Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids. Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids. Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids. Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids. Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids. # Example 2: Input: candies = [4,2,1,1,2], extraCandies = 1 Output: [true,false,false,false,false] Explanation: There is only 1 extra candy. Kid 1 will always have the greatest number of candies, even if a different kid is given the extra candy. # Example 3: Input: candies = [12,1,12], extraCandies = 10 Output: [true,false,true] # 解題思路 # Solution import java.util.ArrayList;import java.util.List;class Solution &#123; public List&lt;Boolean> kidsWithCandies(int[] candies, int extraCandies) &#123; int max = 0; for(int candy : candies)&#123; max = Math.max(candy, max); &#125; List&lt;Boolean> ans = new ArrayList&lt;>(); for(int candy : candies)&#123; int temp = candy + extraCandies; ans.add(temp &lt; max ? false : true); &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"}]},{"title":"2218. Maximum Value of K Coins From Piles","slug":"coding/leetcode/Hard/2218-Maximum-Value-of-K-Coins-From-Piles","date":"2023-04-15T04:01:24.000Z","updated":"2023-05-28T17:13:10.218Z","comments":true,"path":"coding/leetcode/Hard/2218-Maximum-Value-of-K-Coins-From-Piles/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/2218-Maximum-Value-of-K-Coins-From-Piles/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 There are n piles of coins on a table. Each pile consists of a positive number of coins of assorted denominations. In one move, you can choose any coin on top of any pile, remove it, and add it to your wallet. Given a list piles , where piles[i] is a list of integers denoting the composition of the ith pile from top to bottom, and a positive integer k , return the maximum total value of coins you can have in your wallet if you choose exactly k coins optimally. # Example 1: Input: piles = [[1,100,3],[7,8,9]], k = 2 Output: 101 Explanation: The above diagram shows the different ways we can choose k coins. The maximum total we can obtain is 101. # Example 2: Input: piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7 Output: 706 Explanation: The maximum total can be obtained if we choose all coins from the last pile. # 解題思路 # Solution import java.util.Arrays;import java.util.List;class Solution &#123; public int maxValueOfCoins(List&lt;List&lt;Integer>> piles, int k) &#123; int[][] dp = new int[piles.size() + 1][k + 1]; Arrays.fill(dp[0], 0); for (int i = 1; i &lt;= piles.size(); i++) &#123; dp[i][0] = 0; &#125; for (int i = 1; i &lt;= piles.size(); i++) &#123; for (int j = 1; j &lt;= k; j++) &#123; int curr = 0; for (int x = 0; x &lt; Math.min(piles.get(i - 1).size(), j); x++) &#123; curr += piles.get(i - 1).get(x); dp[i][j] = Math.max(dp[i][j], curr + dp[i - 1][j - x - 1]); &#125; dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]); &#125; &#125; return dp[piles.size()][k]; &#125;&#125; 單字 denoting 表示 to represent something 片語 & 搭配詞 assorted denominations 個種面額","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"}]},{"title":"516. Longest Palindromic Subsequence","slug":"coding/leetcode/Medium/516-Longest-Palindromic-Subsequence","date":"2023-04-14T17:08:29.000Z","updated":"2023-05-28T17:13:38.961Z","comments":true,"path":"coding/leetcode/Medium/516-Longest-Palindromic-Subsequence/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/516-Longest-Palindromic-Subsequence/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a string s , find the longest palindromic subsequence's length in s . A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. # Example 1: Input: s = &quot;bbbab&quot; Output: 4 Explanation: One possible longest palindromic subsequence is &quot;bbbb&quot;. # Example 2: Input: s = &quot;cbbd&quot; Output: 2 Explanation: One possible longest palindromic subsequence is &quot;bb&quot;. # 解題思路 # Solution class Solution &#123; public int longestPalindromeSubseq(String s) &#123; int n = s.length(); int[] dp = new int[n]; for (int i = n - 1; i >= 0; i--) &#123; int[] newdp = new int[n]; newdp[i] = 1; for (int j = i + 1; j &lt; n; j++) &#123; if (s.charAt(i) == s.charAt(j)) &#123; newdp[j] = 2 + dp[j-1]; &#125; else &#123; newdp[j] = Math.max(dp[j], newdp[j-1]); &#125; &#125; dp = newdp; &#125; return dp[n-1]; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"946. Validate Stack Sequences","slug":"coding/leetcode/Medium/946-Validate-Stack-Sequences","date":"2023-04-13T01:21:33.000Z","updated":"2023-05-28T17:13:58.465Z","comments":true,"path":"coding/leetcode/Medium/946-Validate-Stack-Sequences/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/946-Validate-Stack-Sequences/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given two integer arrays pushed and popped each with distinct values, return true if this could have been the result of a sequence of push and pop operations on an initially empty stack, or false otherwise. # Example 1: Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1] Output: true Explanation: We might do the following sequence: push(1), push(2), push(3), push(4), pop() -&gt; 4, push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1 # Example 2: Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2] Output: false Explanation: 1 cannot be popped before 2. # 解題思路 # Solution import java.util.Stack;class Solution &#123; public boolean validateStackSequences(int[] pushed, int[] popped) &#123; Stack&lt;Integer> stack = new Stack&lt;>(); int index = 0; for(int p : pushed)&#123; stack.push(p); while(!stack.isEmpty() &amp;&amp; stack.peek() == popped[index])&#123; stack.pop(); index++; &#125; &#125; return stack.isEmpty(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"}]},{"title":"71. Simplify Path","slug":"coding/leetcode/Medium/71-Simplify-Path","date":"2023-04-12T03:22:17.000Z","updated":"2023-05-28T17:13:29.304Z","comments":true,"path":"coding/leetcode/Medium/71-Simplify-Path/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/71-Simplify-Path/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a string path , which is an absolute path (starting with a slash '/' ) to a file or directory in a Unix-style file system, convert it to the simplified canonical path. In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//' ) are treated as a single slash '/' . For this problem, any other format of periods such as '...' are treated as file/directory names. The canonical path should have the following format: The path starts with a single slash '/'. Any two directories are separated by a single slash '/'. The path does not end with a trailing '/'. The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..') Return the simplified canonical path. # Example 1: Input: path = &quot;/home/&quot; Output: &quot;/home&quot; Explanation: Note that there is no trailing slash after the last directory name. # Example 2: Input: path = &quot;/../&quot; Output: &quot;/&quot; Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. # Example 3: Input: path = &quot;/home//foo/&quot; Output: &quot;/home/foo&quot; Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. # 解題思路 # Solution import java.util.Stack;class Solution &#123; public String simplifyPath(String path) &#123; Stack&lt;String> stack = new Stack&lt;>(); for (String str : path.split(\"/\")) &#123; if (!stack.isEmpty() &amp;&amp; str.equals(\"..\")) &#123; stack.pop(); &#125; else if (!str.equals(\".\") &amp;&amp; !str.equals(\"\") &amp;&amp; !str.equals(\"..\")) &#123; stack.add(str); &#125; &#125; StringBuilder ans = new StringBuilder(); for (String str : stack) &#123; ans.append(\"/\").append(str); &#125; return ans.length() == 0 ? \"/\" : ans.toString(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"}]},{"title":"2390. Removing Stars From a String","slug":"coding/leetcode/Medium/2390-Removing-Stars-From-a-String","date":"2023-04-11T03:05:05.000Z","updated":"2023-05-28T17:14:35.475Z","comments":true,"path":"coding/leetcode/Medium/2390-Removing-Stars-From-a-String/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2390-Removing-Stars-From-a-String/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given a string s , which contains stars * . In one operation, you can: Choose a star in s . Remove the closest non-star character to its left, as well as remove the star itself. Return the string after all stars have been removed. Note: The input will be generated such that the operation is always possible. It can be shown that the resulting string will always be unique. # Example 1: Input: s = &quot;leet**cod*e&quot; Output: &quot;lecoe&quot; Explanation: Performing the removals from left to right: The closest character to the 1st star is 't' in &quot;leet**cod*e&quot; . s becomes &quot;lee*cod*e&quot; . The closest character to the 2nd star is 'e' in &quot;lee*cod*e&quot; . s becomes &quot;lecod*e&quot; . The closest character to the 3rd star is 'd' in &quot;lecod*e&quot; . s becomes &quot;lecoe&quot; . There are no more stars, so we return &quot;lecoe&quot; . # Example 2: Input: s = &quot;erase*****&quot; Output: &quot;&quot; Explanation: The entire string is removed, so we return an empty string. # 解題思路 # Solution import java.util.Stack;class Solution &#123; public String removeStars(String s) &#123; char[] toChar = s.toCharArray(); Stack&lt;Character> stack = new Stack&lt;>(); for(int i = 0; i &lt; s.length(); i++)&#123; if(toChar[i] == '*')&#123; stack.pop(); &#125;else &#123; stack.add(toChar[i]); &#125; &#125; String ans = \"\"; while(!stack.isEmpty())&#123; ans = stack.pop() + ans; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"}]},{"title":"20. Valid Parentheses","slug":"coding/leetcode/Easy/20-Valid-Parentheses","date":"2023-04-10T01:44:58.000Z","updated":"2023-05-28T17:11:16.873Z","comments":true,"path":"coding/leetcode/Easy/20-Valid-Parentheses/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/20-Valid-Parentheses/","excerpt":"","text":"⭐️ # 題目敘述 Given a string s containing just the characters '(' , ')' , '&#123;' , '&#125;' , '[' and ']' , determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type. # Example 1: Input: s = &quot;()&quot; Output: true # Example 2: Input: s = &quot;(){}&quot; Output: true # Example 3: Input: s = &quot;(]&quot; Output: false # 解題思路 利用 stack。 # Solution import java.util.Stack;class Solution &#123; public boolean isValid(String s) &#123; if (s.length() % 2 != 0) &#123; return false; &#125; Stack&lt;Character> stack = new Stack&lt;>(); for (char c : s.toCharArray()) &#123; switch(c)&#123; case '(': case '&#123;': case '[': stack.push(c); break; case ')': if(stack.isEmpty() || stack.pop() != '(') return false; break; case '&#125;': if(stack.isEmpty() || stack.pop() != '&#123;') return false; break; case ']': if(stack.isEmpty() || stack.pop() != '[') return false; break; &#125; &#125; return (stack.isEmpty()); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"}]},{"title":"1857. Largest Color Value in a Directed Graph","slug":"coding/leetcode/Hard/1857-Largest-Color-Value-in-a-Directed-Graph","date":"2023-04-09T04:05:26.000Z","updated":"2023-05-28T17:12:59.257Z","comments":true,"path":"coding/leetcode/Hard/1857-Largest-Color-Value-in-a-Directed-Graph/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/1857-Largest-Color-Value-in-a-Directed-Graph/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 There is a directed graph of n colored nodes and m edges. The nodes are numbered from 0 to n - 1 . You are given a string colors where colors[i] is a lowercase English letter representing the color of the ith node in this graph (0-indexed). You are also given a 2D array edges where edges[j] = [aj, bj] indicates that there is a directed edge from node aj to node bj . A valid path in the graph is a sequence of nodes x1 -&gt; x2 -&gt; x3 -&gt; ... -&gt; xk such that there is a directed edge from xi to xi+1 for every 1 &lt;= i &lt; k . The color value of the path is the number of nodes that are colored the most frequently occurring color along that path. Return the largest color value of any valid path in the given graph, or -1 if the graph contains a cycle. # Example 1: Input: colors = &quot;abaca&quot;, edges = [[0,1],[0,2],[2,3],[3,4]] Output: 3 Explanation: The path 0 -&gt; 2 -&gt; 3 -&gt; 4 contains 3 nodes that are colored &quot;a&quot; (red in the above image) . # Example 2: Input: colors = &quot;a&quot;, edges = [[0,0]] Output: -1 Explanation: There is a cycle from 0 to 0. # 解題思路 # Solution import java.util.ArrayList;import java.util.LinkedList;import java.util.List;import java.util.Queue;class Solution &#123; public int largestPathValue(String colors, int[][] edges) &#123; List&lt;List&lt;Integer>> graph = new ArrayList&lt;>(); int length = colors.length(); int inDegree[] = new int[length]; int colorsDP[][] = new int[length][26]; int visited = 0; for (int i = 0; i &lt; length; i++) &#123; graph.add(new ArrayList&lt;>()); &#125; for (int i = 0; i &lt; edges.length; i++) &#123; int start = edges[i][0]; int end = edges[i][1]; graph.get(start).add(end); inDegree[end]++; &#125; Queue&lt;Integer> queue = new LinkedList&lt;>(); for (int i = 0; i &lt; inDegree.length; i++) &#123; if (inDegree[i] == 0) &#123; queue.add(i); &#125; &#125; while (!queue.isEmpty()) &#123; int parent = queue.poll(); int parentColor = colors.charAt(parent) - 'a'; colorsDP[parent][parentColor] = colorsDP[parent][parentColor] + 1; for (Integer child : graph.get(parent)) &#123; inDegree[child]--; if (inDegree[child] == 0) &#123; queue.add(child); &#125; for (int i = 0; i &lt; 26; i++) &#123; colorsDP[child][i] = Math.max(colorsDP[child][i], colorsDP[parent][i]); &#125; &#125; visited++; &#125; if (visited != length) return -1; int maxColor = 0; for (int i = 0; i &lt; colorsDP.length; i++) &#123; for (int j = 0; j &lt; 26; j++) &#123; maxColor = Math.max(maxColor, colorsDP[i][j]); &#125; &#125; return maxColor; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Topological Sort","slug":"Topological-Sort","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Topological-Sort/"},{"name":"Memoization","slug":"Memoization","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Memoization/"}]},{"title":"133. Clone Graph","slug":"coding/leetcode/Medium/133-Clone-Graph","date":"2023-04-08T03:40:24.000Z","updated":"2023-05-28T17:13:32.628Z","comments":true,"path":"coding/leetcode/Medium/133-Clone-Graph/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/133-Clone-Graph/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Each node in the graph contains a value ( int ) and a list ( List[Node] ) of its neighbors. class Node &#123; public int val; public List&lt;Node&gt; neighbors; &#125; Test case format: For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1 , the second node with val == 2 , and so on. The graph is represented in the test case using an adjacency list. An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph. The given node will always be the first node with val = 1 . You must return the copy of the given node as a reference to the cloned graph. # Example 1: Input: adjList = [[2,4],[1,3],[2,4],[1,3]] Output: [[2,4],[1,3],[2,4],[1,3]] Explanation: There are 4 nodes in the graph. 1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4). 2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3). 3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4). 4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3). # Example 2: Input: adjList = [[]] Output: [[]] Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors. # Example 3: Input: adjList = [] Output: [] Explanation: This an empty graph, it does not have any nodes. # 解題思路 # Solution import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;// Definition for a Node.class Node &#123; public int val; public List&lt;Node> neighbors; public Node() &#123; val = 0; neighbors = new ArrayList&lt;Node>(); &#125; public Node(int _val) &#123; val = _val; neighbors = new ArrayList&lt;Node>(); &#125; public Node(int _val, ArrayList&lt;Node> _neighbors) &#123; val = _val; neighbors = _neighbors; &#125;&#125;class Solution &#123; Map&lt;Node, Node> map = new HashMap&lt;>(); public Node cloneGraph(Node node) &#123; if (node == null) return null; if (map.containsKey(node)) return map.get(node); map.put(node, new Node(node.val)); for (Node val : node.neighbors) &#123; map.get(node).neighbors.add(cloneGraph(val)); &#125; return map.get(node); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"}]},{"title":"Reading Highlights 1: Uber: The Worlds Modern Taxi","slug":"language/english/Reading Highlights/Reading-Highlights-1-Uber-The-Worlds-Modern-Taxi","date":"2023-04-07T04:26:45.000Z","updated":"2023-09-03T09:30:12.007Z","comments":true,"path":"language/english/Reading Highlights/Reading-Highlights-1-Uber-The-Worlds-Modern-Taxi/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/language/english/Reading%20Highlights/Reading-Highlights-1-Uber-The-Worlds-Modern-Taxi/","excerpt":"","text":"⭐️⭐️⭐️⭐️ # Uber: The World's Modern Taxi A new taxi trend is taking over the world. Uber doesn't have a long history, but it has proven it's here to stay by providing major benefits and a competitive spirit. Travis Kalanick and Garrett Camp launched the Uber transportation app in 2009 in San Francisco, California, US. In May 2011, it started spreading to other American cities. In December of the same year, it expanded into its first international city - Pairs, France. Uber now operates in 58 countries and 300 cities across the globe. It's worth an estimated US$50 billion. Uber combines the traditional taxi ride with the morden technology of the 21st century. All Uber transactions are handled electronically; the app finds you a drive, navigates, and processes the paymemt. The only interaction you have with the driver is pleasant conversation. Using Uber is slightly different from a normal taxi ride because you can estimate the cost of your ride before you decide to hire a drive and split the fare with other passengers. Additionally, the app can send a text message with your Uber ride information to friends or family, adding an element of safety to your ride. Despite its many advantages, Uber has its critics. Some goverments have banned the app because its drivers aren't properly trained or insured. On February 19, Uber was declared illegal in Taiwan The goverment said that the drivers had violated the Highway Act and Transportation Management Regulations. Taxi companies have also opposed Uber, as they've lost business because of Uber's cheap rates and fast reaponse time. Protestes against Uber have become common, locally and internationally. It remains to be seen whether Uber's many advantages will win out against traditional taxis. Which one would you choose to take a ride in? # 段落大意 第一段: 告知主題是要闡述 new Taxi 第二段 Uber 發展史 第三段 Uber 的運作模式，好處等等 第四段 Uber 的問題或不足 # Reading Questions Which of the following statements about Uber is TRUE? It is illegal in some countries. It was started by a US taxi driver in 2009. It is more popular abroad than in the US. It operates through a control center. According to the passage, how does Uber work? Ubers can share the ride with other passengers. Ubers pay the transportation fare directly to the drivers. Ubers can negotiate the cost of the ride with the driver. Users have to register in paper from before using the service. Compared with normal taxis, Uber is all of the following EXCEPT . more advanced greener less costly more convenient What is one criticism of Uber based on the passage? The drivers don't show up fast enough. The drivers are not paid enough. The drivers lack sufficient training. The customer service is lousy.","categories":[{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"Reading Highlight","slug":"language/english/Reading-Highlight","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/Reading-Highlight/"}],"tags":[{"name":"英文文章","slug":"英文文章","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0/"}]},{"title":"1020. Number of Enclaves","slug":"coding/leetcode/Medium/1020-Number-of-Enclaves","date":"2023-04-07T01:25:06.000Z","updated":"2023-05-28T17:14:01.074Z","comments":true,"path":"coding/leetcode/Medium/1020-Number-of-Enclaves/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1020-Number-of-Enclaves/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an m x n binary matrix grid , where 0 represents a sea cell and 1 represents a land cell. A move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid . Return the number of land cells in grid for which we cannot walk off the boundary of the grid in any number of moves. # Example 1: Input: grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] Output: 3 Explanation: There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary. # Example 2: Input: grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]] Output: 0 Explanation: All 1s are either on the boundary or can reach the boundary. # 解題思路 # Solution class Solution &#123; public int numEnclaves(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; int ans = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if ((i == 0 || j == 0 || i == m - 1 || j == n - 1) &amp;&amp; grid[i][j] == 1) &#123; dfs(i, j, m, n, grid); &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j] == 1) &#123; ans++; &#125; &#125; &#125; return ans; &#125; public void dfs(int x, int y, int m, int n, int[][] grid) &#123; grid[x][y] = 0; int[] dirx = &#123; 0, 1, 0, -1 &#125;; int[] diry = &#123; -1, 0, 1, 0 &#125;; for (int i = 0; i &lt; 4; i++) &#123; int r = x + dirx[i]; int c = y + diry[i]; if (r >= 0 &amp;&amp; r &lt; m &amp;&amp; c >= 0 &amp;&amp; c &lt; n &amp;&amp; grid[r][c] == 1) &#123; dfs(r, c, m, n, grid); &#125; &#125; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"}]},{"title":"1254. Number of Closed Islands","slug":"coding/leetcode/Medium/1254-Number-of-Closed-Islands","date":"2023-04-06T05:47:04.000Z","updated":"2023-05-28T17:14:07.878Z","comments":true,"path":"coding/leetcode/Medium/1254-Number-of-Closed-Islands/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1254-Number-of-Closed-Islands/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a 2D grid consists of 0s (land) and 1s (water). An island is a maximal 4-directionally connected group of 0s and a closed island is an island totally (all left, top, right, bottom) surrounded by 1s . Return the number of closed islands. # Example 1: Input: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]] Output: 2 Explanation: Islands in gray are closed because they are completely surrounded by water (group of 1s). # Example 2: Input: grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]] Output: 1 # Example 3: Input: grid = [[1,1,1,1,1,1,1],[1,0,0,0,0,0,1],[1,0,1,1,1,0,1],[1,0,1,0,1,0,1], [1,0,1,1,1,0,1],[1,0,0,0,0,0,1],[1,1,1,1,1,1,1]] Output: 2 # 解題思路 利用 dfs(Depth-First Search) 去檢查如果該陣列為 0 ，他前後左右是否會碰到 1 ，如果碰到邊界表示封閉，如果碰到 0 再繼續找。 # Solution class Solution &#123; public int closedIsland(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; boolean[][] visit = new boolean[m][n]; int ans = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j] == 0 &amp;&amp; !visit[i][j]) &#123; if(dfs(i, j, m, n, grid, visit)) ans++; &#125; &#125; &#125; return ans; &#125; public boolean dfs(int x, int y, int m, int n, int[][] grid, boolean[][] visit) &#123; if (x &lt; 0 || x >= m || y &lt; 0 || y >= n) &#123; return false; &#125; if (grid[x][y] == 1 || visit[x][y]) &#123; return true; &#125; visit[x][y] = true; boolean isClosed = true; int[] dirx = &#123;0, 1, 0, -1&#125;; int[] diry = &#123;-1, 0, 1, 0&#125;; for (int i = 0; i &lt; 4; i++) &#123; int r = x + dirx[i]; int c = y + diry[i]; isClosed &amp;= dfs(r, c, m, n, grid, visit); &#125; return isClosed; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"}]},{"title":"2439. Minimize Maximum of Array","slug":"coding/leetcode/Medium/2439-Minimize-Maximum-of-Array","date":"2023-04-05T03:58:41.000Z","updated":"2023-05-28T17:14:40.044Z","comments":true,"path":"coding/leetcode/Medium/2439-Minimize-Maximum-of-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2439-Minimize-Maximum-of-Array/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given a 0-indexed array nums comprising of n non-negative integers. In one operation, you must: Choose an integer i such that 1 &lt;= i &lt; n and nums[i] &gt; 0 . Decrease nums[i] by 1. Increase nums[i - 1] by 1. Return the minimum possible value of the maximum integer of nums after performing any number of operations. # Example 1: Input: nums = [3,7,1,6] Output: 5 Explanation: One set of optimal operations is as follows: Choose i = 1, and nums becomes [4,6,1,6]. Choose i = 3, and nums becomes [4,6,2,5]. Choose i = 1, and nums becomes [5,5,2,5]. The maximum integer of nums is 5. It can be shown that the maximum number cannot be less than 5. Therefore, we return 5. # Example 2: Input: nums = [10,1] Output: 10 Explanation: It is optimal to leave nums as is, and since 10 is the maximum value, we return 10. # 解題思路 在題目敘述中我們可以知道， nums 這個陣列無法將前面較大的數值向後移，只能將後面的數值向前移動。 因此我們可以藉由 prefix sum 來計算到目前的總值，除以現在的陣列數目，得到平均值利用高斯取頂 (ceiling function) ⇒\\Rightarrow⇒ 得到當前 subArray 數目的最大值 並與前面的最大值比較: 如果比較大 ⇒\\Rightarrow⇒ 就代表後面的值可以再向前移動。 如果比較小 ⇒\\Rightarrow⇒ 就表示雖然平均最大值可能有更小的，但是前面的值不可以往後移，因此不採用。 # Algorithm Initialize ans = 0 and prefixSum = 0 . Iterate over nums , for each index i : Update the prefix sum as prefixSum += nums[i] . Check the maximum value we can obtain by averaging prefixSum into i + 1 evenly using ceiling division. Take the larger one from ans and the result from the previous integer division. Return ans # Solution class Solution &#123; public int minimizeArrayValue(int[] nums) &#123; long prefixSum = 0; int ans = 0; for(int i = 0; i &lt; nums.length; i++)&#123; prefixSum += nums[i]; ans = Math.max(ans, (int)Math.ceil(prefixSum * 1.0 / (i + 1))); &#125; return ans; &#125;&#125; 單字 decrease 減少 to become less, or to make something become less increase 增加 to (make something) become larger in amount or size 片語 & 搭配詞 comprising of 包括","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"}]},{"title":"2405. Optimal Partition of String","slug":"coding/leetcode/Medium/2405-Optimal-Partition-of-String","date":"2023-04-04T04:02:30.000Z","updated":"2023-05-28T17:14:37.750Z","comments":true,"path":"coding/leetcode/Medium/2405-Optimal-Partition-of-String/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2405-Optimal-Partition-of-String/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a string s , partition the string into one or more substrings such that the characters in each substring are unique. That is, no letter appears in a single substring more than once. Return the minimum number of substrings in such a partition. Note that each character should belong to exactly one substring in a partition. # Example 1: Input: s = &quot;abacaba&quot; Output: 4 Explanation: Two possible partitions are (&quot;a&quot;,&quot;ba&quot;,&quot;cab&quot;,&quot;a&quot;) and (&quot;ab&quot;,&quot;a&quot;,&quot;ca&quot;,&quot;ba&quot;). It can be shown that 4 is the minimum number of substrings needed. # Example 2: Input: s = &quot;ssssss&quot; Output: 6 Explanation: The only valid partition is (&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;). # 解題思路 # Solution Solution.javaclass Solution &#123; public int partitionString(String s) &#123; int[] hashTable = new int[26]; int ans = 0; for(int i = 0; i &lt; s.length(); i++)&#123; int temp = s.charAt(i) - 'a'; if(hashTable[temp] == 1)&#123; hashTable = new int[26]; ans++; hashTable[temp]++; &#125;else&#123; hashTable[temp]++; &#125; &#125; return ans + 1; &#125;&#125; 單字 exactly 確切地 used when you are giving or asking for information that is completely correct","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"}]},{"title":"881. Boats to Save People","slug":"coding/leetcode/Medium/881-Boats-to-Save-People","date":"2023-04-03T08:26:41.000Z","updated":"2023-05-28T17:13:56.031Z","comments":true,"path":"coding/leetcode/Medium/881-Boats-to-Save-People/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/881-Boats-to-Save-People/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit . Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit . Return the minimum number of boats to carry every given person. # Example 1 Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2) # Example 2 Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3) # Example 3 Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) # 解題思路 # Solution Solution.javaimport java.util.Arrays;class Solution &#123; public int numRescueBoats(int[] people, int limit) &#123; Arrays.sort(people); int ans = 0; int left = 0, right = people.length - 1; while (left &lt;= right) &#123; if (people[left] + people[right--] &lt;= limit) &#123; left++; &#125; ans++; &#125; return ans; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-04-02T12:45:48.000Z","updated":"2023-04-03T05:07:21.357Z","comments":true,"path":"hello-world/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. # Quick Start # Create a new post h$ hexo new \"My New Post\"More info: Writing # Run server h$ hexo serverMore info: Server # Generate static files h$ hexo generateMore info: Generating # Deploy to remote sites h$ hexo deployMore info: Deployment","categories":[],"tags":[{"name":"Hello World","slug":"Hello-World","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hello-World/"}]}],"categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"},{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"文法","slug":"language/english/文法","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E6%96%87%E6%B3%95/"},{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Note","slug":"computer-science/Note","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Note/"},{"name":"program-language","slug":"computer-science/Program-Language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/"},{"name":"C Programming Language","slug":"computer-science/Program-Language/C-Programming-Language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/C-Programming-Language/"},{"name":"PHP","slug":"computer-science/Program-Language/PHP","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/PHP/"},{"name":"Framework","slug":"computer-science/Program-Language/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/Framework/"},{"name":"Java Spring Boot","slug":"computer-science/Program-Language/Framework/Java-Spring-Boot","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/Framework/Java-Spring-Boot/"},{"name":"Vue","slug":"computer-science/Program-Language/Framework/Vue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Program-Language/Framework/Vue/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"},{"name":"Reading Highlight","slug":"language/english/Reading-Highlight","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/Reading-Highlight/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"},{"name":"Monotonic Stack","slug":"Monotonic-Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Monotonic-Stack/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bit-Manipulation/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"},{"name":"Sotring","slug":"Sotring","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sotring/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Divide-and-Conquer/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Bitmask","slug":"Bitmask","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bitmask/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Minimum Spanning Tree","slug":"Minimum-Spanning-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Minimum-Spanning-Tree/"},{"name":"Queue","slug":"Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Queue/"},{"name":"Monotonic Queue","slug":"Monotonic-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Monotonic-Queue/"},{"name":"英文文法","slug":"英文文法","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Linked-List/"},{"name":"Quickselect","slug":"Quickselect","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Quickselect/"},{"name":"Web","slug":"Web","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Web/"},{"name":"Tree","slug":"Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Tree/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Tree/"},{"name":"前端框架","slug":"前端框架","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Shortest Path","slug":"Shortest-Path","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Shortest-Path/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"},{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"},{"name":"Windows","slug":"Windows","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Windows/"},{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"},{"name":"Recursion","slug":"Recursion","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Recursion/"},{"name":"Binary Indexed Tree","slug":"Binary-Indexed-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Indexed-Tree/"},{"name":"Brainteaser","slug":"Brainteaser","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Brainteaser/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Number-Theory/"},{"name":"Design","slug":"Design","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Design/"},{"name":"Topological Sort","slug":"Topological-Sort","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Topological-Sort/"},{"name":"Memoization","slug":"Memoization","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Memoization/"},{"name":"英文文章","slug":"英文文章","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0/"},{"name":"Hello World","slug":"Hello-World","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hello-World/"}]}