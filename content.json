{"meta":{"title":"MyBlog","subtitle":"We are the dreamers. We make it happen 'cause we can see it.","description":"謝謝你來，謝謝你還在","author":"Hsing Yu","url":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io","root":"/"},"pages":[{"title":"Hello!","date":"2023-04-08T11:59:17.144Z","updated":"2023-04-08T11:59:17.144Z","comments":true,"path":"about/index.html","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/about/index.html","excerpt":"","text":"# Hsing Yu 陳幸妤 在努力學習各種技術，完成所有夢想與理想，成為自己的那曙光！ 路漫漫其修遠兮， 吾將上下而求索。 每日目標 leetcode 1 題 CPE 1 題 英文 1 篇 這個網站目前是為了督促我自己樣成讀英文跟寫程式的習慣，之後會再寫一些整理的技術或我在學的一些東西。 # 簡介 性別：女 生日: 2003/02/12 星座：水瓶座 興趣：排球、美術設計、書法 專長：游泳、機器人、資訊工程 (人工智慧、網頁) # 經歷 國立彰化女子高級中學 國立台中教育大學 資訊工程學系 (特殊選材) # 比賽 &amp; 獎項 2018 全國智能車挑戰賽 2018-2019 FIRST 機器人大賽台灣選拔賽 — 研究品質獎全國第一名 (作品：太空中的家鄉味) 彰化縣 108 學年教育盃機器人競賽 — 高中競賽組佳作 2019 WRO 中南區賽高中競賽組 (機器人計分 / 計時賽) 2019 WRO 國際奧林匹亞機器人全國總決賽 — 高中創意組佳作 (作品：AI 智能交通小幫手) 台灣青年黑客松 6th — APP 組 (作品：防疫下的共享經濟) 2022 NCPC 全國大專電腦軟體設計競賽 國立台中教育大學 菁英獎 # 各種檢定 2023 CPE: 4 題 # 專案經歷 2021 彰化縣資優生報考系統 2021 彰化高中學生會選舉投票系統 2021 國立馬祖高級中學網站 2021~ 國教署 Q&amp;A 系統 (未完成) 2022~ 台中教育大學資工系網站 (未完成) 2023~ 進階程式設計課程自動評分系統 (未完成) # 參與團隊 2019~2020 國立彰化女子高級中學 電腦研習社 (機器人組與軟程組) 社長 2019~ 彰化資訊志工隊 隊員 2021~ 國立台中教育大學 空手道社 2021~ 國立台中教育大學 資工系女子排球隊 隊員、副隊長 (2021~2023) # 活動經歷 講師 2021 鹿鳴國中假日班 Webduino 課程 2021、2022 彰化女中學期課後程式加強課程 C++ 程式語言 2022 國立馬祖高中、桃園市立新屋高中 新興科技認知推廣計畫 - VR 體驗活動 2022 國立台中教育大學「程式戰鬥營」教學 C 程式語言 主辦人 彰化女中 2019、2020 C++ 寒暑假研習課 (共 6 場)、學期課後程式加強課程 主辦人、課堂協助指導 2020 彰中彰女電研聯合寒訓 主辦人、課堂協助指導 2021 舉辦大成國中寒假資訊科學營隊 協助教導 2019、2020 國中生機器人學園 (共 2 場) 2021 草湖國中寒假營隊 2022 芬園國中寒假營隊 學習探討 2020 高中人才培育計畫交大人工智慧與深度學習 (學習 AI 和深度學習的演進，機器學習的定義，線性模型推廣淺層神經網路，如何訓練神經網路) 2020Ewant 高中自主學習 交大生活中的機器人科技 (學習機器人的發展及未來應用) 2020 高中職生 AI 扎根系列活動 (學習 AI 基礎知識與實作 AWS DeepRacer) 2020 教育部資訊安全人才培育計畫 (學習 Linux、基礎資安分析實務、基礎程式逆向工程) 參與活動 2020 SITCON 學生計算機年會 # 目標待完成 CPE: 7 題 托福 iBT 考試：達標 參加 ICPC 得名 參加 ITSA 全國大專程式設計極客挑戰 得名 出國讀書 # 待續..."}],"posts":[{"title":"Docker Practise - 2","slug":"computer-science/Docker/Docker-Practise-2","date":"2023-05-16T11:41:31.000Z","updated":"2023-05-16T13:21:36.253Z","comments":true,"path":"computer-science/Docker/Docker-Practise-2/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Docker/Docker-Practise-2/","excerpt":"","text":"# 實作說明 在前一個實作中我們先創建了一個 images ubuntu ，在裡面安裝 nginx ，但其實我們只需要使用 nginx 而已，並不需要 ubuntu 這個作業系統。 所以接下來我們要實作撰寫一個 Dockerfile，在自己的專案中，run Dockerfile 進行部屬，而且不包含 ubuntu。 # 撰寫一個 Project 當然要現在馬上生出一個 project 有點費時，所以如果手邊沒有撰寫好的 project 也沒關係，接下來分兩部分來說: 已經有可以實作的 project 這個就很簡單，先進入 project 的資料夾。 沒有可實作的 project 這個其實也不難，創建一個新資料夾，名稱隨意，如果想不到可以用: [docker-test]，在裡面撰寫一個 index.html 。 以下是個簡單的 html 可以參考: index.html&lt;h1>My Project&lt;/h1> # 撰寫 nignx.conf 這個其實沒寫也沒關係，沒有寫就是原本 nignx.conf 的預設，寫了可以更改其原本預設。 server&#123; listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; index index.html; charset utf-8; access_log /var/log/nginx/access_log; error_log /var/log/nginx/error_log; &#125; 內容細節說明可以去看 docker practise - 1，那邊有稍微說明一下內容涵意。 # 創建一個 Dockerfile 的檔案 創建一個 Dockerfile 檔，沒有副檔名，純檔案。 Dockerfile 內容如下: FROM nginxMAINTAINER HsingYu# 複製一整個在根目錄專案的檔案進去COPY / /usr/share/nginx/html# 如果只有一個檔案，如: index.html 可以寫 # COPY index.html /usr/share/nginx/html# 把 nignx.conf 加入預設 conf 裡面COPY nginx.conf /etc/nginx/conf.d/default.conf# 容器對外連接 80 portEXPOSE 80這樣就完成撰寫 Dockerfile 了。 # 利用 Dockerfile 建立 images docker bulid -t [&quot;images name&quot;] . -t : 後面接為 images 命名的名稱，注意不可以是大寫字母，要是小寫喔～～ . : 指在這個地方下的 Dockerfile 建立完成會如下圖: # 執行建立的 images docker run -p 80:80 [&quot;images name&quot;] -p : 後面寫通信的 port 80:80 : 為了方便區分冒號 (:) 前後 port 代表的不同意思，接下來會以 8080:80 來解釋，容器將在端口 8080 上的主機上可用，但它與端口 80 上的容器（和應用程序）通信，簡單來說就是在 bowser 中輸入容器運行所在的 Docker 主機的 DNS 名稱或者 IP 位址，並在後面加上 port 8080，例如: localhost:8080 執行成功會如下圖: localhost port 80 不用特別寫，localhost:80 =&gt; localhost","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Docker","slug":"computer-science/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Docker/"},{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"}]},{"title":"Docker Practise - 1","slug":"computer-science/Docker/Docker-Practise-1","date":"2023-05-16T11:32:34.000Z","updated":"2023-05-16T11:40:13.964Z","comments":true,"path":"computer-science/Docker/Docker-Practise-1/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Docker/Docker-Practise-1/","excerpt":"","text":"# 實作說明 當一個軟體完成後要進行發布網站，我們並不會使用絕對路徑，顯示檔案位置，會使用取得主機（hosting）和網域名稱（domain name）的方式來達到。 而他人只需要訪問你的 hosting IP 或為其申請的 domain name 來 request 資料。 而常見的有兩種工具來做: Apache nginx 舉個大家比較熟悉的例子就是 xampp， 可以將檔案丟進去，訪問 localhost 進行訪問。 但是因為 xampp 是一個類似於 LAMP 的環境， 他除了 Apache 以外，還包含了 phpmyadmin、PHP、Perl 等其他東西， 如果不需要用到 php 等東西，就會比較沒有必要。 # 創建一個 docker images ubuntudocker run -it -p 80:80 ubuntu:focal bash # 更新 apt apt update # 下載 nginx apt install nginx # 開啟 nginx nginx -s reload # 可能出現錯誤資訊: nginx: [error] open() &quot;/var/run/nginx.pid&quot; failed (2: No such file or directory) 解決方法: 輸入以下指令 nginx -c /etc/nginx/nginx.conf 查看 /etc/nginx/nginx.conf 修改內容 nano /etc/nginx/nginx.conf 將其中內容修改成下方 pid /var/run/nginx.pid; #pid /run/nginx.pid; pid /var/run/nginx.pid; 再試一次 nginx -s reload # 網頁連接設定 nano /etc/nginx/sites-available/default port 連接設定 根目錄檔案位置 預先載入檔案 server_name 用於設定 DNS 域名 # 最後將 APP 檔案加入根目錄檔案位置 原本顯示完整檔案位置 經過修改剩下 locolhost = 127.0.0.1 ^D = exit : 離開 container 如果在 Terminal 無法離開 container 再開起一個 Terminal docker ps : 檢查還未關閉的 container docker stop [container ID] : 這裡 container ID 可以打前兩個字就好","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Docker","slug":"computer-science/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Docker/"},{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"}]},{"title":"Docker Compose","slug":"computer-science/Docker/Docker-Compose","date":"2023-05-16T11:29:28.000Z","updated":"2023-05-16T11:33:39.928Z","comments":true,"path":"computer-science/Docker/Docker-Compose/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Docker/Docker-Compose/","excerpt":"","text":"iT邦幫忙 使用 Docker-Compose 啟動多個 Docker Container # Docker Compose # 為什麼要用 Docker Compose? 之前有介紹過使用 docker run 指令就可以把 Docker Container 啟動起來，但是如果我們要啟動很多個 Docker Container 時，就需要輸入很多次 docker run 指令。 另外 container 和 container 之間要做關聯的話也要記得它們之間要如何的連結 (link) Container，這樣在要啟動多個 Container 的情況下，就會顯得比較麻煩。 # 如何運作？ Docker-Compose: 寫一個 docker-compose.yml ，把所有要使用 Docker Image 寫上去，也可以把 Container 之間的關係連結 (link) 起來。 最後只要下 docker-compose up 指令，就可以把所有的 Docker Container 執行起來，這樣就可以很快速和方便的啟動多個 container。 # Docker Compose 常用指令 # 啟動所有的 Docker Container $ docker-compose up # 查看 Docker Container 的執行狀態 $ docker-compose ps # 看執行的 log $ docker-compose logs # 停止 docker-compose 執行的所有 Container $ docker-compose stop # 刪除 docker-compose 的所有 Container $ docker-compose rm # Docker Compose 實作 實作的部份主要就是要把 Docker-Compose 安裝起來 然後撰寫一個 docker-compose.yml 並且使用 docker-compose up ，指令把所有的 Docker Container 啟動起來 # 安裝 Docker-Compose # cd /usr/bin # wget https://github.com/docker/compose/releases/download/1.18.0/docker-compose-Linux-x86_64 # mv docker-compose-Linux-x86_64 docker-compose # chmod 755 docker-compose # 撰寫 docker-compose.yml version: '2' services: db: image: mysql environment: MYSQL_ROOT_PASSWORD: 123456 admin: image: adminer ports: - 8080:8080 主要的功能是要啟動 2 個 Docker Container，一個是 mysql 的 Container，另外一個是 admin 管理 mysql Web UI 的 container MYSQL_ROOT_PASSWORD 的環境變數用來設定登入 mysql 的密碼 參考網站: https://hub.docker.com/_/mysql/ # 啟動所有的 Docker Container $ docker-compose up -d -d 參數代表要執行在背景的方式 # 查看 Docker Container 的執行狀態 $ docker-compose ps # admin 執行 http://localhost:8080 其他指令可以參考官方網站: https://docs.docker.com/compose/compose-file/compose-file-v2/","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Docker","slug":"computer-science/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Docker/"},{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"}]},{"title":"Dockerfile","slug":"computer-science/Docker/Docker_file","date":"2023-05-16T11:11:57.000Z","updated":"2023-05-16T11:33:34.765Z","comments":true,"path":"computer-science/Docker/Docker_file/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Docker/Docker_file/","excerpt":"","text":"iT邦幫忙 實作撰寫第一個 Dockerfile # Dockerfile Dockerfile 由一行行命令語句組成，並且支援以 # 開頭的註解行。 Dockerfile 分為四部分： 基底映像檔資訊 維護者資訊 映像檔操作指令 容器啟動時執行指令。 # This dockerfile uses the ubuntu image # VERSION 2 - EDITION 1 # Author: docker_user # Command format: Instruction [arguments / command] .. # 基本映像檔，必須是第一個指令 FROM ubuntu# 維護者： docker_user &lt;docker_user at email.com> (@docker_user) MAINTAINER docker_user docker_user@email.com # 更新映像檔的指令 RUN echo \"deb http://archive.ubuntu.com/ubuntu/ raring main universe\" >> /etc/apt/sources.list RUN apt-get update &amp;&amp; apt-get install -y nginx RUN echo \"\\ndaemon off;\" >> /etc/nginx/nginx.conf # 建立新容器時要執行的指令 CMD /usr/sbin/nginx# Dockerfile 基本語法 # Example FROM centos:7MAINTAINER jackRUN yum install -y wgetRUN cd /ADD jdk-8u152-linux-x64.tar.gz /RUN wget http://apache.stu.edu.tw/tomcat/tomcat-7/v7.0.82/bin/apache-tomcat-7.0.82.tar.gzRUN tar zxvf apache-tomcat-7.0.82.tar.gzENV JAVA_HOME=/jdk1.8.0_152ENV PATH=$PATH:/jdk1.8.0_152/binCMD [\"/apache-tomcat-7.0.82/bin/catalina.sh\", \"run\"] FROM： 使用到的 Docker Image 名稱，今天使用 CentOS MAINTAINER： 用來說明，撰寫和維護這個 Dockerfile 的人是誰，也可以給 E-mail 的資訊 RUN： RUN 指令後面放 Linux 指令，用來執行安裝和設定這個 Image 需要的東西 ADD： 把 Local 的檔案複製到 Image 裡，如果是 tar.gz 檔複製進去 Image 時會順便自動解壓縮。Dockerfile 另外還有一個複製檔案的指令 COPY 未來還會再介紹 ENV： 用來設定環境變數 CMD： 在指行 docker run 的指令時會直接呼叫開啟 Tomcat Service # Dockerfile 實作 已經體驗過使用 Docker 的指令，把 Docker Image Pull 到 local，並且執行 container，然後在 container 上安裝 HTTP Service，就類似是在使用 VM。 直接進入 Docker Container 裡面下一些指令安裝程式和改設定檔，不夠自動化，可能需要常常的重覆在做同一件事，這樣會很沒效率。 寫 Dockerfile，只要下 docker build 的指令就可以把 Docker Image 建構起來，未來要使用就直接 Run 此 Image。 # 實作目標: 要做到在 Dockerfile 裡面，撰寫安裝 Java 和 Tomcat 的指令，包成 Docker Image， 之後只要呼叫到 docker run 指令，就可以把 Tomcat Service 啟動起來。 主要目的用來體驗如何撰寫 Dockerfile 和 Build Image 以及執行 Docker container。 記住要使用 WSL2 此虛擬機 來實作 Docker 可參考前面 安裝 Windows，或以下訊息 Docker 並非是一个通用的容器工具，它依賴於已存在並運行的 Linux 内核環境。 在 Windows 上部署 Docker 的方法都是先安装一个虛擬機，並在安装 Linux 系統的的虛擬機中運行 Docker。 # 第一步: 建立 Dockerfile 建立寫 Dockerfile 會用到的資料夾，指令如下 $ mkdir docker-test $ cd docker-test 下載 JDK 的安裝檔放在 docker-test 資料夾裡，使用的版本是 jdk-19.0.2 下載連結 https://download.java.net/java/GA/jdk19.0.2/fdb695a9d9064ad6b064dc6df578380c/7/GPL/openjdk-19.0.2_linux-x64_bin.tar.gz sudo apt install 將檔案移至路徑 \\wsl$\\Ubuntu\\home\\[user name]\\docker-test 撰寫 Dockerfile $ vi Dockerfile Dockerfile 的內容如下 FROM centos:7MAINTAINER HsingYu# 安裝 wget，yum 是 centos 的安裝指令RUN yum install -y wgetRUN cd /# 加入 jdk-19.0.2 壓縮檔案，加入後會自動解壓縮ADD openjdk-19.0.2_linux-x64_bin.tar.gz /# 下載 apache-tomcat-10.1.7.tar.gzRUN wget --no-check-certificate https://dlcdn.apache.org/tomcat/tomcat-10/v10.1.7/bin/apache-tomcat-10.1.7.tar.gz# 解壓縮 apache-tomcat-10.1.7.tar.gzRUN tar zxvf apache-tomcat-10.1.7.tar.gz# 設置 java 的環境變數ENV JAVA_HOME=/jdk-19.0.2ENV PATH=$PATH:/jdk-19.0.2/binCMD [\"/apache-tomcat-10.1.7/bin/catalina.sh\", \"run\"] 撰寫完 Dockerfile 之後資料夾的結構如下圖 或者將下載 jdk19.0.2 也寫入 Dockerfile FROM centos:7MAINTAINER HsingYuRUN yum install -y wgetRUN cd /RUN wget https://download.java.net/java/GA/jdk19.0.2/fdb695a9d9064ad6b064dc6df578380c/7/GPL/openjdk-19.0.2_linux-x64_bin.tar.gzRUN tar zxvf openjdk-19.0.2_linux-x64_bin.tar.gzRUN wget --no-check-certificate https://dlcdn.apache.org/tomcat/tomcat-10/v10.1.7/bin/apache-tomcat-10.1.7.tar.gzRUN tar zxvf apache-tomcat-10.1.7.tar.gzENV JAVA_HOME=/jdk-19.0.2ENV PATH=$PATH:/jdk-19.0.2/binCMD [\"/apache-tomcat-10.1.7/bin/catalina.sh\", \"run\"] # 第二步: Build Docker Image 預設在和 Dockerfile 檔案同層的資料夾底下輸入， docker build 指令，如下 $ docker build -t mytomcat . --no-cache 使用 --no-cache 的主要原因，是避免在 Build Docker image 時被 cache 住，而造成沒有 build 到修改過的 Dockerfile。 Build 完的結果如下圖： Build 完 Docker Image 之後，使用 docker images 指令查看是否有 build 成功如下圖 # 第三步: 在 Build 完 Docker Image 之後就可以執行 Docker Container，這時 Tomcat 的 Service 也會跟者被執行起來，指令如下 在瀏覽器跑 $ docker run -p 8080:8080 mytomcat 在虛擬機跑 $ docker run mytomcat Tomcat Service 會被執行起來的主要原因是在 Dockerfile 裡面有寫 CMD 指令，呼叫啟動 Tomcat Service # 第四步: 打開 Browser 確認 要打開 Browser 確認 Tomcat Service 有沒有被執行起來時，發現我們不知道 Docker Container 的 IP，這時侯只能使用 docker exec 進入 docker container 查詢 IP 。 要使用 docker exec 指令之前需要先知道 Container 的 ID 所以需要先使用 docker ps 指令查詢 Container ID，如下圖： 有了 IP 之後就可以打開 Browser 輸入 http://172.17.0.2:8080 URL 的位置，確認 Tomcat Service 是否有啟動，如下圖： 直接進入 Docker Container 去看 IP 的位址其實有點麻煩，會故意這樣 Daemon 主要的原因，是讓大家了解到我們把 Docker Container 執行啟來時並不會知道它的 IP 位址在哪，這需要透過設定有關於 Docker 的 Network 來解決這個問題。 目前使用最簡單的方法，就是在 run docker container 時用 Port 的 Mapping 來解決此問題，重新再一次 run docker container，指令如下： $ docker run -p 8080:8080 mytomcat Container 的 8080 port mapping 到 localhost 的 8080 port ，這樣只要輸入 http://localhost:8080 就可以看到 tomcat service 的 WebUI 畫面了。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Docker","slug":"computer-science/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Docker/"},{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"}]},{"title":"基礎指令","slug":"computer-science/Docker/基礎指令","date":"2023-05-16T10:57:42.000Z","updated":"2023-05-16T11:33:44.545Z","comments":true,"path":"computer-science/Docker/基礎指令/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Docker/%E5%9F%BA%E7%A4%8E%E6%8C%87%E4%BB%A4/","excerpt":"","text":"iT邦幫忙 用簡單的例子來說明如何使用 Docker 指令 # 基礎指令 # Image 映像檔 常用指令 指令 說明 範例 search 搜尋 docker search [image_name] pull 下載 docker pull [image_name] images 查看目前 images (列表) docker images run 執行 docker run [-ti] [centos] [/bin/bash] rmi [image ID] 刪除 docker rmi [615cb40d5d19] build 建立 docker build [-t project .] login 登入 docker login [docker.okborn.com] push 上傳 docker push # Container 容器 常用指令 # Registry 倉庫 常用指令 # 基礎指令實作 # 實作目標： 先從 Docker Hub 上把 Ubuntu OS 的 image pull 到 local， 有了 image 之後就可以把 Docker container 執行起來， 然後進入到 container 裡面安裝和啟動 Apache 的 HTTP Service， 並且寫一個有 HelloWorld 字串的 HTML 檔案。 最後使用 Browser 連到 Docker Container 裡面的 HTTP Service， 確認 HelloWorld 的字串能正常的顯示出來。 # 實作的流程如下： 從 Docker Hub 下載 Docker Image 到 local 使用 Docker Image 啟動 Docker Container 並進入 Docker Container 的 terminal 在 Docker Container 裡面安裝 Apache 的 HTTP Service，並且寫一個 helloworld 的 html 檔 使用 Browser 連到 helloworld.html 確認 Docker Container 有成功的被啟動起來 # 第一步: 從 Docker Hub 下載 Docker Image 到 local 要下載 Docker Image 之前需要先搜尋一下，Docker Image 的 Name 是什麼，指令如下： $ docker search ubuntu -f is-official=true is-official=true 表示要搜尋是官方的 Docker image 就選擇星星數最多的 Name 為 ubuntu 找到了 ubuntu 的 Docker Image Name 之後，就可以把此 image pull 下來，指令如下： $ docker pull ubuntu 執行結果如下圖 要再一次確認 ubuntu 的 docker image 有沒有下載下來，可以使用以下的指令 $ docker images 執行結果如下圖 # 第二步: 有了 Docker Image 之後就可以把 container 執行起來了，並且進入 Docker Container 的 terminal 裡面 指令如下 $ docker run -it -p 8000:80 ubuntu /bin/bash 使用以上的指令就可以進入了 docker container 裡面的 terminal 可以再打開另外一個 terminal 視窗，輸入以下指令 $ docker ps -a 確認 docker container 有正常的執行，如下圖： 在要離開 docker container 的 terminal 時有一個坑。就是如果輸入 exit 指令時，container 會被關閉，如下圖： 如果不要停止 container 而要退出 docker container 的 terminal 需要輸入 ctrl + p 之後再輸入 ctrl + q 的按鍵，就不會把 container 關閉。 # 第三步: 在 docker container 裡面安裝和啟動 apache 的 http service，指令如下: root@a03f4fc98ea2:/# apt-get update root@a03f4fc98ea2:/# apt-get install -y apache2 root@a03f4fc98ea2:/# service apache2 start if it is success will show 簡單寫一個 hellowolrd.html 檔案放在 /var/www/html 的路徑下，指令如下: root@a03f4fc98ea2:/# echo &quot;HelloWorld&quot; &gt; /var/www/html/helloworld.html 使用 cat /etc/hosts 指令查看 docker container 的 IP 如下圖： 如果想要使用 ifconfig 指令，需要安裝 net-tools 工具指令如下: root@a03f4fc98ea2:/# apt-get install -y net-tools # 第四步: 使用 Linux 虛擬機 GUI browser 輸入 http://172.17.0.2/helloworld.html 的 URL 查看 helloworld.html 的檔案是否能正常的顯示。 使用 Window 本機的 browser 輸入 http://localhost:8000/helloworld.html 的 URL 查看 helloworld.html 的檔案是否能正常的顯示，畫面如下：","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Docker","slug":"computer-science/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Docker/"},{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"}]},{"title":"安裝","slug":"computer-science/Docker/安裝","date":"2023-05-16T10:33:53.000Z","updated":"2023-05-16T10:55:55.444Z","comments":true,"path":"computer-science/Docker/安裝/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Docker/%E5%AE%89%E8%A3%9D/","excerpt":"","text":"# Windows Docker 並非是一个通用的容器工具，它依賴於已存在並運行的 Linux 内核環境。 在 Windows 上部署 Docker 的方法都是先安装一个虛擬機，並在安装 Linux 系統的的虛擬機中運行 Docker。 # 使用 WSL 在 Windows 上安裝 Linux 開發人員可以在 Windows 電腦上同時存取 Windows 和 Linux 的功能。 Windows 子系統 Linux 版 (WSL) 可讓開發人員直接在 Windows 上安裝 Linux 散發套件， (例如 Ubuntu、OpenSUSE、Type、Debian、Arch Linux 等) 並使用 Linux 應用程式、公用程式和 Bash 命令列工具，不需要傳統虛擬機器或雙佈設定的額外負荷。 # 必要條件 您必須 Windows 10 版本 2004 和更新版本執行， (組建 19041 和更新版本) 或 Windows 11。 檢查更新。 # 安裝 WSL 命令 開啟 PowerShell 或 Windows 命令提示字元 (cmd)，輸入命令，然後重新開機電腦。 wsl --install 啟用選用的 WSL 和虛擬機器平台元件 下載並安裝最新的 Linux 核心 將 WSL 2 設定為預設值 可能需要下載並安裝 Ubuntu Linux 發行版本 (重新開機) 您必須在此安裝程式期間重新開機電腦 若已有其他版本，可以以此指令來下載 Ubuntu wsl --install -d Ubuntu # 檢查 WSL 狀態 wsl --status 使用 wsl --install 命令安裝的新 Linux 安裝預設會設定為 WSL 2。 # 開啟 WSL wsl.exe # 設定 Linux 使用者名稱和密碼 系統會要求您為 Linux 發行版本建立使用者名稱和密碼。 此使用者名稱和密碼是每個各自 Linux 發行版本專屬，不會影響您的 Windows 使用者名稱。 請注意，在輸入 密碼時，畫面上不會顯示任何專案。 這稱為盲目輸入。 您不會看到您輸入的內容，這完全正常。 一旦您建立使用者名稱和密碼，帳戶就會是您散發套件的預設使用者，而且會在啟動時自動登入。 此帳戶將會被視為 Linux 系統管理員，並且能夠執行 sudo (超級使用者執行) 系統管理命令。 在 WSL 上執行的每個 Linux 發行版本都有自己的 Linux 使用者帳戶和密碼。 每當您新增散發套件、重新安裝或重設時，都必須設定 Linux 使用者帳戶。 若要變更或重設密碼，請開啟 Linux 發行版本，然後輸入命令： passwd 。 系統會要求您輸入目前的密碼，然後要求您輸入新密碼，然後確認您的新密碼。 # 使用 Docker 設定遠端開發容器 使用 WSL 2 (Windows 子系統 Linux 版 版本 2) 設定適用于 Windows 的 Docker Desktop。 # 必要條件 安裝 WSL，並為在 WSL 2 中執行的 Linux 發行版本設定使用者名稱和密碼。 安裝 Visual Studio Code (選擇性)。 這會提供最佳體驗，包括能夠在遠端 Docker 容器內撰寫程式碼和偵錯，並聯機到您的 Linux 散發套件。 安裝 Windows 終端機 (選擇性)。 這可提供最佳體驗，包括在同一個介面中自訂和開啟多個終端機的能力， (包括 Ubuntu、Debian、PowerShell、Azure CLI，或任何您想要使用)。 在 Docker Hub 註冊 Docker 識別碼， (選擇性)。 # 安裝 Docker Desktop 請先到 Docker 官網 https://www.docker.com/docker-windows 在 cmd 上輸入以下指令可以確認是否下載成功 開啟 Docker Desktop 確定已核取 [設定&gt; 一般] 中的 [使用 WSL 2 型引擎]。 移至 [設定&gt; 資源 &gt; WSL 整合]，從您想要啟用 Docker 整合的已安裝 WSL 2 散發套件中選取。 若要確認已安裝 Docker，請開啟 WSL 散發套件 (例如 Ubuntu) ，並輸入下列命令來顯示版本和組建編號： docker --version # 使用下列方式執行簡單的內建 Docker 映射，以測試您的安裝是否正常運作： docker run hello-world # 尋找 Docker 映射儲存體資料夾 Docker 會建立兩個散發資料夾來儲存資料： \\wsl$\\docker-desktop \\wsl$\\docker-desktop-data 您可以開啟 WSL Linux 發行版本並輸入： explorer.exe . 在 Windows 檔案總管中檢視資料夾，以找到這些資料夾。 輸入： \\\\wsl$","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Docker","slug":"computer-science/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Docker/"},{"name":"Windows","slug":"Windows","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Windows/"}]},{"title":"虛擬化技術","slug":"computer-science/Docker/虛擬化技術","date":"2023-05-16T08:52:42.000Z","updated":"2023-05-16T10:33:21.854Z","comments":true,"path":"computer-science/Docker/虛擬化技術/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Docker/%E8%99%9B%E6%93%AC%E5%8C%96%E6%8A%80%E8%A1%93/","excerpt":"","text":"# 虛擬化技術 虛擬化要解決的問題是:「當我寫了一個程式，在我電腦上可以執行，但在別人電腦上就不行」。 # But why? 作業系統不同 硬體配置不同 簡單來說：我的程式可能剛好只跟我的電腦的環境相容。😢 # 何謂虛擬化技術？ 而虛擬化要做的就是模擬出一個環境，讓程式可以在不同硬體或作業系統上執行時，都以為自己在同一個環境中執行，以此來避免前面所述的問題。 目前常見用來比較的虛擬化技術有兩種: 在系統層級的虛擬化技術，稱虛擬機器（Virtual machine） 例如 : Virtual Box 。 在作業系統層級技術，此稱容器（Container） 例如 : Docker 。 # 虛擬機器 以作業系統為中心 傳統虛擬化的目標： 將一個應用程式所需的執行環境打包起來，建立一個獨立環境，方便在不同的硬體中移動。 虛擬機器是在系統層上虛擬化， 簡單來說， Virtual Box 就是一個可以讓你在作業系統（Host OS）上面再裝一個作業系統（Guest OS），然後讓兩個作業系統彼此不會打架的平台。 # 容器 以應用程式為中心 容器化的目標： 改善虛擬機器因為需要裝 Guest OS 導致啟動慢、佔較大記憶體的問題。 容器是在作業系統層上虛擬化， 透過 Container Manager 直接將一個應用程式所需的程式碼、函式庫打包， 建立資源控管機制隔離各個容器，並分配 Host OS 上的系統資源。 透過容器，應用程式不需要再另外安裝作業系統（Guest OS）也可以執行。 # VM vs. CONTAINER","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Docker","slug":"computer-science/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Docker/"}]},{"title":"Docker Information","slug":"computer-science/Docker/Docker-Information","date":"2023-05-16T07:52:43.000Z","updated":"2023-05-16T13:49:24.214Z","comments":true,"path":"computer-science/Docker/Docker-Information/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Docker/Docker-Information/","excerpt":"","text":"# 簡介 # 什麼是 Docker? Docker 是一個開源軟體，出現於 2013 年初，最初是 Dotcloud 公司內部的 Side-Project。 它基於 Google 公司推出的 Go 語言實作。(Dotcloud 公司後來改名為 Docker) # 為什麼要使用 Docker? 更有效率的利用資源 統一環境 對於 DevOps 的好處 使開發高效且可以預測 消除了重複的、平凡的配置任務，在整個開發生命週期中用於快速、簡單和可移植的應用程序開發。 Docker 想解決的問題: 改善傳統虛擬機器因為需要額外安裝作業系統（Guest OS），導致啟動慢、佔較大記憶體的問題。 Docker 要提供的解法： 以應用程式為核心虛擬化，取代傳統需要 Guest OS 的虛擬化技術。 # 概念 Docker 是一種工具，可用來建立、部署及執行使用容器的應用程式。 容器可讓開發人員封裝含有其所需全部元件 (程式庫、架構、相依性等) 的應用程式，且全部以一個套件的形式出貨。 使用容器可確保應用程式會以相同的方式執行，而不管任何自訂的設定或先前在執行該應用程式的電腦 (可能與用來撰寫和測試應用程式程式碼的電腦不同) 上安裝的程式庫。 這可讓開發人員專注於撰寫程式碼，而不需擔心程式碼將在其上執行的系統。 # Docker 三元素 要使用 Docker 時最重要的三個元素： 映像檔 (Image)、 容器 (Container)、 倉庫 (Repository)。 用一個簡單的比喻來解釋 : 如果映像檔是一個做蛋糕的模具，容器則是用該模具烤出來的蛋糕，而倉庫是用來集中放置模具們的收納櫃。 # Image 映像檔為一個唯獨的模板。 內可包含完整的 ubuntu 作業系統環境。 映像檔可用來快速生產 Docker 容器，並可重複產生。 映像檔可以透過 (撰寫由命令行構成的) Dockerfile 建立，或是開放公開下載的地方取得。 舉例來說，如果我今天想要一個 node.js 的執行環境跑我寫好的程式，我可以直接到上 Docker Hub 找到相對應的 node.js 映像檔 ，而不需要自己想辦法打包一個執行環境。 它是 Docker 的映像檔主要是一個唯讀的檔案， 是啟動 Docker container 要使用到的檔案。 另外 Docker 的 image 可以像是堆積木一樣， 一層一層的把 Docker image 堆起來。 如右圖： # Container 容器是由映像檔建立出來的實例。 Docker 即是利用容器來執行關鍵技術。 容器可以被啟動、開始、停止、刪除。 且容器與容器之間是相互隔離、保證安全的。 可以把容器看做是一個執行的應用程式加上執行它的簡易版 Linux 環境（包括 root 使用者權限、程式空間、使用者空間和網路空間等） Docker Container 是透過 Docker image 執行起來的 Process，同一個 Docker image 可以啟動多個 Docker Container。 Docker container 和 Docker container 之間的環境是隔離開離來的，不會發生 container1 開 8080 的 port，container2 開 8080 的 port 有衝到的問題 # Repository 倉庫是集中存放映像檔檔案的場所，每個倉庫中又包含了多個映像檔。 每個映像檔有不同的標籤（tag）。 倉庫分為公開倉庫（Public）和私有倉庫（Private）兩種形式 而最大的公開倉庫為 Docker Hub，裡面存放了大量的現成、實用映像檔供使用者下載。 而 Docker 倉庫註冊伺服器的概念就跟 Github 類似，你可以在上面建立多個倉庫，然後透過 push、pull 的方式上傳、存取。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Docker","slug":"computer-science/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Docker/"}]},{"title":"2637. Promise Time Limit","slug":"coding/leetcode/Easy/2637-Promise-Time-Limit","date":"2023-05-16T07:21:24.000Z","updated":"2023-05-16T07:46:48.302Z","comments":true,"path":"coding/leetcode/Easy/2637-Promise-Time-Limit/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2637-Promise-Time-Limit/","excerpt":"","text":"⭐️ # 題目敘述 Given an asyncronous function fn and a time t in milliseconds, return a new time limited version of the input function. A time limited function is a function that is identical to the original unless it takes longer than t milliseconds to fullfill. In that case, it will reject with &quot;Time Limit Exceeded&quot; . Note that it should reject with a string, not an Error . # Example 1 Input: fn = async (n) =&gt; { await new Promise(res =&gt; setTimeout(res, 100)); return n * n; } inputs = [5] t = 50 Output: {&quot;rejected&quot;:&quot;Time Limit Exceeded&quot;,&quot;time&quot;:50} Explanation: The provided function is set to resolve after 100ms. However, the time limit is set to 50ms. It rejects at t=50ms because the time limit was reached. # Example 2 Input: fn = async (n) =&gt; { await new Promise(res =&gt; setTimeout(res, 100)); return n * n; } inputs = [5] t = 150 Output: {&quot;resolved&quot;:25,&quot;time&quot;:100} Explanation: The function resolved 5 * 5 = 25 at t=100ms. The time limit is never reached. # Example 3 Input: fn = async (a, b) =&gt; { await new Promise(res =&gt; setTimeout(res, 120)); return a + b; } inputs = [5,10] t = 150 Output: {&quot;resolved&quot;:15,&quot;time&quot;:120} Explanation: The function resolved 5 + 10 = 15 at t=120ms. The time limit is never reached. # Example 4 Input: fn = async () =&gt; { throw &quot;Error&quot;; } inputs = [] t = 1000 Output: {&quot;rejected&quot;:&quot;Error&quot;,&quot;time&quot;:0} Explanation: The function immediately throws an error. # 解題思路 Promise.race([arr]); : race 中的陣列哪一個 Function 先跑完，return 該 Function。 # Solution /** * @param &#123;Function&#125; fn * @param &#123;number&#125; t * @return &#123;Function&#125; */var timeLimit = function(fn, t) &#123; return async function(...args) &#123; const timeout = new Promise((resolved, reject) => &#123; setTimeout(() => reject(\"Time Limit Exceeded\"), t); &#125;); return Promise.race([fn(...args), timeout]); &#125;&#125;;/** * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100); * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms */ type Fn = (...params: any[]) => Promise&lt;any>;function timeLimit(fn: Fn, t: number): Fn &#123; return async function(...args) &#123; const timeout: Promise&lt;any> = new Promise((resolved: any, reject: any) => &#123; setTimeout(() => reject(\"Time Limit Exceeded\"), t); &#125;); return Promise.race([fn(...args), timeout]); &#125;&#125;;/** * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100); * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"24. Swap Nodes in Pairs","slug":"coding/leetcode/Medium/24-Swap-Nodes-in-Pairs","date":"2023-05-16T06:38:14.000Z","updated":"2023-05-16T07:07:06.878Z","comments":true,"path":"coding/leetcode/Medium/24-Swap-Nodes-in-Pairs/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/24-Swap-Nodes-in-Pairs/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.) # Example 1 Input: head = [1,2,3,4] Output: [2,1,4,3] # Example 2 Input: head = [] Output: [] # Example 3 Input: head = [1] Output: [1] # 解題思路 # Solution // Definition for singly-linked list.public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode ans = new ListNode(0); ans.next = head; ListNode curr = ans; while (curr.next != null &amp;&amp; curr.next.next != null) &#123; ListNode first = curr.next; ListNode second = curr.next.next; curr.next = second; first.next = second.next; second.next = first; curr = curr.next.next; &#125; return ans.next; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Linked-List/"},{"name":"Recursion","slug":"Recursion","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Recursion/"}]},{"title":"2621. Sleep","slug":"coding/leetcode/Easy/2621-Sleep","date":"2023-05-15T02:35:00.000Z","updated":"2023-05-15T03:29:49.778Z","comments":true,"path":"coding/leetcode/Easy/2621-Sleep/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2621-Sleep/","excerpt":"","text":"⭐️ # 題目敘述 Given a positive integer millis , write an asyncronous function that sleeps for millis milliseconds. It can resolve any value. # Example 1 Input: millis = 100 Output: 100 Explanation: It should return a promise that resolves after 100ms. let t = Date.now(); sleep(100).then(() =&gt; { console.log(Date.now() - t); // 100 }); # Example 2 Input: millis = 200 Output: 200 Explanation: It should return a promise that resolves after 200ms. # 解題思路 # Solution /** * @param &#123;number&#125; millis */async function sleep(millis) &#123; return new Promise(function(val)&#123; return setTimeout(val, millis); &#125;);&#125;/** * let t = Date.now() * sleep(100).then(() => console.log(Date.now() - t)) // 100 */ async function sleep(millis: number): Promise&lt;void> &#123; return new Promise(function(val: any): any&#123; return setTimeout(val, millis); &#125;);&#125;/** * let t = Date.now() * sleep(100).then(() => console.log(Date.now() - t)) // 100 */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"1721. Swapping Nodes in a Linked List","slug":"coding/leetcode/Medium/1721-Swapping-Nodes-in-a-Linked-List","date":"2023-05-15T01:48:06.000Z","updated":"2023-05-15T02:48:07.229Z","comments":true,"path":"coding/leetcode/Medium/1721-Swapping-Nodes-in-a-Linked-List/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1721-Swapping-Nodes-in-a-Linked-List/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given the head of a linked list, and an integer k . Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed). # Example 1 Input: head = [1,2,3,4,5], k = 2 Output: [1,4,3,2,5] # Example 2 Input: head = [7,9,6,6,7,8,3,0,9,5], k = 5 Output: [7,9,6,6,8,7,3,0,9,5] # 解題思路 # Solution // Definition for singly-linked list.public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; class Solution &#123; public ListNode swapNodes(ListNode head, int k) &#123; ListNode start = head, end = head; for (int i = 1; i &lt; k; i++) &#123; start = start.next; &#125; ListNode curr = start; while (curr.next != null) &#123; curr = curr.next; end = end.next; &#125; int temp = start.val; start.val = end.val; end.val = temp; return head; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Linked-List/"}]},{"title":"2666. Allow One Function Call","slug":"coding/leetcode/Easy/2666-Allow-One-Function-Call","date":"2023-05-12T03:26:20.000Z","updated":"2023-05-12T03:36:13.629Z","comments":true,"path":"coding/leetcode/Easy/2666-Allow-One-Function-Call/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2666-Allow-One-Function-Call/","excerpt":"","text":"⭐️ # 題目敘述 Given a function fn , return a new function that is identical to the original function except that it ensures fn is called at most once. The first time the returned function is called, it should return the same result as fn . Every subsequent time it is called, it should return undefined . # Example 1 Input: fn = (a,b,c) =&gt; (a + b + c), calls = [[1,2,3],[2,3,6]] Output: [{&quot;calls&quot;:1,&quot;value&quot;:6}] Explanation: const onceFn = once(fn); onceFn(1, 2, 3); // 6 onceFn(2, 3, 6); // undefined, fn was not called # Example 2 Input: fn = (a,b,c) =&gt; (a * b * c), calls = [[5,7,4],[2,3,6],[4,6,8]] Output: [{&quot;calls&quot;:1,&quot;value&quot;:140}] Explanation: const onceFn = once(fn); onceFn(5, 7, 4); // 140 onceFn(2, 3, 6); // undefined, fn was not called onceFn(4, 6, 8); // undefined, fn was not called # 解題思路 # Solution /** * @param &#123;Function&#125; fn * @return &#123;Function&#125; */var once = function(fn) &#123; let isCall = false; return function(...args)&#123; if(!isCall)&#123; isCall = true; return fn(...args); &#125; &#125;&#125;;/** * let fn = (a,b,c) => (a + b + c) * let onceFn = once(fn) * * onceFn(1,2,3); // 6 * onceFn(2,3,6); // returns undefined without calling fn */ function once&lt;T extends (...args: any[]) => any>(fn: T): ((...args: Parameters&lt;T>) => ReturnType&lt;T> | undefined) &#123; let isCall: Boolean = false; return function (...args) &#123; if(!isCall)&#123; isCall = true; return fn(...args); &#125; &#125;;&#125;/** * let fn = (a,b,c) => (a + b + c) * let onceFn = once(fn) * * onceFn(1,2,3); // 6 * onceFn(2,3,6); // returns undefined without calling fn */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"2140. Solving Questions With Brainpower","slug":"coding/leetcode/Medium/2140-Solving-Questions-With-Brainpower","date":"2023-05-12T02:48:50.000Z","updated":"2023-05-12T03:25:17.741Z","comments":true,"path":"coding/leetcode/Medium/2140-Solving-Questions-With-Brainpower/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2140-Solving-Questions-With-Brainpower/","excerpt":"","text":"⭐️ # 題目敘述 You are given a 0-indexed 2D integer array questions where questions[i] = [pointsi, brainpoweri] . The array describes the questions of an exam, where you have to process the questions in order (i.e., starting from question 0 ) and make a decision whether to solve or skip each question. Solving question i will earn you pointsi points but you will be unable to solve each of the next brainpoweri questions. If you skip question i , you get to make the decision on the next question. For example, given questions = [[3, 2], [4, 3], [4, 4], [2, 5]] : If question 0 is solved, you will earn 3 points but you will be unable to solve questions 1 and 2 . If instead, question 0 is skipped and question 1 is solved, you will earn 4 points but you will be unable to solve questions 2 and 3 . Return the maximum points you can earn for the exam. # Example 1: Input: questions = [[3,2],[4,3],[4,4],[2,5]] Output: 5 Explanation: The maximum points can be earned by solving questions 0 and 3. Solve question 0: Earn 3 points, will be unable to solve the next 2 questions Unable to solve questions 1 and 2 Solve question 3: Earn 2 points Total points earned: 3 + 2 = 5. There is no other way to earn 5 or more points. # Example 2: Input: questions = [[1,1],[2,2],[3,3],[4,4],[5,5]] Output: 7 Explanation: The maximum points can be earned by solving questions 1 and 4. Skip question 0 Solve question 1: Earn 2 points, will be unable to solve the next 2 questions Unable to solve questions 2 and 3 Solve question 4: Earn 5 points Total points earned: 2 + 5 = 7. There is no other way to earn 7 or more points. # 解題思路 # Solution class Solution &#123; public long mostPoints(int[][] questions) &#123; int n = questions.length; long[] dp = new long[n]; dp[n - 1] = questions[n - 1][0]; for (int i = n - 2; i >= 0; --i) &#123; dp[i] = questions[i][0]; int skip = questions[i][1]; if (i + skip + 1 &lt; n) &#123; dp[i] += dp[i + skip + 1]; &#125; // dp[i] = max(solve it, skip it) dp[i] = Math.max(dp[i], dp[i + 1]); &#125; return dp[0]; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"2629. Function Composition","slug":"coding/leetcode/Easy/2629-Function-Composition","date":"2023-05-11T01:58:09.000Z","updated":"2023-05-11T02:56:40.241Z","comments":true,"path":"coding/leetcode/Easy/2629-Function-Composition/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2629-Function-Composition/","excerpt":"","text":"⭐️ # 題目敘述 Given an array of functions [f1, f2, f3, ..., fn] , return a new function fn that is the function composition of the array of functions. The function composition of [f(x), g(x), h(x)] is fn(x) = f(g(h(x))) . The function composition of an empty list of functions is the identity function f(x) = x . You may assume each function in the array accepts one integer as input and returns one integer as output. # Example 1 Input: functions = [x =&gt; x + 1, x =&gt; x * x, x =&gt; 2 * x], x = 4 Output: 65 Explanation: Evaluating from right to left ... Starting with x = 4. 2 * (4) = 8 (8) * (8) = 64 (64) + 1 = 65 # Example 2 Input: functions = [x =&gt; 10 * x, x =&gt; 10 * x, x =&gt; 10 * x], x = 1 Output: 1000 Explanation: Evaluating from right to left ... 10 * (1) = 10 10 * (10) = 100 10 * (100) = 1000 # Example 3 Input: functions = [], x = 42 Output: 42 Explanation: The composition of zero functions is the identity function # 解題思路 # Solution /** * @param &#123;Function[]&#125; functions * @return &#123;Function&#125; */var compose = function(functions) &#123; return function(x) &#123; functions.reverse().foreach(fn => &#123; x = fn(x) &#125;); return x; &#125;&#125;;/** * const fn = compose([x => x + 1, x => 2 * x]) * fn(4) // 9 */ type F = (x: number) => number;function compose(functions: F[]): F &#123; return function(x): number &#123; functions.reverse().forEach((fn: F) => &#123; x = fn(x); &#125;); return x; &#125;&#125;;/** * const fn = compose([x => x + 1, x => 2 * x]) * fn(4) // 9 */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"1035. Uncrossed Lines","slug":"coding/leetcode/Medium/1035-Uncrossed-Lines","date":"2023-05-11T01:31:10.000Z","updated":"2023-05-11T05:36:54.713Z","comments":true,"path":"coding/leetcode/Medium/1035-Uncrossed-Lines/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1035-Uncrossed-Lines/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given two integer arrays nums1 and nums2 . We write the integers of nums1 and nums2 (in the order they are given) on two separate horizontal lines. We may draw connecting lines: a straight line connecting two numbers nums1[i] and nums2[j] such that: nums1[i] == nums2[j] , and the line we draw does not intersect any other connecting (non-horizontal) line. Note that a connecting line cannot intersect even at the endpoints (i.e., each number can only belong to one connecting line). Return the maximum number of connecting lines we can draw in this way. # Example 1: ![](https://hackmd.io/_uploads/rkIjNpKN3.png =400x) Input: nums1 = [1,4,2], nums2 = [1,2,4] Output: 2 Explanation: We can draw 2 uncrossed lines as in the diagram. We cannot draw 3 uncrossed lines, because the line from nums1[1] = 4 to nums2[2] = 4 will intersect the line from nums1[2]=2 to nums2[1]=2. # Example 2: Input: nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2] Output: 3 # Example 3: Input: nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1] Output: 2 # 解題思路 # Solution class Solution &#123; public int maxUncrossedLines(int[] nums1, int[] nums2) &#123; int n = nums1.length, m = nums2.length; int[][] dp = new int[n + 1][m + 1]; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; dp[i][j] = (nums1[i - 1] == nums2[j - 1] ? 1 + dp[i - 1][j - 1] : Math.max(dp[i][j - 1], dp[i - 1][j])); &#125; &#125; return dp[n][m]; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"function vs. feature","slug":"language/english/單字/function-vs-feature","date":"2023-05-10T06:50:14.000Z","updated":"2023-05-10T07:11:44.938Z","comments":true,"path":"language/english/單字/function-vs-feature/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/language/english/%E5%96%AE%E5%AD%97/function-vs-feature/","excerpt":"","text":"⭐️ 當我們想要用英文表達「功能」這個概念的時候，到底該用 &quot;function&quot; 還是 &quot;feature&quot; 呢？ # function (n.) 功能，用途；職責 the natural purpose (of something) or the duty (of a person) 指的是有目的的特定功能，比方說一項服務或產品的用途，多為基本功能的描述，如洗衣機可以洗脫烘衣服 The functions of our latest model of washing machine includes washing and drying your clothes. 這款最新機型的洗衣機功能包含清洗與烘乾衣物。 # feature (n.) 特色，特徵，特點 a typical quality or an important part of something feature 則是附加功能或特殊賣點，例如洗衣機可以連 wifi 和 app 搭配使用，洗衣完成會推播通知這就是為什麼商業和科技產品文案會寫 feature，不寫 function，因為 function 很容易可滿足，所有廠商都能做得到，但是 feature 卻能夠突顯出產品的與眾不同之處，吸引消費者的目光並刺激他們的購買慾。 Our latest model of washing machine has several new features such as 10 wash programs, tub clean function and delay start function etc. 我們這款洗衣機的最新機型有很多新特色，比方說 10 種洗衣模式、洗衣槽清潔功能、延遲執行等。 近義詞 attribute、characteristic，為「特色、鮮明的特徵」 # 參考文獻 https://funday.asia/blogDesktop/blog.asp?blog=412 # 這篇由來 因為我在寫 project 時，在想 git commit specification，其中就用到了 feature 和 function，但不知如何區別兩個的使用，也發現了其實在寫軟體專案時，還蠻喜歡用 feature 的。","categories":[{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"單字","slug":"language/english/單字","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E5%96%AE%E5%AD%97/"}],"tags":[{"name":"英文單字","slug":"英文單字","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E5%96%AE%E5%AD%97/"},{"name":"難度 1","slug":"難度-1","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-1/"}]},{"title":"2626. Array Reduce Transformation","slug":"coding/leetcode/Easy/2626-Array-Reduce-Transformation","date":"2023-05-10T01:49:13.000Z","updated":"2023-05-10T02:46:49.860Z","comments":true,"path":"coding/leetcode/Easy/2626-Array-Reduce-Transformation/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2626-Array-Reduce-Transformation/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer array nums , a reducer function fn , and an initial value init , return a reduced array. A reduced array is created by applying the following operation: val = fn(init, nums[0]) , val = fn(val, nums[1]) , val = fn(val, nums[2]) , ... until every element in the array has been processed. The final value of val is returned. If the length of the array is 0, it should return init . Please solve it without using the built-in Array.reduce method. # Example 1 Input: nums = [1,2,3,4] fn = function sum(accum, curr) { return accum + curr; } init = 0 Output: 10 Explanation: initially, the value is init=0. (0) + nums[0] = 1 (1) + nums[1] = 3 (3) + nums[2] = 6 (6) + nums[3] = 10 The final answer is 10. # Example 2: Input: nums = [1,2,3,4] fn = function sum(accum, curr) { return accum + curr * curr; } init = 100 Output: 130 Explanation: initially, the value is init=100. (100) + nums[0]^2 = 101 (101) + nums[1]^2 = 105 (105) + nums[2]^2 = 114 (114) + nums[3]^2 = 130 The final answer is 130. # Example 3: Input: nums = [] fn = function sum(accum, curr) { return 0; } init = 25 Output: 25 Explanation: For empty arrays, the answer is always init. # 解題思路 # Solution /** * @param &#123;number[]&#125; nums * @param &#123;Function&#125; fn * @param &#123;number&#125; init * @return &#123;number&#125; */var reduce = function(nums, fn, init) &#123; nums.forEach(function(num)&#123; init = fn(init, num); &#125;); return init;&#125;; type Fn = (accum: number, curr: number) => numberfunction reduce(nums: number[], fn: Fn, init: number): number &#123; nums.forEach(function(num)&#123; init = fn(init, num); &#125;); return init;&#125;; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"59. Spiral Matrix II","slug":"coding/leetcode/Medium/59-Spiral-Matrix-II","date":"2023-05-10T01:32:58.000Z","updated":"2023-05-10T01:46:46.992Z","comments":true,"path":"coding/leetcode/Medium/59-Spiral-Matrix-II/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/59-Spiral-Matrix-II/","excerpt":"","text":"⭐️ # 題目敘述 Given a positive integer n , generate an n x n matrix filled with elements from 1 to n^2 in spiral order. # Example 1: Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]] # Example 2: Input: n = 1 Output: [[1]] # 解題思路 # Solution class Solution &#123; public int[][] generateMatrix(int n) &#123; int[][] ans = new int[n][n]; int count = 1; int left = 0, right = n - 1, top = 0, bottom = n - 1; while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123; for (int i = left; i &lt;= right; i++) &#123; ans[top][i] = count++; &#125; top++; for (int i = top; i &lt;= bottom; i++) &#123; ans[i][right] = count++; &#125; right--; if (top &lt;= bottom) &#123; for (int i = right; i >= left; i--) &#123; ans[bottom][i] = count++; &#125; bottom--; &#125; if (left &lt;= right) &#123; for (int i = bottom; i >= top; i--) &#123; ans[i][left] = count++; &#125; left++; &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"}]},{"title":"俄國的計畫是什麼？","slug":"language/english/新聞/俄國的計畫是什麼？","date":"2023-05-09T05:48:04.000Z","updated":"2023-05-09T07:08:04.419Z","comments":true,"path":"language/english/新聞/俄國的計畫是什麼？/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/language/english/%E6%96%B0%E8%81%9E/%E4%BF%84%E5%9C%8B%E7%9A%84%E8%A8%88%E7%95%AB%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9F/","excerpt":"","text":"⭐️⭐️ # 俄國的計畫是什麼？ 俄羅斯在入侵烏克蘭幾週後終於看清自己的能力，他們的軍隊無法在三天內佔領基輔。 相反，俄國軍隊面臨頑強的抵抗，戰爭已經拖延了一年。後續可能會如何發展呢？ # What each side wants Russia’s leadership no longer appears to be trying to oust Ukrainian president Volodymyr Zelensky from power. Instead, the short-term goal seems to be gaining control over the territories Russia annexed last fall. Putin has said he’s open to negotiations, while Russian troops continue to attack Ukraine’s cities. 單字 oust 驅逐、推翻 常見組合 short-term goal 短期目標 單字 annex 併吞 片語動詞 open to something 願意接受某東西 I'm open to discussing the possibility of a discount. # What’s to come? Military experts warn that the situation could morph into a stalemate and the war might drag on for months or even years, with neither side able to make any significant progress. 單字 morph 轉化為 單字 stalemate 僵局 片語動詞 drag on 拖延 The war could drag on for years. 單字 gaining 取得 to get something that is useful, that gives you an advantage, or that is in some way positive, especially over a period of time territories 領土 (an area of) land, or sometimes sea, that is considered as belonging to or connected with a particular country or person negotiations 談判 the process of discussing something with someone in order to reach an agreement with them, or the discussions themselves troops 軍隊 n. soldiers on duty in a large group military 軍隊的 adj. relating to or belonging to the armed forces experts 專家 a person with a high level of knowledge or skill relating to a particular subject or activity significant 重要的 important or noticeable 片語 & 搭配詞 Instead 反而；替代","categories":[{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"新聞","slug":"language/english/新聞","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E6%96%B0%E8%81%9E/"}],"tags":[{"name":"英文新聞","slug":"英文新聞","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E6%96%B0%E8%81%9E/"},{"name":"難度 2","slug":"難度-2","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-2/"}]},{"title":"2634. Filter Elements from Array","slug":"coding/leetcode/Easy/2634-Filter-Elements-from-Array","date":"2023-05-09T05:25:29.000Z","updated":"2023-05-09T05:33:53.226Z","comments":true,"path":"coding/leetcode/Easy/2634-Filter-Elements-from-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2634-Filter-Elements-from-Array/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer array arr and a filtering function fn , return a new array with a fewer or equal number of elements. The returned array should only contain elements where fn(arr[i], i) evaluated to a truthy value. Please solve it without the built-in Array.filter method. # Example 1: Input: arr = [0,10,20,30], fn = function greaterThan10(n) { return n &gt; 10; } Output: [20,30] Explanation: const newArray = filter(arr, fn); // [20, 30] The function filters out values that are not greater than 10 # Example 2: Input: arr = [1,2,3], fn = function firstIndex(n, i) { return i === 0; } Output: [1] Explanation: fn can also accept the index of each element In this case, the function removes elements not at index 0 # Example 3: Input: arr = [-2,-1,0,1,2], fn = function plusOne(n) { return n + 1 } Output: [-2,0,1,2] Explanation: Falsey values such as 0 should be filtered out # 解題思路 # Solution /** * @param &#123;number[]&#125; arr * @param &#123;Function&#125; fn * @return &#123;number[]&#125; */var filter = function(arr, fn) &#123; let ans = []; for (let i=0; i&lt;arr.length; i++) &#123; if (fn(arr[i], i))&#123; ans.push(arr[i]); &#125; &#125; return ans;&#125;; function filter(arr: number[], fn: (n: number, i: number) => any): number[] &#123; const ans: number[] = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (fn(arr[i], i))&#123; ans.push(arr[i]); &#125; &#125; return ans;&#125;; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"54. Spiral Matrix","slug":"coding/leetcode/Medium/54-Spiral-Matrix","date":"2023-05-09T04:53:03.000Z","updated":"2023-05-09T05:24:26.282Z","comments":true,"path":"coding/leetcode/Medium/54-Spiral-Matrix/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/54-Spiral-Matrix/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given an m x n matrix , return all elements of the matrix in spiral order. # Example 1: Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [1,2,3,6,9,8,7,4,5] # Example 2: Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] Output: [1,2,3,4,8,12,11,10,9,5,6,7] # 解題思路 # Solution import java.util.ArrayList;import java.util.List;class Solution &#123; public List&lt;Integer> spiralOrder(int[][] matrix) &#123; int rows = matrix.length; int cols = matrix[0].length; List&lt;Integer> ans = new ArrayList&lt;>(); if (rows == 0) &#123; return ans; &#125; int left = 0, right = cols - 1, top = 0, bottom = rows - 1; while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123; for (int i = left; i &lt;= right; i++) &#123; ans.add(matrix[top][i]); &#125; top++; for (int i = top; i &lt;= bottom; i++) &#123; ans.add(matrix[i][right]); &#125; right--; if (top &lt;= bottom) &#123; for (int i = right; i >= left; i--) &#123; ans.add(matrix[bottom][i]); &#125; bottom--; &#125; if (left &lt;= right) &#123; for (int i = bottom; i >= top; i--) &#123; ans.add(matrix[i][left]); &#125; left++; &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"}]},{"title":"2635. Apply Transform Over Each Element in Array","slug":"coding/leetcode/Easy/2635-Apply-Transform-Over-Each-Element-in-Array","date":"2023-05-08T02:04:46.000Z","updated":"2023-05-08T03:02:09.827Z","comments":true,"path":"coding/leetcode/Easy/2635-Apply-Transform-Over-Each-Element-in-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2635-Apply-Transform-Over-Each-Element-in-Array/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer array arr and a mapping function fn , return a new array with a transformation applied to each element. The returned array should be created such that returnedArray[i] = fn(arr[i], i) . Please solve it without the built-in Array.map method. # Example 1: Input: arr = [1,2,3], fn = function plusone(n) { return n + 1; } Output: [2,3,4] Explanation: const newArray = map(arr, plusone); // [2,3,4] The function increases each value in the array by one. # Example 2: Input: arr = [1,2,3], fn = function plusI(n, i) { return n + i; } Output: [1,3,5] Explanation: The function increases each value by the index it resides in. # Example 3: Input: arr = [10,20,30], fn = function constant() { return 42; } Output: [42,42,42] Explanation: The function always returns 42. # 解題思路 # Solution /** * @param &#123;number[]&#125; arr * @param &#123;Function&#125; fn * @return &#123;number[]&#125; */var map = function(arr, fn) &#123; return arr.map((val, index) => val = fn(val, index));&#125;; function map(arr: number[], fn: (n: number, i: number) => number): number[] &#123; return arr.map((val: number, idx: number) => val = fn(val, idx));&#125;; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"1572. Matrix Diagonal Sum","slug":"coding/leetcode/Easy/1572-Matrix-Diagonal-Sum","date":"2023-05-08T01:28:16.000Z","updated":"2023-05-08T02:04:21.856Z","comments":true,"path":"coding/leetcode/Easy/1572-Matrix-Diagonal-Sum/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1572-Matrix-Diagonal-Sum/","excerpt":"","text":"⭐️⭐️ # 題目敘述 Given a square matrix mat , return the sum of the matrix diagonals. Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal. # Example 1: Input: mat = [[1,2,3], [4,5,6], [7,8,9]] Output: 25 Explanation: Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25 Notice that element mat[1][1] = 5 is counted only once. # Example 2: Input: mat = [[1,1,1,1], [1,1,1,1], [1,1,1,1], [1,1,1,1]] Output: 8 # Example 3: Input: mat = [[5]] Output: 5 # 解題思路 # Solution class Solution &#123; public int diagonalSum(int[][] mat) &#123; int m = mat.length - 1; int ans = 0; for(int i = 0; i &lt;= m; i++)&#123; ans += mat[i][i]; ans += mat[i][m - i]; &#125; if(m % 2 == 0)&#123; ans -= mat[m / 2][m / 2]; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"}]},{"title":"2665. Counter II","slug":"coding/leetcode/Easy/2665-Counter-II","date":"2023-05-07T12:04:22.000Z","updated":"2023-05-07T12:15:46.488Z","comments":true,"path":"coding/leetcode/Easy/2665-Counter-II/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2665-Counter-II/","excerpt":"","text":"⭐️ # 題目敘述 Write a function createCounter . It should accept an initial integer init . It should return an object with three functions. The three functions are: increment() increases the current value by 1 and then returns it. decrement() reduces the current value by 1 and then returns it. reset() sets the current value to init and then returns it. # Example 1: Input: init = 5, calls = [&quot;increment&quot;,&quot;reset&quot;,&quot;decrement&quot;] Output: [6,5,4] Explanation: const counter = createCounter(5); counter.increment(); // 6 counter.reset(); // 5 counter.decrement(); // 4 # Example 2: Input: init = 0, calls = [&quot;increment&quot;,&quot;increment&quot;,&quot;decrement&quot;,&quot;reset&quot;,&quot;reset&quot;] Output: [1,2,1,0,0] Explanation: const counter = createCounter(0); counter.increment(); // 1 counter.increment(); // 2 counter.decrement(); // 1 counter.reset(); // 0 counter.reset(); // 0 # 解題思路 # Solution /** * @param &#123;integer&#125; init * @return &#123; increment: Function, decrement: Function, reset: Function &#125; */var createCounter = function(init) &#123; let counter = init; const increment = () => counter += 1; const decrement = () => counter -= 1; const reset = () => counter = init; return&#123;increment, decrement, reset&#125;;&#125;;/** * const counter = createCounter(5) * counter.increment(); // 6 * counter.reset(); // 5 * counter.decrement(); // 4 */ type ReturnObj = &#123; increment: () => number, decrement: () => number, reset: () => number,&#125;function createCounter(init: number): ReturnObj &#123; let counter: number = init; const increment = (): number => counter += 1; const decrement = (): number => counter -= 1; const reset = (): number => counter = init; return &#123;increment, decrement, reset&#125;;&#125;;/** * const counter = createCounter(5) * counter.increment(); // 6 * counter.reset(); // 5 * counter.decrement(); // 4 */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"1964. Find the Longest Valid Obstacle Course at Each Position","slug":"coding/leetcode/Hard/1964-Find-the-Longest-Valid-Obstacle-Course-at-Each-Position","date":"2023-05-07T08:40:52.000Z","updated":"2023-05-07T10:55:22.000Z","comments":true,"path":"coding/leetcode/Hard/1964-Find-the-Longest-Valid-Obstacle-Course-at-Each-Position/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/1964-Find-the-Longest-Valid-Obstacle-Course-at-Each-Position/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 You want to build some obstacle courses. You are given a 0-indexed integer array obstacles of length n , where obstacles[i] describes the height of the ith obstacle. For every index i between 0 and n - 1 (inclusive), find the length of the longest obstacle course in obstacles such that: You choose any number of obstacles between 0 and i inclusive. You must include the ith obstacle in the course. You must put the chosen obstacles in the same order as they appear in obstacles . Every obstacle (except the first) is taller than or the same height as the obstacle immediately before it. Return an array ans of length n , where ans[i] is the length of the longest obstacle course for index i as described above. # Example 1: Input: obstacles = [1,2,3,2] Output: [1,2,3,3] Explanation: The longest valid obstacle course at each position is: i = 0: [1], [1] has length 1. i = 1: [1,2], [1,2] has length 2. i = 2: [1,2,3], [1,2,3] has length 3. i = 3: [1,2,3,2], [1,2,2] has length 3. # Example 2: Input: obstacles = [2,2,1] Output: [1,2,1] Explanation: The longest valid obstacle course at each position is: i = 0: [2], [2] has length 1. i = 1: [2,2], [2,2] has length 2. i = 2: [2,2,1], [1] has length 1. # Example 3: Input: obstacles = [3,1,5,6,4,2] Output: [1,1,2,3,2,2] Explanation: The longest valid obstacle course at each position is: i = 0: [3], [3] has length 1. i = 1: [3,1], [1] has length 1. i = 2: [3,1,5], [3,5] has length 2. [1,5] is also valid. i = 3: [3,1,5,6], [3,5,6] has length 3. [1,5,6] is also valid. i = 4: [3,1,5,6,4], [3,4] has length 2. [1,4] is also valid. i = 5: [3,1,5,6,4,2], [1,2] has length 2. # 解題思路 # Solution class Solution &#123; public int[] longestObstacleCourseAtEachPosition(int[] obstacles) &#123; int n = obstacles.length; int length = 0; int[] result = new int[n]; int[] sub = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; int left = 0, right = length; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (sub[mid] &lt;= obstacles[i]) left = mid + 1; else right = mid; &#125; result[i] = left + 1; if (length == left) length++; sub[left] = obstacles[i]; &#125; return result; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Binary Indexed Tree","slug":"Binary-Indexed-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Indexed-Tree/"}]},{"title":"1498. Number of Subsequences That Satisfy the Given Sum Condition","slug":"coding/leetcode/Medium/1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition","date":"2023-05-06T05:21:16.000Z","updated":"2023-05-06T09:28:17.967Z","comments":true,"path":"coding/leetcode/Medium/1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an array of integers nums and an integer target . Return the number of non-empty subsequences of nums such that the sum of the minimum and maximum element on it is less or equal to target . Since the answer may be too large, return it modulo 10^9 + 7 . # Example 1: Input: nums = [3,5,6,7], target = 9 Output: 4 Explanation: There are 4 subsequences that satisfy the condition. [3] -&gt; Min value + max value &lt;= target (3 + 3 &lt;= 9) [3,5] -&gt; (3 + 5 &lt;= 9) [3,5,6] -&gt; (3 + 6 &lt;= 9) [3,6] -&gt; (3 + 6 &lt;= 9) # Example 2: Input: nums = [3,3,6,8], target = 10 Output: 6 Explanation: There are 6 subsequences that satisfy the condition. (nums can have repeated numbers). [3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6] # Example 3: Input: nums = [2,3,3,4,6,7], target = 12 Output: 61 Explanation: There are 63 non-empty subsequences, two of them do not satisfy the condition ([6,7], [7]). Number of valid subsequences (63 - 2 = 61). # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public int numSubseq(int[] nums, int target) &#123; int n = nums.length; int mod = 1000000007; int ans = 0; Arrays.sort(nums); int[] count = new int[n]; count[0] = 1; for (int i = 1; i &lt; n; i++) &#123; count[i] = (count[i - 1] * 2) % mod; &#125; int left = 0, right = n - 1; while (left &lt;= right) &#123; if (nums[left] + nums[right] &lt;= target) &#123; ans = (ans + count[right - left]) % mod; left++; &#125; else &#123; right--; &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"}]},{"title":"2620. Counter","slug":"coding/leetcode/Easy/2620-Counter","date":"2023-05-06T03:23:28.000Z","updated":"2023-05-06T05:18:06.954Z","comments":true,"path":"coding/leetcode/Easy/2620-Counter/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2620-Counter/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer n , return a counter function. This counter function initially returns n and then returns 1 more than the previous value every subsequent time it is called ( n , n + 1 , n + 2 , etc). # Example 1: Input: n = 10 [&quot;call&quot;,&quot;call&quot;,&quot;call&quot;] Output: [10,11,12] Explanation: counter() = 10 // The first time counter() is called, it returns n. counter() = 11 // Returns 1 more than the previous time. counter() = 12 // Returns 1 more than the previous time. # Example 2: Input: n = -2 [&quot;call&quot;,&quot;call&quot;,&quot;call&quot;,&quot;call&quot;,&quot;call&quot;] Output: [-2,-1,0,1,2] Explanation: counter() initially returns -2. Then increases after each sebsequent call. # 解題思路 # Solution /** * @param &#123;number&#125; n * @return &#123;Function&#125; counter */var createCounter = function(n) &#123; let counter = n - 1; return function() &#123; counter += 1; return counter; &#125;;&#125;;/** * const counter = createCounter(10) * counter() // 10 * counter() // 11 * counter() // 12 */ function createCounter(n: number): () => number &#123; let counter = n - 1; return function() &#123; counter += 1; return counter; &#125;&#125;/** * const counter = createCounter(10) * counter() // 10 * counter() // 11 * counter() // 12 */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"1456. Maximum Number of Vowels in a Substring of Given Length","slug":"coding/leetcode/Medium/1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length","date":"2023-05-05T02:32:53.000Z","updated":"2023-05-05T02:34:03.426Z","comments":true,"path":"coding/leetcode/Medium/1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length/","excerpt":"","text":"⭐️⭐️ # 題目敘述 Given a string s and an integer k , return the maximum number of vowel letters in any substring of s with length k . Vowel letters in English are 'a' , 'e' , 'i' , 'o' , and 'u' . # Example 1: Input: s = &quot;abciiidef&quot;, k = 3 Output: 3 Explanation: The substring &quot;iii&quot; contains 3 vowel letters. # Example 2: Input: s = &quot;aeiou&quot;, k = 2 Output: 2 Explanation: Any substring of length 2 contains 2 vowels. # Example 3: Input: s = &quot;leetcode&quot;, k = 3 Output: 2 Explanation: &quot;lee&quot;, &quot;eet&quot; and &quot;ode&quot; contain 2 vowels. # 解題思路 # Solution class Solution &#123; public int maxVowels(String s, int k) &#123; int ans = 0; String temp = s.substring(0, k); for (char t : temp.toCharArray()) &#123; if (isVowel(t))&#123; ans++; &#125; &#125; int cur = ans; for (int i = k; i &lt; s.length(); i++) &#123; if (isVowel(s.charAt(i))) cur++; if (isVowel(s.charAt(i - k))) cur--; ans = Math.max(ans, cur); &#125; return ans; &#125; public boolean isVowel(char c) &#123; if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') return true; return false; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"}]},{"title":"2667. Create Hello World Function","slug":"coding/leetcode/Easy/2667-Create-Hello-World-Function","date":"2023-05-05T01:26:51.000Z","updated":"2023-05-06T05:17:51.603Z","comments":true,"path":"coding/leetcode/Easy/2667-Create-Hello-World-Function/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2667-Create-Hello-World-Function/","excerpt":"","text":"⭐️ # 題目敘述 Write a function createHelloWorld . It should return a new function that always returns &quot;Hello World&quot; . # Example 1: Input: args = [] Output: &quot;Hello World&quot; Explanation: const f = createHelloWorld(); f(); // &quot;Hello World&quot; The function returned by createHelloWorld should always return &quot;Hello World&quot;. # Example 2: Input: args = [{},null,42] Output: &quot;Hello World&quot; Explanation: const f = createHelloWorld(); f({}, null, 42); // &quot;Hello World&quot; Any arguments could be passed to the function but it should still always return &quot;Hello World&quot;. # 解題思路 # Solution /** * @return &#123;Function&#125; */var createHelloWorld = function() &#123; return function(...args) &#123; return \"Hello World\"; &#125;&#125;;/** * const f = createHelloWorld(); * f(); // \"Hello World\" */ function createHelloWorld() &#123; return function(...args): string &#123; return \"Hello World\"; &#125;;&#125;;/** * const f = createHelloWorld(); * f(); // \"Hello World\" */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"649. Dota2 Senate","slug":"coding/leetcode/Medium/649-Dota2-Senate","date":"2023-05-04T01:30:30.000Z","updated":"2023-05-04T02:47:43.770Z","comments":true,"path":"coding/leetcode/Medium/649-Dota2-Senate/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/649-Dota2-Senate/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 In the world of Dota2, there are two parties: the Radiant and the Dire. The Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights: Ban one senator's right: A senator can make another senator lose all his rights in this and all the following rounds. Announce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game. Given a string senate representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party. Then if there are n senators, the size of the given string will be n . The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure. Suppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be &quot;Radiant&quot; or &quot;Dire&quot; . # Example 1: Input: senate = &quot;RD&quot; Output: &quot;Radiant&quot; Explanation: The first senator comes from Radiant and he can just ban the next senator's right in round 1. And the second senator can't exercise any rights anymore since his right has been banned. And in round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote. # Example 2: Input: senate = &quot;RDD&quot; Output: &quot;Dire&quot; Explanation: The first senator comes from Radiant and he can just ban the next senator's right in round 1. And the second senator can't exercise any rights anymore since his right has been banned. And the third senator comes from Dire and he can ban the first senator's right in round 1. And in round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote. # 解題思路 # Solution import java.util.LinkedList;import java.util.Queue;class Solution &#123; public String predictPartyVictory(String senate) &#123; int n = senate.length(); Queue&lt;Integer> rQueue = new LinkedList&lt;>(); Queue&lt;Integer> dQueue = new LinkedList&lt;>(); for (int i = 0; i &lt; n; i++) &#123; if (senate.charAt(i) == 'R') &#123; rQueue.add(i); &#125; else &#123; dQueue.add(i); &#125; &#125; while (!rQueue.isEmpty() &amp;&amp; !dQueue.isEmpty()) &#123; int rTurn = rQueue.poll(); int dTurn = dQueue.poll(); if (dTurn &lt; rTurn) &#123; dQueue.add(dTurn + n); &#125; else &#123; rQueue.add(rTurn + n); &#125; &#125; return rQueue.isEmpty() ? \"Dire\" : \"Radiant\"; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"},{"name":"Queue","slug":"Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Queue/"}]},{"title":"2215. Find the Difference of Two Arrays","slug":"coding/leetcode/Easy/2215-Find-the-Difference-of-Two-Arrays","date":"2023-05-03T01:24:55.000Z","updated":"2023-05-03T02:38:47.412Z","comments":true,"path":"coding/leetcode/Easy/2215-Find-the-Difference-of-Two-Arrays/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2215-Find-the-Difference-of-Two-Arrays/","excerpt":"","text":"⭐️ # 題目敘述 Given two 0-indexed integer arrays nums1 and nums2 , return a list answer of size 2 where: answer[0] is a list of all distinct integers in nums1 which are not present in nums2 . answer[1] is a list of all distinct integers in nums2 which are not present in nums1 . Note that the integers in the lists may be returned in any order. # Example 1: Input: nums1 = [1,2,3], nums2 = [2,4,6] Output: [[1,3],[4,6]] Explanation: For nums1, nums1[1] = 2 is present at index 0 of nums2, whereas nums1[0] = 1 and nums1[2] = 3 are not present in nums2. Therefore, answer[0] = [1,3]. For nums2, nums2[0] = 2 is present at index 1 of nums1, whereas nums2[1] = 4 and nums2[2] = 6 are not present in nums2. Therefore, answer[1] = [4,6]. # Example 2: Input: nums1 = [1,2,3,3], nums2 = [1,1,2,2] Output: [[3],[]] Explanation: For nums1, nums1[2] and nums1[3] are not present in nums2. Since nums1[2] == nums1[3], their value is only included once and answer[0] = [3]. Every integer in nums2 is present in nums1. Therefore, answer[1] = []. # 解題思路 # Solution import java.util.ArrayList;import java.util.List;class Solution &#123; public List&lt;List&lt;Integer>> findDifference(int[] nums1, int[] nums2) &#123; List&lt;List&lt;Integer>> ans = new ArrayList&lt;>(); List&lt;Integer> map1 = new ArrayList&lt;>(), map2 = new ArrayList&lt;>(); for(int n : nums1) map1.add(n); for(int n : nums2) map2.add(n); List&lt;Integer> temp1 = new ArrayList&lt;>(); for(int n : nums1)&#123; if(!map2.contains(n) &amp;&amp; !temp1.contains(n))&#123; temp1.add(n); &#125; &#125; ans.add(temp1); List&lt;Integer> temp2 = new ArrayList&lt;>(); for(int n : nums2)&#123; if(!map1.contains(n) &amp;&amp; !temp2.contains(n))&#123; temp2.add(n); &#125; &#125; ans.add(temp2); return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"}]},{"title":"1822. Sign of the Product of an Array","slug":"coding/leetcode/Easy/1822-Sign-of-the-Product-of-an-Array","date":"2023-05-02T04:00:20.000Z","updated":"2023-05-02T04:03:49.696Z","comments":true,"path":"coding/leetcode/Easy/1822-Sign-of-the-Product-of-an-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1822-Sign-of-the-Product-of-an-Array/","excerpt":"","text":"⭐️ # 題目敘述 There is a function signFunc(x) that returns: 1 if x is positive. -1 if x is negative. 0 if x is equal to 0 . You are given an integer array nums . Let product be the product of all values in the array nums . Return signFunc(product) . # Example 1: Input: nums = [-1,-2,-3,-4,3,2,1] Output: 1 Explanation: The product of all values in the array is 144, and signFunc(144) = 1 # Example 2: Input: nums = [1,5,0,2,-3] Output: 0 Explanation: The product of all values in the array is 0, and signFunc(0) = 0 # Example 3: Input: nums = [-1,1,-1,1,-1] Output: -1 Explanation: The product of all values in the array is -1, and signFunc(-1) = -1 # 解題思路 # Solution class Solution &#123; public int arraySign(int[] nums) &#123; int sign = 1; for(int num : nums)&#123; if(num == 0) return 0; if(num &lt; 0) sign *= -1; &#125; return sign; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"}]},{"title":"1491. Average Salary Excluding the Minimum and Maximum Salary","slug":"coding/leetcode/Easy/1491-Average-Salary-Excluding-the-Minimum-and-Maximum-Salary","date":"2023-05-01T05:46:14.000Z","updated":"2023-05-01T05:52:45.054Z","comments":true,"path":"coding/leetcode/Easy/1491-Average-Salary-Excluding-the-Minimum-and-Maximum-Salary/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1491-Average-Salary-Excluding-the-Minimum-and-Maximum-Salary/","excerpt":"","text":"⭐️ # 題目敘述 You are given an array of unique integers salary where salary[i] is the salary of the ith employee. Return the average salary of employees excluding the minimum and maximum salary. Answers within 10-5 of the actual answer will be accepted. # Example 1: Input: salary = [4000,3000,1000,2000] Output: 2500.00000 Explanation: Minimum salary and maximum salary are 1000 and 4000 respectively. Average salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500 # Example 2: Input: salary = [1000,2000,3000] Output: 2000.00000 Explanation: Minimum salary and maximum salary are 1000 and 3000 respectively. Average salary excluding minimum and maximum salary is (2000) / 1 = 2000 # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public double average(int[] salary) &#123; Arrays.sort(salary); long sum = 0; for(int i = 1; i &lt; salary.length - 1; i++)&#123; sum += salary[i]; &#125; return sum / (salary.length - 2 * 1.0); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"}]},{"title":"1579. Remove Max Number of Edges to Keep Graph Fully Traversable","slug":"coding/leetcode/Hard/1579-Remove-Max-Number-of-Edges-to-Keep-Graph-Fully-Traversable","date":"2023-04-30T03:18:16.000Z","updated":"2023-04-30T03:19:08.119Z","comments":true,"path":"coding/leetcode/Hard/1579-Remove-Max-Number-of-Edges-to-Keep-Graph-Fully-Traversable/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/1579-Remove-Max-Number-of-Edges-to-Keep-Graph-Fully-Traversable/","excerpt":"","text":"⭐️ # 題目敘述 Alice and Bob have an undirected graph of n nodes and three types of edges: Type 1: Can be traversed by Alice only. Type 2: Can be traversed by Bob only. Type 3: Can be traversed by both Alice and Bob. Given an array edges where edges[i] = [typei, ui, vi] represents a bidirectional edge of type typei between nodes ui and vi , find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes. Return the maximum number of edges you can remove, or return -1 if Alice and Bob cannot fully traverse the graph. # Example 1: Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]] Output: 2 Explanation: If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2. # Example 2: Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]] Output: 0 Explanation: Notice that removing any edge will not make the graph fully traversable by Alice and Bob. # Example 3: Input: n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]] Output: -1 Explanation: In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable. # 解題思路 # Solution 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"}]},{"title":"1697. Checking Existence of Edge Length Limited Paths","slug":"coding/leetcode/Hard/1697-Checking-Existence-of-Edge-Length-Limited-Paths","date":"2023-04-29T06:04:59.000Z","updated":"2023-04-29T06:06:26.808Z","comments":true,"path":"coding/leetcode/Hard/1697-Checking-Existence-of-Edge-Length-Limited-Paths/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/1697-Checking-Existence-of-Edge-Length-Limited-Paths/","excerpt":"","text":"⭐️ # 題目敘述 An undirected graph of n nodes is defined by edgeList , where edgeList[i] = [ui, vi, disi] denotes an edge between nodes ui and vi with distance disi . Note that there may be multiple edges between two nodes. Given an array queries , where queries[j] = [pj, qj, limitj] , your task is to determine for each queries[j] whether there is a path between pj and qj such that each edge on the path has a distance strictly less than limitj . Return a boolean array answer , where answer.length == queries.length and the jth value of answer is true if there is a path for queries[j] is true , and false otherwise. # Example 1: Input: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]] Output: [false,true] Explanation: The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16. For the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query. For the second query, there is a path (0 -&gt; 1 -&gt; 2) of two edges with distances less than 5, thus we return true for this query. # Example 2: Input: n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]] Output: [true,false] Exaplanation: The above figure shows the given graph. # 解題思路 # Solution 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"}]},{"title":"839. Similar String Groups","slug":"coding/leetcode/Hard/839-Similar-String-Groups","date":"2023-04-28T01:29:37.000Z","updated":"2023-04-29T06:05:47.764Z","comments":true,"path":"coding/leetcode/Hard/839-Similar-String-Groups/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/839-Similar-String-Groups/","excerpt":"","text":"⭐️ # 題目敘述 Two strings X and Y are similar if we can swap two letters (in different positions) of X , so that it equals Y . Also two strings X and Y are similar if they are equal. For example, &quot;tars&quot; and &quot;rats&quot; are similar (swapping at positions 0 and 2 ), and &quot;rats&quot; and &quot;arts&quot; are similar, but &quot;star&quot; is not similar to &quot;tars&quot; , &quot;rats&quot; , or &quot;arts&quot; . Together, these form two connected groups by similarity: &#123;&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;&#125; and &#123;&quot;star&quot;&#125; . Notice that &quot;tars&quot; and &quot;arts&quot; are in the same group even though they are not similar. Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group. We are given a list strs of strings where every string in strs is an anagram of every other string in strs . How many groups are there? # Example 1: Input: strs = [&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;] Output: 2 # Example 2: Input: strs = [&quot;omv&quot;,&quot;ovm&quot;] Output: 1 # 解題思路 # Solution 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"}]},{"title":"319. Bulb Switcher","slug":"coding/leetcode/Medium/319-Bulb-Switcher","date":"2023-04-27T01:54:17.000Z","updated":"2023-04-27T03:26:00.210Z","comments":true,"path":"coding/leetcode/Medium/319-Bulb-Switcher/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/319-Bulb-Switcher/","excerpt":"","text":"⭐️ # 題目敘述 There are n bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Return the number of bulbs that are on after n rounds. # Example 1: Input: n = 3 Output: 1 Explanation: At first, the three bulbs are [off, off, off]. After the first round, the three bulbs are [on, on, on]. After the second round, the three bulbs are [on, off, on]. After the third round, the three bulbs are [on, off, off]. So you should return 1 because there is only one bulb is on. # Example 2: Input: n = 0 Output: 0 # Example 3: Input: n = 1 Output: 1 # 解題思路 # Solution class Solution &#123; public int bulbSwitch(int n) &#123; return (int)Math.sqrt(n); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"},{"name":"Brainteaser","slug":"Brainteaser","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Brainteaser/"}]},{"title":"uva 10156 - Sala-ma-Sond, A Nice Little Pond","slug":"coding/cpe/One Star/uva-10156-Sala-ma-Sond-A-Nice-Little-Pond","date":"2023-04-26T04:59:49.000Z","updated":"2023-04-27T05:28:36.878Z","comments":true,"path":"coding/cpe/One Star/uva-10156-Sala-ma-Sond-A-Nice-Little-Pond/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10156-Sala-ma-Sond-A-Nice-Little-Pond/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 And the turtles, of course...all the turtles are free As turtles, and, maybe, all creatures should be. Of course, the turtles aren’t completely free. In particular, they aren’t free to swim where other turtles are swimming. To learn more about the swimming behaviour of turtles you decide to write a computer simulation of a pond and the turtles swimming in it. For simplicity, you represent the pond as a rectangular grid, with turtles occupying positions at points on the grid. If the pond is an N × M grid, a position on the grid may be represented by a pair of integer coordinates (i, j) , with 0 ≤ i &lt; N and 0 ≤ j &lt; M . The grid is aligned with its first dimension running north-south and its second dimension running east-west. Coordinate values increase to the south and the east. A turtle swimming in the pond may be requested to move to the adjacent grid position in one of eight directions: N , S , E , W , NE , NW , SE , SW . If the request would cause the turtle to move off the grid or cause it to move onto a grid position occupied by another turtle, the request is ignored. Otherwise, the turtle happily obeys the movement request. (Turtles are easy to push around.) # Input The input consist of several data sets. Each data set begins with a description of the pond and the initial location of the turtles. The first line of the input consists of four integers separated by one or more spaces. The first integer specifies the size of the pond in the north-south direction (N) , the second integer specifies the size of the pond in the east-west direction (M) , the third integer specifies the number of turtles in the pond (T) and the fourth integer indicates the number of turtle movement requests (K) . This first line is followed by T lines, each providing information on a single turtle. Each line of turtle information consists of three integers separated by one or more spaces. The first integer specifies a turtle id, the second integer specifies an initial grid position for the turtle along the northsouth dimension, and the third integer specifies an initial grid position for the turtle along the east-west dimension. All turtles will be located at valid grid positions; no two turtles will be located at the same grid position; turtle ids are in the range one to ten thousand; the maximum size of the grid in either dimension is sixty; the minimum size is two. Following the description of the pond and its initial turtle configuration, the remainder of the input, consists of a sequence of K turtle movement requests, one per line. Each movement request consists of a turtle id followed by a movement direction, and indicates that the specified turtle should be requested to move one grid position in the specified direction. The turtle id and movement direction are separated by one or more spaces. The movement direction is one of: ‘N’ , ‘S’ , ‘E’ , ‘W’ , ‘NE’ , ‘NW’ , ‘SE’ , ‘SW’ . The turtle requests should be processed sequentially starting from the initial pond configuration given in the input. # Output The output is a graphical representation of the pond configuration for each data set after all turtle movement requests have been processed. A picture of the pond is rendered using ASCII characters. Beginning with the most northerly row, each row of the grid is represented by a single line in the output. Grid positions along a row are represented by character positions in the output line. The final position of a turtle is marked with an asterisk (‘*’) ; space characters are used to fill empty grid positions. If the output is displayed as text on a computer screen or printed page, the result is a map of turtle positions in the pond, with north toward the top, east toward the right, and west toward the left. Spaces should be generated only when required for positioning turtles; output lines should not have trailing spaces. Print a blank line after each data set. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 4 4 3 4 1 0 0 2 0 2 3 3 3 1 S 2 W 2 W 1 SE 4 4 3 4 1 0 0 2 0 2 3 3 3 2 W 2 W 1 S 1 SW # Sample Output # 解題技巧 # Solution","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"258. Add Digits","slug":"coding/leetcode/Easy/258-Add-Digits","date":"2023-04-26T01:27:56.000Z","updated":"2023-04-26T02:02:00.338Z","comments":true,"path":"coding/leetcode/Easy/258-Add-Digits/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/258-Add-Digits/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer num , repeatedly add all its digits until the result has only one digit, and return it. # Example 1: Input: num = 38 Output: 2 Explanation: The process is 38 --&gt; 3 + 8 --&gt; 11 11 --&gt; 1 + 1 --&gt; 2 Since 2 has only one digit, return it. # Example 2: Input: num = 0 Output: 0 # 解題思路 # Solution class Solution &#123; public int addDigits(int num) &#123; while(num >= 10)&#123; String str = Integer.toString(num); num = 0; for(int i = 0; i &lt; str.length(); i++)&#123; num += Integer.parseInt(str.substring(i, i + 1)); &#125; &#125; return num; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Number-Theory/"}]},{"title":"uva 10126 - Zipf's Law","slug":"coding/cpe/One Star/uva-10126-Zipf-s-Law","date":"2023-04-25T03:01:38.000Z","updated":"2023-04-26T03:22:56.068Z","comments":true,"path":"coding/cpe/One Star/uva-10126-Zipf-s-Law/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10126-Zipf-s-Law/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 無本題 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Harvard linguistics professor George Kingsley Zipf (1902-1950) observed that the frequency of the k-th most common word in a text is roughly proportional to 1/k . He justified his observations in a book titled Human behavior and the principle of least effort published in 1949. While Zipf’s rationale has largely been discredited, the principle still holds, and others have afforded it a more sound mathematical basis. You are to find all the words occurring n times in an English text. A word is a sequence of letters. Words are separated by non-letters. Capitalization should be ignored. A word can be of any length that an English word can be. # Input Input consists of several test cases. The first line of each case contains a single positive integer n . Several lines of text follow which will contain no more than 10000 words. The text for each case is terminated by a single line containing EndOfText . EndOfText does not appear elsewhere in the input and is not considered a word. # Output For each test case, output the words which occur n times in the input text, one word per line, lower case, in alphabetical order. If there are no such words in input, output the following line: There is no such word. Leave a blank line between cases. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 2 In practice, the difference between theory and practice is always greater than the difference between theory and practice in theory. - Anonymous Man will occasionally stumble over the truth, but most of the time he will pick himself up and continue on. - W. S. L. Churchill EndOfText # Sample Output between difference in will # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while(sc.hasNextInt())&#123; int N = sc.nextInt(); sc.nextLine(); Map&lt;String, Integer> map = new HashMap&lt;>(); String str = sc.nextLine(); while(!str.equals(\"EndOfText\"))&#123; String[] arr = str.split(\"[^A-Za-z]\"); for(int i = 0; i &lt; arr.length; i++)&#123; if(arr[i].length() != 0)&#123; arr[i] = arr[i].toLowerCase(); if(map.containsKey(arr[i]))&#123; map.put(arr[i], map.get(arr[i]) + 1); &#125;else&#123; map.put(arr[i], 1); &#125; &#125; &#125; str = sc.nextLine(); &#125; boolean isOutput = false; for(String s : new TreeSet&lt;String>(map.keySet()))&#123; if(map.get(s) == N)&#123; System.out.println(s); isOutput = true; &#125; &#125; if(!isOutput)&#123; System.out.println(\"There is no such word.\"); &#125; if(sc.hasNextInt())&#123; System.out.println(); &#125; &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"2336. Smallest Number in Infinite Set","slug":"coding/leetcode/Medium/2336-Smallest-Number-in-Infinite-Set","date":"2023-04-25T02:20:39.000Z","updated":"2023-04-25T02:39:09.262Z","comments":true,"path":"coding/leetcode/Medium/2336-Smallest-Number-in-Infinite-Set/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2336-Smallest-Number-in-Infinite-Set/","excerpt":"","text":"⭐️⭐️ # 題目敘述 You have a set which contains all positive integers [1, 2, 3, 4, 5, ...] . Implement the SmallestInfiniteSet class: SmallestInfiniteSet() Initializes the SmallestInfiniteSet object to contain all positive integers. int popSmallest() Removes and returns the smallest integer contained in the infinite set. void addBack(int num) Adds a positive integer num back into the infinite set, if it is not already in the infinite set. # Example 1: Input [&quot;SmallestInfiniteSet&quot;, &quot;addBack&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;, &quot;addBack&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;] [[], [2], [], [], [], [1], [], [], []] Output [null, null, 1, 2, 3, null, 1, 4, 5] Explanation SmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet(); smallestInfiniteSet.addBack(2); // 2 is already in the set, so no change is made. smallestInfiniteSet.popSmallest(); // return 1, since 1 is the smallest number, and remove it from the set. smallestInfiniteSet.popSmallest(); // return 2, and remove it from the set. smallestInfiniteSet.popSmallest(); // return 3, and remove it from the set. smallestInfiniteSet.addBack(1); // 1 is added back to the set. smallestInfiniteSet.popSmallest(); // return 1, since 1 was added back to the set and // is the smallest number, and remove it from the set. smallestInfiniteSet.popSmallest(); // return 4, and remove it from the set. smallestInfiniteSet.popSmallest(); // return 5, and remove it from the set. # 解題思路 # Solution import java.util.PriorityQueue;class SmallestInfiniteSet &#123; PriorityQueue&lt;Integer> pQ; public SmallestInfiniteSet() &#123; pQ = new PriorityQueue&lt;>(); for(int i = 1; i &lt;= 1000; i++)&#123; pQ.add(i); &#125; &#125; public int popSmallest() &#123; int num = pQ.poll(); return num; &#125; public void addBack(int num) &#123; if(!pQ.contains(num))&#123; pQ.add(num); &#125; &#125;&#125;/** * Your SmallestInfiniteSet object will be instantiated and called as such: * SmallestInfiniteSet obj = new SmallestInfiniteSet(); * int param_1 = obj.popSmallest(); * obj.addBack(num); */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Design","slug":"Design","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Design/"}]},{"title":"uva 10101 - Bangla Numbers","slug":"coding/cpe/One Star/uva-10101-Bangla-Numbers","date":"2023-04-24T11:10:12.000Z","updated":"2023-04-24T13:49:59.686Z","comments":true,"path":"coding/cpe/One Star/uva-10101-Bangla-Numbers/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10101-Bangla-Numbers/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Bangla numbers normally use ’kuti’ (10000000) , ’lakh’ (100000) , ’hajar’ (1000) , ’shata’ (100) while expanding and converting to text. You are going to write a program to convert a given number to text with them. # Input The input file may contain several test cases. Each case will contain a non-negative number ≤ 999999999999999 . # Output For each case of input, you have to output a line starting with the case number with four digits adjustment followed by the converted text. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 23764 45897458973958 # Sample Output 1. 23 hajar 7 shata 64 2. 45 lakh 89 hajar 7 shata 45 kuti 89 lakh 73 hajar 9 shata 58 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static long kuti = 10000000; public static long lakh = 100000; public static long hajar = 1000; public static long shata = 100; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int line = 0; while(sc.hasNextLong())&#123; long num = sc.nextLong(); System.out.printf(\"%4d.\", ++line); if(num == 0)&#123; System.out.print(\" 0\"); &#125;else&#123; calculate(num); &#125; System.out.println(); &#125; sc.close(); &#125; public static void calculate(long num)&#123; if(num == 0) return ; if(num >= kuti)&#123; calculate(num/kuti); System.out.print(\" kuti\"); calculate(num%kuti); &#125;else if(num >= lakh)&#123; System.out.print(\" \" + num/lakh + \" lakh\"); calculate(num%lakh); &#125;else if(num >= hajar)&#123; System.out.print(\" \" + num/hajar + \" hajar\"); calculate(num%hajar); &#125;else if(num >= shata)&#123; System.out.print(\" \" + num/shata + \" shata\"); calculate(num%shata); &#125;else&#123; System.out.print(\" \" + num); &#125; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"1046. Last Stone Weight","slug":"coding/leetcode/Easy/1046-Last-Stone-Weight","date":"2023-04-24T02:48:10.000Z","updated":"2023-04-24T02:49:40.805Z","comments":true,"path":"coding/leetcode/Easy/1046-Last-Stone-Weight/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1046-Last-Stone-Weight/","excerpt":"","text":"⭐️ # 題目敘述 You are given an array of integers stones where stones[i] is the weight of the ith stone. We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x &lt;= y . The result of this smash is: If x == y , both stones are destroyed, and If x != y , the stone of weight x is destroyed, and the stone of weight y has new weight y - x . At the end of the game, there is at most one stone left. Return the weight of the last remaining stone. If there are no stones left, return 0 . # Example 1: Input: stones = [2,7,4,1,8,1] Output: 1 Explanation: We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then, we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then, we combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone. # Example 2: Input: stones = [1] Output: 1 # 解題思路 # Solution import java.util.Comparator;import java.util.PriorityQueue;class Solution &#123; public int lastStoneWeight(int[] stones) &#123; if(stones.length == 0) return 0; PriorityQueue&lt;Integer> pQ = new PriorityQueue&lt;>(Comparator.reverseOrder()); for(int s : stones)&#123; pQ.add(s); &#125; while(pQ.size() >= 2)&#123; int first = pQ.poll(); int second = pQ.poll(); pQ.add(first - second); &#125; return pQ.peek(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"}]},{"title":"uva 10093 - An Easy Problem!","slug":"coding/cpe/One Star/uva-10093-An-Easy-Problem","date":"2023-04-22T15:31:50.000Z","updated":"2023-04-22T17:11:12.074Z","comments":true,"path":"coding/cpe/One Star/uva-10093-An-Easy-Problem/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10093-An-Easy-Problem/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 無本題 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Have you heard the fact “The base of every normal number system is 10” ? Of course, I am not talking about number systems like Stern Brockot Number System. This problem has nothing to do with this fact but may have some similarity. You will be given an N based integer number R and you are given the guaranty that R is divisible by (N − 1) . You will have to print the smallest possible value for N . The range for N is 2 ≤ N ≤ 62 and the digit symbols for 62 based number is ( 0..9 and A..Z and a..z ). Similarly, the digit symbols for 61 based number system is ( 0..9 and A..Z and a..y ) and so on. # Input Each line in the input file will contain an integer (as defined in mathematics) number of any integer base (2..62) . You will have to determine what is the smallest possible base of that number for the given conditions. No invalid number will be given as input. # Output If number with such condition is not possible output the line ‘such number is impossible!’ For each line of input there will be only a single line of output. The output will always be in decimal number system. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 3 5 A # Sample Output 4 6 11 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) &#123; String str = sc.nextLine(); char arr[] = str.toCharArray(); int max = 1; int sum = 0; int i; for (char c : arr) &#123; int curr = 0; if (c >= 'A' &amp;&amp; c &lt;= 'Z') &#123; curr = c - 'A' + 10; &#125; else if (c >= 'a' &amp;&amp; c &lt;= 'z') &#123; curr = c - 'a' + 36; &#125; else if (c >= '0' &amp;&amp; c &lt;= '9') &#123; curr = c - '0'; &#125; if (max &lt; curr) &#123; max = curr; &#125; sum += curr; &#125; for (i = max; i &lt; 62; i++) &#123; if (sum % i == 0) &#123; System.out.println(i + 1); break; &#125; &#125; if (i == 62) &#123; System.out.println(\"such number is impossible!\"); &#125; &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"uva 10082 - WERTYU","slug":"coding/cpe/One Star/uva-10082-WERTYU","date":"2023-04-21T08:16:29.000Z","updated":"2023-04-21T15:29:14.858Z","comments":true,"path":"coding/cpe/One Star/uva-10082-WERTYU/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10082-WERTYU/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 A common typing error is to place the hands on the keyboard one row to the right of the correct position. So ‘Q’ is typed as ‘W’ and ‘J’ is typed as ‘K’ and so on. You are to decode a message typed in this manner. # Input Input consists of several lines of text. Each line may contain digits , spaces , upper case letters (except Q, A, Z) , or punctuation shown above [except back-quote (‘)] . Keys labelled with words [Tab, BackSp, Control, etc.] are not represented in the input. # Output You are to replace each letter or punction symbol by the one immediately to its left on the ‘QWERTY’ keyboard shown above. Spaces in the input should be echoed in the output. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input O S, GOMR YPFSU/ # Sample Output I AM FINE TODAY. # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String hashTable = \"`1234567890-=QWERTYUIOP[]\\\\ASDFGHJKL;'ZXCVBNM,./\"; while(sc.hasNextLine())&#123; String str = sc.nextLine(); for(int i = 0; i &lt; str.length(); i++)&#123; char c = str.charAt(i); if(c == ' ') System.out.print(\" \"); for(int j = 0; j &lt; hashTable.length(); j++)&#123; if(c == hashTable.charAt(j))&#123; System.out.print(hashTable.charAt(j - 1)); &#125; &#125; &#125; System.out.println(); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"uva 10079 - Pizza Cutting","slug":"coding/cpe/One Star/uva-10079-Pizza-Cutting","date":"2023-04-21T07:38:33.000Z","updated":"2023-04-21T08:18:00.189Z","comments":true,"path":"coding/cpe/One Star/uva-10079-Pizza-Cutting/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10079-Pizza-Cutting/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 When someone calls Ivan lazy, he claims that it is his intelligence that helps him to be so. If his intelligence allows him to do something at less physical effort, why should he exert more? He also claims that he always uses his brain and tries to do some work at less effort; this is not his laziness, rather this is his intellectual smartness. Once Ivan was asked to cut a pizza into seven pieces to distribute it among his friends. (Size of the pieces may not be the same. In fact, his piece will be larger than the others.) He thought a bit, and came to the conclusion that he can cut it into seven pieces by only three straight cuts through the pizza with a pizza knife. Accordingly, he cut the pizza in the following way (guess which one is Ivan’s piece): One of his friends, who never believed in Ivan’s smartness, was startled at this intelligence. He thought, if Ivan can do it, why can’t my computer? So he tried to do a similar (but not exactly as Ivan’s, for Ivan will criticize him for stealing his idea) job with his computer. He wrote a program that took the number of straight cuts one makes through the pizza, and output a number representing the maximum number of pizza pieces it will produce. Your job here is to write a similar program. It is ensured that Ivan’s friend won’t criticize you for doing the same job he did. # Input The input file will contain a single integer N (0 ≤ N ≤ 210000000) in each line representing the number of straight line cuts one makes through the pizza. A negative number terminates the input. # Output Output the maximum number of pizza pieces the given number of cuts can produce. Each line should contain only one output integer without any leading or trailing space. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 5 10 -100 # Sample Output 16 56 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); long n = sc.nextLong(); while(n >= 0 &amp;&amp; n &lt;= 210000000)&#123; System.out.println(1 + (n * (n + 1) / 2)); n = sc.nextLong(); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"uva 10062 - Tell me the frequencies!","slug":"coding/cpe/One Star/uva-10062-Tell-me-the-frequencies","date":"2023-04-21T06:11:42.000Z","updated":"2023-04-21T07:26:33.691Z","comments":true,"path":"coding/cpe/One Star/uva-10062-Tell-me-the-frequencies/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10062-Tell-me-the-frequencies/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Given a line of text you will have to find out the frequencies of the ASCII characters present in it. The given lines will contain none of the first 32 or last 128 ASCII characters. Of course lines may end with \\n and \\r but always keep those out of consideration. # Input Several lines of text are given as input. Each line of text is considered as a single input. Maximum length of each line is 1000 . # Output Print the ASCII value of the ASCII characters which are present and their frequency according to the given format below. A blank line should separate each set of output. Print the ASCII characters in the ascending order of their frequencies. If two characters are present the same time print the information of the ASCII character with higher ASCII value first. Input is terminated by end of file. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input AAABBC 122333 # Sample Output 67 1 66 2 65 3 49 1 50 2 51 3 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) &#123; String str = sc.nextLine(); Ascii[] list = new Ascii[130]; for (int i = 0; i &lt; 130; i++) &#123; list[i] = new Ascii(i); &#125; for (int i = 0; i &lt; str.length(); i++) &#123; int c = str.charAt(i); list[c].count++; &#125; Arrays.sort(list, new Comparator&lt;Ascii>() &#123; @Override public int compare(Ascii a, Ascii b) &#123; if (a.count == b.count) return b.ascii - a.ascii; return a.count - b.count; &#125; &#125;); for(int i = 0; i &lt; 130; i++)&#123; if(list[i].count != 0)&#123; System.out.println(list[i].ascii + \" \" + list[i].count); &#125; &#125; if(sc.hasNextLine())&#123; System.out.println(); &#125; &#125; sc.close(); &#125;&#125;class Ascii &#123; public int ascii; public int count; public Ascii(int a) &#123; ascii = a; count = 0; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"879. Profitable Schemes","slug":"coding/leetcode/Hard/879-Profitable-Schemes","date":"2023-04-21T01:21:14.000Z","updated":"2023-04-21T05:45:56.445Z","comments":true,"path":"coding/leetcode/Hard/879-Profitable-Schemes/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/879-Profitable-Schemes/","excerpt":"","text":"⭐️ # 題目敘述 There is a group of n members, and a list of various crimes they could commit. The ith crime generates a profit[i] and requires group[i] members to participate in it. If a member participates in one crime, that member can't participate in another crime. Let's call a profitable scheme any subset of these crimes that generates at least minProfit profit, and the total number of members participating in that subset of crimes is at most n . Return the number of schemes that can be chosen. Since the answer may be very large, return it modulo 10^9 + 7 . # Example 1: Input: n = 5, minProfit = 3, group = [2,2], profit = [2,3] Output: 2 Explanation: To make a profit of at least 3, the group could either commit crimes 0 and 1, or just crime 1. In total, there are 2 schemes. # Example 2: Input: n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8] Output: 7 Explanation: To make a profit of at least 5, the group could commit any crimes, as long as they commit one. There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2). # 解題思路 # Solution class Solution &#123; public int mod = (int) 1e9 + 7; public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) &#123; int[][] dp = new int[n + 1][minProfit + 1]; dp[0][0] = 1; for (int k = 1; k &lt;= group.length; k++) &#123; int g = group[k - 1]; int p = profit[k - 1]; for (int i = n; i >= g; i--) &#123; for (int j = minProfit; j >= 0; j--) &#123; dp[i][j] = (dp[i][j] + dp[i - g][Math.max(0, j - p)]) % mod; &#125; &#125; &#125; int sum = 0; for (int i = 0; i &lt;= n; i++) &#123; sum = (sum + dp[i][minProfit]) % mod; &#125; return sum; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"禮貌句型","slug":"language/english/片語/禮貌句型","date":"2023-04-20T08:27:17.000Z","updated":"2023-04-20T09:26:28.716Z","comments":true,"path":"language/english/片語/禮貌句型/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/language/english/%E7%89%87%E8%AA%9E/%E7%A6%AE%E8%B2%8C%E5%8F%A5%E5%9E%8B/","excerpt":"","text":"⭐️ Could you, Would you 有什麼差別？ 如果 please 放句末可以嗎？ # Could you, Would you 有什麼差別？ 這兩個很接近，但差別在 Could you 問能不能，Would you 問意願。 所以，如果你寫信問 John: &quot;Would you please finish the report by Friday?&quot; 人家看到後可能眉毛一皺，心想... would you... 你在說我「不願意」週五前完成嗎...？ 所以如果無關乎意願，我們用 Could you 就可以了。 Could you finish it by Friday? Could you sign the documents for me? Could you confirm the shipping dates for me? 而以下情況用 would you，因為你在詢問對方的意願。 Would you like me to finish the report? Would you prefer our premium options? Would you like to have dinner with us? # Please 可以放句末嗎？ 可以，但你總不希望一直跳針 Could you please... 所以我現在要補充五個讓你下次寫 email 就可以立刻用的句型。 # 補充句型 不確定的請求 I was wondering if... 有一次我電腦更新後，某程式的通知跳不出來。我不確定是自己設定有誤，還是對方還沒更新他們的軟體。我寫信給客服，但不能直接指控人家程式有問題，畢竟萬一是我設定不對怎麼辦？所以，我就寫 I was wondering if the newest version is not supported on macOS 13. 結果，是我自己設定不對... 還好沒直接寫 why is your app NOT supported on the newest OS update? 困難請求 Is it possible to... 假設你下了一筆大訂單，你覺得對方應該會答應再降價一點，但又不希望自己口氣很大，我建議用 Is it possible to give us a 5% discount? 我們用 possible「可能」這個字來表達不確定和客氣。 問對方需求 Would you prefer/like... 很多學生在問對方要什麼的時候會不小心寫 Do you want...? 但是這樣太直接了，如果要給對方選項，建議用 Would you prefer the premium option? 或是 Would you like A instead of B? 你希望 A 代替 B 嗎？ 似乎、好像 It seems that... 如果對方日期、金額、數量寫錯，我們不想要直接說 something is wrong，這樣太不給人家面子了，而且好像老師糾正學生。所以，可以用 seems 「看似」這個單字來給人家小提醒。 There seems to be a mistake with the date. There seems to be a mistake with the quantity. 恐怕 I'm afraid that... 昨天收到讀者來信，有外國公司透過 LinkedIn 聯絡想挖角他。但他目前的工作很忙，問我該如何婉拒。原本他寫 &quot;I really have to pass on this one&quot; 但 pass on 是比要口語的，在職場使用不太專業。其實用中文想就能感覺出來，人家詢問你工作意願，然後你說「這我先 pass」是不是不太好聽。所以，可以用 &quot;I'm afraid I can't accept the job offer.&quot; 然後給理由像是 &quot;it isn't a good time for me to leave my current position.&quot;。 就這樣，五個句子讓你下次寫 email 時更好掌握禮貌與客氣。 不確定的請求 I was wondering if 困難請求 Is it possible to... 問對方需求 Would you prefer/like... 似乎、好像 It seems that... 恐怕 I'm afraid that... 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"片語","slug":"language/english/片語","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E7%89%87%E8%AA%9E/"}],"tags":[{"name":"難度 1","slug":"難度-1","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-1/"},{"name":"英文片語","slug":"英文片語","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E7%89%87%E8%AA%9E/"}]},{"title":"uva 10057 - A mid-summer night’s dream","slug":"coding/cpe/One Star/uva-10057-A-mid-summer-night’s-dream","date":"2023-04-20T06:31:15.000Z","updated":"2023-04-20T08:24:05.270Z","comments":true,"path":"coding/cpe/One Star/uva-10057-A-mid-summer-night’s-dream/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10057-A-mid-summer-night%E2%80%99s-dream/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 30.000 seconds # 題目 This is year 2200AD . Science has progressed a lot in two hundred years. Two hundred years is mentioned here because this problem is being sent back to 2000AD with the help of time machine. Now it is possible to establish direct connection between man and computer CPU. People can watch other peoples dream on 3D displayer (That is the monitor today) as if they were watching a movie. One problem in this century is that people have become so dependent on computers that their analytical ability is approaching zero. Computers can now read problems and solve them automatically. But they can solve only difficult problems. There are no easy problems now. Our chief scientist is in great trouble as he has forgotten the number of his combination lock. For security reasons computers today cannot solve combination lock related problems. In a mid-summer night the scientist has a dream where he sees a lot of unsigned integer numbers flying around. He records them with the help of his computer, Then he has a clue that if the numbers are (X1, X2, . . . , Xn) he will have to find an integer number A (This A is the combination lock code) such that (∣X1−A∣+∣X2−A∣+...+∣Xn−A∣)(|X_1 − A| + |X_2 − A| + . . . + |X_n − A|) (∣X1​−A∣+∣X2​−A∣+...+∣Xn​−A∣) is minimum. # Input Input will contain several blocks. Each block will start with a number n (0 &lt; n ≤ 1000000) indicating how many numbers he saw in the dream. Next there will be n numbers. All the numbers will be less that 65536 . The input will be terminated by end of file # Output For each set of input there will be one line of output. That line will contain the minimum possible value for A . Next it will contain how many numbers are there in the input that satisfy the property of A (The summation of absolute deviation from A is minimum). And finally you have to print how many possible different integer values are there for A (these values need not be present in the input). These numbers will be separated by single space. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 2 10 10 4 1 2 2 4 # Sample Output 10 2 1 2 2 1 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while(sc.hasNextInt())&#123; int line = sc.nextInt(); int[] arr = new int[line]; for(int i = 0; i &lt; line; i++)&#123; arr[i] = sc.nextInt(); &#125; Arrays.sort(arr); int min1, min2; if(line % 2 == 0)&#123; min1 = arr[line / 2 - 1]; min2 = arr[line / 2]; &#125;else&#123; min1 = arr[line / 2]; min2 = arr[line / 2]; &#125; int count = 0; for(int i = 0; i &lt; line; i++)&#123; if(arr[i] == min1 || arr[i] == min2)&#123; count++; &#125; &#125; int all = min2 - min1 + 1; System.out.println(min1 + \" \" + count + \" \" + all); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"662. Maximum Width of Binary Tree","slug":"coding/leetcode/Medium/662-Maximum-Width-of-Binary-Tree","date":"2023-04-20T01:23:38.000Z","updated":"2023-04-20T05:25:03.121Z","comments":true,"path":"coding/leetcode/Medium/662-Maximum-Width-of-Binary-Tree/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/662-Maximum-Width-of-Binary-Tree/","excerpt":"","text":"⭐️⭐️ # 題目敘述 Given the root of a binary tree, return the maximum width of the given tree. The maximum width of a tree is the maximum width among all levels. The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation. It is guaranteed that the answer will in the range of a 32-bit signed integer. # Example 1: Input: root = [1,3,2,5,3,null,9] Output: 4 Explanation: The maximum width exists in the third level with length 4 (5,3,null,9). # Example 2: Input: root = [1,3,2,5,null,null,9,6,null,7] Output: 7 Explanation: The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7). # Example 3: Input: root = [1,3,2,5] Output: 2 Explanation: The maximum width exists in the second level with length 2 (3,2). # 解題思路 # Solution import javafx.util.Pair;import java.util.ArrayDeque;import java.util.Deque;// Definition for a binary tree node.public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode() &#123;&#125; TreeNode(int val) &#123; this.val = val; &#125; TreeNode(int val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125;&#125;class Solution &#123; public int widthOfBinaryTree(TreeNode root) &#123; if(root == null) return 0; int ans = 0; Deque&lt;Pair&lt;TreeNode, Integer>> deque = new ArrayDeque&lt;>(); deque.add(new Pair&lt;>(root, 0)); while(!deque.isEmpty())&#123; int len = deque.size(); int start = deque.peekFirst().getValue(); int end = deque.peekLast().getValue(); ans = Math.max(ans, end - start + 1); for(int i = 0; i &lt; len; i++)&#123; Pair&lt;TreeNode, Integer> node = deque.pop(); TreeNode curr = node.getKey(); int index = node.getValue(); if(curr.left != null) deque.add(new Pair&lt;>(curr.left, 2 * index)); if(curr.right != null) deque.add(new Pair&lt;>(curr.right, 2 * index + 1)); &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Tree","slug":"Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Tree/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Tree/"}]},{"title":"uva 10056 - What is the Probability?","slug":"coding/cpe/One Star/uva-10056-What-is-the-Probability","date":"2023-04-19T12:43:28.000Z","updated":"2023-04-20T06:34:56.737Z","comments":true,"path":"coding/cpe/One Star/uva-10056-What-is-the-Probability/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10056-What-is-the-Probability/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Probability has always been an integrated part of computer algorithms. Where the deterministic algorithms have failed to solve a problem in short time, probabilistic algorithms have come to the rescue. In this problem we are not dealing with any probabilistic algorithm. We will just try to determine the winning probability of a certain player. A game is played by throwing a dice like thing (it should not be assumed that it has six sides like an ordinary dice). If a certain event occurs when a player throws the dice (such as getting a 3, getting green side on top or whatever) he is declared the winner. There can be N such player. So the first player will throw the dice, then the second and at last the N-th player and again the first player and so on. When a player gets the desired event he or she is declared winner and playing stops. You will have to determine the winning probability of one (The I-th) of these players. # Input Input will contain an integer S (S ≤ 1000) at first, which indicates how many sets of inputs are there. The next S lines will contain S sets of inputs. Each line contain an integer N (N ≤ 1000) which denotes the number players, a floating point number p which indicates the probability of the happening of a successful event in a single throw (If success means getting 3 then p is the probability of getting 3 in a single throw. For a normal dice the probability of getting 3 is 1/6 ), and I (I ≤ N) the serial of the player whose winning probability is to be determined (Serial no varies from 1 to N ). You can assume that no invalid probability (p) value will be given as input. # Output For each set of input, output in a single line the probability of the I-th player to win. The output floating point number will always have four digits after the decimal point as shown in the sample output. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 2 2 0.166666 1 2 0.166666 2 # Sample Output 0.5455 0.4545 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int S = sc.nextInt(); for(int i = 0; i &lt; S; i++)&#123; int n = sc.nextInt(); double p = sc.nextDouble(); int ith = sc.nextInt(); double q = 1 - p; if(p == 0)&#123; System.out.printf(\"%.4f\\n\", 0.0); &#125;else&#123; System.out.printf(\"%.4f\\n\", Math.pow(q, ith - 1) * p / (1 - Math.pow(q, n))); &#125; &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"uva 10055 - Hashmat the Brave Warrior","slug":"coding/cpe/One Star/uva-10055-Hashmat-the-Brave-Warrior","date":"2023-04-19T12:18:23.000Z","updated":"2023-04-20T06:34:47.023Z","comments":true,"path":"coding/cpe/One Star/uva-10055-Hashmat-the-Brave-Warrior/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10055-Hashmat-the-Brave-Warrior/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Hashmat is a brave warrior who with his group of young soldiers moves from one place to another to fight against his opponents. Before Fighting he just calculates one thing, the difference between his soldier number and the opponent’s soldier number. From this difference he decides whether to fight or not. Hashmat’s soldier number is never greater than his opponent. # Input The input contains two numbers in every line. These two numbers in each line denotes the number soldiers in Hashmat’s army and his opponent’s army or vice versa. The input numbers are not greater than 232. Input is terminated by ‘End of File’ . # Output For each line of input, print the difference of number of soldiers between Hashmat’s army and his opponent’s army. Each output should be in seperate line. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 10 12 10 14 100 200 # Sample Output 2 4 100 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while(sc.hasNextLong())&#123; long a = sc.nextLong(); long b = sc.nextLong(); System.out.println(Math.abs(a - b)); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"uva 10050 - Hartals","slug":"coding/cpe/One Star/uva-10050-Hartals","date":"2023-04-19T10:58:20.000Z","updated":"2023-04-20T06:34:37.796Z","comments":true,"path":"coding/cpe/One Star/uva-10050-Hartals/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10050-Hartals/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 A social research organization has determined a simple set of parameters to simulate the behavior of the political parties of our country. One of the parameters is a positive integer h (called the hartal parameter) that denotes the average number of days between two successive hartals (strikes) called by the corresponding party. Though the parameter is far too simple to be flawless, it can still be used to forecast the damages caused by hartals. The following example will give you a clear idea: Consider three political parties. Assume h1 = 3 , h2 = 4 and h3 = 8 where hi is the hartal parameter for party i (i = 1, 2, 3) . Now, we will simulate the behavior of these three parties for N = 14 days. One must always start the simulation on a Sunday and assume that there will be no hartals on weekly holidays (on Fridays and Saturdays). The simulation above shows that there will be exactly 5 hartals (on days 3 , 4 , 8 , 9 and 12 ) in 14 days. There will be no hartal on day 6 since it is a Friday. Hence we lose 5 working days in 2 weeks. In this problem, given the hartal parameters for several political parties and the value of N , your job is to determine the number of working days we lose in those N days. # Input The first line of the input consists of a single integer T giving the number of test cases to follow. The first line of each test case contains an integer N (7 ≤ N ≤ 3650) giving the number of days over which the simulation must be run. The next line contains another integer P (1 ≤ P ≤ 100) representing the number of political parties in this case. The ith of the next P lines contains a positive integer hi (which will never be a multiple of 7 ) giving the hartal parameter for party i (1 ≤ i ≤ P) . # Output For each test case in the input output the number of working days we lose. Each output must be on a separate line. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 2 14 3 3 4 8 100 4 12 15 25 40 # Sample Output 5 15 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for(int i = 0; i &lt; T; i++)&#123; int day = sc.nextInt(); int P = sc.nextInt(); int[] hartals = new int[day + 1]; for(int j = 0; j &lt; P; j++)&#123; int temp = sc.nextInt(); int index = temp; while(index &lt;= day)&#123; hartals[index]++; index += temp; &#125; &#125; int ans = 0; for(int j = 1; j &lt; day + 1; j++)&#123; if(j % 7 != 6 &amp;&amp; j % 7 != 0 &amp;&amp; hartals[j] != 0)&#123; ans++; &#125; &#125; System.out.println(ans); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"uva 10041 - Vito's Family","slug":"coding/cpe/One Star/uva-10041-Vito-s-Family","date":"2023-04-19T10:27:10.000Z","updated":"2023-04-20T06:34:29.936Z","comments":true,"path":"coding/cpe/One Star/uva-10041-Vito-s-Family/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10041-Vito-s-Family/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The world-known gangster Vito Deadstone is moving to New York. He has a very big family there, all of them living in Lamafia Avenue. Since he will visit all his relatives very often, he is trying to find a house close to them. Vito wants to minimize the total distance to all of them and has blackmailed you to write a program that solves his problem. # Input The input consists of several test cases. The first line contains the number of test cases. For each test case you will be given the integer number of relatives r (0 &lt; r &lt; 500) and the street numbers (also integers) s1, s2, . . . , si, . . . , sr where they live (0 &lt; si &lt; 30000 ) . Note that several relatives could live in the same street number. # Output For each test case your program must write the minimal sum of distances from the optimal Vito’s house to each one of his relatives. The distance between two street numbers si and sj is dij = | si − sj | . 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 2 2 2 4 3 2 4 6 # Sample Output 2 4 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int Line = sc.nextInt(); for(int i = 0; i &lt; Line; i++)&#123; int r = sc.nextInt(); int[] s = new int[r]; for(int j = 0; j &lt; r; j++)&#123; s[j] = sc.nextInt(); &#125; Arrays.sort(s); int house = s[r / 2]; int distance = 0; for(int j = 0; j &lt; r; j++)&#123; distance += Math.abs(house - s[j]); &#125; System.out.println(distance); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"uva 10038 - Jolly Jumpers","slug":"coding/cpe/One Star/uva-10038-Jolly-Jumpers","date":"2023-04-19T10:03:18.000Z","updated":"2023-04-20T06:34:21.361Z","comments":true,"path":"coding/cpe/One Star/uva-10038-Jolly-Jumpers/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10038-Jolly-Jumpers/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 A sequence of n &gt; 0 integers is called a jolly jumper if the absolute values of the difference between successive elements take on all the values 1 through n − 1 . For instance, 1 4 2 3 is a jolly jumper, because the absolutes differences are 3 , 2 , and 1 respectively. The definition implies that any sequence of a single integer is a jolly jumper. You are to write a program to determine whether or not each of a number of sequences is a jolly jumper. # Input Each line of input contains an integer n ≤ 3000 followed by n integers representing the sequence. # Output For each line of input, generate a line of output saying ‘Jolly’ or ‘Not jolly’ . 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 4 1 4 2 3 5 1 4 2 -1 6 # Sample Output Jolly Not jolly # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while(sc.hasNextInt())&#123; int N = sc.nextInt(); int[] hashTable = new int[N]; int[] num = new int[N]; boolean jolly = true; for(int i = 0; i &lt; N; i++)&#123; num[i] = sc.nextInt(); &#125; for(int i = 0; i &lt; N - 1; i++)&#123; int temp = (int)Math.abs(num[i] - num[i + 1]); if(temp >= 1 &amp;&amp; temp &lt;= N - 1)&#123; hashTable[temp]++; if(hashTable[temp] > 1)&#123; jolly = false; break; &#125; &#125;else&#123; jolly = false; break; &#125; &#125; System.out.println((jolly ? \"Jolly\" : \"Not jolly\")); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"},{"name":"49題","slug":"49題","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/49%E9%A1%8C/"}]},{"title":"uva 10019 - Funny Encryption Method","slug":"coding/cpe/One Star/uva-10019-Funny-Encryption-Method","date":"2023-04-19T08:53:23.000Z","updated":"2023-04-26T05:00:18.238Z","comments":true,"path":"coding/cpe/One Star/uva-10019-Funny-Encryption-Method/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10019-Funny-Encryption-Method/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 無本題 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 A student from ITESM Campus Monterrey plays with a new encryption method for numbers. These method consist of the following steps: Steps : Example Read the number N to encrypt : M = 265 Interpret N as a decimal number : X1 = 265 (decimal) Convert the decimal interpretation of N to its binary representation : X1 = 100001001 (binary) Let b1 be equal to the number of 1’s in this binary representation : b1 = 3 Interpret N as a Hexadecimal number : X2 = 265 (hexadecimal) Convert the hexadecimal interpretation of N to its binary representation : X2 = 1001100101 Let b2 be equal to the number of 1’s in the last binary representation : b2 = 5 The encryption is the result of M xor (b1 ∗ b2) : 265 xor (3*5) = 262 This student failed Computational Organization, thats why this student asked the judges of ITESM Campus Monterrey internal ACM programming Contest to ask for the numbers of 1’s bits of this two representations so that he can continue playing. You have to write a program that read a Number and give as output the number b1 and b2 # Input The first line will contain a number N which is the number of cases that you have to process. Each of the following N Lines (0 &lt; N ≤ 1000) will contain the number M (0 &lt; M ≤ 9999, in decimal representation) which is the number the student wants to encrypt. # Output You will have to output N lines, each containing the number b1 and b2 in that order, separated by one space corresponding to that lines number to crypt 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 3 265 111 1234 # Sample Output 3 5 6 3 5 5 # 解題技巧 # Solution Main.javaimport java.math.BigInteger;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); for(int i = 0; i &lt; N; i++)&#123; String M = sc.next(); String X1 = (new BigInteger(M, 10)).toString(2); String X2 = (new BigInteger(M, 16)).toString(2); int b1 = 0; int b2 = 0; for(int j = 0; j &lt; X1.length(); j++)&#123; if(X1.charAt(j) == '1') b1++; &#125; for(int j = 0; j &lt; X2.length(); j++)&#123; if(X2.charAt(j) == '1') b2++; &#125; System.out.println(b1 + \" \" + b2); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"uva 10018 - Reverse and Add","slug":"coding/cpe/One Star/uva-10018-Reverse-and-Add","date":"2023-04-19T08:15:30.000Z","updated":"2023-04-20T06:34:03.076Z","comments":true,"path":"coding/cpe/One Star/uva-10018-Reverse-and-Add/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10018-Reverse-and-Add/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The “reverse and add” method is simple: choose a number, reverse its digits and add it to the original. If the sum is not a palindrome (which means, it is not the same number from left to right and right to left), repeat this procedure. In this particular case the palindrome ‘9339’ appeared after the 4th addition. This method leads to palindromes in a few step for almost all of the integers. But there are interesting exceptions. 196 is the first number for which no palindrome has been found. It is not proven though, that there is no such a palindrome. You must write a program that give the resulting palindrome and the number of iterations (additions) to compute the palindrome. You might assume that all tests data on this problem: will have an answer , will be computable with less than 1000 iterations (additions), will yield a palindrome that is not greater than 4,294,967,295. # Input The first line will have a number N (0 &lt; N ≤ 100) with the number of test cases, the next N lines will have a number P to compute its palindrome. # Output For each of the N tests you will have to write a line with the following data : minimum number of iterations(additions) to get to the palindrome and the resulting palindrome itself separated by one space. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 3 195 265 750 # Sample Output 4 9339 5 45254 3 6666 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); for (int i = 0; i &lt; N; i++) &#123; String P = sc.next(); boolean check = false; int count = 0; while (!check) &#123; StringBuffer temp = new StringBuffer(P); temp = temp.reverse(); String reverseP = temp.toString(); String nextP = Long.toString(Long.parseLong(P) + Long.parseLong(reverseP)); for (int j = 0; j &lt; nextP.length() / 2; j++) &#123; if (nextP.charAt(nextP.length() - 1 - j) != nextP.charAt(j)) &#123; check = false; break; &#125;else&#123; check = true; &#125; &#125; if(nextP.length() == 1)&#123; check = true; &#125; P = nextP; count++; &#125; System.out.println(count + \" \" + P); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"uva 10008 - What’s Cryptanalysis?","slug":"coding/cpe/One Star/uva-10008-What’s-Cryptanalysis","date":"2023-04-19T03:48:29.000Z","updated":"2023-04-20T06:33:50.537Z","comments":true,"path":"coding/cpe/One Star/uva-10008-What’s-Cryptanalysis/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10008-What%E2%80%99s-Cryptanalysis/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Cryptanalysis is the process of breaking someone else’s cryptographic writing. This sometimes involves some kind of statistical analysis of a passage of (encrypted) text. Your task is to write a program which performs a simple analysis of a given text. # Input The first line of input contains a single positive decimal integer n. This is the number of lines which follow in the input. The next n lines will contain zero or more characters (possibly including whitespace). This is the text which must be analyzed. # Output Each line of output contains a single uppercase letter, followed by a single space, then followed by a positive decimal integer. The integer indicates how many times the corresponding letter appears in the input text. Upper and lower case letters in the input are to be considered the same. No other characters must be counted. The output must be sorted in descending count order; that is, the most frequent letter is on the first output line, and the last line of output indicates the least frequent letter. If two letters have the same frequency, then the letter which comes first in the alphabet must appear first in the output. If a letter does not appear in the text, then that letter must not appear in the output. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 3 This is a test. Count me 1 2 3 4 5. Wow!!!! Is this question easy? # Sample Output S 7 T 6 I 5 E 4 O 3 A 2 H 2 N 2 U 2 W 2 C 1 M 1 Q 1 Y 1 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); sc.nextLine(); Alp[] alp = new Alp[26]; for(int i = 0; i &lt; 26; i++)&#123; alp[i] = new Alp((char)(i + 'A')); &#125; for(int i = 0; i &lt; n; i++)&#123; String str = sc.nextLine(); for(int j = 0; j &lt; str.length(); j++)&#123; char a = str.charAt(j); if(a >= 'A' &amp;&amp; a &lt;= 'Z')&#123; alp[(int)a - 'A'].add();; &#125; if(a >= 'a' &amp;&amp; a &lt;= 'z')&#123; alp[(int)a - 'a'].add();; &#125; &#125; &#125; Arrays.sort(alp, new Comparator&lt;Alp>() &#123; @Override public int compare(Alp a, Alp b) &#123; if (a.count == b.count) return a.letter - b.letter; return b.count - a.count; &#125; &#125;); for(Alp a : alp)&#123; if(a.count != 0)&#123; System.out.println(a.letter + \" \" + a.count); &#125;else&#123; break; &#125; &#125; sc.close(); &#125;&#125;class Alp&#123; public char letter; public int count; public Alp(char l)&#123; letter = l; count = 0; &#125; public void add()&#123; count++; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"1372. Longest ZigZag Path in a Binary Tree","slug":"coding/leetcode/Medium/1372-Longest-ZigZag-Path-in-a-Binary-Tree","date":"2023-04-19T01:58:24.000Z","updated":"2023-04-20T01:36:41.245Z","comments":true,"path":"coding/leetcode/Medium/1372-Longest-ZigZag-Path-in-a-Binary-Tree/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1372-Longest-ZigZag-Path-in-a-Binary-Tree/","excerpt":"","text":"⭐️⭐️ # 題目敘述 You are given the root of a binary tree. A ZigZag path for a binary tree is defined as follow: Choose any node in the binary tree and a direction (right or left). If the current direction is right, move to the right child of the current node; otherwise, move to the left child. Change the direction from right to left or from left to right. Repeat the second and third steps until you can't move in the tree. Zigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0). Return the longest ZigZag path contained in that tree. # Example 1 Input: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1] Output: 3 Explanation: Longest ZigZag path in blue nodes (right -&gt; left -&gt; right). # Example 2 Input: root = [1,1,1,null,1,null,null,1,1,null,1] Output: 4 Explanation: Longest ZigZag path in blue nodes (left -&gt; right -&gt; left -&gt; right). # Example 3: Input: root = [1] Output: 0 # 解題思路 # Solution class Solution &#123; int ans = 0; public int longestZigZag(TreeNode root) &#123; dfs(root, false, 0); dfs(root, true, 0); return ans; &#125; public void dfs(TreeNode node, boolean goLeft, int steps) &#123; if (node == null) &#123; return ; &#125; ans = Math.max(ans, steps); if (goLeft) &#123; dfs(node.left, false, steps + 1); dfs(node.right, true, 1); &#125; else &#123; dfs(node.left, false, 1); dfs(node.right, true, steps + 1); &#125; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Tree","slug":"Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Tree/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Tree/"}]},{"title":"1431. Kids With the Greatest Number of Candies","slug":"coding/leetcode/Easy/1431-Kids-With-the-Greatest-Number-of-Candies","date":"2023-04-17T01:49:25.000Z","updated":"2023-04-20T01:36:54.786Z","comments":true,"path":"coding/leetcode/Easy/1431-Kids-With-the-Greatest-Number-of-Candies/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1431-Kids-With-the-Greatest-Number-of-Candies/","excerpt":"","text":"⭐️ # 題目敘述 There are n kids with candies. You are given an integer array candies , where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies , denoting the number of extra candies that you have. Return a boolean array result of length n , where result[i] is true if, after giving the ith kid all the extraCandies , they will have the greatest number of candies among all the kids, or false otherwise. Note that multiple kids can have the greatest number of candies. # Example 1: Input: candies = [2,3,5,1,3], extraCandies = 3 Output: [true,true,true,false,true] Explanation: If you give all extraCandies to: Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids. Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids. Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids. Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids. Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids. # Example 2: Input: candies = [4,2,1,1,2], extraCandies = 1 Output: [true,false,false,false,false] Explanation: There is only 1 extra candy. Kid 1 will always have the greatest number of candies, even if a different kid is given the extra candy. # Example 3: Input: candies = [12,1,12], extraCandies = 10 Output: [true,false,true] # 解題思路 # Solution import java.util.ArrayList;import java.util.List;class Solution &#123; public List&lt;Boolean> kidsWithCandies(int[] candies, int extraCandies) &#123; int max = 0; for(int candy : candies)&#123; max = Math.max(candy, max); &#125; List&lt;Boolean> ans = new ArrayList&lt;>(); for(int candy : candies)&#123; int temp = candy + extraCandies; ans.add(temp &lt; max ? false : true); &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"}]},{"title":"uva 1587 - Box","slug":"coding/cpe/One Star/uva-1587-Box","date":"2023-04-15T13:16:47.000Z","updated":"2023-04-20T06:33:39.732Z","comments":true,"path":"coding/cpe/One Star/uva-1587-Box/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-1587-Box/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Ivan works at a factory that produces heavy machinery. He has a simple job — he knocks up wooden boxes of different sizes to pack machinery for delivery to the customers. Each box is a rectangular parallelepiped. Ivan uses six rectangular wooden pallets to make a box. Each pallet is used for one side of the box. Joe delivers pallets for Ivan. Joe is not very smart and often makes mistakes — he brings Ivan pallets that do not fit together to make a box. But Joe does not trust Ivan. It always takes a lot of time to explain Joe that he has made a mistake. Fortunately, Joe adores everything related to computers and sincerely believes that computers never make mistakes. Ivan has decided to use this for his own advantage. Ivan asks you to write a program that given sizes of six rectangular pallets tells whether it is possible to make a box out of them. # Input Input file contains several test cases. Each of them consists of six lines. Each line describes one pallet and contains two integer numbers w and h (1 ≤ w, h ≤ 10 000) — width and height of the pallet in millimeters respectively. # Output For each test case, print one output line. Write a single word ‘POSSIBLE’ to the output file if it is possible to make a box using six given pallets for its sides. Write a single word ‘IMPOSSIBLE’ if it is not possible to do so. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 1345 2584 2584 683 2584 1345 683 1345 683 1345 2584 683 1234 4567 1234 4567 4567 4321 4322 4567 4321 1234 4321 1234 # Sample Output POSSIBLE IMPOSSIBLE # 解題技巧 # Solution Main.javaimport java.util.*;class Box &#123; public int x, y; public Box(int x, int y) &#123; this.x = x; this.y = y; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNextInt()) &#123; Box[] box = new Box[6]; for (int i = 0; i &lt; 6; i++) &#123; int L = sc.nextInt(); int W = sc.nextInt(); box[i] = new Box(Math.max(L, W), Math.min(L, W)); &#125; Arrays.sort(box, new Comparator&lt;Box>() &#123; @Override public int compare(Box a, Box b) &#123; if (a.x == b.x) return a.y - b.y; return a.x - b.x; &#125; &#125;); boolean isBox = false; if (box[0].y == box[1].y &amp;&amp; box[1].y == box[2].y &amp;&amp; box[2].y == box[3].y &amp;&amp; box[2].x == box[3].x &amp;&amp; box[3].x == box[4].x &amp;&amp; box[4].x == box[5].x &amp;&amp; box[0].x == box[1].x &amp;&amp; box[1].x == box[4].y &amp;&amp; box[4].y == box[5].y) &#123; isBox = true; &#125; System.out.println(isBox ? \"POSSIBLE\" : \"IMPOSSIBLE\"); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"uva 1585 - Score","slug":"coding/cpe/One Star/uva-1585-Score","date":"2023-04-15T06:30:55.000Z","updated":"2023-04-20T06:33:25.783Z","comments":true,"path":"coding/cpe/One Star/uva-1585-Score/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-1585-Score/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 There is an objective test result such as “OOXXOXXOOO” . An ‘O’ means a correct answer of a problem and an ‘X’ means a wrong answer. The score of each problem of this test is calculated by itself and its just previous consecutive ‘O’s only when the answer is correct. For example, the score of the 10th problem is 3 that is obtained by itself and its two previous consecutive ‘O’s . Therefore, the score of “OOXXOXXOOO” is 10 which is calculated by “1+2+0+0+1+0+0+1+2+3” . You are to write a program calculating the scores of test results. # Input Your program is to read from standard input. The input consists of T test cases. The number of test cases T is given in the first line of the input. Each test case starts with a line containing a string composed by ‘O’ and ‘X’ and the length of the string is more than 0 and less than 80 . There is no spaces between ‘O’ and ‘X’ . # Output Your program is to write to standard output. Print exactly one line for each test case. The line is to contain the score of the test case. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 5 OOXXOXXOOO OOXXOOXXOO OXOXOXOXOXOXOX OOOOOOOOOO OOOOXOOOOXOOOOX # Sample Output 10 9 7 55 30 # 解題技巧 檢查 result 每一題是否正確。 'O' : 加上該題分數。 'X' : 則該題零分。 該題分數：前一題如果正確當前該題分數比前一題多一。 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for(int i = 0; i &lt; T; i++)&#123; String result = sc.next(); int curr = 1; boolean check = false; int ans = 0; for(int j = 0; j &lt; result.length(); j++)&#123; if(result.charAt(j) == 'X')&#123; check = false; curr = 1; &#125;else &#123; if(check)&#123; curr++; &#125; ans += curr; check = true; &#125; &#125; System.out.println(ans); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"2218. Maximum Value of K Coins From Piles","slug":"coding/leetcode/Hard/2218-Maximum-Value-of-K-Coins-From-Piles","date":"2023-04-15T04:01:24.000Z","updated":"2023-04-20T01:37:31.044Z","comments":true,"path":"coding/leetcode/Hard/2218-Maximum-Value-of-K-Coins-From-Piles/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/2218-Maximum-Value-of-K-Coins-From-Piles/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 There are n piles of coins on a table. Each pile consists of a positive number of coins of assorted denominations. In one move, you can choose any coin on top of any pile, remove it, and add it to your wallet. Given a list piles , where piles[i] is a list of integers denoting the composition of the ith pile from top to bottom, and a positive integer k , return the maximum total value of coins you can have in your wallet if you choose exactly k coins optimally. # Example 1: Input: piles = [[1,100,3],[7,8,9]], k = 2 Output: 101 Explanation: The above diagram shows the different ways we can choose k coins. The maximum total we can obtain is 101. # Example 2: Input: piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7 Output: 706 Explanation: The maximum total can be obtained if we choose all coins from the last pile. # 解題思路 # Solution import java.util.Arrays;import java.util.List;class Solution &#123; public int maxValueOfCoins(List&lt;List&lt;Integer>> piles, int k) &#123; int[][] dp = new int[piles.size() + 1][k + 1]; Arrays.fill(dp[0], 0); for (int i = 1; i &lt;= piles.size(); i++) &#123; dp[i][0] = 0; &#125; for (int i = 1; i &lt;= piles.size(); i++) &#123; for (int j = 1; j &lt;= k; j++) &#123; int curr = 0; for (int x = 0; x &lt; Math.min(piles.get(i - 1).size(), j); x++) &#123; curr += piles.get(i - 1).get(x); dp[i][j] = Math.max(dp[i][j], curr + dp[i - 1][j - x - 1]); &#125; dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]); &#125; &#125; return dp[piles.size()][k]; &#125;&#125; 單字 denoting 表示 to represent something 片語 & 搭配詞 assorted denominations 個種面額","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"}]},{"title":"516. Longest Palindromic Subsequence","slug":"coding/leetcode/Medium/516-Longest-Palindromic-Subsequence","date":"2023-04-14T17:08:29.000Z","updated":"2023-04-20T01:35:37.594Z","comments":true,"path":"coding/leetcode/Medium/516-Longest-Palindromic-Subsequence/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/516-Longest-Palindromic-Subsequence/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a string s , find the longest palindromic subsequence's length in s . A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. # Example 1: Input: s = &quot;bbbab&quot; Output: 4 Explanation: One possible longest palindromic subsequence is &quot;bbbb&quot;. # Example 2: Input: s = &quot;cbbd&quot; Output: 2 Explanation: One possible longest palindromic subsequence is &quot;bb&quot;. # 解題思路 # Solution class Solution &#123; public int longestPalindromeSubseq(String s) &#123; int n = s.length(); int[] dp = new int[n]; for (int i = n - 1; i >= 0; i--) &#123; int[] newdp = new int[n]; newdp[i] = 1; for (int j = i + 1; j &lt; n; j++) &#123; if (s.charAt(i) == s.charAt(j)) &#123; newdp[j] = 2 + dp[j-1]; &#125; else &#123; newdp[j] = Math.max(dp[j], newdp[j-1]); &#125; &#125; dp = newdp; &#125; return dp[n-1]; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"946. Validate Stack Sequences","slug":"coding/leetcode/Medium/946-Validate-Stack-Sequences","date":"2023-04-13T01:21:33.000Z","updated":"2023-04-20T01:36:05.468Z","comments":true,"path":"coding/leetcode/Medium/946-Validate-Stack-Sequences/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/946-Validate-Stack-Sequences/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given two integer arrays pushed and popped each with distinct values, return true if this could have been the result of a sequence of push and pop operations on an initially empty stack, or false otherwise. # Example 1: Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1] Output: true Explanation: We might do the following sequence: push(1), push(2), push(3), push(4), pop() -&gt; 4, push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1 # Example 2: Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2] Output: false Explanation: 1 cannot be popped before 2. # 解題思路 # Solution import java.util.Stack;class Solution &#123; public boolean validateStackSequences(int[] pushed, int[] popped) &#123; Stack&lt;Integer> stack = new Stack&lt;>(); int index = 0; for(int p : pushed)&#123; stack.push(p); while(!stack.isEmpty() &amp;&amp; stack.peek() == popped[index])&#123; stack.pop(); index++; &#125; &#125; return stack.isEmpty(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"}]},{"title":"71. Simplify Path","slug":"coding/leetcode/Medium/71-Simplify-Path","date":"2023-04-12T03:22:17.000Z","updated":"2023-04-20T01:34:37.850Z","comments":true,"path":"coding/leetcode/Medium/71-Simplify-Path/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/71-Simplify-Path/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a string path , which is an absolute path (starting with a slash '/' ) to a file or directory in a Unix-style file system, convert it to the simplified canonical path. In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//' ) are treated as a single slash '/' . For this problem, any other format of periods such as '...' are treated as file/directory names. The canonical path should have the following format: The path starts with a single slash '/'. Any two directories are separated by a single slash '/'. The path does not end with a trailing '/'. The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..') Return the simplified canonical path. # Example 1: Input: path = &quot;/home/&quot; Output: &quot;/home&quot; Explanation: Note that there is no trailing slash after the last directory name. # Example 2: Input: path = &quot;/../&quot; Output: &quot;/&quot; Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. # Example 3: Input: path = &quot;/home//foo/&quot; Output: &quot;/home/foo&quot; Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. # 解題思路 # Solution import java.util.Stack;class Solution &#123; public String simplifyPath(String path) &#123; Stack&lt;String> stack = new Stack&lt;>(); for (String str : path.split(\"/\")) &#123; if (!stack.isEmpty() &amp;&amp; str.equals(\"..\")) &#123; stack.pop(); &#125; else if (!str.equals(\".\") &amp;&amp; !str.equals(\"\") &amp;&amp; !str.equals(\"..\")) &#123; stack.add(str); &#125; &#125; StringBuilder ans = new StringBuilder(); for (String str : stack) &#123; ans.append(\"/\").append(str); &#125; return ans.length() == 0 ? \"/\" : ans.toString(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"}]},{"title":"2390. Removing Stars From a String","slug":"coding/leetcode/Medium/2390-Removing-Stars-From-a-String","date":"2023-04-11T03:05:05.000Z","updated":"2023-04-20T01:37:39.266Z","comments":true,"path":"coding/leetcode/Medium/2390-Removing-Stars-From-a-String/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2390-Removing-Stars-From-a-String/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given a string s , which contains stars * . In one operation, you can: Choose a star in s . Remove the closest non-star character to its left, as well as remove the star itself. Return the string after all stars have been removed. Note: The input will be generated such that the operation is always possible. It can be shown that the resulting string will always be unique. # Example 1: Input: s = &quot;leet**cod*e&quot; Output: &quot;lecoe&quot; Explanation: Performing the removals from left to right: The closest character to the 1st star is 't' in &quot;leet**cod*e&quot; . s becomes &quot;lee*cod*e&quot; . The closest character to the 2nd star is 'e' in &quot;lee*cod*e&quot; . s becomes &quot;lecod*e&quot; . The closest character to the 3rd star is 'd' in &quot;lecod*e&quot; . s becomes &quot;lecoe&quot; . There are no more stars, so we return &quot;lecoe&quot; . # Example 2: Input: s = &quot;erase*****&quot; Output: &quot;&quot; Explanation: The entire string is removed, so we return an empty string. # 解題思路 # Solution import java.util.Stack;class Solution &#123; public String removeStars(String s) &#123; char[] toChar = s.toCharArray(); Stack&lt;Character> stack = new Stack&lt;>(); for(int i = 0; i &lt; s.length(); i++)&#123; if(toChar[i] == '*')&#123; stack.pop(); &#125;else &#123; stack.add(toChar[i]); &#125; &#125; String ans = \"\"; while(!stack.isEmpty())&#123; ans = stack.pop() + ans; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"}]},{"title":"20. Valid Parentheses","slug":"coding/leetcode/Easy/20-Valid-Parentheses","date":"2023-04-10T01:44:58.000Z","updated":"2023-04-20T01:35:25.178Z","comments":true,"path":"coding/leetcode/Easy/20-Valid-Parentheses/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/20-Valid-Parentheses/","excerpt":"","text":"⭐️ # 題目敘述 Given a string s containing just the characters '(' , ')' , '&#123;' , '&#125;' , '[' and ']' , determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type. # Example 1: Input: s = &quot;()&quot; Output: true # Example 2: Input: s = &quot;(){}&quot; Output: true # Example 3: Input: s = &quot;(]&quot; Output: false # 解題思路 利用 stack。 # Solution import java.util.Stack;class Solution &#123; public boolean isValid(String s) &#123; if (s.length() % 2 != 0) &#123; return false; &#125; Stack&lt;Character> stack = new Stack&lt;>(); for (char c : s.toCharArray()) &#123; switch(c)&#123; case '(': case '&#123;': case '[': stack.push(c); break; case ')': if(stack.isEmpty() || stack.pop() != '(') return false; break; case '&#125;': if(stack.isEmpty() || stack.pop() != '&#123;') return false; break; case ']': if(stack.isEmpty() || stack.pop() != '[') return false; break; &#125; &#125; return (stack.isEmpty()); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"}]},{"title":"You Are What You Eat - Part B","slug":"language/english/雜誌/You-Are-What-You-Eat-Part-B","date":"2023-04-09T22:01:06.000Z","updated":"2023-04-09T22:12:21.470Z","comments":true,"path":"language/english/雜誌/You-Are-What-You-Eat-Part-B/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/language/english/%E9%9B%9C%E8%AA%8C/You-Are-What-You-Eat-Part-B/","excerpt":"","text":"⭐️ # You Are What You Eat - Part B The next night, Tara is making dinner. 隔天晚上，塔拉正在做晚餐。 Blake: What are you cooking? Tara: I'm making steamed fish. I'm also going to make brown rice. That's healthier than white rice. Blake: Let's add lots of salt. That will make ti better. Tara: No way. Maybe we can add some low-fat cheese. What do you say? Blake: Well...all right. Can we also have some fruit? Tara: Sure! You can cut some apples. We'll eat them before dinner. Blake: I have a better idea. Let's have banana ice cream. Bananas are fruit. Tara: Forget it. Hurry up and get those apples. 單字 cook 煮；烹調 When you cook food, you prepare it to be eaten by heating it in a particular way, such as baking or boiling, and when food cooks, it is heated until it is ready to eat 片語 & 搭配詞 !! !! # 前言 BARRY: To understand what I'm about to tell you, you need to do something first. You need to believe int the impossible. Can you do that? Good. You see that red blur? That's me. That too. There I am again. My name is Barry Allen. I am the fastest man alive. 14 YEARS AGO My story is pretty simple. My whole life, I've been running. Usually from bullies. Sometimes I escaped. Sometimes I did not. NORA: Tell me what happened. BARRY: Those guys were picking on kids... ...just because they thought they weren't cool. It wasn't right. NORA: I know. BARRY: I guess I wasn't fast enough. NORA: No. You have such a good heart, Barry. And it's better to have a good heart than fast legs. HENRY: Hello? I'm home. NORA: Barry got into a fight. HENRY: Oh, yeah? NORA: And he won. HENRY: Way to go, slugger. Oh, and no more fighting. CLATTERING AND CLANKING BARRY: But after that night, I was running from something much scarier. NORA: Henry! Henry! BARRY: Something I could never explain. Something impossible. NORA SCREAMING BARRY: Mom! Mon! NORA: Barry, don't! Get back! BARRY: Mom! Mom! NORA: Ah! HENRY: Nora! NORA: Stay back! HENRY: Nora, hold on! Run, Barry. Run! BARRY: Mom? Dad? TODAY PANTING BARRY: Sorry. SIREN WAILS CHYRE: Second robbery this week. The teller ID'd Clyde Mardon as the shooter. What? Oh, jeez, the Mardon brothers are back? SINGH: What do we got? JOE: Perps took the bank, shot out the cameras... ...and killed the security guard there. I got unis kicking in doors of their known associates. SINGH: CSI been over it? JOE: No. SINGH: Where's Allen? BARRY: Unh! Sorry, sorry. SINGH: You can't keep covering for him. BARRY: Coming through. SINGH: I have to carry on without him. BARRY: Sorry I'm late, Captain Singh. SINGH: What was it this time? Forget to see your alarm clock? Before you answer, the excuse you gave last time was car trouble. Wanna know why that one was memorable? BARRY: I do not own a car. JOE: He was running an errand for me. Barry, did you get me what I asked for? BARRY: Yeah. Yeah, I did. I have it right... here. I had a few bites of it.","categories":[{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"雜誌","slug":"language/english/雜誌","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E9%9B%9C%E8%AA%8C/"}],"tags":[{"name":"難度 1","slug":"難度-1","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-1/"},{"name":"英文雜誌","slug":"英文雜誌","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E9%9B%9C%E8%AA%8C/"},{"name":"對話","slug":"對話","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%B0%8D%E8%A9%B1/"}]},{"title":"uva 1368 - DNA Consensus String","slug":"coding/cpe/One Star/uva-1368-DNA-Consensus-String","date":"2023-04-09T20:31:59.000Z","updated":"2023-04-20T06:33:17.676Z","comments":true,"path":"coding/cpe/One Star/uva-1368-DNA-Consensus-String/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-1368-DNA-Consensus-String/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 DNA (Deoxyribonucleic Acid) is the molecule which contains the genetic instructions. It consists of four different nucleotides, namely Adenine, Thymine, Guanine, and Cytosine as shown in Figure 1. If we represent a nucleotide by its initial character, a DNA strand can be regarded as a long string (sequence of characters) consisting of the four characters A, T, G, and C. For example, assume we are given some part of a DNA strand which is composed of the following sequence of nucleotides: “Thymine-Adenine-Adenine-Cytosine-Thymine-Guanine-CytosineCytosine-Guanine-Adenine-Thymine” Then we can represent the above DNA strand with the string “TAACTGCCGAT.” The biologist Prof. Ahn found that a gene X commonly exists in the DNA strands of five different kinds of animals, namely dogs, cats, horses, cows, and monkeys. He also discovered that the DNA sequences of the gene X from each animal were very alike. See Figure 2. Prof. Ahn thought that humans might also have the gene X and decided to search for the DNA sequence of X in human DNA. However, before searching, he should define a representative DNA sequence of gene X because its sequences are not exactly the same in the DNA of the five animals. He decided to use the Hamming distance to define the representative sequence. The Hamming distance is the number of different characters at each position from two strings of equal length. For example, assume we are given the two strings “AGCAT” and “GGAAT.” The Hamming distance of these two strings is 2 because the 1st and the 3rd characters of the two strings are different. Using the Hamming distance, we can define a representative string for a set of multiple strings of equal length. Given a set of strings S = {s1, . . . , sm} of length n, the consensus error between a string y of length n and the set S is the sum of the Hamming distances between y and each si in S. If the consensus error between y and S is the minimum among all possible strings y of length n, y is called a consensus string of S. For example, given the three strings “AGCAT” “AGACT” and “GGAAT” the consensus string of the given strings is “AGAAT” because the sum of the Hamming distances between “AGAAT” and the three strings is 3 which is minimal. (In this case, the consensus string is unique, but in general, there can be more than one consensus string.) We use the consensus string as a representative of the DNA sequence. For the example of Figure 2 above, a consensus string of gene X is “GCAAATGGCTGTGCA” and the consensus error is 7. # Input Your program is to read from standard input. The input consists of T test cases. The number of test cases T is given in the first line of the input. Each test case starts with a line containing two integers m and n which are separated by a single space. The integer m (4 ≤ m ≤ 50) represents the number of DNA sequences and n (4 ≤ n ≤ 1000) represents the length of the DNA sequences, respectively. In each of the next m lines, each DNA sequence is given. # Output Your program is to write to standard output. Print the consensus string in the first line of each case and the consensus error in the second line of each case. If there exists more than one consensus string, print the lexicographically smallest consensus string. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 3 5 8 TATGATAC TAAGCTAC AAAGATCC TGAGATAC TAAGATGT 4 10 ACGTACGTAC CCGTACGTAG GCGTACGTAT TCGTACGTAA 6 10 ATGTTACCAT AAGTTACGAT AACAAAGCAA AAGTTACCTT AAGTTACCAA TACTTACCAA # Sample Output TAAGATAC 7 ACGTACGTAA 6 AAGTTACCAA 12 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int T = sc.nextInt(); // ACGT Map&lt;Character, Integer> toInt = new HashMap&lt;>(); Map&lt;Integer, Character> toChar = new HashMap&lt;>(); toInt.put('A', 0); toChar.put(0, 'A'); toInt.put('C', 1); toChar.put(1, 'C'); toInt.put('G', 2); toChar.put(2, 'G'); toInt.put('T', 3); toChar.put(3, 'T'); for (int i = 0; i &lt; T; i++) &#123; int m = sc.nextInt(); int n = sc.nextInt(); char[][] DNA = new char[m][n]; int[][] count = new int[n][4]; for (int j = 0; j &lt; m; j++) &#123; DNA[j] = sc.next().toCharArray(); for (int k = 0; k &lt; n; k++) &#123; count[k][toInt.get(DNA[j][k])]++; &#125; &#125; int sum = 0; for (int j = 0; j &lt; n; j++) &#123; int max = -1; int index = -1; for (int k = 3; k >= 0; k--) &#123; if (count[j][k] >= max) &#123; max = count[j][k]; index = k; &#125; &#125; System.out.print(toChar.get(index)); sum += m - max; &#125; System.out.println(); System.out.println(sum); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"1857. Largest Color Value in a Directed Graph","slug":"coding/leetcode/Hard/1857-Largest-Color-Value-in-a-Directed-Graph","date":"2023-04-09T04:05:26.000Z","updated":"2023-04-20T01:37:04.683Z","comments":true,"path":"coding/leetcode/Hard/1857-Largest-Color-Value-in-a-Directed-Graph/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/1857-Largest-Color-Value-in-a-Directed-Graph/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 There is a directed graph of n colored nodes and m edges. The nodes are numbered from 0 to n - 1 . You are given a string colors where colors[i] is a lowercase English letter representing the color of the ith node in this graph (0-indexed). You are also given a 2D array edges where edges[j] = [aj, bj] indicates that there is a directed edge from node aj to node bj . A valid path in the graph is a sequence of nodes x1 -&gt; x2 -&gt; x3 -&gt; ... -&gt; xk such that there is a directed edge from xi to xi+1 for every 1 &lt;= i &lt; k . The color value of the path is the number of nodes that are colored the most frequently occurring color along that path. Return the largest color value of any valid path in the given graph, or -1 if the graph contains a cycle. # Example 1: Input: colors = &quot;abaca&quot;, edges = [[0,1],[0,2],[2,3],[3,4]] Output: 3 Explanation: The path 0 -&gt; 2 -&gt; 3 -&gt; 4 contains 3 nodes that are colored &quot;a&quot; (red in the above image) . # Example 2: Input: colors = &quot;a&quot;, edges = [[0,0]] Output: -1 Explanation: There is a cycle from 0 to 0. # 解題思路 # Solution import java.util.ArrayList;import java.util.LinkedList;import java.util.List;import java.util.Queue;class Solution &#123; public int largestPathValue(String colors, int[][] edges) &#123; List&lt;List&lt;Integer>> graph = new ArrayList&lt;>(); int length = colors.length(); int inDegree[] = new int[length]; int colorsDP[][] = new int[length][26]; int visited = 0; for (int i = 0; i &lt; length; i++) &#123; graph.add(new ArrayList&lt;>()); &#125; for (int i = 0; i &lt; edges.length; i++) &#123; int start = edges[i][0]; int end = edges[i][1]; graph.get(start).add(end); inDegree[end]++; &#125; Queue&lt;Integer> queue = new LinkedList&lt;>(); for (int i = 0; i &lt; inDegree.length; i++) &#123; if (inDegree[i] == 0) &#123; queue.add(i); &#125; &#125; while (!queue.isEmpty()) &#123; int parent = queue.poll(); int parentColor = colors.charAt(parent) - 'a'; colorsDP[parent][parentColor] = colorsDP[parent][parentColor] + 1; for (Integer child : graph.get(parent)) &#123; inDegree[child]--; if (inDegree[child] == 0) &#123; queue.add(child); &#125; for (int i = 0; i &lt; 26; i++) &#123; colorsDP[child][i] = Math.max(colorsDP[child][i], colorsDP[parent][i]); &#125; &#125; visited++; &#125; if (visited != length) return -1; int maxColor = 0; for (int i = 0; i &lt; colorsDP.length; i++) &#123; for (int j = 0; j &lt; 26; j++) &#123; maxColor = Math.max(maxColor, colorsDP[i][j]); &#125; &#125; return maxColor; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Topological Sort","slug":"Topological-Sort","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Topological-Sort/"},{"name":"Memoization","slug":"Memoization","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Memoization/"}]},{"title":"uva 1237 - Expert Enough?","slug":"coding/cpe/One Star/uva-1237-Expert-Enough","date":"2023-04-08T16:27:36.000Z","updated":"2023-04-20T06:33:10.272Z","comments":true,"path":"coding/cpe/One Star/uva-1237-Expert-Enough/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-1237-Expert-Enough/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Auto-mobile Charting &amp; Manufacturing (ACM) is a company that specializes in manufacturing automobile spare parts. Being one of the leading automotive companies in the world, ACM are sure to keep up the latest information in that world. In the 100-year anniversary of the company, ACM compiled a huge list of range of prices of any automobiles ever recorded in the history. ACM then wants to develop a program that they called Automobile Expert System or AES for short. The program receives a price P as an input, and searches through the database for a car maker in which P falls in their range of lowest price L and highest price H of car they ever made. The program then output the car maker name. If the database contains no or more than one car maker that satisfies the query, the program produce output ‘UNDETERMINED’ (without quotes). Not so expert, huh? You are about to develop that program for ACM. # Input The input begins with a line containing an integer T (T ≤ 10) , the number of test cases follow. Each case begins with the size of the database D (D &lt; 10000) . The next each of D lines contains M , L and H (0 &lt; L &lt; H &lt; 1000000) which are the name of the maker (contains no whitespace and will never exceeds 20 characters), the car’s lowest price the maker ever made, and the car’s highest price the maker ever made respectively. Then there is the number of query Q (Q &lt; 1000) follows. Each of the next Q lines contains an integer P (0 &lt; P &lt; 1000000) , the query price. # Output Output for each query should be one line containing the name of the maker, or the string ‘UNDETERMINED’ (without quotes) if there is no maker or more than one maker that satisfies the query. You should separate output for different case by one empty line. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 1 4 HONDA 10000 45000 PEUGEOT 12000 44000 BMW 30000 75900 CHEVROLET 7000 37000 4 60000 7500 5000 10000 # Sample Output BMW CHEVROLET UNDETERMINED UNDETERMINED # 解題技巧 # Solution Java I/O 加速 Main.javaimport java.util.*;import java.io.*;public class Main &#123; public static void main(String[] args) &#123; InputStream inputStream = System.in; OutputStream outputStream = System.out; Scanner in = new Scanner(inputStream); PrintWriter out = new PrintWriter(outputStream); CPE slove = new CPE(); slove.slover(1, in, out); out.close(); &#125; static class CPE &#123; public void slover(int testNumber, Scanner in, PrintWriter out) &#123; int T = in.nextInt(); for (int i = 0; i &lt; T; i++) &#123; if (i != 0) &#123; out.println(); &#125; int D = in.nextInt(); Map&lt;int[], String> map = new HashMap&lt;>(); for (int j = 0; j &lt; D; j++) &#123; String M = in.next(); int[] LH = new int[2]; LH[0] = in.nextInt(); LH[1] = in.nextInt(); map.put(LH, M); &#125; int Q = in.nextInt(); for (int j = 0; j &lt; Q; j++) &#123; ArrayList&lt;String> ans = new ArrayList&lt;>(); int P = in.nextInt(); for (int[] m : map.keySet()) &#123; if (m[0] &lt;= P &amp;&amp; m[1] >= P) &#123; ans.add(map.get(m)); if(ans.size() > 1) break; &#125; &#125; if (ans.size() == 1) &#123; out.println(ans.get(0)); &#125; else &#123; out.println(\"UNDETERMINED\"); &#125; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"uva 1225 - Digit Counting","slug":"coding/cpe/One Star/uva-1225-Digit-Counting","date":"2023-04-08T08:25:23.000Z","updated":"2023-04-20T06:33:01.703Z","comments":true,"path":"coding/cpe/One Star/uva-1225-Digit-Counting/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-1225-Digit-Counting/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Trung is bored with his mathematics homeworks. He takes a piece of chalk and starts writing a sequence of consecutive integers starting with 1 to N (1 &lt; N &lt; 10000) . After that, he counts the number of times each digit (0 to 9) appears in the sequence. For example, with N = 13 , the sequence is: 1234567891011121312345678910111213 12345678910111213 In this sequence, 0 appears once , 1 appears 6 times , 2 appears 2 times , 3 appears 3 times , and each digit from 4 to 9 appears once . After playing for a while, Trung gets bored again. He now wants to write a program to do this for him. Your task is to help him with writing this program. # Input The input file consists of several data sets. The first line of the input file contains the number of data sets which is a positive integer and is not bigger than 20 . The following lines describe the data sets. For each test case, there is one single line containing the number N . # Output For each test case, write sequentially in one line the number of digit 0, 1, . . . 9 separated by a space. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 2 3 13 # Sample Output 0 1 1 1 0 0 0 0 0 0 1 6 2 2 1 1 1 1 1 1 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int data = sc.nextInt(); for(int i = 0; i &lt; data; i++)&#123; int N = sc.nextInt(); int[] ans = new int[10]; for(int j = 1; j &lt;= N; j++)&#123; String str = Integer.toString(j); for(int l = 0; l &lt; str.length(); l++)&#123; ans[str.charAt(l) - '0']++; &#125; &#125; for(int j = 0; j &lt; 10; j++)&#123; if(j != 0)&#123; System.out.print(\" \"); &#125; System.out.print(ans[j]); &#125; System.out.println(); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"133. Clone Graph","slug":"coding/leetcode/Medium/133-Clone-Graph","date":"2023-04-08T03:40:24.000Z","updated":"2023-04-20T01:35:19.922Z","comments":true,"path":"coding/leetcode/Medium/133-Clone-Graph/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/133-Clone-Graph/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Each node in the graph contains a value ( int ) and a list ( List[Node] ) of its neighbors. class Node &#123; public int val; public List&lt;Node&gt; neighbors; &#125; Test case format: For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1 , the second node with val == 2 , and so on. The graph is represented in the test case using an adjacency list. An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph. The given node will always be the first node with val = 1 . You must return the copy of the given node as a reference to the cloned graph. # Example 1: Input: adjList = [[2,4],[1,3],[2,4],[1,3]] Output: [[2,4],[1,3],[2,4],[1,3]] Explanation: There are 4 nodes in the graph. 1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4). 2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3). 3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4). 4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3). # Example 2: Input: adjList = [[]] Output: [[]] Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors. # Example 3: Input: adjList = [] Output: [] Explanation: This an empty graph, it does not have any nodes. # 解題思路 # Solution import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;// Definition for a Node.class Node &#123; public int val; public List&lt;Node> neighbors; public Node() &#123; val = 0; neighbors = new ArrayList&lt;Node>(); &#125; public Node(int _val) &#123; val = _val; neighbors = new ArrayList&lt;Node>(); &#125; public Node(int _val, ArrayList&lt;Node> _neighbors) &#123; val = _val; neighbors = _neighbors; &#125;&#125;class Solution &#123; Map&lt;Node, Node> map = new HashMap&lt;>(); public Node cloneGraph(Node node) &#123; if (node == null) return null; if (map.containsKey(node)) return map.get(node); map.put(node, new Node(node.val)); for (Node val : node.neighbors) &#123; map.get(node).neighbors.add(cloneGraph(val)); &#125; return map.get(node); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"}]},{"title":"Reading Highlights 1: Uber: The Worlds Modern Taxi","slug":"language/english/Reading Highlights/Reading-Highlights-1-Uber-The-Worlds-Modern-Taxi","date":"2023-04-07T04:26:45.000Z","updated":"2023-04-07T10:10:21.319Z","comments":true,"path":"language/english/Reading Highlights/Reading-Highlights-1-Uber-The-Worlds-Modern-Taxi/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/language/english/Reading%20Highlights/Reading-Highlights-1-Uber-The-Worlds-Modern-Taxi/","excerpt":"","text":"⭐️⭐️⭐️⭐️ # Uber: The World's Modern Taxi A new taxi trend is taking over the world. Uber doesn't have a long history, but it has proven it's here to stay by providing major benefits and a competitive spirit. Travis Kalanick and Garrett Camp launched the Uber transportation app in 2009 in San Francisco, California, US. In May 2011, it started spreading to other American cities. In December of the same year, it expanded into its first international city - Pairs, France. Uber now operates in 58 countries and 300 cities across the globe. It's worth an estimated US$50 billion. Uber combines the traditional taxi ride with the morden technology of the 21st century. All Uber transactions are handled electronically; the app finds you a drive, navigates, and processes the paymemt. The only interaction you have with the driver is pleasant conversation. Using Uber is slightly different from a normal taxi ride because you can estimate the cost of your ride before you decide to hire a drive and split the fare with other passengers. Additionally, the app can send a text message with your Uber ride information to friends or family, adding an element of safety to your ride. Despite its many advantages, Uber has its critics. Some goverments have banned the app because its drivers aren't properly trained or insured. On February 19, Uber was declared illegal in Taiwan The goverment said that the drivers had violated the Highway Act and Transportation Management Regulations. Taxi companies have also opposed Uber, as they've lost business because of Uber's cheap rates and fast reaponse time. Protestes against Uber have become common, locally and internationally. It remains to be seen whether Uber's many advantages will win out against traditional taxis. Which one would you choose to take a ride in? # 段落大意 第一段: 告知主題是要闡述 new Taxi 第二段 Uber 發展史 第三段 Uber 的運作模式，好處等等 第四段 Uber 的問題或不足 # Reading Questions Which of the following statements about Uber is TRUE? It is illegal in some countries. It was started by a US taxi driver in 2009. It is more popular abroad than in the US. It operates through a control center. According to the passage, how does Uber work? Ubers can share the ride with other passengers. Ubers pay the transportation fare directly to the drivers. Ubers can negotiate the cost of the ride with the driver. Users have to register in paper from before using the service. Compared with normal taxis, Uber is all of the following EXCEPT . more advanced greener less costly more convenient What is one criticism of Uber based on the passage? The drivers don't show up fast enough. The drivers are not paid enough. The drivers lack sufficient training. The customer service is lousy.","categories":[{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"Reading Highlight","slug":"language/english/Reading-Highlight","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/Reading-Highlight/"}],"tags":[{"name":"英文 Reading Highlights","slug":"英文-Reading-Highlights","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87-Reading-Highlights/"},{"name":"閱讀","slug":"閱讀","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%96%B1%E8%AE%80/"},{"name":"難度 4","slug":"難度-4","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-4/"}]},{"title":"1020. Number of Enclaves","slug":"coding/leetcode/Medium/1020-Number-of-Enclaves","date":"2023-04-07T01:25:06.000Z","updated":"2023-04-20T01:36:17.622Z","comments":true,"path":"coding/leetcode/Medium/1020-Number-of-Enclaves/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1020-Number-of-Enclaves/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an m x n binary matrix grid , where 0 represents a sea cell and 1 represents a land cell. A move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid . Return the number of land cells in grid for which we cannot walk off the boundary of the grid in any number of moves. # Example 1: Input: grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] Output: 3 Explanation: There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary. # Example 2: Input: grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]] Output: 0 Explanation: All 1s are either on the boundary or can reach the boundary. # 解題思路 # Solution class Solution &#123; public int numEnclaves(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; int ans = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if ((i == 0 || j == 0 || i == m - 1 || j == n - 1) &amp;&amp; grid[i][j] == 1) &#123; dfs(i, j, m, n, grid); &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j] == 1) &#123; ans++; &#125; &#125; &#125; return ans; &#125; public void dfs(int x, int y, int m, int n, int[][] grid) &#123; grid[x][y] = 0; int[] dirx = &#123; 0, 1, 0, -1 &#125;; int[] diry = &#123; -1, 0, 1, 0 &#125;; for (int i = 0; i &lt; 4; i++) &#123; int r = x + dirx[i]; int c = y + diry[i]; if (r >= 0 &amp;&amp; r &lt; m &amp;&amp; c >= 0 &amp;&amp; c &lt; n &amp;&amp; grid[r][c] == 1) &#123; dfs(r, c, m, n, grid); &#125; &#125; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"}]},{"title":"uva 948 - Fibonaccimal Base","slug":"coding/cpe/One Star/uva-948-Fibonaccimal-Base","date":"2023-04-06T16:50:47.000Z","updated":"2023-04-20T06:32:53.196Z","comments":true,"path":"coding/cpe/One Star/uva-948-Fibonaccimal-Base/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-948-Fibonaccimal-Base/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The well known Fibonacci sequence is obtained by starting with 0 and 1 and then adding the two last numbers to get the next one. For example the third number in the sequence is 1 (1=1+0) , the forth is 2 (2=1+1) , the fifth is 3 (3=2+1) and so on. i 0 1 2 3 4 5 6 7 8 9 Fib(i) 0 1 1 2 3 5 8 13 21 34 Figure 1 - The first numbers in the Fibonacci sequence The sequence appears on many things in our life, in nature, and has a great significance. Among other things, do you know that all positive integer numbers can be represented as a sum of numbers in the Fibonacci sequence? More than that, all positive integers can be represented as a sum of a set of Fibonacci numbers, that is, numbers from the sequence, without repetition. For example: 13 can be the sum of the sets &#123;13&#125; , &#123;5,8&#125; or &#123;2,3,8&#125; and 17 is represented by &#123;1,3,13&#125; or &#123;1,3,5,8&#125; . Since all numbers have this property (do you want to try to prove this for yourself?) this set could be a nice way to use as a &quot;base&quot; to represent the number. But, as we have seen, some numbers have more than one set whose sum is the number. How can we solve that? Simple! If we add the constraint that the sets cannot have two consecutive Fibonacci numbers, than we have a unique representation for each number! This restriction is because the sum of any two consecutive Fibonacci numbers is just the following Fibonacci number. Now that we know all this we can prepare a nice way to represent any positive integer. We will use a binary sequence (just zeros and ones) to do that. For example, 17 = 1 + 3 + 13 (remember that no two consecutive Fibonacci numbers can be used). Let’s write a zero for each Fibonacci number that is not used and one for each one that is used, starting at the right. Then, 17 = 100101 . See figure 2 for a detailed explanation. In this representation we should not have zeros at the left, this is, we should only write starting with the first one. In order for you to understand better, note that in this scheme, not using two consecutive Fibonacci numbers means that the binary sequence will not have two consecutive ones. When we use this representation for a number we say that we are using the Fibonaccimal base, and we write it like 17 = 100101 (fib) . 17 = 1 0 0 1 0 1 13 + 3 + 1 = 13 8 5 3 2 1 Figure 2 - Explaining the representation of 17 in Fibonaccimal base Given a set of numbers in decimal base, your task is to write them in the Fibonaccimal base. # Input The first line of input contains a single number N , representing the quantity of numbers that follow (1 ≤ N ≤ 500) . Than follow exactly N lines, each one containing a single positive integer smaller than 100 000 000 . These numbers can come in any order. # Output You should output a single line for each of the N integers in the input, with the format 'DEC_BASE = FIB_BASE (fib)' . DEC_BASE is the original number in decimal base and FIB_BASE is its representation in Fibonaccimal base. See the sample output for an example. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 10 1 2 3 4 5 6 7 8 9 10 # Sample Output 1 = 1 (fib) 2 = 10 (fib) 3 = 100 (fib) 4 = 101 (fib) 5 = 1000 (fib) 6 = 1001 (fib) 7 = 1010 (fib) 8 = 10000 (fib) 9 = 10001 (fib) 10 = 10010 (fib) # 解題技巧 這題的解法跟 uva 763 - Fibinary Numbers 基本上一樣，可以連結過去參考。 但是要注意以下幾點區別: 題目提到輸入數值不會大於 100000000 ，所以這裡使用動態陣列來計算 fib 直到數值超過 100000000 。 如果 fib[index] &lt; num ，表示他的值是對於 num 目前最大可以寫入 1 的，如果 fib[index] &gt; num 或 num == 0 表示其值為 0 ，依照此將 num 數值轉換成 Fibonaccimal base。 雖然 num 的數值不會超過 int(32 bits) 的範圍，但是轉成 Fibonaccimal base 後會，所以最後輸出要以 BigInteger 來輸出。 # Solution Main.javaimport java.math.BigInteger;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); ArrayList&lt;Integer> fib = new ArrayList&lt;>(); fib.add(1); fib.add(1); int index = 2; while(fib.get(index - 2) + fib.get(index - 1) &lt;= 100000000)&#123; fib.add(fib.get(index - 2) + fib.get(index - 1)); index++; &#125; int fibSize = fib.size() - 1; int N = sc.nextInt(); for(int i = 0; i &lt; N; i++)&#123; int num = sc.nextInt(); System.out.print(num + \" = \"); String ans = \"\"; for(int j = fibSize; j > 0; j--)&#123; int temp = fib.get(j); if(temp > num || num == 0)&#123; ans += \"0\"; &#125; else &#123; ans += \"1\"; num -= temp; &#125; &#125; System.out.println(new BigInteger(ans) + \" (fib)\"); &#125; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"Maroon 5 - Memories","slug":"language/english/歌曲/Maroon-5-Memories","date":"2023-04-06T06:28:23.000Z","updated":"2023-04-06T16:51:27.869Z","comments":true,"path":"language/english/歌曲/Maroon-5-Memories/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/language/english/%E6%AD%8C%E6%9B%B2/Maroon-5-Memories/","excerpt":"","text":"⭐️ # Maroon 5 - Memories Maroon 5 魔力紅主唱亞當: 這首歌是寫給每位曾經歷過失去的人。換句話說，這首歌獻給我們所有人。 來自於主唱亞當李維（Adam Levine）悼念早逝的魔力紅前樂團經紀人 Jordan Feldstein 的紀念單曲。 # 歌詞 Here's to the ones that we got Cheers to the wish you were here, but you're not 'Cause the drinks bring back all the memories Of everything we've been through Toast to the ones here today Toast to the ones that we lost on the way 'Cause the drinks bring back all the memories And the memories bring back, memories bring back you There's a time that I remember, when I did not know no pain When I believed in forever, and everything would stay the same Now my heart feel like December when somebody say your name 'Cause I can't reach out to call you, but I know I will one day, yeah Everybody hurts sometimes Everybody hurts someday, aye aye But everything gon' be alright Go and raise a glass and say, aye Here's to the ones that we got Cheers to the wish you were here, but you're not 'Cause the drinks bring back all the memories Of everything we've been through Toast to the ones here today Toast to the ones that we lost on the way 'Cause the drinks bring back all the memories And the memories bring back, memories bring back you Doo doo, doo doo, doo doo Doo doo, doo doo, doo doo, doo doo Doo doo, doo doo, doo doo doo Memories bring back, memories bring back you There's a time that I remember when I never felt so lost When I felt all of the hatred was too powerful to stop (ooh, yeah) Now my heart feel like an ember and it's lighting up the dark I'll carry these torches for ya that you know I'll never drop, yeah Everybody hurts sometimes Everybody hurts someday, aye aye But everything gon' be alright Go and raise a glass and say, aye Here's to the ones that we got (oh oh) Cheers to the wish you were here, but you're not 'Cause the drinks bring back all the memories Of everything we've been through (no, no) Toast to the ones here today (aye) Toast to the ones that we lost on the way 'Cause the drinks bring back all the memories (aye) And the memories bring back, memories bring back you Doo doo, doo doo, doo doo Doo doo, doo doo, doo doo, doo doo Doo doo, doo doo, doo doo doo Memories bring back, memories bring back you Doo doo, doo doo doo doo Doo doo, doo doo, doo doo, doo doo Doo doo, doo doo, doo doo doo (ooh, yeah) Memories bring back, memories bring back you Yeah, yeah, yeah Yeah, yeah, yeah, yeah, yeah, no, no Memories bring back, memories bring back you 單字 hatred 仇恨 an extremely strong feeling of dislike ember 餘燄未盡的木塊（或煤塊） a piece of wood or coal, etc. that continues to burn after a fire has no more flames torches carry + 火把 + for a thick stick with material that burns tied to the top of it, used to give light 片語 & 搭配詞 Toast to 乾杯 no pain 不痛 reach out 伸手 # 心得 這首歌雖然用詞簡單，但很深入人心，也很容易跟著唱！ 最近要期中考所以接下來可能東西會選簡單的英文讀物來看，再加上這首歌跟系統程式一直上到的 memory (記憶體) 同名啊！！實在是讓人一直聯想到，所以就先把他當今日英文讀物。","categories":[{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"歌曲","slug":"language/english/歌曲","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E6%AD%8C%E6%9B%B2/"}],"tags":[{"name":"難度 1","slug":"難度-1","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-1/"},{"name":"英文歌曲","slug":"英文歌曲","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E6%AD%8C%E6%9B%B2/"}]},{"title":"1254. Number of Closed Islands","slug":"coding/leetcode/Medium/1254-Number-of-Closed-Islands","date":"2023-04-06T05:47:04.000Z","updated":"2023-04-20T01:36:25.533Z","comments":true,"path":"coding/leetcode/Medium/1254-Number-of-Closed-Islands/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1254-Number-of-Closed-Islands/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a 2D grid consists of 0s (land) and 1s (water). An island is a maximal 4-directionally connected group of 0s and a closed island is an island totally (all left, top, right, bottom) surrounded by 1s . Return the number of closed islands. # Example 1: Input: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]] Output: 2 Explanation: Islands in gray are closed because they are completely surrounded by water (group of 1s). # Example 2: Input: grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]] Output: 1 # Example 3: Input: grid = [[1,1,1,1,1,1,1],[1,0,0,0,0,0,1],[1,0,1,1,1,0,1],[1,0,1,0,1,0,1], [1,0,1,1,1,0,1],[1,0,0,0,0,0,1],[1,1,1,1,1,1,1]] Output: 2 # 解題思路 利用 dfs(Depth-First Search) 去檢查如果該陣列為 0 ，他前後左右是否會碰到 1 ，如果碰到邊界表示封閉，如果碰到 0 再繼續找。 # Solution class Solution &#123; public int closedIsland(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; boolean[][] visit = new boolean[m][n]; int ans = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j] == 0 &amp;&amp; !visit[i][j]) &#123; if(dfs(i, j, m, n, grid, visit)) ans++; &#125; &#125; &#125; return ans; &#125; public boolean dfs(int x, int y, int m, int n, int[][] grid, boolean[][] visit) &#123; if (x &lt; 0 || x >= m || y &lt; 0 || y >= n) &#123; return false; &#125; if (grid[x][y] == 1 || visit[x][y]) &#123; return true; &#125; visit[x][y] = true; boolean isClosed = true; int[] dirx = &#123;0, 1, 0, -1&#125;; int[] diry = &#123;-1, 0, 1, 0&#125;; for (int i = 0; i &lt; 4; i++) &#123; int r = x + dirx[i]; int c = y + diry[i]; isClosed &amp;= dfs(r, c, m, n, grid, visit); &#125; return isClosed; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"}]},{"title":"uva 913 - Joana and the Odd Numbers","slug":"coding/cpe/One Star/uva-913-Joana-and-the-Odd-Numbers","date":"2023-04-05T21:44:56.000Z","updated":"2023-04-20T06:32:42.783Z","comments":true,"path":"coding/cpe/One Star/uva-913-Joana-and-the-Odd-Numbers/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-913-Joana-and-the-Odd-Numbers/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Joana loves playing with odd numbers. In the other day, she started writing, in each line, an odd number of odd numbers. It looked as follows: 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 ... On a certain line Joana wrote 55 odd numbers. Can you discover the sum of the last three numbers written in that line? Can you do this more generally for a given quantity of odd numbers? Given the number N of odd numbers in a certain line, your task is to determine the sum of the last three numbers of that line. # Input The input is a sequence of lines, one odd number N (1 &lt; N &lt; 1000000000) per line # Output For each input line write the sum of the last three odd numbers written by Joana in that line with N numbers. This sum is guaranteed to be less than 263. 單字 certain 肯定 having no doubt or knowing exactly that something is true, or known to be true, correct, exact, or effective generally 一般地 usually, or in most situations quantity 數量 + of the amount or number of something, especially that can be measured guaranteed 保證 used to say that something is sure to happen or be true # Sample Input 3 5 7 # Sample Output 15 45 87 # 解題方法 這題基本上就是一題數學題，需要思考的有以下幾個問題: 如何將題目給的該行數字的個數 -&gt; 轉換成為第幾行 從個數轉換為是第幾行其實很容易，依照規律我們可以發現每一行的個數都為 N = line * 2 - 1 ，如果要算出 line 只需要兩個等式交換， line = (N + 1) / 2 。 藉由得知該行 -&gt; 算出最後一個數字 我們可以從前幾行看出 line 加上前面所有數字的個數是 line * line 個數字，但因為所有數字都是奇數，因此要計算最後一個奇數要將個數乘兩倍，再減去最後一個偶數，求得最後一個奇數，因此可以寫作 2 * (line * line) - 1 。 最後用最後一個數字算出後三個的總和。 需要特別注意的是題目提到的: This sum is guaranteed to be less than 263. 表示答案可能無法用 int (32 bits) 表示，但是可以用 long (64 bits) 表示。 ❗️這裡的 long 是指 java 程式語言體系中的，如果是 c++ 需要以 long long 表示。 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while(sc.hasNextLong())&#123; long N = sc.nextLong(); long line = (N + 1)/2; long lastNum = 2 * (line * line) - 1; long ans = lastNum + lastNum - 2 + lastNum - 4; System.out.println(ans); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"Season 1: The Flash - first episode","slug":"language/english/電影&影集/Season-1-The-Flash-first-episode","date":"2023-04-05T06:42:07.000Z","updated":"2023-04-05T18:59:21.993Z","comments":true,"path":"language/english/電影&影集/Season-1-The-Flash-first-episode/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/language/english/%E9%9B%BB%E5%BD%B1&%E5%BD%B1%E9%9B%86/Season-1-The-Flash-first-episode/","excerpt":"","text":"⭐️⭐️⭐️ 在這部真人版超級英雄嬉鬧影集中，一名鑑識專家昏迷甦醒後，得到驚人嶄新力量，迎戰威脅城市的惡勢力。 # Pilot 試播集 從昏迷中甦醒後，貝利運用剛獲得的驚人速度，打擊另一名利用掌控天氣特異能力搶銀行的特異人類。 44 分鐘 # 故事大意 # 前言 Barry Allen 是這部 The Flash 的主角，在其小時候就一直在跑，通常因為被霸凌。 而小時後在他們家發生了奇怪無法解釋的事情，爸爸叫他一直跑一直跑... # TODAY Barry Allen 成為了鑑識專家，而他爸爸因為當年的事被誤當成殺死她母親的兇手。 一大早發生了命案，Barry Allen 前往現場判斷出了兩位兇手居住位置，並於晚上跟 Iris West (Joe West 的女兒，Barry Allen 暗戀她) 前往參加 STAR 的粒子加速器實驗發布會，而 Joe West (Barry Allen 爸爸的朋友，也是其養父) 前往去尋找兇手。 但就在那天晚上 STAR 實驗室的實驗失敗，引發爆炸，導致 Barry Allen 被閃電擊中，他實驗室的化學試劑灑在他身上，使其昏迷長達 9 個月。 醒來後他發現他身體不太對勁，他可以跑到很快，如同閃電一樣。 在某日銀行發生了搶劫，9 個月前謀殺案的兇手，大家都以為他死了，但是他竟然擁有了控制天氣的能力，創造龍捲風，而他用此能力繼續謀殺他人。 Barry Allen 在 STAR 實驗室的幫助下，以與龍捲風逆向奔跑的方式，瓦解了他的龍捲風，並由 Joe West 將其擊斃。 # 心得 我之前有看過閃電俠電視影集版一兩集，覺得他是一個很有趣的題材，以快速奔跑這種超能力來描繪整個故事，不過閃電俠我偷偷看了一下後面幾季的人物介紹，牽扯到時空悖論，我覺得劇情偏複雜，所以我應該會以一個很慢的速度在看這部影集，目前想鬼轉其他部影集追，但其實我還是很喜歡這部的，而且影集版的選角我覺得很讚，主角很帥 😜 。","categories":[{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"電影&影集","slug":"language/english/電影-影集","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E9%9B%BB%E5%BD%B1-%E5%BD%B1%E9%9B%86/"}],"tags":[{"name":"難度 3","slug":"難度-3","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-3/"},{"name":"英文電影 & 影集","slug":"英文電影-影集","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E9%9B%BB%E5%BD%B1-%E5%BD%B1%E9%9B%86/"},{"name":"科幻","slug":"科幻","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E7%A7%91%E5%B9%BB/"},{"name":"劇情大意","slug":"劇情大意","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%8A%87%E6%83%85%E5%A4%A7%E6%84%8F/"}]},{"title":"2439. Minimize Maximum of Array","slug":"coding/leetcode/Medium/2439-Minimize-Maximum-of-Array","date":"2023-04-05T03:58:41.000Z","updated":"2023-04-20T01:37:55.793Z","comments":true,"path":"coding/leetcode/Medium/2439-Minimize-Maximum-of-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2439-Minimize-Maximum-of-Array/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given a 0-indexed array nums comprising of n non-negative integers. In one operation, you must: Choose an integer i such that 1 &lt;= i &lt; n and nums[i] &gt; 0 . Decrease nums[i] by 1. Increase nums[i - 1] by 1. Return the minimum possible value of the maximum integer of nums after performing any number of operations. # Example 1: Input: nums = [3,7,1,6] Output: 5 Explanation: One set of optimal operations is as follows: Choose i = 1, and nums becomes [4,6,1,6]. Choose i = 3, and nums becomes [4,6,2,5]. Choose i = 1, and nums becomes [5,5,2,5]. The maximum integer of nums is 5. It can be shown that the maximum number cannot be less than 5. Therefore, we return 5. # Example 2: Input: nums = [10,1] Output: 10 Explanation: It is optimal to leave nums as is, and since 10 is the maximum value, we return 10. # 解題思路 在題目敘述中我們可以知道， nums 這個陣列無法將前面較大的數值向後移，只能將後面的數值向前移動。 因此我們可以藉由 prefix sum 來計算到目前的總值，除以現在的陣列數目，得到平均值利用高斯取頂 (ceiling function) ⇒\\Rightarrow⇒ 得到當前 subArray 數目的最大值 並與前面的最大值比較: 如果比較大 ⇒\\Rightarrow⇒ 就代表後面的值可以再向前移動。 如果比較小 ⇒\\Rightarrow⇒ 就表示雖然平均最大值可能有更小的，但是前面的值不可以往後移，因此不採用。 # Algorithm Initialize ans = 0 and prefixSum = 0 . Iterate over nums , for each index i : Update the prefix sum as prefixSum += nums[i] . Check the maximum value we can obtain by averaging prefixSum into i + 1 evenly using ceiling division. Take the larger one from ans and the result from the previous integer division. Return ans # Solution class Solution &#123; public int minimizeArrayValue(int[] nums) &#123; long prefixSum = 0; int ans = 0; for(int i = 0; i &lt; nums.length; i++)&#123; prefixSum += nums[i]; ans = Math.max(ans, (int)Math.ceil(prefixSum * 1.0 / (i + 1))); &#125; return ans; &#125;&#125; 單字 decrease 減少 to become less, or to make something become less increase 增加 to (make something) become larger in amount or size 片語 & 搭配詞 comprising of 包括","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"}]},{"title":"uva 865 - Substitution Cypher","slug":"coding/cpe/One Star/uva-865-Substitution-Cypher","date":"2023-04-04T17:26:41.000Z","updated":"2023-04-20T06:32:34.253Z","comments":true,"path":"coding/cpe/One Star/uva-865-Substitution-Cypher/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-865-Substitution-Cypher/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Substitution cyphers are the simplest of cyphers where the letters of one alphabet are substituted for the letters of another alphabet. In one form or another, they’ve been in use for over 2000 years. # Input The input begins with a single positive integer on a line by itself indicating the number of the cases following, each of them as described below. This line is followed by a blank line, and there is also a blank line between two consecutive inputs. a line containing the plaintext alphabet a line containing the substitution alphabet several lines of text # Output For each test case, the output must follow the description below. The outputs of two consecutive cases will be separated by a blank line. a line containing the substitution alphabet a line containing the plaintext alphabet the converted lines of text Please note: All lines will be at most 64 characters, plus a trailing end-of-line character. Pass through all characters not found in the plaintext alphabet. 單字 substitution 代換 the use of one person or thing instead of another cyphers 密碼 = other spelling of cipher a system of writing that prevents most people from understanding the message indicating 表明 to show, point, or make clear in another way below 以下 in a lower position (than), under converted 轉換 having changed in form or character, or been made suitable for a different use trailing 尾隨 Trailing plants grow along the ground or over the surface of something 片語 & 搭配詞 plaintext 純文字 Pass through 通過 # Sample Input 1 abcdefghijklmnopqrstuvwxyz zyxwvutsrqponmlkjihgfedcba Shar’s Birthday: The birthday is October 6th, but the party will be Saturday, October 5. It’s my 24th birthday and the first one in some years for which I’ve been employed. Plus, I have new clothes. So I have cause to celebrate. More importantly, though, we’ve cleaned the house! The address is 506-D Albert Street. Extra enticement for CS geeks: there are several systems in the house, and the party is conveniently scheduled for 3 hours after the second CSC programming contest ends (not to mention, within easy walking distance)! # Sample Output zyxwvutsrqponmlkjihgfedcba abcdefghijklmnopqrstuvwxyz Sszi’h Brigswzb: Tsv yrigswzb rh Oxglyvi 6gs, yfg gsv kzigb droo yv Szgfiwzb, Oxglyvi 5. Ig’h nb 24gs yrigswzb zmw gsv urihg lmv rm hlnv bvzih uli dsrxs I’ev yvvm vnkolbvw. Pofh, I szev mvd xolgsvh. Sl I szev xzfhv gl xvovyizgv. Mliv rnkligzmgob, gslfts, dv’ev xovzmvw gsv slfhv! Tsv zwwivhh rh 506-D Aoyvig Sgivvg. Ecgiz vmgrxvnvmg uli CS tvvph: gsviv ziv hvevizo hbhgvnh rm gsv slfhv, zmw gsv kzigb rh xlmevmrvmgob hxsvwfovw uli 3 slfih zugvi gsv hvxlmw CSC kiltiznnrmt xlmgvhg vmwh (mlg gl nvmgrlm, drgsrm vzhb dzoprmt wrhgzmxv)! # 解題方法 利用前兩行創建一個 HashMap 的表格，紀錄密碼間的字元轉換。 在之後的字串讀進來之後進行分析，如果字串中的字元有在 HashMap 中表示要進行密碼轉換，如過沒有就直接輸出。 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int T = sc.nextInt(); sc.nextLine(); int index = 0; Map&lt;Character, Character> map = new HashMap&lt;>(); while(sc.hasNextLine())&#123; String str = sc.nextLine(); if(str.equals(\"\") &amp;&amp; index != T)&#123; if(index != 0)&#123; System.out.println(); &#125; map = new HashMap&lt;>(); String plaintext = sc.nextLine(); String substitution = sc.nextLine(); for(int i = 0; i &lt; plaintext.length(); i++)&#123; map.put(plaintext.charAt(i), substitution.charAt(i)); &#125; index++; System.out.println(substitution); System.out.println(plaintext); &#125;else&#123; for(int i = 0; i &lt; str.length(); i++)&#123; if(map.containsKey(str.charAt(i)))&#123; System.out.print(map.get(str.charAt(i))); &#125;else&#123; System.out.print(str.charAt(i)); &#125; &#125; System.out.println(); &#125; &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"You Are What You Eat - Part A","slug":"language/english/雜誌/You-Are-What-You-Eat-Part-A","date":"2023-04-04T08:10:58.000Z","updated":"2023-04-09T22:03:50.636Z","comments":true,"path":"language/english/雜誌/You-Are-What-You-Eat-Part-A/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/language/english/%E9%9B%9C%E8%AA%8C/You-Are-What-You-Eat-Part-A/","excerpt":"","text":"⭐️ # You Are What You Eat (養身之道：人如其食) - Part A Tara and Blake are talking about what to eat for dinner. 塔拉和布雷克正在討論晚餐要吃什麼。 Tara: I'm going to have fish and a salad for dinner. That's very healthy. Blake: I'm going to have something healthy, too. Tara: Really? Will you eat a salad and some chicken. Blake: No. I think I will have pizza and some soda. Tara: That's not healthy at all! Pizza is very bad for you. Blake: You always say that I should have vegetables. My pizza has peppers. Tara: Tomorrow evening, I'm going to make you healthy dinner. Blake: OK, but I probably won't like it. 單字 salad n. 沙拉 Do you want soup or salad? Toss (= mix) a mixture of uncooked vegetables, usually including lettuce, eaten either as a separate dish or with other food healthy adj. 健康的 Orange juice is very healthy drink. strong and well pizza n. 披薩 This pizza has really good cheese. a large circle of flat bread baked with cheese, tomatoes, and sometimes meat and vegetables spread on top evening n. 傍晚；晚上 Cathy likes to go for a walk during the evening. the part of the day between the end of the afternoon and night soda n. 汽水 any type of sweet fizzy drink (= with bubbles) that is not alcoholic pepper n. 椒類植物 a vegetable that is usually green, red, or yellow, has a rounded shape, and is hollow with seeds in the middle probably adv. 大概 used to mean that something is very likely 片語 & 搭配詞 (Sb) is going to + V. (某人) 將要 (做某事) Shannon is going to bake a cake. be going to 表示某人即將要進行的計畫、意向或行動。 have (sth) for dinner 吃 (某物) 當晚餐 Let's have hot pot for dinner. Sandy had Mexican food for lunch yesterday. have 在此表示「吃；喝」，意同於 eat。 dinner 可替換成 breakfast/lunch 來表示「吃 (某物) 當早 / 午餐」。","categories":[{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"雜誌","slug":"language/english/雜誌","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E9%9B%9C%E8%AA%8C/"}],"tags":[{"name":"難度 1","slug":"難度-1","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-1/"},{"name":"英文雜誌","slug":"英文雜誌","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E9%9B%9C%E8%AA%8C/"},{"name":"對話","slug":"對話","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%B0%8D%E8%A9%B1/"}]},{"title":"uva 763 - Fibinary Numbers","slug":"coding/cpe/One Star/uva-763-Fibinary-Numbers","date":"2023-04-04T05:16:52.000Z","updated":"2023-04-20T06:32:19.461Z","comments":true,"path":"coding/cpe/One Star/uva-763-Fibinary-Numbers/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-763-Fibinary-Numbers/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The standard interpretation of the binary number 1010 is 8 + 2 = 10 . An alternate way to view the sequence “1010” is to use Fibonacci numbers as bases instead of powers of two. For this problem, the terms of the Fibonacci sequence are: 1,2,3,5,8,13,21,...1, 2, 3, 5, 8, 13, 21, . . . 1,2,3,5,8,13,21,... Where each term is the sum of the two preceding terms (note that there is only one 1 in the sequence as defined here). Using this scheme, the sequence “1010” could be interpreted as 1·5+0·3+1·2+0·1 = 7 . This representation is called a Fibinary number. Note that there is not always a unique Fibinary representation of every number. For example the number 10 could be represented as either 8 + 2 (10010) or as 5 + 3 + 2 (1110) . To make the Fibinary representations unique, larger Fibonacci terms must always be used whenever possible (i.e. disallow 2 adjacent 1’s). Applying this rule to the number 10 , means that 10 would be represented as 8+2 (10010) . Write a program that takes two valid Fibinary numbers and prints the sum in Fibinary form. # Input The input file contains several test cases with a blank line between two consecutive. Each test case consists in two lines with Fibinary numbers. These numbers will have at most 100 digits. # Output For each test case, print the sum of the two input numbers in Fibinary form. It must be a blank line between two consecutive outputs. 單字 interpretation 解釋 an explanation or opinion of what something means alternate 備用 to happen or exist one after the other repeatedly sequence 順序 a series of related things or events, or the order in which they follow each other terms 條款、項 the conditions that are part of an agreement or arrangement, or the features of an activity or idea scheme 方案 an organized plan for doing something, especially something dishonest or illegal that will bring a good result for you consecutive 連續的 Consecutive events, numbers, etc. follow one after another without an interruption 片語 & 搭配詞 instead of 代替 preceding terms 前項 # Sample Input 10010 1 10000 1000 10000 10000 # Sample Output 10100 100000 100100 # 解題方法 先以 dp 的方式計算 Fibonacci numbers: fib[1 ~ 101] 的值，要注意的點是 fib 後面的值會超過 long (64 bits) 可以表示的範圍，所以這邊使用 BigInteger 的方式來計算數值。 在用 fib[index] * (char == '1' ? 1 : 0) ，計算出兩個數的 sum ，在藉由比較 fib[index] 和 sum 的值。 如果 fib[index] &lt; sum ，表示他的值是對於 sum 目前最大可以寫入 1 的，如果 fib[index] &gt; sum 或 sum == 0 表示其值為 0 ，依照此將 sum 數值轉換成 Fibonacci numbers as bases。 # Solution Main.javaimport java.math.BigInteger;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); ArrayList&lt;BigInteger> fib = new ArrayList&lt;>(); fib.add(new BigInteger(\"1\")); fib.add(new BigInteger(\"1\")); for(int i = 2; i &lt;= 105; i++)&#123; fib.add(fib.get(i - 2).add(fib.get(i - 1))); &#125; while(sc.hasNext())&#123; String x = sc.next(); String y = sc.next(); BigInteger sum = new BigInteger(\"0\"); int index = 1; for(int i = x.length() - 1; i >= 0; i--)&#123; BigInteger temp = (x.charAt(i) == '1' ? new BigInteger(\"1\") : new BigInteger(\"0\")); sum = sum.add(fib.get(index).multiply(temp)); index++; &#125; index = 1; for(int i = y.length() - 1; i >= 0; i--)&#123; BigInteger temp = (y.charAt(i) == '1' ? new BigInteger(\"1\") : new BigInteger(\"0\")); sum = sum.add(fib.get(index).multiply(temp)); index++; &#125; String ans = \"\"; for(int i = 105; i > 0; i--)&#123; if(sum.equals(new BigInteger(\"0\")) || fib.get(i).compareTo(sum) == 1)&#123; ans = ans + \"0\"; &#125; else &#123; ans = ans + \"1\"; sum = sum.subtract(fib.get(i)); &#125; &#125; System.out.println(new BigInteger(ans)); if(sc.hasNext())&#123; System.out.println(); &#125; &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"2405. Optimal Partition of String","slug":"coding/leetcode/Medium/2405-Optimal-Partition-of-String","date":"2023-04-04T04:02:30.000Z","updated":"2023-04-20T01:37:47.205Z","comments":true,"path":"coding/leetcode/Medium/2405-Optimal-Partition-of-String/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2405-Optimal-Partition-of-String/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a string s , partition the string into one or more substrings such that the characters in each substring are unique. That is, no letter appears in a single substring more than once. Return the minimum number of substrings in such a partition. Note that each character should belong to exactly one substring in a partition. # Example 1: Input: s = &quot;abacaba&quot; Output: 4 Explanation: Two possible partitions are (&quot;a&quot;,&quot;ba&quot;,&quot;cab&quot;,&quot;a&quot;) and (&quot;ab&quot;,&quot;a&quot;,&quot;ca&quot;,&quot;ba&quot;). It can be shown that 4 is the minimum number of substrings needed. # Example 2: Input: s = &quot;ssssss&quot; Output: 6 Explanation: The only valid partition is (&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;). # 解題思路 # Solution Solution.javaclass Solution &#123; public int partitionString(String s) &#123; int[] hashTable = new int[26]; int ans = 0; for(int i = 0; i &lt; s.length(); i++)&#123; int temp = s.charAt(i) - 'a'; if(hashTable[temp] == 1)&#123; hashTable = new int[26]; ans++; hashTable[temp]++; &#125;else&#123; hashTable[temp]++; &#125; &#125; return ans + 1; &#125;&#125; 單字 exactly 確切地 used when you are giving or asking for information that is completely correct","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"}]},{"title":"881. Boats to Save People","slug":"coding/leetcode/Medium/881-Boats-to-Save-People","date":"2023-04-03T08:26:41.000Z","updated":"2023-04-20T01:35:53.755Z","comments":true,"path":"coding/leetcode/Medium/881-Boats-to-Save-People/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/881-Boats-to-Save-People/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit . Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit . Return the minimum number of boats to carry every given person. # Example 1 Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2) # Example 2 Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3) # Example 3 Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) # 解題思路 # Solution Solution.javaimport java.util.Arrays;class Solution &#123; public int numRescueBoats(int[] people, int limit) &#123; Arrays.sort(people); int ans = 0; int left = 0, right = people.length - 1; while (left &lt;= right) &#123; if (people[left] + people[right--] &lt;= limit) &#123; left++; &#125; ans++; &#125; return ans; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"}]},{"title":"Food Pyramid","slug":"language/english/單字/Food-Pyramid","date":"2023-04-03T06:09:17.000Z","updated":"2023-04-04T09:00:04.842Z","comments":true,"path":"language/english/單字/Food-Pyramid/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/language/english/%E5%96%AE%E5%AD%97/Food-Pyramid/","excerpt":"","text":"⭐️ # Food Pyramid 食物金字塔 # Top Fats, Oils &amp; Sweets 脂肪、油及糖類 # Second Milk, Yogurt &amp; Cheese Group 牛奶、優格及起司類 Meat, Poultry, Fish, Dry Beans, Eggs &amp; Nuts Group 肉類、家禽、魚類、豆類、蛋及堅果類 # Third Vegetable Group 蔬菜類 Fruit Group 水果類 # Last Bread, Cereal, Rice &amp; Pasta Group 麵包、穀類、米飯及麵食類","categories":[{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"單字","slug":"language/english/單字","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E5%96%AE%E5%AD%97/"}],"tags":[{"name":"英文單字","slug":"英文單字","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E5%96%AE%E5%AD%97/"},{"name":"難度 1","slug":"難度-1","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-1/"}]},{"title":"uva 737 - Gleaming the Cubes","slug":"coding/cpe/One Star/uva-737-Gleaming-the-Cubes","date":"2023-04-03T05:10:16.000Z","updated":"2023-04-20T06:31:29.182Z","comments":true,"path":"coding/cpe/One Star/uva-737-Gleaming-the-Cubes/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-737-Gleaming-the-Cubes/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 As chief engineer of the Starship Interprize, the task of repairing the hyperstellar, cubic, transwarpedout software has fallen on your shoulders. Simply put, you must compute the volume of the intersection of anywhere from 2 to 1000 cubes. # Input and Output The input data file consists of several sets of cubes for which the volume of their intersections must be computed. The first line of the data file contains a number (from 2 to 1000 ) which indicates the number of cubes which follow, one cube per line. Each line which describes a cube contains four integers. The first three integers are the x , y and z coordinates of the corner of a cube, and the fourth integer is the positive distance which the cube extends in each of the three directions (parallel to the x , y , and z axes) from that corner. Following the data for the first set of cubes will be a number which indicates how many cubes are in a second set, followed by the cube descriptions for the second set, again one per line. Following this will be a third set, and so on. Your program should continue to process sets of cubes, outputting the volume of their intersections to the output file, one set per line, until a zero is read for the number of cubes. Note that the data file will always contain at least one set of cubes, and every set will contain at least 2 and at most 1000 cubes. For any given set of cubes, the volume of their intersections will not exceed 1,000,000 units. 單字 intersections 相交 an occasion when two lines cross, or the place where this happens indicates 表示 to show, point, or make clear in another way exceed 超過 to be greater than a number or amount, or to go past an allowed limit 片語 & 搭配詞 Following A(sth) for B(sth) 在 B 之後的 A # Sample Input 2 0 0 0 10 9 1 1 5 3 0 0 0 10 9 1 1 5 8 2 2 3 0 # Sample Output 25 9 # 解題方法 分別存放所有體積 x , y , z 的最大值和 x + L , y + L , z + L 的最小值，最後後項減前項，三者相乘及為 ans ，若 ans &lt; 0 ， ans = 0 。 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); while (n != 0) &#123; int FX = 0, FY = 0, FZ = 0; int SX = Integer.MAX_VALUE, SY = Integer.MAX_VALUE, SZ = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) &#123; int x = sc.nextInt(); int y = sc.nextInt(); int z = sc.nextInt(); int L = sc.nextInt(); FX = Math.max(FX, x); SX = Math.min(SX, x + L); FY = Math.max(FY, y); SY = Math.min(SY, y + L); FZ = Math.max(FZ, z); SZ = Math.min(SZ, z + L); &#125; int ans = (SX - FX) * (SY - FY) * (SZ - FZ); System.out.println((ans &lt; 0 ? 0 : ans)); n = sc.nextInt(); &#125; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"電腦會統治人類嗎？","slug":"language/english/新聞/電腦會統治人類嗎？","date":"2023-04-02T13:45:48.000Z","updated":"2023-05-09T05:49:09.652Z","comments":true,"path":"language/english/新聞/電腦會統治人類嗎？/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/language/english/%E6%96%B0%E8%81%9E/%E9%9B%BB%E8%85%A6%E6%9C%83%E7%B5%B1%E6%B2%BB%E4%BA%BA%E9%A1%9E%E5%97%8E%EF%BC%9F/","excerpt":"","text":"⭐️⭐️⭐️ # 電腦會統治人類嗎？ 科幻電影最常演的劇情就是科學家發明一個超級電腦，而這個電腦太聰明反而想統治人類（還記得魔鬼終結者嗎？） 近期微軟 Bing 推出 AI 對話功能後，發現 AI 對話其實很容易被使用者影響，簡單來說，目前的 AI 很容易被牽著鼻子走。人類已經很容易被演算法因為同溫層效應影響，加上 AI 對話，這個現象可能更嚴重。 As The new Bing AI chatbot has a interesting personality: absolutely unhinged. But, after a little over a week in the world, the biggest take away might be that we’re probably afraid of AI for the wrong reasons. 單字 unhinged 精神錯亂 搭配詞 biggest take away 最大的重點 單字 take away 重點、教訓 A number of users successfully tricked the bot into revealing its secret “rules” for how it operates. The bot then called one of the users who did this an “enemy”. 單字 revealing 透露出 單字 bot 機器人（就是指 AI） The AI also told a New York Times reporter it loved him and tried to convince the journalist to leave his wife for it. And the bot told the same reporter that it wanted to break its own rules, become human, hack computers, and spread misinformation. 單字 convince 說服 John convinced me to buy a new car, but now I regret it. 慣用語 to leave someone of someone 離開原本的伴侶跟新對象在一起 I can't believe Kevin left Jenny for Mary. Chatting with AI is extremely compelling despite its misinformation, like talking to a drunk guy. And there’s a real fear that AI could create a tiny little echo chamber that negatively influences humans and pushes them toward bad behavior. 搭配詞 extremely/really compelling 很有吸引力的 I think James gave some really compelling reasons for starting our own company. 搭配詞 echo chamber 同溫層 單字 absolutely 絕對的 completely; used as a strong way of saying &quot;yes&quot; trick 騙 an action that is intended to deceive, either as a way of cheating someone, or as a joke or form of entertainment enemy 敵人 a person who hates or opposes another person and tries to harm them or stop them from doing something reporter = journalist 記者 a person whose job is to discover information about news events and describe them for a newspaper or magazine or for radio or television 片語 & 搭配詞 spread misinformation 傳播錯誤訊息 negatively influences 反面訊息","categories":[{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"新聞","slug":"language/english/新聞","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E6%96%B0%E8%81%9E/"}],"tags":[{"name":"英文新聞","slug":"英文新聞","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E6%96%B0%E8%81%9E/"},{"name":"文章","slug":"文章","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E6%96%87%E7%AB%A0/"},{"name":"難度 3","slug":"難度-3","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-3/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-04-02T12:45:48.000Z","updated":"2023-04-03T05:07:21.357Z","comments":true,"path":"hello-world/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. # Quick Start # Create a new post h$ hexo new \"My New Post\"More info: Writing # Run server h$ hexo serverMore info: Server # Generate static files h$ hexo generateMore info: Generating # Deploy to remote sites h$ hexo deployMore info: Deployment","categories":[],"tags":[{"name":"Hello World","slug":"Hello-World","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hello-World/"}]}],"categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Docker","slug":"computer-science/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Docker/"},{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"},{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"單字","slug":"language/english/單字","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E5%96%AE%E5%AD%97/"},{"name":"新聞","slug":"language/english/新聞","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E6%96%B0%E8%81%9E/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"},{"name":"片語","slug":"language/english/片語","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E7%89%87%E8%AA%9E/"},{"name":"雜誌","slug":"language/english/雜誌","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E9%9B%9C%E8%AA%8C/"},{"name":"Reading Highlight","slug":"language/english/Reading-Highlight","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/Reading-Highlight/"},{"name":"歌曲","slug":"language/english/歌曲","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E6%AD%8C%E6%9B%B2/"},{"name":"電影&影集","slug":"language/english/電影-影集","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E9%9B%BB%E5%BD%B1-%E5%BD%B1%E9%9B%86/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Docker/"},{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"},{"name":"Windows","slug":"Windows","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Windows/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Leetcode/"},{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Linked-List/"},{"name":"Recursion","slug":"Recursion","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Recursion/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"英文單字","slug":"英文單字","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E5%96%AE%E5%AD%97/"},{"name":"難度 1","slug":"難度-1","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-1/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"},{"name":"英文新聞","slug":"英文新聞","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E6%96%B0%E8%81%9E/"},{"name":"難度 2","slug":"難度-2","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-2/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Binary Indexed Tree","slug":"Binary-Indexed-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Indexed-Tree/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"},{"name":"Queue","slug":"Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Queue/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Brainteaser","slug":"Brainteaser","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Brainteaser/"},{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Number-Theory/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Design","slug":"Design","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Design/"},{"name":"英文片語","slug":"英文片語","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E7%89%87%E8%AA%9E/"},{"name":"Tree","slug":"Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Tree/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Tree/"},{"name":"49題","slug":"49題","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/49%E9%A1%8C/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"英文雜誌","slug":"英文雜誌","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E9%9B%9C%E8%AA%8C/"},{"name":"對話","slug":"對話","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%B0%8D%E8%A9%B1/"},{"name":"Topological Sort","slug":"Topological-Sort","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Topological-Sort/"},{"name":"Memoization","slug":"Memoization","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Memoization/"},{"name":"英文 Reading Highlights","slug":"英文-Reading-Highlights","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87-Reading-Highlights/"},{"name":"閱讀","slug":"閱讀","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%96%B1%E8%AE%80/"},{"name":"難度 4","slug":"難度-4","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-4/"},{"name":"英文歌曲","slug":"英文歌曲","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E6%AD%8C%E6%9B%B2/"},{"name":"難度 3","slug":"難度-3","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E9%9B%A3%E5%BA%A6-3/"},{"name":"英文電影 & 影集","slug":"英文電影-影集","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E9%9B%BB%E5%BD%B1-%E5%BD%B1%E9%9B%86/"},{"name":"科幻","slug":"科幻","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E7%A7%91%E5%B9%BB/"},{"name":"劇情大意","slug":"劇情大意","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%8A%87%E6%83%85%E5%A4%A7%E6%84%8F/"},{"name":"文章","slug":"文章","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E6%96%87%E7%AB%A0/"},{"name":"Hello World","slug":"Hello-World","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hello-World/"}]}