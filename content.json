{"meta":{"title":"MyBlog","subtitle":"We are the dreamers. We make it happen 'cause we can see it.","description":"謝謝你來，謝謝你還在","author":"Hsing Yu","url":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io","root":"/"},"pages":[{"title":"Hello!","date":"2023-08-13T05:41:18.092Z","updated":"2023-08-13T05:41:18.092Z","comments":true,"path":"about/index.html","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/about/index.html","excerpt":"","text":"# Hsing Yu 陳幸妤 在努力學習各種技術，完成所有夢想與理想，成為自己的那曙光！ 路漫漫其修遠兮， 吾將上下而求索。 每日目標 leetcode 1 題 CPE 3 題 英文 1 篇 這個網站目前是為了督促我自己養成讀英文跟寫程式的習慣，之後會再寫一些整理的技術或我在學的一些東西。 # 簡介 性別：女 生日: 2003/02/12 星座：水瓶座 興趣：排球、美術設計、書法 專長：游泳、機器人、資訊工程 (人工智慧、網頁) # 經歷 國立彰化女子高級中學 國立台中教育大學 資訊工程學系 (特殊選材) # 比賽 &amp; 獎項 2018 全國智能車挑戰賽 2018-2019 FIRST 機器人大賽台灣選拔賽 — 研究品質獎全國第一名 (作品：太空中的家鄉味) 彰化縣 108 學年教育盃機器人競賽 — 高中競賽組佳作 2019 WRO 中南區賽高中競賽組 (機器人計分 / 計時賽) 2019 WRO 國際奧林匹亞機器人全國總決賽 — 高中創意組佳作 (作品：AI 智能交通小幫手) 台灣青年黑客松 6th — APP 組 (作品：防疫下的共享經濟) 2022 NCPC 全國大專電腦軟體設計競賽 國立台中教育大學 菁英獎 # 各種檢定 2023 CPE: 4 題 # 專案經歷 2021 彰化縣資優生報考系統 2021 彰化高中學生會選舉投票系統 2021 國立馬祖高級中學網站 2021~ 至今 國教署 Q&amp;A 系統 (擱置) 2022~ 至今 台中教育大學資工系網站 (準備部署) =&gt; 負責網路管理 / 系統維護 2023.02~ 至今 進階程式設計課程自動評分系統 - 專案負責人 (撰寫程式中) =&gt; 整體專案 2023.06 MyJob 工作排成網站 2023.06~ 至今 學校產學合作數位部專案 (剛啟動) 2023.07 項目管理系統 # 參與團隊 2019~2020 國立彰化女子高級中學 電腦研習社 (機器人組與軟程組) - 社長 2019~ 至今 彰化資訊志工隊 - 隊員 2021~ 至今 國立台中教育大學空手道社 - 社員 2021~2023 國立台中教育大學資工系女子排球隊 - 隊員、副隊長 (2021~2023) 2023.07~2023.08 上海電腦軟體技術開發中心 - 軟體開發實習生 # 活動經歷 講師 2021 鹿鳴國中假日班 Webduino 課程 2021、2022 彰化女中學期課後程式加強課程 C++ 程式語言 2022 國立馬祖高中、桃園市立新屋高中 新興科技認知推廣計畫 - VR 體驗活動 2022 國立台中教育大學「程式戰鬥營」教學 C 程式語言 主辦人 彰化女中 2019、2020 C++ 寒暑假研習課 (共 6 場)、學期課後程式加強課程 主辦人、課堂協助指導 2020 彰中彰女電研聯合寒訓 主辦人、課堂協助指導 2021 舉辦大成國中寒假資訊科學營隊 協助教導 2019、2020 國中生機器人學園 (共 2 場) 2021 草湖國中寒假營隊 2022 芬園國中寒假營隊 學習探討 2020 高中人才培育計畫交大人工智慧與深度學習 (學習 AI 和深度學習的演進，機器學習的定義，線性模型推廣淺層神經網路，如何訓練神經網路) 2020Ewant 高中自主學習 交大生活中的機器人科技 (學習機器人的發展及未來應用) 2020 高中職生 AI 扎根系列活動 (學習 AI 基礎知識與實作 AWS DeepRacer) 2020 教育部資訊安全人才培育計畫 (學習 Linux、基礎資安分析實務、基礎程式逆向工程) 參與活動 2020 SITCON 學生計算機年會 # 目標待完成 CPE: 7 題 托福 iBT 考試：達標 參加 ICPC 得名 參加 ITSA 全國大專程式設計極客挑戰 得名 出國讀書 # 待續..."}],"posts":[{"title":"239. Sliding Window Maximum","slug":"coding/leetcode/Hard/239-Sliding-Window-Maximum","date":"2023-08-16T07:29:08.000Z","updated":"2023-08-16T08:38:01.361Z","comments":true,"path":"coding/leetcode/Hard/239-Sliding-Window-Maximum/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/239-Sliding-Window-Maximum/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 You are given an array of integers nums , there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. # Example 1 Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 # Example 2 Input: nums = [1], k = 1 Output: [1] # 解題思路 Use Deque name dq . Map k integer in the nums , and keep the high number in the dq first value. Adding dp first value in List name res which will become the answer. Making List&lt;Integer&gt; into int[] and return. # Solution import java.util.ArrayDeque;import java.util.ArrayList;import java.util.Deque;import java.util.List;class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; Deque&lt;Integer> dq = new ArrayDeque&lt;>(); List&lt;Integer> res = new ArrayList&lt;>(); for (int i = 0; i &lt; k; i++) &#123; while (!dq.isEmpty() &amp;&amp; nums[i] >= nums[dq.peekLast()]) &#123; dq.pollLast(); &#125; dq.offerLast(i); &#125; res.add(nums[dq.peekFirst()]); for (int i = k; i &lt; nums.length; i++) &#123; if (dq.peekFirst() == i - k) &#123; dq.pollFirst(); &#125; while (!dq.isEmpty() &amp;&amp; nums[i] >= nums[dq.peekLast()]) &#123; dq.pollLast(); &#125; dq.offerLast(i); res.add(nums[dq.peekFirst()]); &#125; return res.stream().mapToInt(Integer::intValue).toArray(); &#125;&#125; 單字 slide 滑動 v. to (cause to) move easily and without interruption over a surface sliding doors 片語 & 搭配詞 make sth into sth 把… 變成 make + 受詞 (物) + into + 受詞 (物) They’ve made the spare room into an office. 他們已把空置的房間改成辦公室。","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Queue","slug":"Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Queue/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Monotonic Queue","slug":"Monotonic-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Monotonic-Queue/"}]},{"title":"動詞的現在簡單式","slug":"language/english/文法/動詞的現在簡單式","date":"2023-08-15T17:09:11.000Z","updated":"2023-08-16T07:27:58.326Z","comments":true,"path":"language/english/文法/動詞的現在簡單式/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/language/english/%E6%96%87%E6%B3%95/%E5%8B%95%E8%A9%9E%E7%9A%84%E7%8F%BE%E5%9C%A8%E7%B0%A1%E5%96%AE%E5%BC%8F/","excerpt":"","text":"⭐️⭐️ # 文法摘要 主詞是第三人稱單數 (he, she, it) 且為現在式，使用的動詞字尾上必須加 &quot;-s&quot; 或 &quot;-es&quot;，規則如下: 動詞規則改法 範例 動詞字尾加上 s hit - hits 動詞結尾是 e，加上 s hide - hides 動詞字尾是 s/o/x/z/ch/sh，加上 es catch - catches 動詞字尾為 「母音 + y」，只要加 s stay - stays 動詞字尾為 「子音 + y」，要去 y 加上 ies study - studies 表示現在或事實的動作與狀態：注意第三人稱單數的字尾 s/es/ies 變化: 例一: Mr. Smith lives in Taichung, but he works in Taipei. 史密斯先生住在台中，但他在台北工作。 例二: You look tired. Stop working and take a break. 你看起來很累，別工作了，休息一下吧。 表示不變的格言、真理和事實: 例一: The sun rises in the east and sets in the west. 太陽從東邊升起，西邊落下。 例二: There is no royal road to learning. 學習無坦途。 表示現在的習慣或反覆的動作，常與以下頻率副詞連用: always (總是) /frequently (頻繁地) /often (常常) /usually (通常) /sometime (有時) /seldom (不常) /never (絕不) every + 時間 次數 + a/an + 單數時間 例一: On Halloween, houses and yards in the U.S.A. are often lit up by jack-o'-lanterns. 萬聖節時，美國的房子和庭院常點著南瓜燈。 例二: Cindy studies math and English every day. 辛蒂每天讀數學和英文。 例三: He writes to his parents once a week. 他每週寫一次信給父母。 表示時間或條件的副詞子句，用現在式代替未來式 例一: If she comes here tomorrow, please give her this letter. 若她明天來到這，請給她這封信。 例二: Even when you are very old, your fingerprints will still look very much the way they do now. 即便當你非常老，你的指紋仍會看起來和現在非常像。 註：在副詞子句和名詞子句中，仍用未來式表示未來式 例一: Tell me where she will go next month. 告訴我她下個月會去那裡。 例二: I don't know the exact time when he will hand in the report. 我不知道他會繳交報告的確切時間。 單字 royal 皇家的 adj. belonging or connected to a king or queen or a member of their family the royal family # 精選試題 Bill never carries a bag or a wallet when shopping. Every time he has to pay, he takes out money from his pocket. Bill 買東西時從來不帶包包或皮夾。每次要付錢的時候，他就會從口袋裡拿出錢來。 Although Annie know fast food is not good for her health, she still eats it. 雖然 Annie 知道速食對健康不好，她還是繼續吃。 Somewhere along the road, there is a shop which sells things from foreign countries. 這條路上的某處，有家賣異國商品的店。","categories":[{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"文法","slug":"language/english/文法","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E6%96%87%E6%B3%95/"}],"tags":[{"name":"英文文法","slug":"英文文法","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95/"}]},{"title":"86. Partition List","slug":"coding/leetcode/Medium/86-Partition-List","date":"2023-08-15T15:59:54.000Z","updated":"2023-08-15T16:52:26.324Z","comments":true,"path":"coding/leetcode/Medium/86-Partition-List/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/86-Partition-List/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given the head of a linked list and a value x , partition it such that all nodes less than x come before nodes greater than or equal to x . You should preserve the original relative order of the nodes in each of the two partitions. # Example 1 Input: head = [1,4,3,2,5,2], x = 3 Output: [1,2,2,4,3,5] # Example 2 Input: head = [2,1], x = 2 Output: [1,2] # 解題思路 Use two ListNode , less and greater , to hold nodes with values less than x and which node greater than or equal to x . Linking two ListNode togother, attach the greater to the end of the less . # Solution // Definition for singly-linked list.public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125;class Solution &#123; public ListNode partition(ListNode head, int x) &#123; ListNode less = new ListNode(0); ListNode lessTail = less; ListNode greater = new ListNode(0); ListNode greaterTail = greater; while (head != null) &#123; if (head.val &lt; x) &#123; lessTail.next = new ListNode(head.val); lessTail = lessTail.next; &#125; else &#123; greaterTail.next = new ListNode(head.val); greaterTail = greaterTail.next; &#125; head = head.next; &#125; lessTail.next = greater.next; return less.next; &#125;&#125; 單字 preserve 保存 v. to keep something as it is, especially in order to prevent it from decaying or being damaged or destroyed to preserve the environment We want to preserve the character of the town while improving the facilities.","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Linked-List/"}]},{"title":"215. Kth Largest Element in an Array","slug":"coding/leetcode/Medium/215-Kth-Largest-Element-in-an-Array","date":"2023-08-14T13:56:51.000Z","updated":"2023-08-15T16:07:40.696Z","comments":true,"path":"coding/leetcode/Medium/215-Kth-Largest-Element-in-an-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/215-Kth-Largest-Element-in-an-Array/","excerpt":"","text":"⭐️⭐️ # 題目敘述 Given an integer array nums and an integer k , return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Can you solve it without sorting? # Example 1 Input: nums = [3,2,1,5,6,4], k = 2 Output: 5 # Example 2 Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 # 解題思路 Use the PriorityQueue which is a data structure. # Solution import java.util.Comparator;import java.util.PriorityQueue;class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; PriorityQueue&lt;Integer> PQ = new PriorityQueue&lt;>(new PQComparator()); for (int num : nums) &#123; PQ.add(num); &#125; int ans = 0; for (int i = 0; i &lt; k; i++) &#123; ans = PQ.poll(); &#125; return ans; &#125;&#125;class PQComparator implements Comparator&lt;Integer> &#123; @Override public int compare(Integer number1, Integer number2) &#123; int value = number1.compareTo(number2); // elements are sorted in reverse order if (value > 0) &#123; return -1; &#125; else if (value &lt; 0) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;&#125; 單字 distinct 清楚的 adj. There's a distinct smell of cigarettes in here. clearly noticeable; that certainly exists 片語 & 搭配詞 smell of + sth ... 的香味","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Divide-and-Conquer/"},{"name":"Quickselect","slug":"Quickselect","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Quickselect/"}]},{"title":"2369. Check if There is a Valid Partition For The Array","slug":"coding/leetcode/Medium/2369-Check-if-There-is-a-Valid-Partition-For-The-Array","date":"2023-08-13T11:59:37.000Z","updated":"2023-08-14T13:10:58.958Z","comments":true,"path":"coding/leetcode/Medium/2369-Check-if-There-is-a-Valid-Partition-For-The-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2369-Check-if-There-is-a-Valid-Partition-For-The-Array/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given a 0-indexed integer array nums . You have to partition the array into one or more contiguous subarrays. We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions: The subarray consists of exactly 2 equal elements. For example, the subarray [2,2] is good. The subarray consists of exactly 3 equal elements. For example, the subarray [4,4,4] is good. The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1 . For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not. Return true if the array has at least one valid partition. Otherwise, return false. # Example 1 Input: nums = [4,4,4,5,6] Output: true Explanation: The array can be partitioned into the subarrays [4,4] and [4,5,6]. This partition is valid, so we return true. # Example 2 Input: nums = [1,1,1,2] Output: false Explanation: There is no valid partition for this array. # 解題思路 # Solution import java.util.HashMap;import java.util.Map;class Solution &#123; Map&lt;Integer, Boolean> map = new HashMap&lt;>(); public boolean prefixIsValid(int[] nums, int i) &#123; if (map.containsKey(i)) &#123; return map.get(i); &#125; boolean ans = false; if (i > 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; ans |= prefixIsValid(nums, i - 2); &#125; if (i > 1 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; nums[i - 1] == nums[i - 2]) &#123; ans |= prefixIsValid(nums, i - 3); &#125; if (i > 1 &amp;&amp; nums[i] == nums[i - 1] + 1 &amp;&amp; nums[i - 1] == nums[i - 2] + 1) &#123; ans |= prefixIsValid(nums, i - 3); &#125; map.put(i, ans); return ans; &#125; public boolean validPartition(int[] nums) &#123; int n = nums.length; map.put(-1, true); return prefixIsValid(nums, n - 1); &#125;&#125; 單字 partition 分割、隔開 v. to divide one part of a room from another with a thin wall Why don't you partition that large room into a lounge and a dining-room? contiguous 連續的 adj. next to or touching another, usually similar, thing The two states are contiguous with/to each other, but the laws are quite different. valid 有效的 adj. based on truth or reason; able to be accepted My way of thinking might be different from yours, but it's equally valid. obtain 獲得 v. to get something, especially by asking for it, buying it, working for it, or producing it from something else First editions of these books are now almost impossible to obtain. satisfy 滿足 v. to please someone by giving them what they want or need Come on, satisfy my curiosity (= tell me what I want to know) - what happened last night? exactly 確切地 adv. used when you are giving or asking for information that is completely correct It tastes exactly the same as the real thing, but has half the fat. consecutive 連續的 adj. Consecutive events, numbers, etc. follow one after another without an interruption This is the fifth consecutive weekend that I've spent working. adjacent 鄰近的 adj. very near, next to, or touching They lived in a house adjacent to the railway. 片語 & 搭配詞 to obtain permission 獲得許可 satisfy conditions/needs/requirements 滿足條件 / 需求 / 要求 consists of 由... 組成","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"UML 實務手冊","slug":"computer-science/Note/UML-實務手冊","date":"2023-08-13T09:46:23.000Z","updated":"2023-08-13T09:49:44.898Z","comments":true,"path":"computer-science/Note/UML-實務手冊/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Note/UML-%E5%AF%A6%E5%8B%99%E6%89%8B%E5%86%8A/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 認識 UML # 統一建模語言 UML (Unified Modeling Language) 是建構模式 (model) 的專用語言。 在編寫程式碼前，開發人員會先經過分析設計的思考，並繪製一些圖形，再搭配一些文字，作為分析設計的產出，這份產出可稱之為軟體模式模型。 # UML 圖 UML 推出了十多款圖，不過並非每款圖都實用，在開發商用資訊系統時，最常用到的 UML 圖，包含有：類別圖、循序圖、使用案例圖、狀態圖 (state machine diagram) 和活動圖 (activity diagram)。 # 簡易的開發程序 實務上， 使用案例圖及敘述 、 類別圖 與 循序圖 三者之搭配，幾乎是 UML 專案的基本型，所以在分工或外包的設計文檔中，通常少不了這三款 UML 圖。 最常見的開發程序是，並行建構使用案例圖文與類別圖，接著才建構循序圖以及按圖編碼。 一個系統只有一個內部結構，而且系統對外提供的所有服務，都僅依賴這個系統穩定的內部結構所支撐。 然而，每一項服務的運作方式皆不同，所以雖然系統僅有一個靜態結構，卻可以有很多個動態行為。 因此，透過 UML 圖來呈現系統的狀況時，一個系統僅有一張呈現系統內部結構的類別圖，而且無論使用案例圖中有多少個使用案例。 但是，每一個使用案例至少對應一張循序圖，呈現出系統執行使用案例期間，其內部的一群物件互動的運作情況。 再者，類別圖通常不是一次就能夠設計完全，而是透過一個又一個的使用案例，以及一張又一張的循序圖，三者經過多次循環更新的歷程後，類別圖才能逐步形成且穩定下來。 # 類別圖 類別圖 (class diagram) 是最重要的 UML 圖。 主要功能: 用來呈現系統內部的靜態結構，而這樣的靜態結構通常可以用直接對應程式碼，因此，從程式設計師的角度來看，類別圖是最被關注的 UML 圖。 類別圖描述了系統的類別集合，類別的屬性和類別之間的關係。 矩形代表類別 (class)、類別內部記載屬性 (attribute) 與操作 (operation)。 類別之間有代表結合關係 (association relationship) 的實線、組合關係 (composition relationship) 的實心菱形實線、一般化關係 (generalization relationship) 的三角形實線。 類別圖符號分成兩種: 物件本身 物件與物件的關係 物件本身 + : public - : private # : protected 物件間的關係 association relationship 結合關係 # 使一個類別知道另一個類別屬性和方法。 // 通常含有「知道」、「了解」的含義。 (A knows B) dependency relationship 依賴關係 # 指在參數或回傳時有用到 (A uses B) Implementation relationship 實作關係 # 指的是一個 class 類別實現 interface 介面 (A implements B) generalization relationship 一般化關係 # 指的是父類別擁有子類別的共用功能，子類別可以視作父類別的特例。 # 描述 is-a 關係。 (A is a type of B) aggregation relationship 聚合關係 # 整體與部分的「弱」包含關係，部分類別可以單獨存在，也可以屬於多個整體物件。 # 描述 has-a 關係。 (A owns B) composition relationship 組合關係 # 整體與部分的「強」包含關係，部分類別無法單獨存在，其生命週期與整體相同。 # 描述 contains-a 關係。 (B is part of A) 多重性 (Multiplicity) | 指示符 | 意思 | | ------ | ------- | | 0...1 | 0 or 1 | | 1 | 1 | | 0...* | 0 or 多 | | 1...* | 1 or 多 | | * | 多 | # 循序圖 循序圖 (sequence diagram) 將類別圖部分更細節。 主要功能: 呈現類別圖操作之實作方法。 在類別圖中，未能提出操作之實作方法，這部分的細節設計，可藉由循序圖來呈現。雖然，我們可以從類別圖對應到程式中的類別、屬性、關係及操作之宣告，但也僅止於此，對於操作的實作方法，還要搭配循序圖才能獲得。 除了表達實作方法外，更重要的是，循序圖還能夠表達執行期間的一群物件，為了合力完成某一個目的，呼叫操作之互動情況。 ![image sequence diagram][reference link] # 使用案例圖 使用案例圖 (use case diagram) 是最與眾不同的 UML 圖。 主要功能: 獨特之處在於它適合用來表達系統的「外部」行為，其餘的 UML 圖都適用於呈現系統內部結構或行為。其餘的 UML 圖都是用於呈現系統的「內部」結構或行為。 橢圓形的使用案例圖示位於系統內部，代表系統將提供且支援這些使用案例，而參與者位於系統外部，代表使用案例的啟動者或支援者。 ![image use case diagram][reference link] # 狀態圖 狀態圖 (state machine diagram) 主要功能: 狀態圖可以讓我們聚焦在單一種類的物件本身，表達物件一生中可以出現的狀態 (state) 變化。 相較之下，狀態圖的觀點與循序圖的觀點全然不同，循序圖表達某一種物件與其他種物件之間的互動情況。 簡而言之，循序圖用以表達物件外部互動行為，而狀態圖表達物件內部的狀態變化。 ![image use case diagram][reference link] # 活動圖 活動圖 (activity diagram) 主要功能: 活動圖非常適合用來表達一連串的行動。 活動圖相當容易理解與使用，它跟我們隨手繪製的流程圖沒什麼不同，唯一需要講究的只有它特定的圖示。 在企業組織領域裡，我們經常用它來表達工作流程、企業流程或聯合服務等的活動流程。 至於資訊系統的應用上，遇到較為複雜的系統流程、整合流程及操作時，我們也會配合使用活動圖協助思考及設計。 其他時候，為了節省開發成本與縮短開發時程，可能僅採用循序圖來表達系統內部物件的互動情況。 ![image use case diagram][reference link] # UML 工具 StarUML IBM RSA Case Complete","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Note","slug":"computer-science/Note","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Note/"}],"tags":[]},{"title":"C Program 進階","slug":"computer-science/Program-Language/C Programming Language/C-Program-進階","date":"2023-08-13T09:15:16.000Z","updated":"2023-08-14T14:04:11.723Z","comments":true,"path":"computer-science/Program-Language/C Programming Language/C-Program-進階/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Program-Language/C%20Programming%20Language/C-Program-%E9%80%B2%E9%9A%8E/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # Array 變數可以幫我們存取一筆資料，但要存取多筆資料時就會顯得很麻煩。 比如我們要記錄三個學生的成績: # Declare Data type 變數名稱[陣列大小] = &#123;資料&#125;; # Array Input/Output # Two-dimensional Arrays 二維陣列 陣列裡面存放陣列 # Declare Data type 變數名稱[column][row] = &lt;!--swig￼1-->; # Two-dimensional Arrays Input/Output # String 字串 在 C programming language 中，沒有 string 的變數型態， 因此我們這邊提到的字串是以字元陣列的型態表示， 另一種是用 pointer 的型態來表示。 # Declare char 變數名稱[陣列大小] = &#123;‘資’, ‘料’&#125;; char 變數名稱[陣列大小] = “資料”; # Gets/Fgets/Puts 字串輸入 / 輸出 因為 gets 函式無法知道字元陣列的大小，而是依賴換行符號或 EOF 才會結束輸入，因此有可能引發緩衝區溢位的安全問題 。 # Scanf # String of function There are many important string functions defined in &quot;string.h&quot; library. # Strlen The strlen() function returns the length of the given string. It doesn't count null character '\\0' . # Strcpy The strcpy(destination, source) function copies the source string in destination. # Strcat The strcat(first_string, second_string) function concatenates two strings and result is returned to first_string. # Strcmp The strcmp(first_string, second_string) function compares two string and returns 0 if both strings are equal. # Strrev The strrev(string) function returns reverse of the given string. # Strlwr The strlwr(string) function returns string characters in lowercase. # Strupr The strupr(string) function returns string characters in uppercase. # Strstr strstr () 函數返回指向給定字符串中第一次出現的匹配字符串的指針。 它用於返回從第一個匹配到最後一個字符的子字符串。 # Function 函式 A function is a block of code which only runs when it is called. Functions are used to perform certain actions, and they are important for reusing code: Define the code once and use it many times. 我們可以簡單的將程式的函數分成兩種: 有回傳值的 無回傳值的 # Advantage 函式 (function) 是程序抽象化 (procedure abstraction) 的實踐方法: Reusability 重複利用性 Readability 易讀性 Reduce Coupling 降低耦合性 (耦合，指的是和其它程式碼「有」相關) Modularity of the program 模組化 # Syntax _ return value # Syntax _ without parameter # Syntax _ without return value # Function Function 可以把他想成某個功能的實現，用於簡化 main 中的程式，並妥善的將程式清楚區分功能，達到重用、降低耦合性，也讓寫思考程式功能更能分塊撰寫。 在這邊我們可以先不管 Function 內的程式是如何寫的，但是我們知道他可以實現他的功能；區分好後再開始分段思考，要如何撰寫 Function 內的程式可以達到我們所希望的樣子。 # Pointer # Recall Data type 變數名稱 = 資料; # Value # Pointer # Declare T* ptr ptr is pointed a T type object/value &amp;value get address of value *ptr Access data by an address # Pointer # Pointer in Pointer # Pointer and Array # Thinking 請問右邊程式執行後會輸出什麼呢？ # Struct 結構 (structure) 是一種複合型別 (derived data type)，用來表達由多個屬性組成的型別，而這些屬性可以是基本型別或是另一個複合型別所組成。 # 宣告結構 # 存取結構內屬性 # 內嵌在結構內的結構 # 儲存結構的陣列 # 存取結構指標的屬性 # Scope 主要是指我們的變數都有可以使用的範圍，通常一個可以用的範圍是其 “{} ” 內。 EX: 自訂 function 和 main function，其實是兩個不同括號 (“ {} ” ) 的兩段程式碼，所以它裡面的變數命名一樣是不會導致錯誤的，因為對程式來說它是兩塊不同的東西。 EX: main function 中 while/for 中所定義的變數，在 while/for 的 “{} ” 是無法被使用的。 # Argument Passing # Call by Value 利用 call by value 的方法去傳值時，因為 a, b 的記憶體和 swap function 內 a, b 的記憶體是分開的，所以不會互相干擾，但需要使用另外的兩個記憶體去儲存他們！ # Call by Address 使用了一個 swap function，它的功能是將 a 和 b 傳入的 address 進行交換，之後在 main 裡面利用 &amp; 符號傳入 address ，然後執行一遍就可以發現，交換前 a 的值為 1，b 的值為 0，交換後 a 的記憶體空間和 b 交換，所以各自代表的值也變成了 0 和 1。 # Algorithm 由有限步驟所構成的集合，可以用於解決某一個特定的問題。 其實演算法就是一種解決問題的邏輯思維！ Ex: 假設我們今天要解決的那一個特定問題是「把蘋果做成一杯蘋果汁」 可以透過以下幾個步驟來實現： 清洗蘋果 將蘋果削皮、去籽 將經過步驟 (2) 處理的蘋果放入果汁機 在果汁機中加入一定比例的水 按下果汁機啟動按鈕 將果汁機裡面的蘋果汁倒入玻璃杯中","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"program-language","slug":"computer-science/program-language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/"},{"name":"C Programming Language","slug":"computer-science/program-language/C-Programming-Language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/C-Programming-Language/"}],"tags":[]},{"title":"C Program 基礎","slug":"computer-science/Program-Language/C Programming Language/C-Program-基礎","date":"2023-08-13T08:44:47.000Z","updated":"2023-08-14T14:04:04.066Z","comments":true,"path":"computer-science/Program-Language/C Programming Language/C-Program-基礎/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Program-Language/C%20Programming%20Language/C-Program-%E5%9F%BA%E7%A4%8E/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # Get Start 前情提要 Program language C C++ Java JavaScript Python Source-code Editor VS code dev c++ Code::Block notepad++ Compiler # Introduction 介紹 雖然他是一個很古老的語言，也相較底層，但到如今還是一個相當熱門的語言。 他是很多語言的基礎，學習 C 語言後，在學習其他語言，會更加容易上手。 C 語言 與 UNIX 密切相關，因為它是為編寫 UNIX 作業系統而開發的。 C 語言 相較於其他語言來說，較為快速。 # Base 基本概念 Rule Left to Right, Up to Down ; at the end of each line of instructions return 0 ; end of program Use TAB &#123;&#125; content in structure Comment // … single line /* … */ multi-line # Syntax 語法 get start #include &lt;stdio.h>int main()&#123; ... return 0;&#125; 引入函式庫 Standard Library Header File 標準函式庫標頭檔 #include &lt;stdio.h&gt; : 內容大略為處理輸入和輸出對象 scanf / printf 給電腦字典 (標頭檔) 查詢程式內容意思 主函式 程式執行的主要內容，任何程式的切入點 備註：學到 function 後會更加清楚 # Variable 變數 簡單來說，就是它的數值會改變的數 Type 型態 Label 標籤 Data 資料 # Declare Data type 變數名稱 = 資料; # Data Type Primitive Data Types : int, float, char, bool, void Derived Data Types : function, array, pointer, reference Abstract or User-Defined Data Types : Class, Structure, Union, Enumeration, Typedef defined Datatype # Primitive Data Type These data types are built-in or predefined data types and can be used directly by the user to declare variables. Data Type byte Remark Int 整數 4 byte range from ≈ 10^9 Float 單精度浮點數 4 byte Double 雙經度浮點數 8 byte range from -128 to 127 or 0 to 255 Char 字元 1 byte True(1) or False(0) Bool 布林 1byte used for function which does not return a value Void 無 / 空 1byte == 8bits # Identifiers Can contain letters, digits and underscores Must begin with a letter or an underscore (_) case sensitive (myVar and myvar are different variables) Cannot contain whitespaces or special characters ( ! # % ……) Reserved words cannot be used (like C keywords, such as int) 名稱要有描述性且合理 少用縮寫，對於沒有參與這個專案、但在相關領域的人熟悉的縮寫字，可以使用 變數（包括函式的參數）的名稱一律小寫，單字之間用底線連接 命名規則 # Constants 常數 無法被更改的數值 cconst Data type 變數名稱 = 資料; # I/O # Printf 輸出 將資料輸出，顯示在螢幕上 輸出變數 將變數輸出，顯示在螢幕上 輸出變數於特定格式 將變數輸出成特定格式，顯示在螢幕上 # Escape \\ 跳脫字元 \\0 空字元 (NULL) \\t TAB \\n 換行 \\a 響鈴 (BEL) \\” 雙引號 \\’ 單引號 # Scanf 輸入 輸入資料，需要利用變數來放入輸入的資料 # Getchar/Putchar 字元輸入 / 輸出 如果輸入了兩個以上的字元，則 getchar 會取得第一個字元，並將第二個字元留在緩衝區中，直到再使用 getchar 或 scanf 取得輸入。 # Operator Arithmetic Operator Assignment Operator Relational Operator / Comparison Operator Logical Operator Unary Operator # Arithmetic Operators + 加法 - 減法 * 乘法 / 商數除法 % 餘數除法 # Assignment Operators = 指派 += 複合指派 # Relational Operators &gt; 大於 &gt;= 大於等於 &lt; 小於 &lt;= 小於等於 == 等於 != 不等於 = VS. == = 指派: a = b 將 b 的值存入 a 變數中 == 等於: a == b a 與 b 是否相等？True/False # Logical Operators &amp;&amp; AND 且 || OR 或 ! NOT 相反 # Unary Operators ++ / -- postfix-expression ++ ++ unary-expression # Challenge (B) (A) (A) (B) # Encoding Encoding is the process of converting information from one format to another. # ASCII American Standard Code for Information Interchange 字元編碼（Character encoding）total 128 Control character 33 Printable characters 95 ASCII 維基百科 大寫轉小寫 英文大寫 A 十進位表示方式: 65 英文小寫 a 十進位表示方式: 97 # 97–65=3297 – 65 = 3297–65=32 # 英文大小寫 十進位表示方式差 32 # Control flow Selection Statements 選擇語句 Iteration Statements 反覆語句 Jump Statements 跳轉語句 # Selection Statements 經由判斷條件是 TRUE 或是 FALSE，來選擇要執行哪段程式 If … else Switch case # Iteration Statements 重複執行單個或多個運算式，在每次執行前會先判斷條件式，若為 FALSE 或是 break，才會中斷。 While Do while For loop # Jump Statements Break 中斷 中斷並結束迴圈。 Continue 繼續 中斷當次迴圈循環，到開頭在執行一次。 # Selection Statements # If … else If _ Flow chart If _ Syntax If … else _ Flow chart If … else _ Syntax Shorthand if … else _ Syntax If … else if … else _ Flow chart If … else if … else _ Syntax Nested if _ Flow chart Nested if _ Syntax # Switch Switch _ Flow chart Switch _ Syntax # Thinking 請問右邊程式執行後會輸出什麼呢？ 中止條件: 一直執行到沒有 case 為止 當遇到 break 時，強制跳離 # Iteration Statements # While While _ Flow chart While _ Syntax # Do while Do while _ Flow chart Do while _ Syntax # For loop For loop _ Flow chart For loop_ Syntax statement 1 : initialization statement 2 : conditional statement 3 : update # Nested loop 巢狀是指東西如同鳥巢一樣，一層一層的包下去，而程式中的巢狀迴圈是， while/for 迴圈內包著 while/for 迴圈。 # Midway Challenge","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"program-language","slug":"computer-science/program-language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/"},{"name":"C Programming Language","slug":"computer-science/program-language/C-Programming-Language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/C-Programming-Language/"}],"tags":[]},{"title":"PHP 串接資料庫","slug":"computer-science/Program-Language/PHP/PHP-串接資料庫","date":"2023-08-13T08:10:47.000Z","updated":"2023-08-14T14:03:59.948Z","comments":true,"path":"computer-science/Program-Language/PHP/PHP-串接資料庫/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Program-Language/PHP/PHP-%E4%B8%B2%E6%8E%A5%E8%B3%87%E6%96%99%E5%BA%AB/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 與資料庫的結合運用 在 PHP 中連結資料庫 all.php&lt;?php require '../header.php'; ?>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', '帳號', '密碼');?>&lt;?php require '../footer.php'; ?>網頁沒有顯示錯誤訊息就表示連接成功。 # 利用 PDO 連接資料庫 在 PHP 中要連結資料庫，通常使用提供了 PHP 與資料庫間的連線機制的 PDO。 在 PHP 中，可以使用 類別 (Class) 來統整定義相關的變數與函式。 PDO 即是一種類別，裡面包含了操作資料庫時會使用到的變數與函式。 類別中的變數稱為 屬性 (property)，類別內的函式稱為 方法 (Method)。 要使用類別之前，一定要產生 instance。 # 產生 PDO 的 instance $pdo=new PDO(...); 用來識別資料庫的參數 (DSN) 'mysql:host=localhost;dbname=shop;charset=utf8' mysql 表示要連線到 MySQL。在冒號 (:) 之後列出連線資料庫所需的資料，並以分號 ( ; ) 分隔每項資料。 host=localhost 是指 MySQL 存在於 localhost。在此所用的 MySQL，是與 XAMPP 一起安裝在您手邊的電腦上，因此指定位置為 localhost。 dbname=shop 表示 shop 資料庫。 charset=utf8 則表示資料庫所用的文字編碼為 UTF-8。 登入的使用者名稱 'staff'第 2 個參數用來設定登入資料庫的使用者名稱。 這裡指定為建立 shop 資料庫時建立的使用者 staff。必須以單引號 (') 框住。 登入密碼 'password'第 3 個參數用來設定登入密碼。 這裡指定為建立使用者所設定的密碼 password。必須以單引號 (') 框住。 用 PHP 顯示 table 中資料 all2.php&lt;?php require '../header.php'; ?>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');foreach ($pdo->query('select * from product') as $row) &#123; echo '&lt;p>'; echo $row['id'], ':'; echo $row['name'], ':'; echo $row['price']; echo '&lt;/p>';&#125;?>&lt;?php require '../footer.php'; ?>all3.php&lt;?php require '../header.php'; ?>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');foreach ($pdo->query('select * from product') as $row) &#123; echo \"&lt;p>$row[id]:$row[name]:$row[price]&lt;/p>\";&#125;?>&lt;?php require '../footer.php'; ?>以雙引號框住的字串，具有可在字串之中插入變數值的功能。 # 執行 SQL 指令 PDO的變數->query('SQL指令')變數 PDO 名字是 $pdo $pdo->query('SQL指令')呼叫方法的程式寫法為 (變數 -&gt; 方法 ) # 取得資料欄內的資料 陣列名稱['資料欄名稱']利用 foreach 迴圈，就可將資料逐筆處理。 用 PHP 顯示 Table 中資料 all4.php&lt;?php require '../header.php'; ?>&lt;table>&lt;tr>&lt;th>商品編號&lt;/th>&lt;th>商品名稱&lt;/th>&lt;th>商品價格&lt;/th>&lt;/tr>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=pratice;charset=utf8', '帳號', '密碼');foreach ($pdo->query('select * from person') as $row) &#123; echo \"&lt;tr>&lt;td>$row[person_id]&lt;/td>&lt;td>$row[person_name]&lt;/td>&lt;td>$row[person_birth]&lt;/td>&lt;/tr>\"; echo \"\\n\";&#125;?>&lt;/table>&lt;?php require '../footer.php'; ?>以雙引號框住的字串，具有可在字串之中插入變數值的功能。 all5.php&lt;?php require '../header.php'; ?>&lt;table>&lt;tr>&lt;th>商品編號&lt;/th>&lt;th>商品名稱&lt;/th>&lt;th>商品價格&lt;/th>&lt;/tr>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');foreach ($pdo->query('select * from product') as $row) &#123; echo '&lt;tr>'; echo '&lt;td>', htmlspecialchars($row['id']), '&lt;/td>'; echo '&lt;td>', htmlspecialchars($row['name']), '&lt;/td>'; echo '&lt;td>', htmlspecialchars($row['price']), '&lt;/td>'; echo '&lt;/tr>'; echo \"\\n\";&#125;?>&lt;/table>&lt;?php require '../footer.php'; ?>資料中若有可能包含在 HTML 中有特殊意義的字，顯示前應先經 htmlspecialchars 函式處理。 # 函式的定義 PHP 不僅提供了許多現成的函式，程式設計師也可自行撰寫需要的函式。 function 函式名稱(傳入參數, ...)&#123; 執行的處理; ... return 回傳值;&#125;# 資料的搜尋 用欄位中的名稱搜尋資料 search-input.php&lt;?php require '../header.php'; ?>請輸入商品名稱：&lt;form action=\"search-output.php\" method=\"post\">&lt;input type=\"text\" name=\"keyword\">&lt;input type=\"submit\" value=\"搜尋\">&lt;/form>&lt;?php require '../footer.php'; ?>search-output.php&lt;?php require '../header.php'; ?>&lt;table>&lt;tr>&lt;th>商品編號&lt;/th>&lt;th>商品名稱&lt;/th>&lt;th>商品價格&lt;/th>&lt;/tr>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');$sql=$pdo->prepare('select * from product where name=?');$sql->execute([$_REQUEST['keyword']]);foreach ($sql->fetchAll() as $row) &#123; echo '&lt;tr>'; echo '&lt;td>', $row['id'], '&lt;/td>'; echo '&lt;td>', $row['name'], '&lt;/td>'; echo '&lt;td>', $row['price'], '&lt;/td>'; echo '&lt;/tr>'; echo \"\\n\";&#125;?>&lt;/table>&lt;?php require '../footer.php'; ?> # where 在 SQL 的 select 敘述中，用來指定搜尋條件，在他之後直接寫出條件式。 where 資料欄名稱 ='搜尋的鍵值'可以用？來代替之後才要代入的值。 select * from product where 資料欄名稱 =?# prepare 是用來進行 SQL 指令執行前的準備。 PDO的變數->prepare('SQL指令')prepare 方法在執行後，會回傳已設定好 SQL 指令的 PDOStatement 實例。 這個實例在之後執行 SQL 指令時還是會用到，因此要先將它指定給變數。 $sql=$pdo->prepare('select * from product where name=?'); # execute 要執行以傳入參數傳入 prepare 方法的 SQL 指令，必須利用 PHP 內建的 PDOStatement 類別的 execute 方法。 變數->execute(值)若指令中有多個 (?) 時，可以用 ( , ) 分隔多值。 [$_REQUEST['first_keyword'], $_REQUEST['second_keywork']]利用 prepare 方法預處理好 SQL 指令，要利用 execute 方法執行。 # fetchAll 利用 execute 方法執行 SQL 指令後，可再利用 PDOStatement 類別的 fetchAll 方法取的執行結果。 foreach(PDO的變數->fetchAll() as 要將取的結果代入的變數)foreach ($sql->fetchAll() as $row) &#123;# like 搜尋部分符合的商品 select * from product where name like ?;? =&gt; %word% 指就算 word 前後有其他字也符合條件 $sql=$pdo->prepare('select * from product where name like ?');$sql->execute(['%'.$_REQUEST['keyword'].'%']);# not like 找出不含搜尋關鍵字的資訊 select * from product where name not like ?;# like and not like select * from product where name like ? and name not like ?;# 在資料表內新增資料 insert-input.php&lt;?php require '../header.php'; ?>&lt;p>資料新增：&lt;/p>&lt;form action=\"insert-output.php\" method=\"post\">商品名稱&lt;input type=\"text\" name=\"name\">價格&lt;input type=\"text\" name=\"price\">&lt;input type=\"submit\" value=\"確定新增\">&lt;/form>&lt;?php require '../footer.php'; ?>insert-output.php&lt;?php require '../header.php'; ?>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');$sql=$pdo->prepare('insert into product values(null, ?, ?)');if ($sql->execute([$_REQUEST['name'], $_REQUEST['price']])) &#123; echo '新增成功。';&#125; else &#123; echo '新增失敗。';&#125;?>&lt;?php require '../footer.php'; ?>insert-output2.php&lt;?php require '../header.php'; ?>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');$sql=$pdo->prepare('insert into product values(null, ?, ?)');if (empty($_REQUEST['name'])) &#123; echo '請輸入商品名稱。';&#125; else if (!preg_match('/[0-9]+/', $_REQUEST['price'])) &#123; echo '請以整數輸入商品價格。';&#125; else if ($sql->execute( [htmlspecialchars($_REQUEST['name']), $_REQUEST['price']] )) &#123; echo '新增成功。'; &#125; else &#123; echo '新增失敗。'; &#125;?>&lt;?php require '../footer.php'; ?> # empty 在值為空時，回傳 TRUE。 empty(值)# 資料隱碼攻擊 (SQL injection) 說到要預防資料庫存入有問題的資料，就必須提到 資料隱碼攻擊 (SQL injection)。 資料隱碼攻擊 是指系統執行了非開發者撰寫的 SQL 指令，導致資料庫被非法存取的問題。 # 修改資料庫資料 update-input.php&lt;?php require '../header.php'; ?>&lt;table>&lt;tr>&lt;th>商品編號&lt;/th>&lt;th>商品名稱&lt;/th>&lt;th>商品價格&lt;/th>&lt;/tr>&lt;?php$pdo=new PDO( 'mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');foreach ($pdo->query('select * from product') as $row) &#123; echo '&lt;tr>&lt;form action=\"update-output.php\" method=\"post\">'; echo '&lt;input type=\"hidden\" name=\"id\" value=\"', $row['id'], '\">'; echo '&lt;td>', $row['id'], '&lt;/td>'; echo '&lt;td>'; echo '&lt;input type=\"text\" name=\"name\" value=\"', $row['name'], '\">'; echo '&lt;/td>'; echo '&lt;td>'; echo '&lt;input type=\"text\" name=\"price\" value=\"', $row['price'], '\">'; echo '&lt;/td>'; echo '&lt;td>&lt;input type=\"submit\" value=\"確定修改\">&lt;/td>'; echo '&lt;/form>&lt;/tr>'; echo \"\\n\";&#125;?>&lt;/table>&lt;?php require '../footer.php'; ?>update-output.php&lt;?php require '../header.php'; ?>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');$sql=$pdo->prepare('update product set name=?, price=? where id=?');if (empty($_REQUEST['name'])) &#123; echo '請輸入商品名稱。';&#125; elseif (!preg_match('/[0-9]+/', $_REQUEST['price'])) &#123; echo '請以整數輸入商品價格。';&#125; elseif ($sql->execute( [htmlspecialchars($_REQUEST['name']), $_REQUEST['price'], $_REQUEST['id']])) &#123; echo '修改成功。';&#125; else &#123; echo '修改失敗。';&#125;?>&lt;?php require '../footer.php'; ?> # 刪除資料庫資料 delete-input.php&lt;?php require '../header.php'; ?>&lt;table>&lt;tr>&lt;th>商品編號&lt;/th>&lt;th>商品名稱&lt;/th>&lt;th>商品價格&lt;/th>&lt;/tr>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');foreach ($pdo->query('select * from product') as $row) &#123; echo '&lt;tr>'; echo '&lt;td>', $row['id'], '&lt;/td>'; echo '&lt;td>', $row['name'], '&lt;/td>'; echo '&lt;td>', $row['price'], '&lt;/td>'; echo '&lt;td>'; echo '&lt;a href=\"delete-output.php?id=', $row['id'], '\">確定刪除&lt;/a>'; echo '&lt;/td>'; echo '&lt;/tr>'; echo \"\\n\";&#125;?>&lt;/table>&lt;?php require '../footer.php'; ?>delete-output.php&lt;?php require '../header.php'; ?>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');$sql=$pdo->prepare('delete from product where id=?');if ($sql->execute([$_REQUEST['id']])) &#123; echo '刪除成功。';&#125; else &#123; echo '刪除失敗。';&#125;?>&lt;?php require '../footer.php'; ?> # 含有 REQUEST 參數的連結 要開啟的檔案名稱?REQUEST參數名=值要開啟的檔案名稱?REQUEST參數名=值 &amp; REQUEST參數名=值 &amp;...echo '&lt;a href=\"delete-output.php?id=', $row['id'], '\">確定刪除&lt;/a>';# 整合新增、修改、刪除 edit3.php&lt;?php require '../header.php'; ?>&lt;table>&lt;tr>&lt;th>商品編號&lt;/th>&lt;th>商品名稱&lt;/th>&lt;th>價格&lt;/th>&lt;/tr>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');if (isset($_REQUEST['command'])) &#123; switch ($_REQUEST['command']) &#123; case 'insert': if (empty($_REQUEST['name']) || !preg_match('/[0-9]+/', $_REQUEST['price'])) break; $sql=$pdo->prepare('insert into product values(null,?,?)'); $sql->execute( [htmlspecialchars($_REQUEST['name']), $_REQUEST['price']]); break; case 'update': if (empty($_REQUEST['name']) || !preg_match('/[0-9]+/', $_REQUEST['price'])) break; $sql=$pdo->prepare( 'update product set name=?, price=? where id=?'); $sql->execute( [htmlspecialchars($_REQUEST['name']), $_REQUEST['price'], $_REQUEST['id']]); break; case 'delete': $sql=$pdo->prepare('delete from product where id=?'); $sql->execute([$_REQUEST['id']]); break; &#125;&#125;foreach ($pdo->query('select * from product') as $row) &#123; echo '&lt;tr>'; echo '&lt;form action=\"edit3.php\" method=\"post\">'; echo '&lt;input type=\"hidden\" name=\"command\" value=\"update\">'; echo '&lt;input type=\"hidden\" name=\"id\" value=\"', $row['id'], '\">'; echo '&lt;td>', $row['id'], '&lt;/td>'; echo '&lt;td>'; echo '&lt;input type=\"text\" name=\"name\" value=\"', $row['name'], '\">'; echo '&lt;/td>'; echo '&lt;td>'; echo '&lt;input type=\"text\" name=\"price\" value=\"', $row['price'], '\">'; echo '&lt;/td>'; echo '&lt;td>&lt;input type=\"submit\" value=\"確定修改\">&lt;/td>'; echo '&lt;/form>'; echo '&lt;form action=\"edit3.php\" method=\"post\">'; echo '&lt;input type=\"hidden\" name=\"command\" value=\"delete\">'; echo '&lt;input type=\"hidden\" name=\"id\" value=\"', $row['id'], '\">'; echo '&lt;td>&lt;input type=\"submit\" value=\"確定刪除\">&lt;/td>'; echo '&lt;/form>'; echo '&lt;/tr>'; echo \"\\n\";&#125;?>&lt;tr>&lt;form action=\"edit3.php\" method=\"post\">&lt;input type=\"hidden\" name=\"command\" value=\"insert\">&lt;td>&lt;/td>&lt;td>&lt;input type=\"text\" name=\"name\">&lt;/td>&lt;td>&lt;input type=\"text\" name=\"price\">&lt;/td>&lt;td>&lt;input type=\"submit\" value=\"確定新增\">&lt;/td>&lt;/form>&lt;/tr>&lt;/table>&lt;?php require '../footer.php'; ?> # 實用的 PHP 程式 - 以購物網站為例 # Session 是在網頁應用程式中用來放置各使用者資料的機制。 利用 Session 機制，就能管理每個使用者的個別資料。 在 PHP 中，可透過 $_SESSION 陣列存取 Session 資料。 # 網站上線的實務知識 # 限制錯誤訊息的顯示 error_reporting(級別);級別 常數 意義 0 隱藏所有錯誤訊息 E_ERROR 出現重大的執行錯誤時，中斷程式的執行 E_WARNING 執行時出現的警告不會中斷程式的執行 E_PARSE 解釋程式時出現錯誤。會在語法錯誤時發生 E_NOTICE 執行時出現注意。會在懷疑程式可能有誤發生時 E_ALL 顯示所有錯誤訊息 # 利用框架 (Framework) 框架 (Framework) 與函式庫一樣，都是用來支援應用程式開發的軟體。 但是框架提供的不是好用的函式與類別，而且用來規範應用程式的技術方式。 框架並不是用來提供應用程式會用到的部分功能，而是用來提供建構應用程式的整體框架。 因此和函式庫一樣，若能善用框架，就能在短時間開發出功能更好的應用程式。 此外，在多人同時開發應用程式時，利用框架就能統一應用程式的技術方式。 可以讓開發團隊更容易共享資訊，提高開發效率。 Laravel https://laravel.com/","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"program-language","slug":"computer-science/program-language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/"},{"name":"PHP","slug":"computer-science/program-language/PHP","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/PHP/"}],"tags":[]},{"title":"PHP 基本語法","slug":"computer-science/Program-Language/PHP/PHP-基本語法","date":"2023-08-13T06:49:13.000Z","updated":"2023-08-14T14:03:55.596Z","comments":true,"path":"computer-science/Program-Language/PHP/PHP-基本語法/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Program-Language/PHP/PHP-%E5%9F%BA%E6%9C%AC%E8%AA%9E%E6%B3%95/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # PHP 標籤與程式碼 &lt;?phpPHP 程式內容?> PHP 只會執行 &lt;?php 與 ?&gt; 所框住的內容。 # echo 用來顯示文字訊息 echo '文字訊息'; 以 ' 或 &quot; 框住的內容會被當作是字串。 請留意每行程式的最後，都會有一個分號 (😉。 有多個敘述並列時，將由上至下依序執行。 &lt;?phpecho Welcome;?> 未定義常數 Welcome，錯誤發生於 C:\\xampp\\htdocs\\php\\chapter3\\welcome-error.php 第 2 行 # print 用來顯示文字訊息 print '文字訊息'; echo 和 print 都可用來顯示文字訊息。 通常認為 echo 的處理速度較快 (執行到顯示出訊息所需的時間較短)。 echo 具有將多個字串、數值連接起來顯示的功能。 HTML 區塊: 用於顯示固定不變的內容。 PHP 區塊: 用於顯示會因情況而變動的內容。 &lt;?php echo '歡迎光臨'; ?>可以化簡為 &lt;?= '歡迎光臨'; ?> # require 在 PHP 中，要載入並執行放在其他檔案中的程式，必須使用 require 敘述。 require '檔案名稱'; 可將程式中重複使用的內容存為獨立檔案，再用 require 載入他。 節省反覆輸入重複內容的時間，讓程式看起來更簡潔。 要修改共通使用的部分時，不需在多支程式裡分別修改，只要修改單一檔案的內容即可。 user-input.php&lt;?php require '../header.php'; ?>&lt;p>請輸入姓名：&lt;/p>&lt;form action=\"user-output.php\" method=\"post\"> &lt;!-- post v.s. get --> &lt;input type=\"text\" name=\"user\"> &lt;!-- user 是用在 PHP 中接收的 REQUEST 參數名 --> &lt;input type=\"submit\" value=\"確定\">&lt;/form>&lt;?php require '../footer.php'; ?># request 取得表單回傳的參數 (字串) $_REQUEST['REQUEST參數名']user-output.php&lt;?php require '../header.php'; ?>&lt;?phpecho '午安，', $_REQUEST['user'], '您好。';?>&lt;?php require '../footer.php'; ?># 優化程式 避免出現 REQUEST 參數名 未被定義 (Undefined) 的情形，可以用以下寫法。 &lt;?php require '../header.php'; ?>&lt;?phpif (isset($_REQUEST['user'])) &#123; echo '午安，', $_REQUEST['user'], '您好。';&#125;?>&lt;?php require '../footer.php'; ?> 避免出現 輸入內容含有 HTML，並被執行 的情形，可以用以下寫法。 &lt;?php require '../header.php'; ?>&lt;?phpif (isset($_REQUEST['user'])) &#123; echo '午安，', htmlspecialchars($_REQUEST['user']), '您好。';&#125;?>&lt;?php require '../footer.php'; ?> # 算符 (或稱運算子 Operator) 進行計算的處理即稱為「運算」 算符 作用 ** 平方 ++ -- 加 1、減 1 ! 邏輯 (反值) * / % 乘法、除法、餘數 + - . 加法、減法、字串相連 &lt; &lt;= &gt; &gt;= 比較 (小於、小於等於、大於、大於等於) == != 比較 (等於、不等於) &amp;&amp; 邏輯 (AND) || 邏輯 (OR) = 指派 算符有優先順序之分 # 變數 是用來存放資料的機制 變數名稱的前面必須加上錢字號 ($)。 開頭第 1 個字必須為英文字母或底線 (_)。 除了第 1 個字之外，其他可用英文字母、數字、底線隨意組成。 英文字母的大小寫視為不同文字。 預先定義好的變數 自行定義的變數名稱不可與這些 PHP 預先定義的變數名稱相同 變數名稱 功能 $_REQUEST HTTP 的所有 REQUEST 參數 (無論是以 GET 或 POST 方式傳送) $_GET HTTP 以 GET 方式傳送的 REQUEST 參數 $_POST HTTP 以 POST 方式傳送的 REQUEST 參數 $_FILES 上傳檔案的資料 $_SESSION Session $_COOKIE Cookie # 指派 「=」被稱為指派算符，可將他右邊的值寫入左邊的變數。 變數=值# 變數之間的指派 變數A=變數B# 常數 一開始指派了常數的值之後，就不能再對值做變更。 const 常數名=值# 陣列 (Array) 陣列內區分為多個區塊，用來存放多個資料值，這些區塊稱為陣列的元素。 為了區隔個別元素，必須使用 索引 (index) 來存取。 陣列=[值A, 值B, 值C, ...];陣列=[ 值A, 值B, 值C, ...];陣列=[索引A => 值A,索引B => 值B,索引C => 值C,...];陣列=[ 索引A => 值A, 索引B => 值B, 索引C => 值C, ...];# 新增元素 陣列[]=新元素;# 流程控制 核取方塊 check-input.php&lt;?php require '../header.php'; ?>&lt;form action=\"check-output.php\" method=\"post\"> &lt;p>&lt;input type=\"checkbox\" name=\"mail\">訂閱特賣情報電子報&lt;/p> &lt;p>&lt;input type=\"submit\" value=\"確定\">&lt;/p>&lt;/form>&lt;?php require '../footer.php'; ?> check-output.php&lt;?php require '../header.php'; ?>&lt;?phpif (isset($_REQUEST['mail'])) &#123; echo '已訂閱特賣情報電子報。';&#125; else &#123; echo '未訂閱特賣情報電子報。';&#125;?>&lt;?php require '../footer.php'; ?> # if if 判斷式是 PHP 中用於條件分歧的語法之一。 if(條件)&#123; 條件成立時進行的處理;&#125;以真偽值代入 if 判斷式 if(條件)&#123; 條件為 TRUE 時執行的處理;&#125;# if-else 在條件成立時與條件不成立時，分別執行對應的處理。 if(條件)&#123; 條件成立時進行的處理;&#125; else&#123; 條件不成立時進行的處理;&#125;以真偽值代入 if-else 判斷式 if(條件)&#123; 條件為 TRUE 時執行的處理;&#125; else&#123; 條件為 FALSE 時執行的處理;&#125;# isset 檢查變數是否宣告， NULL 是用來表示變數內為空值的特殊值。 若變數中已代入值且其值不為 NULL 時，則回傳 TRUE 。 isset(變數)在 if 判斷式中使用 REQUEST 參數 if(isset(REQUEST 參數中的變數))&#123; 變數已宣告時要執行的處理;&#125;在 if-else 判斷式中使用 REQUEST 參數 if(isset(REQUEST 參數中的變數))&#123; 變數已宣告時要執行的處理;&#125; else&#123; 變數未宣告時要執行的處理;&#125;# 條件運算式 在 if 判斷式和 if-else 判斷式的條件中，也可使用運算式。 常數 + 算符 (運算子) + 常數 在 if 判斷式的條件中使用運算式 if(運算式)&#123; 當運算結果條件為 TRUE 時執行的處理;&#125;在 if-else 判斷式的條件中使用運算式 if(運算式)&#123; 當運算結果條件為 TRUE 時執行的處理;&#125; else&#123; 當運算結果條件為 FALSE 時執行的處理;&#125;省略大括號 &#123;&#125; 當 if 判斷式的 &#123;&#125; 中只有 1 行程式時，可省略 &#123;&#125; 。 但若 &#123;&#125; 有多行程式，則不可省略。 if(運算式) 當運算結果條件為 TRUE 時執行的處理;if(運算式) 當運算結果條件為 TRUE 時執行的處理; else 當運算結果條件為 FALSE 時執行的處理; 單選紐 radio-input.php&lt;?php require '../header.php'; ?>請選擇餐點：&lt;form action=\"radio-output.php\" method=\"post\"> &lt;p>&lt;input type=\"radio\" name=\"meal\" value=\"日式套餐\" checked>日式套餐&lt;/p> &lt;p>&lt;input type=\"radio\" name=\"meal\" value=\"西式套餐\">西式套餐&lt;/p> &lt;p>&lt;input type=\"radio\" name=\"meal\" value=\"中式套餐\">中式套餐&lt;/p> &lt;p>&lt;input type=\"submit\" value=\"確定\">&lt;/p>&lt;/form>&lt;?php require '../footer.php'; ?> radio-output.php&lt;?php require '../header.php'; ?>&lt;?phpswitch ($_REQUEST['meal']) &#123;case '日式套餐': echo '烤魚、燉菜、味噌湯、白飯、水果'; break;case '西式套餐': echo '果汁、水波蛋、薯餅、麵包、咖啡'; break;case '中式套餐': echo '春捲、煎餃、蛋花湯、炒飯、杏仁豆腐'; break;&#125;echo '將稍候送達';?>&lt;?php require '../footer.php'; ?> # switch 依照不同的輸入訊息顯示出不同訊息的程式，是常見將程式流程分成多段，再依使用者所選內容執行對應的流程。 switch (運算式) &#123;case 值A: 運算結果為 A 時應執行的處理; break;case 值B: 運算結果為 B 時應執行的處理; break;case 值C: 運算結果為 C 時應執行的處理; break;...&#125; 在 case 敘述的最後必須寫上 break 敘述，用來表示處理程序結果，跳出 switch 判斷式的區塊。請記得加上 break 敘述。 下拉式選單 select-input.php&lt;?php require '../header.php'; ?>&lt;p>請選擇座位類型：&lt;/p>&lt;form action=\"select-output.php\" method=\"post\"> &lt;select name=\"seat\"> &lt;option value=\"自由席\">自由席&lt;/option> &lt;option value=\"指定席\">指定席&lt;/option> &lt;option value=\"商務車廂\">商務車廂&lt;/option> &lt;/select> &lt;p>&lt;input type=\"submit\" value=\"確定\">&lt;/p>&lt;/form>&lt;?php require '../footer.php'; ?> select-output.php&lt;?php require '../header.php'; ?>&lt;?phpswitch ($_REQUEST['seat']) &#123;case '指定席': echo '需加付120元補票。'; break;case '商務車廂': echo '需加付250元補票。'; break;default: echo '不需補票。'; break;&#125;?>&lt;?php require '../footer.php'; ?> # default 以上皆非可以使用 default 敘述撰寫。 switch (條件運算式) &#123;case 值A: 運算結果為 A 時應執行的處理; break;case 值B: 運算結果為 B 時應執行的處理; break;default: 運算結果與所有 case 的值都不符合時應執行的處理; break;...&#125; 下拉式選單 select-for-input.php&lt;?php require '../header.php'; ?>&lt;p>請選擇訂購數量：&lt;/p>&lt;form action=\"select-for-output.php\" method=\"post\"> &lt;select name=\"count\"> &lt;option value=\"0\">0&lt;/option> &lt;option value=\"1\">1&lt;/option> &lt;option value=\"2\">2&lt;/option> &lt;option value=\"3\">3&lt;/option> &lt;option value=\"4\">4&lt;/option> &lt;option value=\"5\">5&lt;/option> &lt;option value=\"6\">6&lt;/option> &lt;option value=\"7\">7&lt;/option> &lt;option value=\"8\">8&lt;/option> &lt;option value=\"9\">9&lt;/option> &lt;/select> &lt;p>&lt;input type=\"submit\" value=\"確定\">&lt;/p>&lt;/form>&lt;?php require '../footer.php'; ?>select-for-input2.php&lt;?php require '../header.php'; ?>&lt;p>請選擇訂購數量：&lt;/p>&lt;form action=\"select-for-output.php\" method=\"post\"> &lt;select name=\"count\"> &lt;?php for ($i=0; $i&lt;10; $i++) &#123; echo '&lt;option value=\"', $i, '\">', $i, '&lt;/option>'; &#125; ?> &lt;/select> &lt;p>&lt;input type=\"submit\" value=\"確定\">&lt;/p>&lt;/form>&lt;?php require '../footer.php'; ?> select-for-output.php&lt;?php require '../header.php'; ?>&lt;?phpecho $_REQUEST['count'], '個商品放入購物車。';?>&lt;?php require '../footer.php'; ?> # for 用來進行重複處理的語法之一。 for(開始處理; 條件式; 更新處理)&#123; 重複執行的處理;&#125;# 比較算符 演算子 讀法 判斷結果為 TRUE 的情況 &lt; 小於 左邊值小於右邊 &gt; 大於 左邊值大於右邊 &lt;= 小於等於 左邊值小於等於右邊 (左邊值在右邊以下) &gt;= 大於等於 左邊值大於等於右邊 (左邊值在右邊以上) == 相等 左右相等 != 不相等 (! 為否定之意) 左右不相等 # while 用來進行重複處理的語法之一。 while(條件式)&#123; 重複執行的處理;&#125; for 迴圈與他最大的差異，在於 while 迴圈沒有開始處理和更新處理。 開始處理while(條件式)&#123; 重複執行的處理; 更新處理&#125;# foreach foreach(陣列 as 變數)&#123; 使用變數進行的處理;&#125;foreach($question as $item)&#123; echo '&lt;option value=\"', $item, '\">', $item, '&lt;/option>';&#125;foreach(陣列 as 索引鍵的變數 => 值的變數)&#123; 以索引鍵與值進行的處理;&#125;foreach($store as $key => $value)&#123; echo '&lt;option value=\"', $value, '\">', $key, '&lt;/option>';&#125;# 使用函式 # 呼叫函式 函式(傳入參數)函式(傳入參數1, 傳入參數2, ...)# 設定時區 date_default_timezone_set(地區)# 顯示日期時間 date 函式執行時，會先取得現在的日期時間，再依指定的格式將它當做字串回傳。 date(格式) 文字 說明 Y 年。4 位數 m 月。2 位數，無十位數時自動補 0 d 日。2 位數，無十位數時自動補 0 H 小時。2 位數，無十位數時自動補 0。24 小時制 i 分。2 位數，無十位數時自動補 0 s 秒。2 位數，無十位數時自動補 0 # rand 函式 用來隨機產生一組數值，如果未傳入任何參數，則會回傳 0 以上，亂數最大值以下的亂數回來。 rand()亂數最大值會依執行環境不同而有差異，利用 gettrandmax 函式就能取得最大值。 gettrandmax()rand(最小值, 最大值)# preg_match 函式 利用常規表達式檢查資料格式。 preg_match(模板, 輸入字串)當傳入參數中指定的模板與輸入字串的格式相符，則 preg_match 函式會回傳「1」、「TRUE」; 若格式不符，則回傳「0」、「FALSE」。 preg_match('/^[0-9]&#123;7&#125;$/', $postcode) ^ : 句首 [0-9] :0 ~ 9 的數字 1 個 &#123;7&#125; : 符合前項格式的文字 7 個 $ : 句尾 - : 連字號 (?=.*[a-z]) : 包含小寫英文字母 (a ~ z) (?=.*[A-Z]) : 包含大寫英文字母 (A ~ Z) (?=.*[0-9]) : 包含數字 (0 ~ 9) [a-zA-Z0-9] : 小寫英文字母、大寫英文字母、數字各 1 個 &#123;8,&#125; : 符合前項格式的文字 8 個以上 首先是「.」與「*」，「.」代表任意 1 字；「*」則代表它前面的文字重複 0 次以上。 兩者合一的「.*」，表示任意文字重複 0 次以上。 8 個字母 (包含) 以上，包含至少一個大寫字母、一個小寫字母、一個數字，正則表達式的含義如下： $pattern = '/^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])[a-zA-Z\\d]&#123;8,&#125;$/'; ^ 匹配字符串的開始位置 (?=.*[0-9]) 至少包含一個數字 (?=.*[a-z]) 至少包含一個小寫字母 (?=.*[A-Z]) 至少包含一個大寫字母 [a-zA-Z0-9]&#123;8,&#125; 由大小寫字母和數字組成的字符串，長度至少為 8 個字符 $ 匹配字符串的結束位置 # 將半形轉換成全形 mb_convert_kana(字串, 類型代碼)mb_convert_kana($_REQUEST['name'], 'R') // R 的代碼就表示將半形轉換成全形 類型代碼 意義 r 全形英文字母轉換成半形 R 半形英文字母轉換成全形 n 全形數字轉換成半形 N 半形數字轉換成全形 a 全形英數字轉換成半形 A 半形英數字轉換成全形 s 全形空格轉換成半形 S 半形空格轉換成全形 檔案讀寫 board-input.php&lt;?php require '../header.php'; ?>&lt;p>請輸入留言內容。&lt;/p>&lt;form action=\"board-output.php\" method=\"post\"> &lt;input type=\"text\" name=\"message\"> &lt;input type=\"submit\" value=\"送出\">&lt;/form>&lt;?php require '../footer.php'; ?> board-output.php&lt;?php require '../header.php'; ?>&lt;?php$file='board.txt';if (file_exists($file)) &#123; $board=json_decode(file_get_contents($file));&#125;$board[]=$_REQUEST['message'];file_put_contents($file, json_encode($board));foreach ($board as $message) &#123; echo '&lt;p>', $message, '&lt;/p>&lt;hr>';&#125;?>&lt;?php require '../footer.php'; ?> # 檔案存取 從檔案讀出所有留言清單 將新留言加入留言清單 將所有留言寫入檔案 顯示留言一覽 要與留言內容儲存到檔案，必須使用 JSON 格式。JSON 為 JSON JavaScript Object Notation 的縮寫。 JSON 是緣自於程式語言 JavaScript 的標記方式，除了 JavaScript，亦被運用在多種不同的程式語言。 在 PHP 中使用 JSON 的優點是可輕易地從檔案讀取、寫入字串與陣列等資料結構。 # 讀取檔案 指定的檔案 (資料夾) 存在時，會回傳 TRUE；若檔案 (資料夾) 不存在則回傳 FALSE。 file_exists(檔案名稱)讀取檔案 file_get_contents(檔案名稱)由於讀取檔案是以 JSON 格式儲存，必須先轉換成 PHP 可用的格式，此時使用可以用來進行 JSON 編碼的 json_decode 函式。 json_decode(字串)$board=json_decode(file_get_contents($file))將陣列轉換成 JSON 格式 json_encode(值)寫入檔案 file_put_contents(檔案名稱, 字串) 若要新增檔案不存在，則會新增一個檔案。 檔案上傳 upload-input.php&lt;?php require '../header.php'; ?>&lt;p>請選擇要上傳的檔案。&lt;/p>&lt;form action=\"upload-output.php\" method=\"post\" enctype=\"multipart/form-data\"> &lt;p>&lt;input type=\"file\" name=\"file\">&lt;/p> &lt;p>&lt;input type=\"submit\" value=\"開始上傳\">&lt;/p>&lt;/form>&lt;?php require '../footer.php'; ?> upload-output.php&lt;?php require '../header.php'; ?>&lt;?phpif (is_uploaded_file($_FILES['file']['tmp_name'])) &#123; if (!file_exists('upload')) &#123; mkdir('upload'); &#125; $file='upload/'.basename($_FILES['file']['name']); if (move_uploaded_file($_FILES['file']['tmp_name'], $file)) &#123; echo $file, '上傳成功。'; echo '&lt;p>&lt;img src=\"', $file, '\">&lt;/p>'; &#125; else &#123; echo '上傳失敗。'; &#125;&#125; else &#123; echo '請選擇檔案。';&#125;?>&lt;?php require '../footer.php'; ?> # 取得暫存檔的檔名 $_FILES['檔案選擇按鈕的名稱']['tmp_name'] tmp_name : 取得暫存檔檔名 name : 取得原檔名 # 檢查是否是輸入畫面所上傳的檔案 is_uploaded_file(檔案名稱)# 建立資料夾 mkdir(資料夾名稱)# 只抽取出檔案名 basename(路徑)# 儲存暫存檔 將上傳後產生的暫存檔移動到儲存上傳檔的位置。 move_uploaded_file(暫存檔的檔名, 儲存用的檔名)# 時間戳 # 時間參數 參數 說明 範例 Y 年，四位元數字 “1999″ y 年，二位元數字 “99″ m 月份，若不足二位元則在前面補零 “01″ 至 “12″ n 月份 “1″ 至 “12″ F 月份，英文全名 “January&quot; M 月份，三個英文字母 “Jan&quot; d 幾日，若不足二位元則前面補零 “01″ 至 “31″ j 幾日，二位元數字 “1″ 至 “31″ S 字尾加英文序數，二個英文字母 “th&quot;，&quot;nd&quot; w 星期幾，數字型 “0″ (星期日) 至 “6″ (星期六) l 星期幾，英文全名 “Friday&quot; D 星期幾，三個英文字母 “Fri&quot; A 上下午 “AM&quot;或是 “PM&quot; a 上下午 “am&quot;或是 “pm&quot; h 12 小時制的小時，若不足二位元則前面補零 “01″ 至 “12″ g 12 小時制的小時 “1″ 至 12″ H 24 小時制的小時，若不足二位元則前面補零 “00″ 至 “23″ G 24 小時制的小時 “0″ 至 “23″ i 分鐘 “00″ 至 “59″ s 秒 “00″ 至 “59″ v 毫秒 (PHP 7.0.0 以後) “654″ u 微秒，000000 (PHP 5.2.2 以後，DateTime::format () 才支援) “654321″ z 一年中的第幾天 “0″ 至 “365″ W 一年中的第幾週 “42″ t 該月份的天數 “28″ 至 “31″ U 總秒數 (1970-01-01 00:00:00 開始計算) 可參考 time () 函數","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"program-language","slug":"computer-science/program-language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/"},{"name":"PHP","slug":"computer-science/program-language/PHP","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/PHP/"}],"tags":[]},{"title":"PHP infomation","slug":"computer-science/Program-Language/PHP/PHP-infomation","date":"2023-08-13T06:18:21.000Z","updated":"2023-08-14T14:03:51.401Z","comments":true,"path":"computer-science/Program-Language/PHP/PHP-infomation/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Program-Language/PHP/PHP-infomation/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # PHP 的用途概要 PHP 主要用於製作網頁應用程式 (Web Application) HTML 無法做到的依 Request 內容變化處理，但是 PHP 程式可以製作。 JavaScript 程式更擅長在瀏覽器上就能解決的處理。 程式語言與程式 網頁應用程式示意圖 透過瀏覽器與網站伺服器使用網頁應用程式 Request 與 Response 網頁應用程式需進行的處理 # 建立開發環境 安裝之後你的電腦就是伺服器，具備了開發網頁應用程式時必備的網站伺服器和資料庫管理系統等軟體。 裡用 XAMPP 可一次建構好網站伺服器與資料庫 XAMPP 所包含的軟體 Apache MariaDB (MySQL) PHP 套件 Perl 套件 可以支援 Windows、Linux、Mac OS X 等作業系統。 LAMP Linux Apache MySQL PHP / Perl / Python 除 XAMPP 之外，LAMP 也是常指開發環境，LAMP 原本常用來建置網站伺服器的軟體合稱。 # 下載 XAMPP XAMPP 官方網站 https://www.apachefriends.org/zh_tw/index.html XAMPP 下載網頁 https://www.apachefriends.org/zh_tw/download.html # 安裝 XAMPP 執行安裝檔 選擇要安裝的軟體 選擇安裝路徑 開始安裝 # 啟動 XAMPP 控制面板 XAMPP Control Panel # 啟動 Apache # 確認 Apache 是否啟動 利用瀏覽器開啟下列 URL，確認 Apache 是否正常啟動。 http://localhost/ http://localhost/dashboard/ # 執行 PHP 程式 在檔案總管中開啟 C 磁碟機中 xampp 資料夾下的 htdocs 資料夾，即路徑 C:\\xampp\\htdocs。 這個 htdocs 資料夾內就是用來放置 PHP 程式和 HTML 等檔案。 請務必記住 http://localhost 與 C:\\xampp\\htdocs\\ 的對應關係。 要執行 PHP 程式時，必須輸入程式的對應 URL。 # 顯示執行結果 # 沒有正常顯示？ Apache 沒有啟動 檔案存放的位置不正確","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"program-language","slug":"computer-science/program-language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/"},{"name":"PHP","slug":"computer-science/program-language/PHP","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/PHP/"}],"tags":[]},{"title":"What is API?","slug":"computer-science/Note/What-is-API","date":"2023-08-13T06:10:53.000Z","updated":"2023-08-14T13:26:10.377Z","comments":true,"path":"computer-science/Note/What-is-API/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Note/What-is-API/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # API 介紹: https://www.hububble.co/blog/api 引用文 https://aws.amazon.com/tw/what-is/api/ # 什麼是 API？ API 是使用一組定義和協定讓兩個軟體元件彼此通訊的機制。舉例來說，氣象局的軟體系統包含有每日的天氣資料。您手機中的天氣應用程式會透過 API 與此系統「交談」並且在您的手機顯示每日天氣的最新消息。 # API 代表什麼意思？ API 代表應用程式開發介面。在 API 的內容中，應用程式一詞指的是具有不同功能的任何軟體。可以將介面看作是兩個應用程式之間的服務合約。這份合約定義了兩者如何使用要求與回應彼此進行通訊。它們的 API 文件包含有關開發人員如何構建這些要求與回應的資訊。 # API 如何運作？ API 架構通常會藉由用戶端和伺服器來說明。傳送要求的應用程式稱為用戶端，傳送回應的應用程式則稱為伺服器。因此在天氣的例子當中，氣象局的天氣資料庫是伺服器，行動應用程式是用戶端。 API 有四種不同方式可以運作，具體取決於它們建立的時機以及原因為何。 SOAP API 這些 API 使用簡單物件存取協定 (Simple Object Access Protocol)。用戶端和伺服器使用 XML 交換訊息。這是過去較為常用，但是較不具有彈性的 API。 RPC API 這些 API 稱為遠端程序呼叫 (Remote Procedure Call)。用戶端在伺服器上完成功能 (或程序)，伺服器則將輸出傳回用戶端。 WebSocket API WebSocket API 是使用 JSON 物件傳遞資料的另一個現代 Web API 開發。WebSocket API 可支援用戶端應用程式以及伺服器之間的雙向通訊。伺服器可將回呼訊息傳送至連接的用戶端，使得它與 REST API 更有效率。 REST API 這是現今在 Web 上可以找到最常用以及最彈性的 API。用戶端傳送要求至伺服器作為資料。伺服器使用此用戶端輸入來啟動內部功能，並且將輸出資料傳回用戶端。讓我們在下面更詳細地看看 REST API。 # 什麼是 API 整合？ API 整合是會自動更新用戶端與伺服器之間資料的軟體元件。API 整合的一些例子是當自動資料從手機的圖片庫同步至雲端，或是當您前往其他時區時，時間與日期自動地在您的筆記型電腦上同步。企業可以使用它們有效地自動化許多系統功能。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Note","slug":"computer-science/Note","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Note/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Web/"}]},{"title":"Maven - create project","slug":"computer-science/Note/Maven-create-project","date":"2023-08-13T05:56:45.000Z","updated":"2023-08-13T06:54:38.054Z","comments":true,"path":"computer-science/Note/Maven-create-project/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Note/Maven-create-project/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # Maven download https://maven.apache.org/download.cgi # 環境變數設定 ![](https://i.imgur.com/AWZuYAJ.png =400x) # 確認有安裝好 Maven mvn -v mvn -version # Create Project Cmd mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false powershell 珍惜生命，學習 Java 請少用 PowerShell 當成你主要的 Shell 環境 mvn archetype:generate '-DgroupId=com.mycompany.app' -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart '-DarchetypeVersion=1.4' -DinteractiveMode=false Git Bash mvn archetype:generate \\ -DgroupId=com.mycompany.app -DartifactId=my-app \\ -DarchetypeArtifactId=maven-archetype-quickstart \\ -DarchetypeVersion=1.4 -DinteractiveMode=false \\ 換行只有 bash 以上皆無法 mvn archetype:generate 並選取以下功能 # Add exec-maven-plugin &lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!-- 其他 plugins ... --&gt; &lt;!--===== 加入這段 =====--&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;java&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;mainClass&gt;com.mycompany.app.App&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!--===== 加入這段 =====--&gt; &lt;!-- 其他 plugins ... --&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;jar.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;name&gt;my-app&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt;&lt;!--設定Goal的執行方式--&gt; &lt;goals&gt; &lt;goal&gt;java&lt;/goal&gt; &lt;!--要設定的goal--&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;mainClass&gt;jar.App&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; # 清除 target mvn clean # 產生執行檔 Compile: 通常只下這行就可以執行了 mvn compile Building: 會完整的建構整個專案，並把專案打包成.jar 檔，供別人下載執行。但會產出較多檔案，且耗費較多時間 mvn package # 執行 Execute mvn exec:java","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Note","slug":"computer-science/Note","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Note/"}],"tags":[]},{"title":"Java spring boot 串接資料庫","slug":"computer-science/Framework/Java-Spring-boot/Java-spring-boot-串接資料庫","date":"2023-07-10T06:09:52.000Z","updated":"2023-07-10T07:58:03.610Z","comments":true,"path":"computer-science/Framework/Java-Spring-boot/Java-spring-boot-串接資料庫/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Framework/Java-Spring-boot/Java-spring-boot-%E4%B8%B2%E6%8E%A5%E8%B3%87%E6%96%99%E5%BA%AB/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 資料庫串接檔案配置 檔案路徑: ruoyi-admin/src/main/resources/application.yml ruoyi-admin/src/main/resources/application-druid.yml # 資料庫搜尋 開始撰寫前，記得檢查資料庫配置文件是否修改正確！ # 信息操作處理 檔案路徑: ruoyi-admin/src/main/java/com.ruoyi/web/controller/system 創建檔案: ExerciseController ExerciseController.javapackage com.ruoyi.web.controller.system;import com.ruoyi.common.core.controller.BaseController;import com.ruoyi.system.domain.Exercise;import com.ruoyi.system.service.IExerciseService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;/** * 参数配置 信息操作处理 * * @author ruoyi */@RestController@RequestMapping(\"/system/exercise\")public class ExerciseController extends BaseController&#123; @Autowired private IExerciseService exerciseService; @GetMapping(\"/List\") public List&lt;Exercise> selectExerciseList()&#123; return exerciseService.selectExerciseList(); &#125;;&#125;# 參數配置表 檔案路徑: ruoyi-system/src/main/java/com.ruoyi.system/domain 創建檔案: Exercise.java Exercise.javapackage com.ruoyi.system.domain;import com.ruoyi.common.core.domain.BaseEntity;/** * 参数配置表 exercise * * @author ruoyi */public class Exercise extends BaseEntity&#123; private static final long serialVersionUID = 1L; private Integer id; private String exercise1; private String exercise2; private String exercise3; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getExercise1() &#123; return exercise1; &#125; public void setExercise1(String exercise1) &#123; this.exercise1 = exercise1; &#125; public String getExercise2() &#123; return exercise2; &#125; public void setExercise2(String exercise2) &#123; this.exercise2 = exercise2; &#125; public String getExercise3() &#123; return exercise3; &#125; public void setExercise3(String exercise3) &#123; this.exercise3 = exercise3; &#125;&#125;# 數據層 檔案路徑: ruoyi-system/src/main/java/com.ruoyi.system/mapper 創建檔案: ExerciseMapper.java ExerciseMapper.javapackage com.ruoyi.system.mapper;import com.ruoyi.system.domain.Exercise;import java.util.List;/** * 参数配置 数据层 * * @author ruoyi */public interface ExerciseMapper&#123; public List&lt;Exercise> selectExerciseList();&#125;# 服務層 檔案路徑: ruoyi-system/src/main/java/com.ruoyi.system/service/impl 創建檔案: ExerciseServiceImpl.java ExerciseServiceImpl.javapackage com.ruoyi.system.service.impl;import com.ruoyi.common.core.redis.RedisCache;import com.ruoyi.system.domain.Exercise;import com.ruoyi.system.mapper.ExerciseMapper;import com.ruoyi.system.service.IExerciseService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * 参数配置 服务层实现 * * @author ruoyi */@Servicepublic class ExerciseServiceImpl implements IExerciseService&#123; @Autowired private ExerciseMapper exerciseMapper; @Autowired private RedisCache redisCache; public List&lt;Exercise> selectExerciseList()&#123; return exerciseMapper.selectExerciseList(); &#125;;&#125; 檔案路徑: ruoyi-system/src/main/java/com.ruoyi.system/service 創建檔案: IExerciseService.java IExerciseService.javapackage com.ruoyi.system.service;import com.ruoyi.system.domain.Exercise;import java.util.List;/** * 参数配置 服务层 * * @author ruoyi */public interface IExerciseService&#123; public List&lt;Exercise> selectExerciseList();&#125;# SQL 內容 檔案路徑: ruoyi-system/src/main/resources/mapper.system 創建檔案: ExerciseMapper.xml ExerciseMapper.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">&lt;mapper namespace=\"com.ruoyi.system.mapper.ExerciseMapper\"> &lt;resultMap type=\"Exercise\" id=\"ExerciseResult\"> &lt;id property=\"id\" column=\"id\" /> &lt;result property=\"exercise1\" column=\"exercise_1\" /> &lt;result property=\"exercise2\" column=\"exercise_2\" /> &lt;result property=\"exercise3\" column=\"exercise_3\" /> &lt;/resultMap> &lt;sql id=\"selectExerciseVo\"> select * from exercise &lt;/sql> &lt;select id=\"selectExerciseList\" resultMap=\"ExerciseResult\"> &lt;include refid=\"selectExerciseVo\"/> &lt;/select>&lt;/mapper># 資料庫新增","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Framework","slug":"computer-science/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Framework/"},{"name":"Java Spring Boot","slug":"computer-science/Framework/Java-Spring-Boot","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Framework/Java-Spring-Boot/"}],"tags":[]},{"title":"Java spring boot 框架概念","slug":"computer-science/Framework/Java-Spring-boot/Java-spring-boot-框架概念","date":"2023-07-10T06:08:58.000Z","updated":"2023-07-10T07:38:43.743Z","comments":true,"path":"computer-science/Framework/Java-Spring-boot/Java-spring-boot-框架概念/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Framework/Java-Spring-boot/Java-spring-boot-%E6%A1%86%E6%9E%B6%E6%A6%82%E5%BF%B5/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 利用若依管理系統程式內容進行延伸撰寫，可以先 clone 若依管理系統的程式，方便跟上後面描述 (待附上連接) IDE: intellij API 測試工具: Postman (與 swagger 差異待比較) SQL Sever: MySQL/Xampp phpmyadmin # 檔案結構","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Framework","slug":"computer-science/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Framework/"},{"name":"Java Spring Boot","slug":"computer-science/Framework/Java-Spring-Boot","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Framework/Java-Spring-Boot/"}],"tags":[]},{"title":"111. Minimum Depth of Binary Tree","slug":"coding/leetcode/Easy/111-Minimum-Depth-of-Binary-Tree","date":"2023-07-10T01:36:40.000Z","updated":"2023-07-10T03:21:42.946Z","comments":true,"path":"coding/leetcode/Easy/111-Minimum-Depth-of-Binary-Tree/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/111-Minimum-Depth-of-Binary-Tree/","excerpt":"","text":"⭐️ # 題目敘述 Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. # Example 1 Input: root = [3,9,20,null,null,15,7] Output: 2 # Example 2 Input: root = [2,null,3,null,4,null,5,null,6] Output: 5 # 解題思路 # Solution DFS// Definition for a binary tree node.public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode() &#123;&#125; TreeNode(int val) &#123; this.val = val; &#125; TreeNode(int val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125;&#125;class Solution &#123; public int minDepth(TreeNode root) &#123; return dfs(root); &#125; private int dfs(TreeNode root)&#123; if(root == null) return 0; if(root.left == null &amp;&amp; root.right == null) return 1; if(root.left == null) return 1 + dfs(root.right); if(root.right == null) return 1 + dfs(root.left); return 1 + Math.min(dfs(root.left), dfs(root.right)); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Tree","slug":"Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Tree/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Tree/"}]},{"title":"2024. Maximize the Confusion of an Exam","slug":"coding/leetcode/Medium/2024-Maximize-the-Confusion-of-an-Exam","date":"2023-07-07T01:40:57.000Z","updated":"2023-07-07T06:45:10.432Z","comments":true,"path":"coding/leetcode/Medium/2024-Maximize-the-Confusion-of-an-Exam/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2024-Maximize-the-Confusion-of-an-Exam/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 A teacher is writing a test with n true/false questions, with 'T' denoting true and 'F' denoting false. He wants to confuse the students by maximizing the number of consecutive questions with the same answer (multiple trues or multiple falses in a row). You are given a string answerKey , where answerKey[i] is the original answer to the ith question. In addition, you are given an integer k , the maximum number of times you may perform the following operation: Change the answer key for any question to 'T' or 'F' (i.e., set answerKey[i] to 'T' or 'F' ). Return the maximum number of consecutive 'T' s or 'F' s in the answer key after performing the operation at most k times. # Example 1 Input: answerKey = &quot;TTFF&quot;, k = 2 Output: 4 Explanation: We can replace both the 'F's with 'T's to make answerKey = &quot;TTTT&quot;. There are four consecutive 'T's. # Example 2 Input: answerKey = &quot;TFFT&quot;, k = 1 Output: 3 Explanation: We can replace the first 'T' with an 'F' to make answerKey = &quot;FFFT&quot;. Alternatively, we can replace the second 'T' with an 'F' to make answerKey = &quot;TFFF&quot;. In both cases, there are three consecutive 'F's. # Example 3 Input: answerKey = &quot;TTFTTFTT&quot;, k = 1 Output: 5 Explanation: We can replace the first 'F' to make answerKey = &quot;TTTTTFTT&quot; Alternatively, we can replace the second 'F' to make answerKey = &quot;TTFTTTTT&quot;. In both cases, there are five consecutive 'T's. # 解題思路 # Solution import java.util.HashMap;import java.util.Map;class Solution &#123; public int maxConsecutiveAnswers(String answerKey, int k) &#123; int n = answerKey.length(); int left = k, right = n; while (left &lt; right) &#123; int mid = (left + right + 1) / 2; if (isValid(answerKey, mid, k)) &#123; left = mid; &#125; else &#123; right = mid - 1; &#125; &#125; return left; &#125; public boolean isValid(String answerKey, int size, int k) &#123; int n = answerKey.length(); Map&lt;Character, Integer> counter = new HashMap&lt;>(); for (int i = 0; i &lt; size; i++) &#123; char c = answerKey.charAt(i); counter.put(c, counter.getOrDefault(c, 0) + 1); &#125; if (Math.min(counter.getOrDefault('T', 0), counter.getOrDefault('F', 0)) &lt;= k) &#123; return true; &#125; for (int i = size; i &lt; n; i++) &#123; char c1 = answerKey.charAt(i); counter.put(c1, counter.getOrDefault(c1, 0) + 1); char c2 = answerKey.charAt(i - size); counter.put(c2, counter.getOrDefault(c2, 0) - 1); if (Math.min(counter.getOrDefault('T', 0), counter.getOrDefault('F', 0)) &lt;= k) &#123; return true; &#125; &#125; return false; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"1493. Longest Subarray of 1's After Deleting One Element","slug":"coding/leetcode/Medium/1493-Longest-Subarray-of-1-s-After-Deleting-One-Element","date":"2023-07-05T04:09:53.000Z","updated":"2023-07-06T01:25:54.769Z","comments":true,"path":"coding/leetcode/Medium/1493-Longest-Subarray-of-1-s-After-Deleting-One-Element/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1493-Longest-Subarray-of-1-s-After-Deleting-One-Element/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a binary array nums , you should delete one element from it. Return the size of the longest non-empty subarray containing only 1 's in the resulting array. Return 0 if there is no such subarray. # Example 1 Input: nums = [1,1,0,1] Output: 3 Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's. # Example 2 Input: nums = [0,1,1,1,0,1,1,0,1] Output: 5 Explanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1]. # Example 3 Input: nums = [1,1,1] Output: 2 Explanation: You must delete one element. # 解題思路 # Solution class Solution &#123; public int longestSubarray(int[] nums) &#123; int n = nums.length; int left = 0; int zeros = 0; int ans = 0; for (int right = 0; right &lt; n; right++) &#123; if (nums[right] == 0) &#123; zeros++; &#125; while (zeros > 1) &#123; if (nums[left] == 0) &#123; zeros--; &#125; left++; &#125; ans = Math.max(ans, right - left + 1 - zeros); &#125; return (ans == n) ? ans - 1 : ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"上海實習 GoGo","slug":"上海實習-GoGo","date":"2023-07-04T04:32:49.000Z","updated":"2023-08-13T05:26:56.149Z","comments":true,"path":"上海實習-GoGo/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/%E4%B8%8A%E6%B5%B7%E5%AF%A6%E7%BF%92-GoGo/","excerpt":"","text":"# 2023.07.02 (日) 行程 8:00 ~ 10:00 立榮航空飛機 台北松山 (TSA) - 上海浦東 (PVG) 12:00 ~ 13:00 前往如家酒店.neo (上海火車站店)/ 午餐 14:00 ~ 16:00 辦理電話卡 16:00 ~ 19:00 吃晚餐 # 紀錄 日記 第一天抵達上海，沒想到天氣還蠻熱的，今天還沒開始實習，下午由上海市科協的老師帶我們去申辦電話卡，因為我們人蠻多的，所以了一些時間，不過其實整個辦理的流程很快，接下來就是吃完餐了，但因為今天一大早就搭飛機，5:00 就到松山機場，前一天基本上也沒睡，所以我吃飯到後面的時候基本都在打嗑睡，吃的差不多的時候發現外面下大雷雨，本來想說等雨小一點再去搭地鐵，但是依舊很大，我們就分別叫車回去，不過下雨天的滴滴真的不好叫，最後我坐上海市科協老師的車回酒店的，回酒店一洗完澡直接開始睡覺，本來想做一些事情，但是完全抵擋不住睡意。 # 2023.07.03 (一) 行程 7:00 ~ 8:00 起床洗漱 8:00 ~ 8:30 地鐵 1 號線 + 528 公交 → 區塊鏈生態谷 8:40 抵達公司 上海计算机软件技术开发中心 - 大数据与区块链技术研究所 9:00 ~ 9:30 介紹一下公司環境 9:30 ~ 10:00 辦理手續 / 安排工位 10:00 ~ 11:20 需求分析培訓 / 撰寫功能清單 11:20 ~ 12:00 吃飯 12:00 ~ 13:30 跟胡晨路上海銀行辦理銀行卡 (沒有成功) 13:30 ~ 17:00 撰寫功能清單 17:00 ~ 17:30 下班 跟吳小麗掃碼自行車 + 地鐵 18:30 ~ 19:30 吃晚餐 # 紀錄 學習項目 今天主要做的事為需求分析培訓，講解了基本的需求分析流程，從概念、目標、非功能性的需求、產出進行闡述，並詳細說明功能性需求與非功能性需求兩個的差異，接著了解需求分析的項目實踐，包含項目介紹、需求分析過程 (需求調研、梳理功能、需求規格說明書)。 之前有就大致了解需求分析的相關概念，也實際參與過幾次專案的需求分析，所以在這方面我相對比較熟練，不過在這邊需求分析過程中的梳理功能，是我之前沒有嘗試過的，但我覺得這個方式蠻好的，利用功能清單可以更加明確、有條理的呈現所有需求，方便在撰寫需求規格說明書時，更加快速釐清所有功能性需求；在需求調研的部分是利用原型的方式進行，我藉由查閱原型完成功能清單。 日記 今天是正式實習的第一天，由於前一天實在太早睡了，我大概 6:30 左右就很有精神，本來以為是 9:00 上班想說不要壓線到，再加上我有點怕迷路，所以早早就出門，結果是 9:00 ~ 9:30 是上班時間，在 9:30 前到就好了，最後不小心太早到，整間公司基本上是暗的，第一次進公司默默地就跟一個人進去了，之後綜合辦來看到我超驚訝，想說我怎麼這麼早到，問我叫什麼名字時，拿了張紙讓我寫起來，但我只會寫繁體字，一下就被認出是台灣人。 接下來是我的指導老師來接我，他其實也蠻早到的，大家好像都叫他戴老師或戴所，學歷感覺蠻猛的，然後他就帶著我逛了一下公司，介紹了一下超宏偉的一樓，我覺得一樓感覺很高級，此外也稍微介紹了一下這邊的情況，說了許多人的名字，大概會有那些人會帶我，但實在是說太多人了，以至於我誰都沒記住哈哈哈，我記名字超爛，我記得小胡，這個稱呼，但我感覺我實在不是適合這樣叫他們，畢竟我應該是這裡最嫩的，啥都不會。 早上是由顧老師帶著我簡單的進行了需求分析的培訓，基本上 20 分鐘內就解決了，非常的快速，但其實這是我一整天的工作安排，所以我就開始做明天的，撰寫功能清單 (項目管理系統)，不過需求分析給的原型其實列的蠻清楚的，所以功能清單的文件其實寫得算很快，今天剩下最後一個小功能沒描述完，所以我把它帶回酒店寫一寫，順便把繁體字翻譯成簡體字。 中午的時候我與另一個大二實習生一起去吃飯，我們因為年紀一樣，所以聊起來比較多是校內課程，我們比較了一下課程名稱，基本每科名稱都不太一樣，後來我跟小胡一起去上海銀行辦卡，因為其實銀行下午一點才開始，所以我們就微微的聊一下天，感覺我們公司的人都蠻好的，微微聊了一下兩邊大學的內容，聊了一些偶像、遊戲跟動漫，感覺比想像中的還更加親切。 下班的時候因為公交車稍微遠了一點，所以由小麗老師帶我騎掃碼自行車，我一直覺得我腳踏車騎的應該還不錯，但是我騎上掃碼自行車後，我覺得它絕對是我今天最累的行程，那個龍頭超鬆的，手微微抖一下，方向就轉了，從後面看我一定在蛇行，真的很難控制，感覺整台車沒有摩擦力，我手把握的超緊的，回家收超酸。 # 2023.07.04 (二) 行程 8:00 ~ 8:30 起床洗漱 8:30 ~ 8:40 地鐵 1 號線 9:00 ~ 9:30 跟小劉一起坐北市上海園區公交 9:40 ~ 10:10 匯報昨天的功能清單 10:10 ~ 10:40 修改匯報時出現的問題 10:40 ~ 11:20 開始撰寫需求規格說明書 11:20 ~ 12:00 跟高悅一起吃自助餐 12:00 ~ 13:00 中午午休 / 寫 leetcode 13:00 ~ 17:00 勤奮工作 17:20 ~ 17:50 528 公交 + 地鐵 1 號線 18:40 ~ 19:30 買 + 吃晚餐 (東北千層餅 + 酸奶) 20:00 ~ 21:00 洗澡 + 休息 # 紀錄 學習項目 今天匯報了昨天完成的功能清單，第一次寫比較不確定，其實顧老師叫我說一下自己寫的內容的時候，我有點傻住了，還好我在報告上應該算是蠻擅長的，就開是報告了起來，但是因為只有我一個人報告，沒有比較的東西，所以我也不是很確定我這樣是不是還可以，不過老師沒有提出什麼問題，感覺應該還不錯，他建議我修改一些層級，把功能再區分成子功能，更方便釐清，確實這樣改我一下就更清楚所有功能。 因為功能清單原本是今天要完成的，就感覺下午在交就可以了，不過我昨天就用好，所以我一大早就先交出去了，因此接下來做的事情是三天的安排，撰寫需求規格說明書，包括項目概述、系統分析 (系統的初步調查)、產品概述 (營運可行性、技術可行性、開發的軟件可行性)、系統功能設計 (系統功能模塊圖、系統功能模塊詳細描述)、系統性能需求 (性能需求、系統兼容性和用戶體驗要求)，我今天先把項目的一些描述寫了一下，但由於我剛了解這個項目，所以寫起來還是比較卡的，不過老師說這份文件專注在寫功能設計及性能即可，因此我的項目概述就大致寫了一下我了解的項目內容。 日記 今天是第二天上班，跟小劉約一起座上海園區公交上班，準確來說是因為我不會搭，小劉帶著我搭，人也蠻好的，感覺很開朗，在車上我們稍微聊了一下上海可以遊玩的地方，他超認真的在介紹，但是我實在記不住這麼多，不過我有記住可以去陸家嘴騎自行車，感覺蠻不錯的。 今天座在工位上的時間比較多，一大早稍微拍了一下工位的樣子，發現我坐在研發部，感覺是個會禿頭的部門哈哈哈，今天早上先匯報了昨天完成的功能清單，就開始撰寫需求規格說明書，依舊還是撰寫文件，打字打到後面還是會很想睡覺，於是我戴上耳機，幫助自己提高專注力。 我午餐跟高悅一起去吃自助餐，感覺就跟陸劇場景一樣，不過我們是自己打飯菜，沒有手抖的食堂大媽，可惜的是我忘記拍照了，高悅是個很可愛的姊姊，非常的照顧我，基本上都會問我意見，只不過我對吃的真的就不是很在乎，所以我的回答就是都可以啊！感覺好爛，我下次努力有點想法，爭取不要讓大家尷尬。 下班回家的時候，因為小麗姐姐很忙，所以我是自己坐公交車回家的，我們的下班時間其實跟公交好像對不太上，所以都要等一陣子，回到飯店就稍微比較晚了，今天晚餐的時候，因為其他同學在他們上班的地方吃了，所以我是自己出去吃的，為了避免我支付寶不能用，所以我給樓下超商的阿姨 200 元，請他把錢轉到我的支付寶錢包裡，因為他好像比較常用微信支付，所已支付寶裡只有 200 元，所以我只能先存 200 了，不過應該可以撐幾天。 當然有支付寶了我就非常方便，可以自己吃飯，不用寄生於別人，結果第一次使用支付寶好像有蠻多優惠的，我的晚餐雖然計 11 元，但是因為支付寶優惠，最後其實不用錢，好爽，然後我再去買了很想喝的酸奶，想說上次來的時候幾乎天天喝，結果這次來就基本上找不到，找到也是常溫的，我覺得酸奶就是要冰的啊！ # 2023.07.05 (三) 行程 8:10 ~ 8:40 起床洗漱 8:45 ~ 8:55 地鐵 1 號線 9:00 ~ 9:30 坐北市上海園區公交 9:40 ~ 11:20 撰寫需求規格說明書 11:20 ~ 12:00 跟 4 位同事一起吃自助餐 12:00 ~ 13:00 中午午休 13:00 ~ 13:30 去上海銀行辦銀行卡 (成功) 13:30 ~ 14:30 匯報需求規格說明書 v1.0 14:30 ~ 17:00 修改匯報時遇到的問題 17:20 ~ 17:50 528 公交 + 地鐵 1 號線 18:40 ~ 20:30 叫外賣 (黃燜雞飯) + 吃 21:00 ~ 23:00 討論周末行程 23:00 ~ 23:30 洗澡 + 休息 # 紀錄 學習項目 今天早上把昨天的需求規格說明書整理一下後，畫了一些模組圖、流程圖，下午進行了匯報，雖然依舊無法進行比較，但顧老師提出了一些問題，包括詳細程度與文字排版的問題。 排版上因為我其實有一點找不到我 Word 的目錄修改在哪邊，所以這個我也當場問了一下，後來發現其實蠻好找的，老師也說了不用全部一個功能的描述全部寫一起，還是可以分段的，確實分段後更好閱讀，更容易專注於某個描述。 至於詳細程度了話，因為我之前基本就是把功能清單的說明加入到功能的說明中，當時寫得雖然已經蠻詳細的，不過確實有描述可以更清楚以及完整，我也近一步完善了這部分。 日記 今天是第三天上班，工作依舊是整理需求，撰寫需求規格說明書，但生活上還是有一些變化的，今天是我獨自搭北市園區的公交車，算是正式獨立上班了，午餐跟坐我附近的一些實習生一起吃，這次都是男生，討論了一些很有趣的事情，話題包括學校、結婚跟台灣是用什麼錢，他們還說我的位置很難摸魚，有一個男生說他原本坐我這，但因為太難摸魚了所以換了...，不考慮換回來嗎？其實我有發現，因為我的位置簡直就是交通樞紐，裝水、電梯、廁所全都要經過我，我真的會謝哈哈哈，不過我還是會聽歌來輔助我打字，不然真的好想睡。 中午回來我就跟小胡去上海銀行辦銀行卡，這次有實習證明相對就比較順利，但是還是卡了一下子，不過往好處想我至少辦成功了，在台灣的中國信託銀行都沒辦成功，在這辦成功了，而且就算因為我是台灣人比較麻煩，但是流程還是比中國信託銀行快了至少半天，我覺得中國信託銀行要檢討檢討，真的是做蠻爛的，一個上午只開了四個戶頭... 做事效率堪憂，重點我等了這麼久不給辦，好啦～～這是題外話，我就像嘴一下台灣的中國信託銀行，我只能說他是我前進的動力，我一定要搞垮中國信託銀行，之後我成功了有一半一定要感謝那些曾經看不起我的人。 然後辦完確認一下銀行卡可以用，我跟小胡回公司了，我們確認可以用的方法讓我覺得小胡真的是太好了，之前的飲料錢，我有支付寶後他也不跟我收，為了測試我的銀行可不可以轉錢，他直接轉了錢給我，我跟他說我在還給他，結果他不要，真的是讓我很手足無措啊！因為支付寶一定要對方同意顯示支付條碼才可以，不可以像台灣一樣阿嬤式塞錢法，還有前一天小麗姐姐用支付寶幫我用掃碼自行車，他也說不用沒關係，天啊！我真的是有被驚訝到。 晚餐因為有了銀行卡，所以我就試試看點了外賣，第一次用也太爽了，超多優惠，不過不確定是不是因為第一次用啦！有很多現金折抵的優惠，我的晚餐一下子變得很多有不太貴，甚至我吃不完。 # 2023.07.06 (四) 行程 8:20 ~ 8:40 起床洗漱 8:45 ~ 8:55 地鐵 1 號線 9:00 ~ 9:30 坐北市上海園區公交 9:40 ~ 11:20 撰寫需求規格說明書 11:20 ~ 12:00 跟 5 位同事一起吃自助餐 12:00 ~ 13:00 中午午休 / 打羽球、乒乓球 13:30 ~ 14:00 撰寫需求規格說明書 14:00 ~ 15:00 戴老師帶著我們了解公司的項目 16:30 ~ 17:15 最終匯報需求階段文件 17:20 ~ 18:00 走路 + 地鐵 1 號線 18:40 ~ 21:30 叫 + 吃外賣 (小龍蝦 + 喜茶) 21:30 ~ 00:00 休息 00:00 ~ 00:50 洗澡 # 紀錄 學習項目 今天繼續把昨天的需求規格說明書完善，從 14 頁直接暴增到 31 頁啊！兩倍啊啊啊啊！好多，總共 1 萬 4 千多字，還好我是用繁體打字，不然我大概要打一個禮拜吧，完全不會拼音的人，我直接用爛翻譯，繁體轉簡體，還被關注了一下我在做什麼，我快笑死。 因為我有一點超前進度了，所以我在今天向我的實習指導老師匯報了這週的工作內容，也是蠻突然的，完全沒有準備啊！不過整理狀況還是蠻好的，老師說整體做的還是蠻細緻的，指導我坐需求規格說明書的老師說，整體效率很快，交代的事情一下子就解決了，還不錯，不過到今天為止都還在我很熟練的部分，所以暫時都沒甚麼問題，只不過有一些方式我們用的不太一樣，但都很不錯值得使用。 日記 今天就是一個忙碌的一天，由於我前幾天就將需求規格說明書寫得差不多了，今天剩下排版、字型和繁體字轉簡體字等，簡單來說就是過了一下整份文件，然後就突然超多事，我的實習導師帶我去了解公司，之後他去見了一下客戶，我就開啟了匯報工作，真的是挺突然的。 晚上叫了我們小龍蝦，體驗了一下電視劇上面看起來很好吃的東西，確實真的蠻不錯的，不過感覺可以再吃辣一點，我們點十三香，下次可以試試其他口味，我們還叫了喜茶喝，真的不錯喝哈哈哈，什麼廢話，我是點芝芝玫影，下次想喝鴨喜香檸打茶。 # 2023.07.07 (五) 行程 8:20 ~ 8:40 起床洗漱 8:45 ~ 8:55 地鐵 1 號線 9:00 ~ 9:30 坐北市上海園區公交 9:40 ~ 11:20 上班？ 11:20 ~ 12:45 叫 + 吃外送酸菜魚 13:30 ~ 14:00 上班？ 15:30 ~ 16:00 聽了一下 spring boot 框架 16:00 ~ 17:00 上班？ 17:20 ~ 18:00 公交車 + 地鐵 1 號線 18:00 ~ 19:00 吃澆油麵 20:30 ~ 01:00 酒吧喝酒 01:20 ~ 01:25 參觀夜店... 哈哈哈 02:00 ~ 03:00 洗澡 # 紀錄 學習項目 今天簡單的了解了一下 java spring boot 框架，但由於大家今天有很多會議，上科院的領導也來了，好像還有客戶，所以大家其實今天沒什麼時間管我，所以我今天確實沒有很忙。 日記 今天撇除掉工作，我們下班還是很瘋的，一群人大概 10 個左右去了酒吧喝酒，因為坐卡座，低消 3000，貴到爛，但我們大概 8 點多，一路喝到 1 點左右，裡面有個小姐姐唱歌唱很多台灣歌手的歌，結果小萬 (我們這群的其中一位) 超級嗨，我快笑死，他還一直說我都不嗨，沒有喝很多，但其實我也喝了 6 ~ 7 杯左右了，第一次喝這麼多威士忌，聞起來真的很苦，我的小祕訣是喝酒前喝酸奶，感覺完全沒有醉的感覺，如果不想喝醉可以學學，但是隔天肚子超痛哈哈哈。 然後我們上廁所的時候認識了一個貴州的小姊姊，來上海讀大學跟實習，帶著一個約他一起出來玩的高學歷帥哥，結果我們最後拼在一起玩，我個人表示好扯，喝酒喝到拐走別人的小姐姐，最後連帥哥都一起了，後來我們還有去夜店玩，但是我真的是受不了煙味，那裏簡直煙霧瀰漫，所以我就進去了一下就出來了，感覺差點窒息在夜店裡，好可怕，聽說夜店這樣很正常，再也不去了嗚嗚嗚，出來手還好養。","categories":[],"tags":[]},{"title":"137. Single Number II","slug":"coding/leetcode/Medium/137-Single-Number-II","date":"2023-07-04T02:26:24.000Z","updated":"2023-07-04T04:50:02.007Z","comments":true,"path":"coding/leetcode/Medium/137-Single-Number-II/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/137-Single-Number-II/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it. You must implement a solution with a linear runtime complexity and use only constant extra space. # Example 1 Input: nums = [2,2,3,2] Output: 3 # Example 2 Input: nums = [0,1,0,1,0,1,99] Output: 99 # 解題思路 # Solution class Solution &#123; public int singleNumber(int[] nums) &#123; int once = 0, twice = 0; for(int num : nums)&#123; once = (num ^ once) &amp; (~twice); twice = (num ^ twice) &amp; (~once); &#125; return once; &#125;&#125; import java.util.HashMap;import java.util.Map;class Solution &#123; public int singleNumber(int[] nums) &#123; Map&lt;Integer, Integer> mp = new HashMap&lt;>(); for(int i = 0; i &lt; nums.length; i++)&#123; mp.put(nums[i], mp.getOrDefault(nums[i], 0) + 1); if(mp.get(nums[i]) == 3)&#123; mp.remove(nums[i]); &#125; &#125; int ans = 0; for(int m : mp.keySet())&#123; ans = m; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bit-Manipulation/"}]},{"title":"859. Buddy Strings","slug":"coding/leetcode/Easy/859-Buddy-Strings","date":"2023-07-03T14:43:19.000Z","updated":"2023-07-03T16:25:00.140Z","comments":true,"path":"coding/leetcode/Easy/859-Buddy-Strings/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/859-Buddy-Strings/","excerpt":"","text":"⭐️ # 題目敘述 Given two strings s and goal , return true if you can swap two letters in s so the result is equal to goal , otherwise, return false . Swapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j] . For example, swapping at indices 0 and 2 in &quot;abcd&quot; results in &quot;cbad&quot; . # Example 1 Input: s = &quot;ab&quot;, goal = &quot;ba&quot; Output: true Explanation: You can swap s[0] = 'a' and s[1] = 'b' to get &quot;ba&quot;, which is equal to goal. # Example 2 Input: s = &quot;ab&quot;, goal = &quot;ab&quot; Output: false Explanation: The only letters you can swap are s[0] = 'a' and s[1] = 'b', which results in &quot;ba&quot; != goal. # Example 3 Input: s = &quot;aa&quot;, goal = &quot;aa&quot; Output: true Explanation: You can swap s[0] = 'a' and s[1] = 'a' to get &quot;aa&quot;, which is equal to goal. # 解題思路 # Solution import java.util.HashSet;import java.util.Set;class Solution &#123; public boolean buddyStrings(String s, String goal) &#123; int n = s.length(); if (s.equals(goal)) &#123; Set&lt;Character> temp = new HashSet&lt;>(); for (char c : s.toCharArray()) &#123; temp.add(c); &#125; return temp.size() &lt; goal.length(); // Swapping same characters &#125; // two string equal int i = 0; int j = n - 1; while (i &lt; j &amp;&amp; s.charAt(i) == goal.charAt(i)) &#123; i++; &#125; while (j >= 0 &amp;&amp; s.charAt(j) == goal.charAt(j)) &#123; j--; &#125; if (i &lt; j) &#123; char[] clone = s.toCharArray(); char temp = clone[i]; clone[i] = clone[j]; clone[j] = temp; s = new String(clone); &#125; // Find two letter to swap, when two letter on deference string in same index isn't equal return s.equals(goal); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"Vue 指令","slug":"computer-science/Framework/Vue/Vue-指令","date":"2023-06-29T17:45:03.000Z","updated":"2023-06-30T16:56:45.237Z","comments":true,"path":"computer-science/Framework/Vue/Vue-指令/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Framework/Vue/Vue-%E6%8C%87%E4%BB%A4/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # Text Interpolation Using the &quot;Mustache&quot; syntax (double curly braces 兩個大括號 &#123;&#123; &#125;&#125; ) &lt;p> &#123;&#123; value &#125;&#125; &lt;/p>But Mustaches cannot be used inside HTML attributes. # v-bind 用法 &lt;div v-bind:[attribute]=\"[Vue data]\">&lt;/div># v-if 、 v-else-if 、 v-else 用法 &lt;p v-if=\"score >= 80\">Perfect&lt;/p>&lt;p v-else-if=\"scroe > 60\">Good&lt;/p>&lt;p v-else>Poor&lt;/p> A condition, or &quot;if-statement&quot;, is something that is either true or false . A condition is often a comparison check between two values like in the example above to see if one value is greater than the other. We use comparison operators like &lt; , &gt;= or !== to do such checks. Comparison checks can also be combined with logical operators such as &amp;&amp; or || . &lt;script>export default &#123; data() &#123; return &#123; text: 'I like taco, pizza, Thai beef salad, pho soup and tagine.' &#125; &#125;&#125;&lt;/script>&lt;template> &lt;p v-if=\"text.includes('pizza')\">The text includes the word 'pizza'&lt;/p> &lt;p v-else>The word 'pizza' is not found in the text&lt;/p>&lt;/template># v-show 當條件為 false 時，該指令通過將 CSS display 屬性值設置為 none 來隱藏元素。 &lt;script>export default &#123; data() &#123; return &#123; showDiv: true &#125; &#125;&#125;&lt;/script>&lt;template> &lt;div v-show=\"showDiv\">This div tag can be hidden&lt;/div>&lt;/template># 參考 / 學習文章 官方文件 w3school 維基百科 MDN web docs Vue.js 30 天隨身包系列","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Framework","slug":"computer-science/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Framework/"},{"name":"Vue","slug":"computer-science/Framework/Vue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Framework/Vue/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}]},{"title":"Vue 基本介紹","slug":"computer-science/Framework/Vue/Vue-基本介紹","date":"2023-06-29T12:51:20.000Z","updated":"2023-06-30T16:43:20.348Z","comments":true,"path":"computer-science/Framework/Vue/Vue-基本介紹/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Framework/Vue/Vue-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 專案結構 tree /f > structure.txt有整理過的 structure.txtvue-project│ .gitignore│ env.d.ts│ index.html│ output.txt│ package-lock.json│ package.json│ README.md│ tsconfig.app.json│ tsconfig.json│ tsconfig.node.json│ vite.config.ts│ ├─.vscode│ extensions.json│ ├─public│ favicon.ico│ └─src │ App.vue │ main.ts │ ├─assets │ base.css │ logo.svg │ main.css │ └─components │ HelloWorld.vue │ └─icons IconCommunity.vue public ：這個資料夾包含了所有發布的靜態檔案，這些檔案在建置過程不會經過 Webpack 加工。（但是有一個例外： index.html 會有一些處理）。 favicon.ico ：這是應用程式的 favicon。目前是 Vue 的標誌。 index.html ：這是應用程式的模板。你的 Vue 應用程式會透過這個 HTML 頁面來運行，你也可以使用 lodash 樣板語言在這個頁面穿插一些值。 src ：這個資料夾是 Vue 專案的核心。 main.js ：這是應用程式的進入點。目前，這個檔案會初始化你的 Vue 應用程式並定義要將應用掛載到 index.html 檔案中的哪個 HTML 元素。通常還會在這個檔案註冊全域性元件或載入其他 Vue 函式庫。 App.vue ：這是 Vue 應用程式的根節點元件。往下看可以了解更多關於 Vue 元件的說明。 components ：你可以把你的元件放在這個資料夾。目前它只有放一個範例元件。 assets ：這個資料夾是用來放一些靜態檔案像是 CSS 和圖片。因為這些檔案在來源目錄下，它們可以透過 Webpack 加工處理。這表示你可以使用一些預處理器，像是 Sass / SCSS 或是 Stylus 。 # Web 元件化系統 Vue.js 嚮往的就是先建立好根實體 (Vue Instance)，再開發好底下每個小元件 (Components)，慢慢往上組合成一個完整頁面，最後全部搭建起來成為一個完整專案。 通常一個元件包含 html、css、js，而 Vue 會將其全部寫在一個 .vue 為副檔名的檔案當中，vue-loader 會編譯這個 .vue 的檔案，將結果顯示出來。 # Vue Instance 根實體 (Vue Instance) 是樹狀結構中最上面的那個點。 每個 Vue App 都是從創建一個 vue instance 開始，Vue Instance 是透過 Vue Constructor (建構式) 所產生。 在實體化時，可傳入一個選項物件 (Options)，此物件包含這個 vue instance 需要用到的屬性，像是掛載點 (el)、資料 (data)、方法 (methods)、模板 (template)、** 生命週期鉤子 (hooks)** 等等。 var vm = new Vue (&#123; // options&#125;) # .vue 檔案（單一檔案元件） Vue 讓你把模板、相關指令碼和 CSS 整合在一起放在以 .vue 結尾的檔案裡。這些檔案會被 JS 的打包工具（像是 Webpack ）加以處理，這也代表你可以在你的專案裡使用一些建置工具，像是 Babel 、 TypeScript 、 SCSS 等工具來創造更複雜的元件。 # App.vue 在創建專案時，你可以在 src 資料夾中，看到第一個 .vue 檔案。 由三個部分組成： &lt;template&gt; 、 &lt;script&gt; 以及 &lt;style&gt; ，分別包含了元件的模板、指令碼和樣式資訊。 所有的單一檔案元件都是使用這種基本架構。 App.vue&lt;script setup lang=\"ts\"> &#123;/* javascript */&#125;import HelloWorld from './components/HelloWorld.vue'import TheWelcome from './components/TheWelcome.vue'&lt;/script>&lt;template> &#123;/* html */&#125; &lt;header> &lt;img alt=\"Vue logo\" class=\"logo\" src=\"./assets/logo.svg\" width=\"125\" height=\"125\" /> &lt;div class=\"wrapper\"> &lt;HelloWorld msg=\"You did it!\" /> &lt;/div> &lt;/header> &lt;main> &lt;TheWelcome /> &lt;/main>&lt;/template>&lt;style scoped> &#123;/* css */&#125;header &#123; line-height: 1.5;&#125;.logo &#123; display: block; margin: 0 auto 2rem;&#125;&lt;/style> &lt;template&gt; 元件的模板: 包含所有的標記結構以及元件的呈現邏輯。 模板可以包含任何有效的 HTML，以及一些 Vue 特定的語法。 在 &lt;template&gt; 標籤上設定 lang 屬性。例如設置 &lt;template lang=&quot;pug&quot;&gt; ，你就可以使用 Pug 樣板語法來取代標準的 HTML 。在本教學中我們會使用標準 HTML ，但還是值得知道有這個方法。 &lt;script&gt; 指令碼: 包含元件中所有非顯示的邏輯。最重要的是， &lt;script&gt; 標籤必須輸出一個 JS 物件。 這個物件是在本地端註冊的元件，包含定義屬性、處理本地狀態、定義方法等等。 如果想要使用 TypeScript 語法，必須把 &lt;script&gt; 標籤的 lang 屬性設定成 &lt;script lang=&quot;ts&quot;&gt; 來告訴編譯器你要使用 TypeScript 。 &lt;style&gt; 樣式: 是撰寫元件的 CSS 的地方。 如果加上 scoped 屬性，例如 &lt;style scoped&gt; ， Vue 會把樣式的範圍限制在這個單一檔案元件裡。這類似 CSS-in-JS 的解決方案，但是它允許你寫單純的 CSS 。 如果在使用 CLI 創建專案時有選擇 CSS 預處理器，就可以在 &lt;style&gt; 標籤上添加 lang 屬性，這些內容在建置的時候將會被 Webpack 處理。舉例來說， &lt;style lang=&quot;scss&quot;&gt; 允許在樣式資訊中使用 SCSS 語法。 # Lifecycle Hooks 這 8 個 hook 的資料型態皆為 function: beforeCreate 在初始化 vue instance 並開啟整個 Lifecycle 後，資料綁定與事件配置之前。 目前階段還無法調用 $data 。 應用場景：loading 進頁面的事件 created vue instance 創建完成 $data 已可以取得，屬性與事件也已綁定好。 目前階段尚未掛載 el ，DOM 也尚未生成。 beforeMount 在掛載 el 開始之前。 目前階段是相關 render 函式首次被調用，尚未被 DOM 給綁定。 mounted el 被剛創建好的 vm.$el 替換取代，並且掛載到 vm 上。 目前階段已被 DOM 綁定。 應用場景：對後端發出請求或讀取新資料 beforeUpdate 在資料更新時調用，Virtual DOM 重新 render 與 patch 之前，可以在這個階段變更資料狀態。 目前階段還不會繪製 view。 updated 資料更新後會使 Virtual DOM 重新 render 頁面。 目前階段會繪製出正確的 view。 beforeDestroy 在 vue instance 被銷毀前調用。 目前階段還可以完全使用這個 vue instance。 destroyed vue instance 銷毀後可以調用 調用後這個 vue instance 底下的資料與樣板會解除綁定，事件會取消監聽，所有子元件也會被銷毀。 # Example var vm = new Vue(&#123; data: &#123; name: 'Eva', &#125;, beforeCreate: function() &#123; //vue instance 尚未創建完成，還不能讀取到資料 console.log('beforeCreate: My name is ' + this.name); &#125;, created: function() &#123; //vue instance 創建完成，資料已綁定 console.log('created: My name is ' + this.name); &#125;, beforeMount: function() &#123; // 尚未掛載 el 與綁定 DOM console.log('beforeMount: My name is ' + this.name); &#125;, mounted: function() &#123; // 綁定 DOM 之後 console.log('mounted: My name is ' + this.name); &#125;, beforeUpdate: function() &#123; // 資料更新時調用，尚未更新 DOM console.log('beforeUpdate: My name is ' + this.name); &#125;, updated: function() &#123; // 因為資料更新而更新 DOM console.log('updated: My name is ' + this.name); &#125;, beforeDestroy: function() &#123; // 銷毀整個 vue instance 之前 console.log('beforeDestroy'); &#125;, destroyed: function() &#123; // 銷毀整個 vue instance 之後 console.log('destroyed'); &#125;,&#125;);# 第一階段：beforeCreate /created 在綁定 el 之前，beforeCreate 階段還不能讀取資料 # 第二階段：beforeMount /mounted 加入 el 屬性在物件裡 # 第三階段：beforeUpdate /updated 因為要變更資料才會觸發這兩個 function，這邊我們使用強制變更資料 # 第四階段：beforeDestroy /destroyed 因為上面第三階段強制變更資料的方法會導致一直執行更新資料，所以先將剛剛新增的 vm.$beforeUpdate(); 刪掉，加入 destroy 的方法 # 參考 / 學習文章 官方文件 w3school 維基百科 MDN web docs Vue.js 30 天隨身包系列","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Framework","slug":"computer-science/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Framework/"},{"name":"Vue","slug":"computer-science/Framework/Vue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Framework/Vue/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}]},{"title":"創建 Vue.js Project","slug":"computer-science/Framework/Vue/創建-Vue-js-Project","date":"2023-06-28T18:06:32.000Z","updated":"2023-06-30T16:43:12.271Z","comments":true,"path":"computer-science/Framework/Vue/創建-Vue-js-Project/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Framework/Vue/%E5%89%B5%E5%BB%BA-Vue-js-Project/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 創建的項目將使用基於 Vite 的構建設置，並允許我們使用 Vue 的單文件組件 (SFC)。 請先確認是否安裝 Node.js，可運用以下指令測試 node -v 。 # 創建 Vue Project npm vue 版本 npm init vue@latest# 設定 Vue Project # 運行 Vue Project 在第一次創建或是更新 package 內容時，記得要輸入 npm install ，安裝內容所需。 npm run dev終端機會出現類似以下的訊息: > vue-project@0.0.0 dev> vite VITE v4.3.9 ready in 801 ms ➜ Local: http://localhost:5173/ ➜ Network: use --host to expose ➜ press h to show help 可以在瀏覽器輸入 http://localhost:5173/ 來查看專案樣式 # 建構 Vue Project npm run build 此命令會在 ./dist 文件夾中為你的應用創建一個生產環境的構建版本。 # 參考 / 學習文章 官方文件 w3school 維基百科 MDN web docs Vue.js 30 天隨身包系列","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Framework","slug":"computer-science/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Framework/"},{"name":"Vue","slug":"computer-science/Framework/Vue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Framework/Vue/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}]},{"title":"什麼是Vue?","slug":"computer-science/Framework/Vue/什麼是Vue","date":"2023-06-28T06:57:21.000Z","updated":"2023-06-29T17:53:24.947Z","comments":true,"path":"computer-science/Framework/Vue/什麼是Vue/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Framework/Vue/%E4%BB%80%E9%BA%BC%E6%98%AFVue/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 先備知識 HTML CSS JavaScript # What is Vue? Evan You 是一名使用 AngularJS 的 Google 員工，於 2013 年開始開發 Vue。 Vue 1.0 版本於 2015 年發布。 Vue（發音為 /vjuː/，如 view）是一個用於構建用戶界面的 JavaScript 框架。 與 Vue 類似的框架有 React 和 Angular，但 Vue 更輕量級，更容易上手。 構建在標準 HTML、CSS 和 JavaScript 之上，提供聲明性和基於組件的程式模型，幫助您高效地開發用戶界面，無論是簡單的還是複雜的。 它提供了很多有用的功能來達到漸進增強（ progressive enhancement ）的策略。 與其他的框架不同的是，你可以把 Vue 和既有的 HTML 做整合，這讓你可以像使用插入性替換的函式庫一樣來使用 Vue。 # 優勢 簡單易用。 能夠處理簡單和復雜的項目。 其日益普及和開源社區的支持。 在普通 JavaScript 中，我們需要編寫 HTML 和 JavaScript 如何連接，但在 Vue 中，我們只需要確保存在連接，然後讓 Vue 處理其餘的事情。 通過基於模板的語法、雙向數據綁定和集中狀態管理實現更高效的開發過程。 Vue 所關注的核心是 MVC 模式中的視圖層，同時，它也能方便地取得資料更新，並通過組件內部特定的方法實現視圖與模型的互動。 # 特性 組件 (Components) 為了更好地管理一個大型的應用程式，往往需要將應用切割為小而獨立、具有復用性的組件。 在 Vue 中，組件是基礎 HTML 元素的拓展，可方便地自訂其資料與行為。 模板 (Templates) 回應式設計 (Reactivity) 回應式是指 MVC 模型中的視圖隨著模型變化而變化。 在 Vue 中，開發者只需將視圖與對應的模型進行繫結，Vue 便能自動觀測模型的變動，並重繪視圖。 這一特性使得 Vue 的狀態管理變得相當簡單直觀。 過渡效果 (Transitions) 單檔案組件 (SFC) 為了更好地適應複雜的專案，Vue 支援以 .vue 為副檔名的檔案來定義一個完整組件，用以替代使用 Vue.component 註冊組件的方式。 # Chose which API? 在 Vue 中編寫代碼有兩種不同的方式：The Options API 和 The Composition API。 基本概念是相同的，因此在學習其中一個 API 後，可以輕鬆切換到另一個。 建議可以先學習 The Options API，相對比較好上手。 # 選項式 API (Options API) 使用選項式 API，我們可以用包含多個選項的對象來描述組件的邏輯，例如 data 、 methods 和 mounted 。選項所定義的屬性都會暴露在函數內部的 this 上，它會指向當前的組件實例。 Vue (Options API)&lt;script>export default &#123; //data () 返回的属性将会成为响应式的状态 // 并且暴露在 `this` 上 data() &#123; return &#123; count: 0 &#125; &#125;, //methods 是一些用来更改状态与触发更新的函数 // 它们可以在模板中作为事件处理器绑定 methods: &#123; increment() &#123; this.count++ &#125; &#125;, // 生命周期钩子会在组件生命周期的各个不同阶段被调用 // 例如这个函数就会在组件挂载完成后被调用 mounted() &#123; console.log(`The initial count is $&#123;this.count&#125;.`) &#125;&#125;&lt;/script>&lt;template> &lt;button @click=\"increment\">Count is: &lt;!--swig￼1-->&lt;/button>&lt;/template># 組合式 API (Composition API) 通過組合式 API，我們可以使用導入的 API 函數來描述組件邏輯。在單文件組件中，組合式 API 通常會與 &lt;script setup&gt; 搭配使用。這個 setup attribute 是一個標識，告訴 Vue 需要在編譯時進行一些處理，讓我們可以更簡潔地使用組合式 API。比如， &lt;script setup&gt; 中的導入和頂層變量 / 函數都能夠在模板中直接使用。 下面是使用了組合式 API 與 &lt;script setup&gt; 改造後和上面的模板完全一樣的組件： Vue (Composition API)&lt;script setup>import &#123; ref, onMounted &#125; from 'vue'// 响应式状态const count = ref(0)// 用来修改状态、触发更新的函数function increment() &#123; count.value++&#125;// 生命周期钩子onMounted(() => &#123; console.log(`The initial count is $&#123;count.value&#125;.`)&#125;)&lt;/script>&lt;template> &lt;button @click=\"increment\">Count is: &lt;!--swig￼2-->&lt;/button>&lt;/template># 參考 / 學習文章 官方文件 w3school 維基百科 MDN web docs Vue.js 30 天隨身包系列","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Framework","slug":"computer-science/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Framework/"},{"name":"Vue","slug":"computer-science/Framework/Vue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Framework/Vue/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}]},{"title":"1514. Path with Maximum Probability","slug":"coding/leetcode/Medium/1514-Path-with-Maximum-Probability","date":"2023-06-28T05:02:53.000Z","updated":"2023-06-28T06:56:37.516Z","comments":true,"path":"coding/leetcode/Medium/1514-Path-with-Maximum-Probability/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1514-Path-with-Maximum-Probability/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an undirected weighted graph of n nodes (0-indexed), represented by an edge list where edges[i] = [a, b] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb[i] . Given two nodes start and end , find the path with the maximum probability of success to go from start to end and return its success probability. If there is no path from start to end , return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5. # Example 1 Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2 Output: 0.25000 Explanation: There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25. # Example 2 Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2 Output: 0.30000 # Example 3 Input: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2 Output: 0.00000 Explanation: There is no path between 0 and 2. # 解題思路 # Solution class Solution &#123; public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) &#123; double[] maxProb = new double[n]; maxProb[start] = 1.0; for (int i = 0; i &lt; n - 1; i++) &#123; boolean hasUpdate = false; for (int j = 0; j &lt; edges.length; j++) &#123; int u = edges[j][0]; int v = edges[j][1]; double pathProb = succProb[j]; if (maxProb[u] * pathProb > maxProb[v]) &#123; maxProb[v] = maxProb[u] * pathProb; hasUpdate = true; &#125; if (maxProb[v] * pathProb > maxProb[u]) &#123; maxProb[u] = maxProb[v] * pathProb; hasUpdate = true; &#125; &#125; if (!hasUpdate) &#123; break; &#125; &#125; return maxProb[end]; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Shortest Path","slug":"Shortest-Path","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Shortest-Path/"}]},{"title":"373. Find K Pairs with Smallest Sums","slug":"coding/leetcode/Medium/373-Find-K-Pairs-with-Smallest-Sums","date":"2023-06-27T15:01:24.000Z","updated":"2023-06-27T16:47:57.307Z","comments":true,"path":"coding/leetcode/Medium/373-Find-K-Pairs-with-Smallest-Sums/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/373-Find-K-Pairs-with-Smallest-Sums/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k . Define a pair (u, v) which consists of one element from the first array and one element from the second array. Return the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums. # Example 1 Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 Output: [[1,2],[1,4],[1,6]] Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] # Example 2 Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2 Output: [[1,1],[1,1]] Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] # Example 3 Input: nums1 = [1,2], nums2 = [3], k = 3 Output: [[1,3],[2,3]] Explanation: All possible pairs are returned from the sequence: [1,3],[2,3] # 解題思路 # Solution import java.util.ArrayList;import java.util.HashSet;import java.util.List;import java.util.PriorityQueue;import java.util.Set;class Solution &#123; public List&lt;List&lt;Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) &#123; int m = nums1.length; int n = nums2.length; List&lt;List&lt;Integer>> ans = new ArrayList&lt;>(); Set&lt;Pair&lt;Integer, Integer>> visited = new HashSet&lt;>(); PriorityQueue&lt;int[]> minHeap = new PriorityQueue&lt;>((a, b)->(a[0] - b[0])); minHeap.offer(new int[]&#123;nums1[0] + nums2[0], 0, 0&#125;); visited.add(new Pair&lt;Integer, Integer>(0, 0)); while (k-- > 0 &amp;&amp; !minHeap.isEmpty()) &#123; int[] top = minHeap.poll(); int i = top[1]; int j = top[2]; ans.add(List.of(nums1[i], nums2[j])); if (i + 1 &lt; m &amp;&amp; !visited.contains(new Pair&lt;Integer, Integer>(i + 1, j))) &#123; minHeap.offer(new int[]&#123;nums1[i + 1] + nums2[j], i + 1, j&#125;); visited.add(new Pair&lt;Integer, Integer>(i + 1, j)); &#125; if (j + 1 &lt; n &amp;&amp; !visited.contains(new Pair&lt;Integer, Integer>(i, j + 1))) &#123; minHeap.offer(new int[]&#123;nums1[i] + nums2[j + 1], i, j + 1&#125;); visited.add(new Pair&lt;Integer, Integer>(i, j + 1)); &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"}]},{"title":"2462. Total Cost to Hire K Workers","slug":"coding/leetcode/Medium/2462-Total-Cost-to-Hire-K-Workers","date":"2023-06-26T05:17:30.000Z","updated":"2023-06-26T14:30:13.448Z","comments":true,"path":"coding/leetcode/Medium/2462-Total-Cost-to-Hire-K-Workers/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2462-Total-Cost-to-Hire-K-Workers/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the ith worker. You are also given two integers k and candidates . We want to hire exactly k workers according to the following rules: You will run k sessions and hire exactly one worker in each session. In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers. Break the tie by the smallest index. For example, if costs = [3,2,7,7,1,2] and candidates = 2 , then in the first hiring session, we will choose the 4th worker because they have the lowest cost [3,2,7,7,1,2] . In the second hiring session, we will choose 1st worker because they have the same lowest cost as 4th worker but they have the smallest index [3,2,7,7,2] . Please note that the indexing may be changed in the process. If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index. A worker can only be chosen once. Return the total cost to hire exactly k workers. # Example 1 Input: costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4 Output: 11 Explanation: We hire 3 workers in total. The total cost is initially 0. In the first hiring round we choose the worker from [17,12,10,2,7,2,11,20,8]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2. In the second hiring round we choose the worker from [17,12,10,7,2,11,20,8]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4. In the third hiring round we choose the worker from [17,12,10,7,11,20,8]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers. The total hiring cost is 11. # Example 2 Input: costs = [1,2,4,1], k = 3, candidates = 3 Output: 4 Explanation: We hire 3 workers in total. The total cost is initially 0. In the first hiring round we choose the worker from [1,2,4,1]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers. In the second hiring round we choose the worker from [2,4,1]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2. In the third hiring round there are less than three candidates. We choose the worker from the remaining workers [2,4]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4. The total hiring cost is 4. # 解題思路 # Solution import java.util.PriorityQueue;class Solution &#123; public long totalCost(int[] costs, int k, int candidates) &#123; PriorityQueue&lt;int[]> pq = new PriorityQueue&lt;>((a, b) -> &#123; if (a[0] == b[0]) &#123; return a[1] - b[1]; &#125; return a[0] - b[0]; &#125;); for (int i = 0; i &lt; candidates; i++) &#123; pq.offer(new int[] &#123; costs[i], 0 &#125;); &#125; for (int i = Math.max(candidates, costs.length - candidates); i &lt; costs.length; i++) &#123; pq.offer(new int[] &#123; costs[i], 1 &#125;); &#125; long answer = 0; int nextHead = candidates; int nextTail = costs.length - candidates - 1; for (int i = 0; i &lt; k; i++) &#123; int[] currWorker = pq.poll(); int currCost = currWorker[0], currSectionId = currWorker[1]; answer += currCost; if (nextHead &lt;= nextTail) &#123; if (currSectionId == 0) &#123; pq.offer(new int[] &#123; costs[nextHead], 0 &#125;); nextHead++; &#125; else &#123; pq.offer(new int[] &#123; costs[nextTail], 1 &#125;); nextTail--; &#125; &#125; &#125; return answer; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"}]},{"title":"956. Tallest Billboard","slug":"coding/leetcode/Hard/956-Tallest-Billboard","date":"2023-06-24T03:43:15.000Z","updated":"2023-06-24T15:48:45.787Z","comments":true,"path":"coding/leetcode/Hard/956-Tallest-Billboard/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/956-Tallest-Billboard/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height. You are given a collection of rods that can be welded together. For example, if you have rods of lengths 1 , 2 , and 3 , you can weld them together to make a support of length 6 . Return the largest possible height of your billboard installation. If you cannot support the billboard, return 0 . # Example 1 Input: rods = [1,2,3,6] Output: 6 Explanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6. # Example 2 Input: rods = [1,2,3,4,5,6] Output: 10 Explanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10. # Example 3 Input: rods = [1,2] Output: 0 Explanation: The billboard cannot be supported, so we return 0. # 解題思路 # Solution import java.util.Arrays;public class Solution &#123; public int tallestBillboard(int[] rods) &#123; int maxSize = 0; for(int rod : rods)&#123; maxSize += rod; &#125; int[] dp = new int[maxSize + 1]; Arrays.fill(dp, -1); dp[0] = 0; for(int rod : rods)&#123; int[] dpCopy = dp.clone(); for (int i = 0; i &lt;= maxSize - rod; i++) &#123; if (dpCopy[i] &lt; 0) continue; dp[i + rod] = Math.max(dp[i + rod], dpCopy[i]); dp[Math.abs(i - rod)] = Math.max(dp[Math.abs(i - rod)], dpCopy[i] + Math.min(i, rod)); &#125; &#125; return dp[0]; &#125;&#125; 單字 installing 安裝 v. (READY TO USE) to put furniture, a machine, or a piece of equipment into position and make it ready to use to put a computer program onto a computer so that the computer can use it billboard 廣告牌 n. a very large board on which advertisements are shown, especially at the side of a road steel 鋼 n. a strong metal that is a mixture of iron and carbon, used for making things that need a strong structure, especially vehicles and buildings support 支持 v. to agree with and give encouragement to someone or something because you want him, her, or it to succeedn 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"1027. Longest Arithmetic Subsequence","slug":"coding/leetcode/Medium/1027-Longest-Arithmetic-Subsequence","date":"2023-06-23T08:25:06.000Z","updated":"2023-06-24T03:49:50.072Z","comments":true,"path":"coding/leetcode/Medium/1027-Longest-Arithmetic-Subsequence/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1027-Longest-Arithmetic-Subsequence/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given an array nums of integers, return the length of the longest arithmetic subsequence in nums . Note that: A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. A sequence seq is arithmetic if seq[i + 1] - seq[i] are all the same value (for 0 &lt;= i &lt; seq.length - 1 ). # Example 1 Input: nums = [3,6,9,12] Output: 4 Explanation: The whole array is an arithmetic sequence with steps of length = 3. # Example 2 Input: nums = [9,4,7,2,10] Output: 3 Explanation: The longest arithmetic subsequence is [4,7,10]. # Example 3 Input: nums = [20,1,15,3,10,5,8] Output: 4 Explanation: The longest arithmetic subsequence is [20,15,10,5]. # 解題思路 # Solution import java.util.HashMap;import java.util.Map;class Solution &#123; public int longestArithSeqLength(int[] nums) &#123; Map&lt;Integer, Integer>[] dp = new HashMap[nums.length]; int longest = 2; for(int i = 0; i &lt; nums.length; i++)&#123; dp[i] = new HashMap&lt;>(); for(int j = 0; j &lt; i; j++)&#123; int diff = nums[i] - nums[j]; dp[j].put(diff, dp[i].getOrDefault(diff, 1) + 1); longest = Math.max(longest, dp[j].get(diff)); &#125; &#125; return longest; &#125;&#125; 單字 arithmetic 算數 n. the part of mathematics that involves the adding and multiplying, etc. of numbers subsequence 子序列 n. something that follows something else 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"714. Best Time to Buy and Sell Stock with Transaction Fee","slug":"coding/leetcode/Medium/714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee","date":"2023-06-22T07:22:26.000Z","updated":"2023-06-23T08:24:16.320Z","comments":true,"path":"coding/leetcode/Medium/714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee. Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). # Example 1 Input: prices = [1,3,2,8,4,9], fee = 2 Output: 8 Explanation: The maximum profit can be achieved by: Buying at prices[0] = 1 Selling at prices[3] = 8 Buying at prices[4] = 4 Selling at prices[5] = 9 The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8. # Example 2 Input: prices = [1,3,7,5,10,3], fee = 3 Output: 6 # 解題思路 # Solution class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; int ans = 0; int buy = -prices[0]; for (int price : prices) &#123; int temp = buy; buy = Math.max(buy, ans - price); ans = Math.max(ans, temp + price - fee); &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"}]},{"title":"2448. Minimum Cost to Make Array Equal","slug":"coding/leetcode/Hard/2448-Minimum-Cost-to-Make-Array-Equal","date":"2023-06-21T17:05:34.000Z","updated":"2023-06-21T19:20:50.119Z","comments":true,"path":"coding/leetcode/Hard/2448-Minimum-Cost-to-Make-Array-Equal/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/2448-Minimum-Cost-to-Make-Array-Equal/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 You are given two 0-indexed arrays nums and cost consisting each of n positive integers. You can do the following operation any number of times: Increase or decrease any element of the array nums by 1 . The cost of doing one operation on the ith element is cost[i] . Return the minimum total cost such that all the elements of the array nums become equal. # Example 1 Input: nums = [1,3,5,2], cost = [2,3,1,14] Output: 8 Explanation: We can make all the elements equal to 2 in the following way: Increase the 0th element one time. The cost is 2. Decrease the 1st element one time. The cost is 3. Decrease the 2nd element three times. The cost is 1 + 1 + 1 = 3. The total cost is 2 + 3 + 3 = 8. It can be shown that we cannot make the array equal with a smaller cost. # Example 2 Input: nums = [2,2,2,2,2], cost = [4,2,8,1,3] Output: 0 Explanation: All the elements are already equal, so no operations are needed. # 解題思路 # Solution class Solution &#123; public long minCost(int[] nums, int[] cost) &#123; int left = nums[0]; int right = nums[0]; for (int num : nums) &#123; left = Math.min(left, num); right = Math.max(right, num); &#125; // Find the min and max in nums[] array long ans = 0; while (left &lt; right) &#123; int mid = (left + right) / 2; long cost1 = helper(nums, cost, mid); long cost2 = helper(nums, cost, mid + 1); if (cost1 > cost2) &#123; left = mid + 1; ans = cost2; &#125; else &#123; right = mid; ans = cost1; &#125; &#125; return ans; &#125; public long helper(int[] nums, int[] cost, int all) &#123; long totalCost = 0L; for (int i = 0; i &lt; nums.length; i++) &#123; totalCost += 1L * Math.abs(nums[i] - all) * cost[i]; &#125; return totalCost; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"}]},{"title":"What is CI/CD?","slug":"computer-science/DevOps/What-is-CI-CD","date":"2023-06-20T15:23:34.000Z","updated":"2023-06-28T07:00:13.665Z","comments":true,"path":"computer-science/DevOps/What-is-CI-CD/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/What-is-CI-CD/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 從測試、建置到部署一次自動化 # What is CI/CD? CI/CD 工具也是為了 DevOps 概念而產生的自動化工具，透過持續整合、持續部署的方式，在開發階段就自動協助開發人員偵測程式碼問題，並部署至伺服器。 # CI（Continuous Integration）持續整合 當開發人員完成一個階段性的程式碼後就經由自動化工具測試、驗證，協助偵測程式碼問題，並建置出即將部署的版本（Build）。 # CD（Continuous Deployment）持續部署 可以說是 CI 的下一階段，經過 CI 測試後所構建的程式碼可以透過 CD 工具部署至伺服器，減少人工部署的時間。 # CI/CD 工具 - GitLab GitLab 主要的服務是提供 git 版本控制系統，其 CI/CD Pipeline 功能簡單又實用，使用者只需要設定於專案根目錄下的「.gitlab-ci.yml」檔，便可以開始驅動各種 Pipeline 協助您完成自動化測試及部署。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"}],"tags":[]},{"title":"What is DevOps?","slug":"computer-science/DevOps/What-is-DevOps","date":"2023-06-20T14:40:23.000Z","updated":"2023-06-28T07:00:17.716Z","comments":true,"path":"computer-science/DevOps/What-is-DevOps/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/What-is-DevOps/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # What is DevOps? DevOps 拆開來就是 Development + Operations ，也就是開發與維運。 更準確的說可以是「開發」「測試」「維運」三者的結合，是一種軟體開發和部署的方法論。 DevOps 主要促進開發和 IT 運營兩個團隊的結合與運作，提升團隊之間的協作和溝通。 DevOps 的目的是通過協調和自動化開發、測試和部署來實現更快的產品交付速度、更高的品質及提升工作效率。 生命週期的每個階段：從初始軟體規劃到程式碼、建構、測試和發佈階段，再到部署、作業與持續監控。 這種關係推動了進一步改善、開發、測試及部署的持續客戶回饋循環。可能可以更快速地持續發佈必要的功能變更或新增項目。 # DevOps 核心五個概念 - CALMS Culture 文化： DevOps 不是一個工具而是代表一個 IT 文化轉型的概念，藉由同理心與換位思考讓開發與營運人員合作更加順暢。 Automation 自動化： 自動化流程提高效率，有助於建立敏捷的團隊，產出品質優良的產品。 Lean 精實： DevOps 希望能建立敏捷開發的團隊，因此精實生產過程也非常重要，包含了減少浪費、盡快交付、延遲做決定等原則，延遲做決定是指領導者可以等接收到完整的資訊後再做決策。 Measurement 測量： 利用數據判斷決策是否正確，若數字一旦有所異常即可隨時改變策略，使團隊保持敏捷性。 Sharing 分享： 藉由團隊間共享資訊，可以提升解決問題的效率。 # 生命週期 持續開發：這項實務做法涵蓋了 DevOps 開發維運生命週期的規劃與編碼階段。其中可能涉及版本控制機制。 持續測試：這項實務做法可以在正在編寫或更新應用程式的程式碼時納入預先排定的持續自動化程式碼測試。這類測試可以加快將程式碼交付至正式作業的速度。 持續整合 (CI)：這項實務做法可以將組態管理 (CM) 工具和其他測試與開發工具結合，以追蹤正在開發的程式碼有多少已準備就緒可供正式作業使用。其中涉及在測試與開發之間快速提供意見反應，以便迅速識別並解決程式碼問題。 持續交付：這項實務做法可以在測試後，自動將程式碼變更傳送至正式作業前或接移環境。然後，員工可以決定是否要將這類程式碼變更推廣至正式作業環境。 持續部署 (CD)：與持續交付類似，這項實務做法可以自動將新程式碼或變更後的程式碼發佈至正式作業環境。執行持續部署的公司每天可以發佈數次程式碼或功能變更。使用 Docker 和 Kubernetes 等 Container 技術有助於在不同的部署平台和環境中維持程式碼的一致性，進而實現持續部署。 持續監控：這項實務做法包括持續監控運作中的程式碼以及支援該程式碼的底層基礎架構。回報錯誤或問題的回饋循環隨後又會回到開發階段。 基礎架構即程式碼：這項實務做法可在各種 DevOps 開發維運階段中使用，以自動化軟體版本所需的基礎架構資源配置。開發人員可從其現有的開發工具中新增基礎架構「程式碼」。例如，開發人員可以視需求從 Docker、Kubernetes 或 OpenShift 建立儲存 Volume。這項實務做法也可讓營運團隊監控環境組態、追蹤變更，並簡化組態的復原作業。 # 工具 規劃：此階段有助於定義商業價值與需求。範例工具包括 Jira 或 Git，可協助追蹤已知問題並執行專案管理。 程式碼：此階段涉及軟體設計及軟體程式碼的建立。範例工具包括 GitHub、GitLab、BitBucket 或 Stash。 建置：在此階段，您將管理軟體建置與版本，並使用自動化工具來協助編譯及封裝程式碼，以供將來發佈到正式作業環境。您使用的原始碼程式碼儲存庫或套件儲存庫也會「封裝」產品發佈所需的基礎架構。範例工具包括 Docker、Ansible、Puppet、Chef、Gradle、Maven 或 JFrog Artifactory。 測試：此階段包括持續測試（手動或自動），以確保最佳的程式碼品質。範例工具包括 JUnit、Codeception、Selenium、Vagrant、TestNG 或 BlazeMeter。 部署：此階段可以包含有助於管理、協調、排程和自動將產品發佈至正式作業環境的工具。範例工具包括 Puppet、Chef、Ansible、Jenkins、Kubernetes、OpenShift、OpenStack、Docker 或 Jira。 操作：此階段可在正式作業期間管理軟體。範例工具包括 Ansible、Puppet、PowerShell、Chef、Salt 或 Otter。 監督：此階段包括識別及收集有關正式作業中特定軟體版本問題的資訊。範例工具包括 New Relic、Datadog、Grafana、Wireshark、Splunk、Nagios 或 Slack。 # 優勢 更快、更好地交付產品 更快地解決問題並降低複雜度 更高的擴充性與可用度 更穩定的作業環境 更佳的資源使用率 更優異的自動化功能 更清楚地掌握系統成果 更高程度的創新","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"}],"tags":[]},{"title":"uva 10170 - The Hotel with Infinite Rooms","slug":"coding/cpe/One Star/uva-10170-The-Hotel-with-Infinite-Rooms","date":"2023-06-20T07:42:09.000Z","updated":"2023-06-21T17:04:30.967Z","comments":true,"path":"coding/cpe/One Star/uva-10170-The-Hotel-with-Infinite-Rooms/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10170-The-Hotel-with-Infinite-Rooms/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The city of HaluaRuti has a strange hotel with infinite rooms. The groups that come to this hotel follow the following rules: a) At the same time only members of one group can rent the hotel. b) Each group comes in the morning of the check-in day and leaves the hotel in the evening of the check-out day. c) Another group comes in the very next morning after the previous group has left the hotel. d) A very important property of the incoming group is that it has one more member than its previous group unless it is the starting group. You will be given the no of members of the starting group. e) A group with n members stays for n days in the hotel. For example, if a group of four members comes on 1st August in the morning, it will leave the hotel on 4th August in the evening and the next group of five members will come on 5th August in the morning and stay for five days and so on. Given the initial group size you will have to find the group size staying in the hotel on a specified day. # Input The input contains round numbers S(1 ≤ S ≤ 10000) and D(1 ≤ D &lt; 10^15) in every line. S denotes the initial size of the group and D denotes that you will have to find the group size staying in the hotel on D-th day (starting from 1). All the input and output integers will be less than 10^15 . A group size S means that on the first day a group of S members come to the hotel and stays for S days then comes a group of S + 1 members according to the previously described rules and so on. # Output For each line of input, print on a single line the size of the group staying in the hotel on the D-th day. 單字 strange 奇怪的 adj. unusual and unexpected, or difficult to understand rent 租 v. rent + from + (where)/ for + (money)/ to + (sb) a fixed amount of money that you pay regularly for the use of a room, house, car, television, etc. that someone else owns previous 以前的 adj. happening or existing before something or someone else property 財產 n. an object or objects that belong to someone 片語 & 搭配詞 !! !! # Sample Input 1 6 3 10 3 14 # Sample Output 3 5 6 # 解題技巧 需要知道第 d 天有幾人在飯店，起始有 s 人，居住 s 天，居住結束後 s + 1。 可以利用 d - s 的方式得知經過 s 人居住完 s 天後，距離題目要求的 d 天住幾人還有幾天。 而當 d = 0 時，當時的 s 就表示當時 d 天酒店有多少人。 # Solution Main.javaimport java.lang.reflect.Array;import java.util.ArrayList;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNextLong()) &#123; long s = sc.nextLong(); long d = sc.nextLong(); while ((d - s) > 0) &#123; d -= s; s++; &#125; System.out.println(s); &#125; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"}]},{"title":"2090. K Radius Subarray Averages","slug":"coding/leetcode/Medium/2090-K-Radius-Subarray-Averages","date":"2023-06-20T04:38:59.000Z","updated":"2023-06-26T16:57:05.905Z","comments":true,"path":"coding/leetcode/Medium/2090-K-Radius-Subarray-Averages/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2090-K-Radius-Subarray-Averages/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given a 0-indexed array nums of n integers, and an integer k . The k-radius average for a subarray of nums centered at some index i with the radius k is the average of all elements in nums between the indices i - k and i + k (inclusive). If there are less than k elements before or after the index i , then the k-radius average is -1 . Build and return an array avgs of length n where avgs[i] is the k-radius average for the subarray centered at index i . The average of x elements is the sum of the x elements divided by x , using integer division. The integer division truncates toward zero, which means losing its fractional part. For example, the average of four elements 2 , 3 , 1 , and 5 is (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75 , which truncates to 2 . # Example 1 Input: nums = [7,4,3,9,1,8,5,2,6], k = 3 Output: [-1,-1,-1,5,4,4,-1,-1,-1] Explanation: avg[0], avg[1], and avg[2] are -1 because there are less than k elements before each index. The sum of the subarray centered at index 3 with radius 3 is: 7 + 4 + 3 + 9 + 1 + 8 + 5 = 37. Using integer division, avg[3] = 37 / 7 = 5. For the subarray centered at index 4, avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4. For the subarray centered at index 5, avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4. avg[6], avg[7], and avg[8] are -1 because there are less than k elements after each index. # Example 2 Input: nums = [100000], k = 0 Output: [100000] Explanation: The sum of the subarray centered at index 0 with radius 0 is: 100000. avg[0] = 100000 / 1 = 100000. # Example 3 Input: nums = [8], k = 100000 Output: [-1] Explanation: avg[0] is -1 because there are less than k elements before and after index 0. # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public int[] getAverages(int[] nums, int k) &#123; int n = nums.length; int windows = 2 * k + 1; int[] ans = new int[n]; Arrays.fill(ans, -1); if(n &lt; windows)&#123; return ans; &#125; long[] sum = new long[n + 1]; for(int i = 0; i &lt; n; i++)&#123; sum[i + 1] = sum[i] + nums[i]; &#125; for(int i = k; i &lt; n - k; i++)&#123; ans[i] = (int) ((sum[i + k + 1] - sum[i - k]) / windows); &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"}]},{"title":"1732. Find the Highest Altitude","slug":"coding/leetcode/Easy/1732-Find-the-Highest-Altitude","date":"2023-06-19T06:31:22.000Z","updated":"2023-06-20T04:39:55.465Z","comments":true,"path":"coding/leetcode/Easy/1732-Find-the-Highest-Altitude/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1732-Find-the-Highest-Altitude/","excerpt":"","text":"⭐️ # 題目敘述 There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0 . You are given an integer array gain of length n where gain[i] is the net gain in altitude between points i ​​​​​​ and i + 1 for all (0 &lt;= i &lt; n) . Return the highest altitude of a point. # Example 1 Input: gain = [-5,1,5,0,-7] Output: 1 Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1. # Example 2 Input: gain = [-4,-3,-2,-1,4,3,2] Output: 0 Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0. # 解題思路 # Solution class Solution &#123; public int largestAltitude(int[] gain) &#123; int curr = 0; int ans = curr; for(int i = 0; i &lt; gain.length; i++)&#123; curr += gain[i]; ans = Math.max(ans, curr); &#125; return ans; &#125;&#125; 單字 altitudes 海拔，海拔高度 height above sea level 片語 & 搭配詞 consist of 由... 組成 [主動] 群體 + consist of + 部分 The committee consists of doctors and nurses. 該委員會由醫生和護士組成。 →「群體」committee 當主詞，consist of + 「部分」 doctors and nurses consist 必須搭配 of，consist of 只能用主動語態。 「群體」當主詞，consist of + 「部分」。 be composed of 由... 組成 [被動] 群體 + be composed of + 部分 Water is composed of hydrogen and oxygen. 水由氫和氧組成。 →「群體」water 當主詞，is composed of + 「部分」hydrogen and oxygen compose 當組成意思時，使用被動語態，必須搭配 of，用 be composed of。 「群體」當主詞，be composed of + 「部分」。 comprise 由... 組成 [主動] 群體 + comprise + 部分 The country comprises 22 cities. 該國由 22 個城市組成。 →「群體」the country 當主詞，comprise + 「部分」22 cities [主動] 部分 + comprise + 群體 Semiconductor chips and oil comprises the imports of this country. 該國的進口物有半導體晶片和石油。 →「部分」semiconductor chips and oil 當主詞，comprise + 「整體」the imports of this country [被動] 群體 + is comprised of + 部分 The basketball school team is comprised of 12 players. 籃球校隊由 12 名球員組成。 →「群體」the basketball school team 當主詞，is comprised of + 「部分」12 players comprise 的用法比較特別，在主動語態時，可以用「群體當主詞 + comprise + 組成部分」，或「組成部分當組詞 + comprise + 群體」。 在被動語態時，用群體當「主詞 + is comprised of + 組成部分」。 make up 由... 組成 [主動] 部分 + make up + 群體 Plasma, platelets, and blood cells make up blood. 血漿、血小板和血細胞構成血液。 →「部分」plasma, platelets, and blood cells 當主詞，make up + 「整體」blood [被動] 群體 + is made up of + 部分 The model plane is made up of 200 pieces of bricks. 模型飛機由 200 塊積木組成。 →「群體」the model plane 當主詞，is made up of + 「部分」200 pieces of bricks make up 意思是「組成」，用主詞語態時，以「部分」當主詞 + make up + 「群體」。 用被動語態時，「群體」當主詞，be made up of + 「部分」。","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"}]},{"title":"介紹 Java Script Boot","slug":"computer-science/Framework/Java-Spring-boot/介紹-Java-Script-Boot","date":"2023-06-17T07:11:23.000Z","updated":"2023-06-26T14:57:42.886Z","comments":true,"path":"computer-science/Framework/Java-Spring-boot/介紹-Java-Script-Boot/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Framework/Java-Spring-boot/%E4%BB%8B%E7%B4%B9-Java-Script-Boot/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 淺淺介紹一下 Java JAVA 彈性且方便使用者使用，是開發人員建置多種應用程式時的最愛，舉凡社交媒體、Web 和遊戲應用程式及網路與企業應用程式，無所不在。 # Spring vs. Spring Boot Spring Spring Boot Info 以 JAVA 為基礎的開放原始碼 Web 應用程式架構。 在 Spring 架構上建置的延伸模組或模組。 Feature 使用預先建置程式碼的工具和程式庫，提供彈性且完全可設定的環境，以建立自訂、鬆散結合的 Web 應用程式。 提供建立獨立 Spring 應用程式的功能，這些應用程式只要立即執行，不需要註解、XML 設定或撰寫大量其他程式碼。 # Spring Boot 是什麼？ Spring Boot 是由 Pivotal 團隊在 2013 年開始研發、2014 年 4 月發布第一個版本。 它基於 Spring4.0 設計，不僅繼承了 Spring 框架原有的優秀特性，而且還通過簡化配置來進一步簡化了 Spring 應用的整個搭建和開發過程。 JAVA Spring Boot 提供的核心功能，除了 Spring 架構之外。 Spring Boot 提供更輕鬆、更快速的路徑來設定、設定及執行應用程式。 這會消除設定大多數 Spring 型應用程式所需的大量設定。 開發人員無需學習基礎 Spring 架構，就能直接加入並使用 Spring Boot。 Spring Boot 可以說是在 Java 中開發基於 REST Web 應用程序的最快方法之一。 Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can &quot;just run&quot;. We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need minimal Spring configuration. # 主要功能 創建獨立的 Spring 應用程序 直接嵌入 Tomcat、Jetty 或 Undertow（無需部署 WAR 文件） 提供自以為是的 “入門” 依賴項以簡化您的構建配置 盡可能自動配置 Spring 和 3rd 方庫 提供生產就緒的功能，例如指標、健康檢查和外部化配置 絕對沒有代碼生成，也不需要 XML 配置 # 參考連結 Spring Boot 官方網站","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Framework","slug":"computer-science/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Framework/"},{"name":"Java Spring Boot","slug":"computer-science/Framework/Java-Spring-Boot","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Framework/Java-Spring-Boot/"}],"tags":[]},{"title":"什麼是框架?","slug":"computer-science/Framework/什麼是框架","date":"2023-05-28T17:05:57.000Z","updated":"2023-06-28T07:00:02.138Z","comments":true,"path":"computer-science/Framework/什麼是框架/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Framework/%E4%BB%80%E9%BA%BC%E6%98%AF%E6%A1%86%E6%9E%B6/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 軟體框架 (Software Framework) 為軟體開發提供了一個基礎的架構、地基，去實現更複雜的軟體或是邏輯，使開發更有效率的進行，他扮演著規範和定義的角色。 框架本身無法自行運作，開發者必須將自己的程式搭配框架才是一個完整的應用程式。 運用框架其實就像把別人已經做好的零件拿來使用，就像要製作一台機器人，總不可能從製作螺絲開始吧！螺絲通常是像他人購買，而我們專注於完成機器人的整體。 而軟體架構就是如此，他提供了別人事先寫好的函式庫（Library）或類別庫（Class Library），提供軟體開發的便利性，加速了開發過程。 # 提供的好處 圖片來源 https://docs.f5ezcode.in/cs-basic/di-ba-zhang-gong-cheng-de-gong-ju/8.2-cheng-shi-yan-de-kuang-jia # 常見程式語言框架 CSS – bootstrap PHP - Laravel JavaScript – JQuery、Vue.js、React.js、Angular.js、Svelte.js、Express.js Java – Spring MVC、Spring boot Python – Django C# – .NET framework 接下來的系列文章會介紹我學習過的框架且在使用的框架，當然這裡還是以學習筆記的方式呈現，我會盡量整理的有閱讀順序啦～～ 有的框架我不是很熟，但是我會盡量與同類型的進行比較，有時間專研後，再寫筆記。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Framework","slug":"computer-science/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Framework/"}],"tags":[]},{"title":"2627. Debounce","slug":"coding/leetcode/Medium/2627-Debounce","date":"2023-05-19T05:19:53.000Z","updated":"2023-05-28T17:14:48.054Z","comments":true,"path":"coding/leetcode/Medium/2627-Debounce/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2627-Debounce/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a function fn and a time in milliseconds t, return a debounced version of that function. A debounced function is a function whose execution is delayed by t milliseconds and whose execution is cancelled if it is called again within that window of time. The debounced function should also recieve the passed parameters. For example, let's say t = 50ms, and the function was called at 30ms, 60ms, and 100ms. The first 2 function calls would be cancelled, and the 3rd function call would be executed at 150ms. If instead t = 35ms, The 1st call would be cancelled, the 2nd would be executed at 95ms, and the 3rd would be executed at 135ms. The above diagram shows how debounce will transform events. Each rectangle represents 100ms and the debounce time is 400ms. Each color represents a different set of inputs. Please solve it without using lodash's _.debounce() function. # Example 1: Input: t = 50 calls = [ {&quot;t&quot;: 50, inputs: [1]}, {&quot;t&quot;: 75, inputs: [2]} ] Output: [{&quot;t&quot;: 125, inputs: [2]}] Explanation: let start = Date.now(); function log(...inputs) { console.log([Date.now() - start, inputs ]) } const dlog = debounce(log, 50); setTimeout(() =&gt; dlog(1), 50); setTimeout(() =&gt; dlog(2), 75); The 1st call is cancelled by the 2nd call because the 2nd call occurred before 100ms The 2nd call is delayed by 50ms and executed at 125ms. The inputs were (2). # Example 2: Input: t = 20 calls = [ {&quot;t&quot;: 50, inputs: [1]}, {&quot;t&quot;: 100, inputs: [2]} ] Output: [{&quot;t&quot;: 70, inputs: [1]}, {&quot;t&quot;: 120, inputs: [2]}] Explanation: The 1st call is delayed until 70ms. The inputs were (1). The 2nd call is delayed until 120ms. The inputs were (2). # Example 3: Input: t = 150 calls = [ {&quot;t&quot;: 50, inputs: [1, 2]}, {&quot;t&quot;: 300, inputs: [3, 4]}, {&quot;t&quot;: 300, inputs: [5, 6]} ] Output: [{&quot;t&quot;: 200, inputs: [1,2]}, {&quot;t&quot;: 450, inputs: [5, 6]}] Explanation: The 1st call is delayed by 150ms and ran at 200ms. The inputs were (1, 2). The 2nd call is cancelled by the 3rd call The 3rd call is delayed by 150ms and ran at 450ms. The inputs were (5, 6). # 解題思路 # Solution /** * @param &#123;Function&#125; fn * @param &#123;number&#125; t milliseconds * @return &#123;Function&#125; */var debounce = function(fn, t) &#123; let timeout; return function(...args) &#123; clearTimeout(timeout); timeout = setTimeout(function()&#123; fn(...args); &#125;, t); &#125;&#125;;/** * const log = debounce(console.log, 100); * log('Hello'); // cancelled * log('Hello'); // cancelled * log('Hello'); // Logged at t=100ms */ type F = (...p: any[]) => anyfunction debounce(fn: F, t: number): F &#123; let timeout: any; return function(...args) &#123; clearTimeout(timeout); timeout = setTimeout(function()&#123; fn(...args); &#125;, t); &#125;&#125;;/** * const log = debounce(console.log, 100); * log('Hello'); // cancelled * log('Hello'); // cancelled * log('Hello'); // Logged at t=100ms */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"785. Is Graph Bipartite?","slug":"coding/leetcode/Medium/785-Is-Graph-Bipartite","date":"2023-05-19T04:30:34.000Z","updated":"2023-05-28T17:13:53.473Z","comments":true,"path":"coding/leetcode/Medium/785-Is-Graph-Bipartite/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/785-Is-Graph-Bipartite/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1 . You are given a 2D array graph , where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u] , there is an undirected edge between node u and node v . The graph has the following properties: There are no self-edges ( graph[u] does not contain u ). There are no parallel edges ( graph[u] does not contain duplicate values). If v is in graph[u] , then u is in graph[v] (the graph is undirected). The graph may not be connected, meaning there may be two nodes u and v such that there is no path between them. A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B . Return true if and only if it is bipartite. # Example 1: Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]] Output: false Explanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other. # Example 2: Input: graph = [[1,3],[0,2],[1,3],[0,2]] Output: true Explanation: We can partition the nodes into two sets: {0, 2} and {1, 3}. # 解題思路 # Solution class Solution &#123; public boolean isBipartite(int[][] graph) &#123; int n = graph.length; int[] remeber = new int[n]; // remeber graph index in which group, group A = 1, group B = -1 for (int i = 0; i &lt; n; i++) &#123; if (remeber[i] == 0 &amp;&amp; !dfs(graph, remeber, i, 1)) return false; &#125; return true; &#125; public boolean dfs(int[][] graph, int[] remeber, int node, int group) &#123; if (remeber[node] != 0) return remeber[node] == group; remeber[node] = group; for (int neighbor : graph[node]) &#123; if (!dfs(graph, remeber, neighbor, -group)) return false; &#125; // if neighbor node is not in same group, mean it can divide to two group. return true; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"}]},{"title":"Git 進階指令","slug":"computer-science/DevOps/Git/Git 進階指令","date":"2023-05-18T09:36:07.000Z","updated":"2023-06-20T14:43:22.320Z","comments":true,"path":"computer-science/DevOps/Git/Git 進階指令/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Git/Git%20%E9%80%B2%E9%9A%8E%E6%8C%87%E4%BB%A4/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 版本退回 引用文: https://gitbook.tw/chapters/using-git/reset-commit git log 檢視提交的歷史記錄。 git log --oneline 目前的 Git 紀錄。 git reset [版本 id] 版本退回","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"}],"tags":[]},{"title":"Work Flow","slug":"computer-science/DevOps/Git/Work-Flow","date":"2023-05-18T07:34:08.000Z","updated":"2023-06-20T14:43:44.971Z","comments":true,"path":"computer-science/DevOps/Git/Work-Flow/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Git/Work-Flow/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 當大家一起開發專案時，專案撰寫的內容越來越多，Git Commit 內容增加，就很容易有 Git Graph 非常雜亂的問題，對某一個功能重複撰寫等等。 這個時候就非常需要工作流程 (Work Flow)，讓大家有規劃，更效率地開發。 # 常見 Work Flow Git Flow GitHub Flow GitLab Flow # 定義部署的環境 開發環境（工程師的電腦） 測試環境（讓審核人員測試使用，像是 QA 測試） 展示環境（讓早期用戶或是驗收使用） 產品環境（正式讓所有用戶使用） # Git Flow Git Flow 是上述三種 Work Flow 中最早出現的。 master 負責管理發布的狀態。當準備好發佈指定版本時，最後的提交會給予一個發布版本標籤。 develop Develop 分支是針對日常開發的分支。所有新功能開發最終都會合併到這裡。 feature 這個分支是新功能的開發或修復錯誤的時候從 develop 分支分開出來的。 release Release 分支是為了發布而準備的。通常這種分支的名稱最前面會加上 &quot;release-&quot;。 hotfit Hot fix 分支是在發布的產品需要緊急修改時，從 master 分支建立的分支。 通常會在分支名稱的最前面會加上 &quot;hotfix-&quot;。 # 開發過程 從 master 分支拉出一條分支 develop 進行日常開發。 要開發新功能 / 修復錯誤時，從 develop 分支拉取一條 feature 分支。 開發完成後，將 feature 分支合入到 develop 分支，並進行開發環境的驗證。 確認完成後，從 develop 分支拉取一條 release 分支，到測試環境進行 SIT/UAT 測試。 測試完成後，可將 release 分支合入 master 分支並將現在內容給回 develop 分支。 版本部屬時，直接將 master 分支程式碼部署到最終環境。 優點: 每個分支都有明確的定義，嚴格按照 Git Flow 管理專案程式碼的話，很難出現程式碼混亂 缺點: 如果 feature 分支過多的話很容易造成程式碼衝突，從而提高了合入的成本 由於每次提交都涉及多個分支，所以 Git Flow 也太不適合提交頻率較高的項目 # GitHub Flow &amp; GitLab Flow By 因為我還沒研究過 GitHub Flow &amp; GitLab Flow，所以這裡提供我覺得寫得很不錯的文章給大家參考 文章 medium.com/@trylovetom 讓我們來了解 GitHub Flow 吧！除了會 Git 你還需要 Work Flow medium.com/i-think-so-i-live Git上的三種工作流程","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"}],"tags":[]},{"title":"Git Branch","slug":"computer-science/DevOps/Git/Git-Branch","date":"2023-05-18T07:31:13.000Z","updated":"2023-06-20T14:43:36.000Z","comments":true,"path":"computer-science/DevOps/Git/Git-Branch/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Git/Git-Branch/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 什麼是 branch? 在開發軟體時，可能同時會有多人在開發同一功能或修復錯誤，也可能會有多個發佈版本的存在，並且需要針對每個版本進行維護，同一個數據庫可以同時進行多個修改。 現在最常用來管理 Git 分支的方法: master develop feature release hotfix # 分支常用指令 git branch# 查看分支。git branch [BRANCH_NAME]# 建立分支。git checkout [BRANCH_NAME]# 取出指定的分支。git checkout -b [BRANCH_NAME]# 建立並跳到該分支。git branch -D [BRANCH_NAME]# 強制刪除指定分支 (須先切換至其他分支再做刪除)。git branch -m [OLD_BRANCH_NAME] [NEW_BRANCH_NAME]# 修改分支名稱。git merge [要合併的分支]# 切換到合併後的分支，再合併分支 合併分支: 例：把 release-1.0 分支的修改合併到 master。 先將分支切換到 mastergit checkout master 合併 release-1.0 分支git merge release-v1.0 # 分支命名和標記 如果可能，請創建不包含特殊字符的分支和標記名稱，因為這些字符需要轉義。用於分支名稱和標記名稱的安全默認字符集為： 英文字母 （a-z 和 A-Z） 數字 (0-9) 有限的標點字符集： 句點 (.) 連字符 (-) 下劃線 (_) 正斜杠 (/) 為避免混淆，分支名稱應以字母開頭。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"}],"tags":[]},{"title":"Git commit specification","slug":"computer-science/DevOps/Git/Git-commit-specification","date":"2023-05-18T07:02:09.000Z","updated":"2023-06-20T14:43:38.826Z","comments":true,"path":"computer-science/DevOps/Git/Git-commit-specification/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Git/Git-commit-specification/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 建議提交格式 建議以這種形式填寫提交訊息 Header: &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; type: 代表 commit 的類別：feat, fix, docs, style, refactor, test, chore，必要欄位。 scope 代表 commit 影響的範圍，例如資料庫、控制層、模板層等等，視專案不同而不同，為可選欄位。 subject 代表此 commit 的簡短描述，不要超過 50 個字元，結尾不要加句號，為必要欄位。 Body: 72-character wrapped. This should answer: Body 部份是對本次 Commit 的詳細描述，可以分成多行，每一行不要超過 72 個字元。 說明程式碼變動的項目與原因，還有與先前行為的對比。 Footer: 填寫任務編號（如果有的話）. BREAKING CHANGE（可忽略），記錄不兼容的變動， 以 BREAKING CHANGE: 開頭，後面是對變動的描述、以及變動原因和遷移方法。 # git commit Header feat: 新增 / 修改功能 (feature)。 fix: 修補 bug (bug fix)。 docs: 文件 (documentation)。 style: 格式 (不影響程式碼運行的變動 white-space, formatting, missing semi colons, etc)。 refactor: 重構 (既不是新增功能，也不是修補 bug 的程式碼變動)。 perf: 改善效能 (A code change that improves performance)。 test: 增加測試 (when adding missing tests)。 chore: 建構程序或輔助工具的變動 (maintain)。 revert: 撤銷回覆先前的 commit 例如：revert: type (scope): subject (回覆版本：xxxx)。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"}],"tags":[]},{"title":"Git 基本指令與觀念","slug":"computer-science/DevOps/Git/Git-基本指令與觀念","date":"2023-05-18T06:59:43.000Z","updated":"2023-06-20T14:43:33.574Z","comments":true,"path":"computer-science/DevOps/Git/Git-基本指令與觀念/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Git/Git-%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4%E8%88%87%E8%A7%80%E5%BF%B5/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 基本指令與觀念 提交訊息是查看其他人提交的修改內容或自己檢查歷史記錄時重要的資料。 所以要用心填寫讓人容易理解的提交訊息。 Git 的標準提交 (commit) 訊息： 第 1 行：提交時修改內容的摘要 第 2 行：空行 第 3 行以後：修改的理由 建議以這種形式填寫提交訊息，詳細可以參考 Git commit specification # 基本指令 git init# 建立新的本地端儲存庫 (Repository)git clone [URL]# 複製遠端的 Repository 檔案到本地端。git status# 檢查本地端檔案異動狀態。 沒事常用 git status 檢查 git 的情況 clone v.s. download clone 可以做 git 後續的一些指令，但 download 無法。 # 常用指令 # add git add [檔案或資料夾]# 將指定的檔案 (或資料夾) 加入版本控制。用 git add . 可加入全部。# commit git commit -m \"[修改內容]\"# 提交 (commit) 目前的異動並透過 -m 參數設定摘要說明文字。git commit# 提交 (commit) 目前的異動，可以打超過一行的 commit information。# push git push# 將本地端 Repository 的 commit 發佈到遠端。git push origin [BRANCH_NAME]# 發佈至遠端指定的分支 (Branch)。# pull git pull# 檔案抓取下來到自己的本地端。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"}],"tags":[]},{"title":"Git 安裝","slug":"computer-science/DevOps/Git/Git-安裝","date":"2023-05-18T06:55:23.000Z","updated":"2023-06-20T14:43:29.523Z","comments":true,"path":"computer-science/DevOps/Git/Git-安裝/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Git/Git-%E5%AE%89%E8%A3%9D/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 安裝 git - Windows git 官網: https://git-scm.com/download/win 然後開啟 Git Bash # 設定 git 識別資料 在你安裝 Git 後首先應該做的事是設定使用者名稱及電子郵件。 這一點非常重要，因為每次 Git 的提交會使用這些資訊，而且提交後不能再被修改。 git config --global user.name \"[使用者名字]\"git config --global user.email \"[電子信箱]\"若你有傳遞 --global 參數，只需要做這工作一次，因為在此系統，不論 Git 做任何事都會採用此資訊。 # 檢查讀者的設定 git config --list# 建立全新的儲存庫 echo \"# test\" >> README.mdgit initgit add README.mdgit commit –m “first commit”git remote add origin [github_repository URL]git push –u origin main","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Windows/"}]},{"title":"Git Information","slug":"computer-science/DevOps/Git/Git-Information","date":"2023-05-18T06:15:06.000Z","updated":"2023-06-20T14:43:41.261Z","comments":true,"path":"computer-science/DevOps/Git/Git-Information/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Git/Git-Information/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 前言 版本控制系統：對軟體開發過程中程式碼、文件、文檔等，發生的變更進行管理的系统，它可以幫助團隊更好的溝通協作，從而更好的進行交付。 常見的版本控制系統分為: 集中式版本控制系統，如: SVN 用主從式架構的作法 需要網路才可以工作，版本在中央服務器上 分布式版本控制系統 distributed version control，如: Git 它允許軟體開發者可以共同參與一個軟體開發專案，但是不必在相同的網路系統下工作 用對等網路的作法來處理版本控制 版本存在自己的 host 上，同時動到一個檔案時，互相給對方看，因此衍伸出遠端數據庫 前情提要: 這章主要在介紹 git 是什麼，以及其的用法，並介紹 github 一個遠端數據庫。也會概述一下 git 分支，可以如何使用。 # Git 是什麼？ Git 是一個軟體，可藉由它產生一個數據庫（repository），並且做到分散式版本控制。 以下幾個功能讓協同開發變得容易，例如: 多處放置同一份程式碼 歷史紀錄追蹤與回朔 版本控制系統 (Version Control System) – 管理你的程式碼版本反悔了回得去、合併了能處理、多人協作互不干擾 # GitHub 是什麼？ GitHub 是一個遠端數據庫，可用於檔案存放，並紀錄檔案版本，將本地端的數據庫存於遠端，達到共同開發的目的。 常見遠端數據庫 GitHub GitLab BitBucket # Git vs. GitHub? 一個是工具，一個是網站，GitHub 的本體是一個 Git Server。 # 沒有 Git? 當你好不容易寫完程式碼，卻被你的好同事 gank。😢","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"}],"tags":[]},{"title":"2622. Cache With Time Limit","slug":"coding/leetcode/Medium/2622-Cache-With-Time-Limit","date":"2023-05-18T02:45:47.000Z","updated":"2023-05-28T17:14:43.090Z","comments":true,"path":"coding/leetcode/Medium/2622-Cache-With-Time-Limit/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2622-Cache-With-Time-Limit/","excerpt":"","text":"⭐️⭐️⭐️⭐️ # 題目敘述 Write a class that allows getting and setting key-value pairs, however a time until expiration is associated with each key. The class has three public methods: set(key, value, duration) : accepts an integer key , an integer value , and a duration in milliseconds. Once the duration has elapsed, the key should be inaccessible. The method should return true if the same un-expired key already exists and false otherwise. Both the value and duration should be overwritten if the key already exists. get(key) : if an un-expired key exists, it should return the associated value. Otherwise it should return -1 . count() : returns the count of un-expired keys. # Example 1: Input: [&quot;TimeLimitedCache&quot;, &quot;set&quot;, &quot;get&quot;, &quot;count&quot;, &quot;get&quot;] [[], [1, 42, 100], [1], [], [1]] [0, 0, 50, 50, 150] Output: [null, false, 42, 1, -1] Explanation: At t=0, the cache is constructed. At t=0, a key-value pair (1: 42) is added with a time limit of 100ms. The value doesn't exist so false is returned. At t=50, key=1 is requested and the value of 42 is returned. At t=50, count() is called and there is one active key in the cache. At t=100, key=1 expires. At t=150, get(1) is called but -1 is returned because the cache is empty. # Example 2: Input: [&quot;TimeLimitedCache&quot;, &quot;set&quot;, &quot;set&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;, &quot;count&quot;] [[], [1, 42, 50], [1, 50, 100], [1], [1], [1], []] [0, 0, 40, 50, 120, 200, 250] Output: [null, false, true, 50, 50, -1] Explanation: At t=0, the cache is constructed. At t=0, a key-value pair (1: 42) is added with a time limit of 50ms. The value doesn't exist so false is returned. At t=40, a key-value pair (1: 50) is added with a time limit of 100ms. A non-expired value already existed so true is returned and the old value was overwritten. At t=50, get(1) is called which returned 50. At t=120, get(1) is called which returned 50. At t=140, key=1 expires. At t=200, get(1) is called but the cache is empty so -1 is returned. At t=250, count() returns 0 because the cache is empty. # 解題思路 # Solution var TimeLimitedCache = function() &#123; this.cache = new Map();&#125;;/** * @param &#123;number&#125; key * @param &#123;number&#125; value * @param &#123;number&#125; time until expiration in ms * @return &#123;boolean&#125; if un-expired key already existed */TimeLimitedCache.prototype.set = function(key, value, duration) &#123; const val = this.cache.get(key); if(val)&#123; clearTimeout(val.timeout); &#125; const timeout = setTimeout(() => this.cache.delete(key), duration); this.cache.set(key, &#123;value, timeout&#125;); return Boolean(val);&#125;;/** * @param &#123;number&#125; key * @return &#123;number&#125; value associated with key */TimeLimitedCache.prototype.get = function(key) &#123; return this.cache.has(key) ? this.cache.get(key).value : -1;&#125;;/** * @return &#123;number&#125; count of non-expired keys */TimeLimitedCache.prototype.count = function() &#123; return this.cache.size;&#125;;/** * Your TimeLimitedCache object will be instantiated and called as such: * var obj = new TimeLimitedCache() * obj.set(1, 42, 1000); // false * obj.get(1) // 42 * obj.count() // 1 */ class TimeLimitedCache &#123; cache: Map&lt;any, any>; constructor() &#123; this.cache = new Map(); &#125; set(key: number, value: number, duration: number): boolean &#123; const val: any = this.cache.get(key); if (val) &#123; clearTimeout(val.timeout); &#125; const timeout = setTimeout((): Boolean => this.cache.delete(key), duration); this.cache.set(key, &#123; value, timeout &#125;); return Boolean(val); &#125; get(key: number): number &#123; return this.cache.has(key) ? this.cache.get(key).value : -1; &#125; count(): number &#123; return this.cache.size; &#125;&#125;/** * Your TimeLimitedCache object will be instantiated and called as such: * var obj = new TimeLimitedCache() * obj.set(1, 42, 1000); // false * obj.get(1) // 42 * obj.count() // 1 */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"1557. Minimum Number of Vertices to Reach All Nodes","slug":"coding/leetcode/Medium/1557-Minimum-Number-of-Vertices-to-Reach-All-Nodes","date":"2023-05-18T01:57:45.000Z","updated":"2023-05-28T17:14:21.558Z","comments":true,"path":"coding/leetcode/Medium/1557-Minimum-Number-of-Vertices-to-Reach-All-Nodes/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1557-Minimum-Number-of-Vertices-to-Reach-All-Nodes/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a directed acyclic graph, with n vertices numbered from 0 to n - 1 , and an array edges where edges[i] = [fromi, toi] represents a directed edge from node fromi to node toi . Find the smallest set of vertices from which all nodes in the graph are reachable. It's guaranteed that a unique solution exists. Notice that you can return the vertices in any order. # Example 1: Input: n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]] Output: [0,3] Explanation: It's not possible to reach all the nodes from a single vertex. From 0 we can reach [0,1,2,5]. From 3 we can reach [3,4,2,5]. So we output [0,3]. # Example 2: Input: n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]] Output: [0,2,3] Explanation: Notice that vertices 0, 3 and 2 are not reachable from any other node, so we must include them. Also any of these vertices can reach nodes 1 and 4. # 解題思路 # Solution import java.util.ArrayList;import java.util.HashSet;import java.util.List;import java.util.Set;class Solution &#123; public List&lt;Integer> findSmallestSetOfVertices(int n, List&lt;List&lt;Integer>> edges) &#123; Set&lt;Integer> link = new HashSet&lt;>(); for (List&lt;Integer> edge : edges) &#123; link.add(edge.get(1)); &#125; List&lt;Integer> ans = new ArrayList&lt;>(); for (int i = 0; i &lt; n; i++) &#123; if (!link.contains(i)) &#123; ans.add(i); &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"}]},{"title":"2636. Promise Pool","slug":"coding/leetcode/Medium/2636-Promise-Pool","date":"2023-05-17T01:55:36.000Z","updated":"2023-05-28T17:14:50.972Z","comments":true,"path":"coding/leetcode/Medium/2636-Promise-Pool/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2636-Promise-Pool/","excerpt":"","text":"⭐️ # 題目敘述 Given an array of asyncronous functions functions and a pool limit n , return an asyncronous function promisePool . It should return a promise that resolves when all the input functions resolve. Pool limit is defined as the maximum number promises that can be pending at once. promisePool should begin execution of as many functions as possible and continue executing new functions when old promises resolve. promisePool should execute functions[i] then functions[i + 1] then functions[i + 2] , etc. When the last promise resolves, promisePool should also resolve. For example, if n = 1 , promisePool will execute one function at a time in series. However, if n = 2 , it first executes two functions. When either of the two functions resolve, a 3rd function should be executed (if available), and so on until there are no functions left to execute. You can assume all functions never reject. It is acceptable for promisePool to return a promise that resolves any value. # Example 1: Input: functions = [ () =&gt; new Promise(res =&gt; setTimeout(res, 300)), () =&gt; new Promise(res =&gt; setTimeout(res, 400)), () =&gt; new Promise(res =&gt; setTimeout(res, 200)) ] n = 2 Output: [[300,400,500],500] Explanation: Three functions are passed in. They sleep for 300ms, 400ms, and 200ms respectively. They resolve at 300ms, 400ms, and 500ms respectively. The returned promise resolves at 500ms. At t=0, the first 2 functions are executed. The pool size limit of 2 is reached. At t=300, the 1st function resolves, and the 3rd function is executed. Pool size is 2. At t=400, the 2nd function resolves. There is nothing left to execute. Pool size is 1. At t=500, the 3rd function resolves. Pool size is zero so the returned promise also resolves. # Example 2: Input: functions = [ () =&gt; new Promise(res =&gt; setTimeout(res, 300)), () =&gt; new Promise(res =&gt; setTimeout(res, 400)), () =&gt; new Promise(res =&gt; setTimeout(res, 200)) ] n = 5 Output: [[300,400,200],400] Explanation: The three input promises resolve at 300ms, 400ms, and 200ms respectively. The returned promise resolves at 400ms. At t=0, all 3 functions are executed. The pool limit of 5 is never met. At t=200, the 3rd function resolves. Pool size is 2. At t=300, the 1st function resolved. Pool size is 1. At t=400, the 2nd function resolves. Pool size is 0, so the returned promise also resolves. # Example 3: Input: functions = [ () =&gt; new Promise(res =&gt; setTimeout(res, 300)), () =&gt; new Promise(res =&gt; setTimeout(res, 400)), () =&gt; new Promise(res =&gt; setTimeout(res, 200)) ] n = 1 Output: [[300,700,900],900] Explanation: The three input promises resolve at 300ms, 700ms, and 900ms respectively. The returned promise resolves at 900ms. At t=0, the 1st function is executed. Pool size is 1. At t=300, the 1st function resolves and the 2nd function is executed. Pool size is 1. At t=700, the 2nd function resolves and the 3rd function is executed. Pool size is 1. At t=900, the 3rd function resolves. Pool size is 0 so the returned promise resolves. # 解題思路 # Solution /** * @param &#123;Function[]&#125; functions * @param &#123;number&#125; n * @return &#123;Function&#125; */var promisePool = async function (functions, n) &#123; const nextPromise = async function next() &#123; if (functions.length == 0)&#123; return ; &#125; const fn = functions.shift(); await fn(); await next(); &#125; const ans = Array(n).fill(null).map(nextPromise); return await Promise.all(ans);&#125;;/** * const sleep = (t) => new Promise(res => setTimeout(res, t)); * promisePool([() => sleep(500), () => sleep(400)], 1) * .then(console.log) // After 900ms */ type F = () => Promise&lt;any>;function promisePool(functions: F[], n: number): Promise&lt;any> &#123; const nextPromise = async function next():Promise&lt;any> &#123; if(functions.length == 0)&#123; return ; &#125; const fn: Function = functions.shift(); await fn(); await next(); &#125; const ans: Promise&lt;any>[] = Array(n).fill(null).map(nextPromise); return Promise.all(ans);&#125;;/** * const sleep = (t) => new Promise(res => setTimeout(res, t)); * promisePool([() => sleep(500), () => sleep(400)], 1) * .then(console.log) // After 900ms */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"2130. Maximum Twin Sum of a Linked List","slug":"coding/leetcode/Medium/2130-Maximum-Twin-Sum-of-a-Linked-List","date":"2023-05-17T01:29:29.000Z","updated":"2023-05-28T17:14:27.773Z","comments":true,"path":"coding/leetcode/Medium/2130-Maximum-Twin-Sum-of-a-Linked-List/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2130-Maximum-Twin-Sum-of-a-Linked-List/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 In a linked list of size n , where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 &lt;= i &lt;= (n / 2) - 1 . For example, if n = 4 , then node 0 is the twin of node 3 , and node 1 is the twin of node 2 . These are the only nodes with twins for n = 4 . The twin sum is defined as the sum of a node and its twin. Given the head of a linked list with even length, return the maximum twin sum of the linked list. # Example 1: Input: head = [5,4,2,1] Output: 6 Explanation: Nodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6. There are no other nodes with twins in the linked list. Thus, the maximum twin sum of the linked list is 6. # Example 2: Input: head = [4,2,2,3] Output: 7 Explanation: The nodes with twins present in this linked list are: Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7. Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4. Thus, the maximum twin sum of the linked list is max(7, 4) = 7. # Example 3: ![](https://assets.leetcode.com/uploads/2021/12/03/eg3drawio.png =300x) Input: head = [1,100000] Output: 100001 Explanation: There is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001. # 解題思路 # Solution // Definition for singly-linked list.import java.util.Deque;import java.util.LinkedList;public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; class Solution &#123; public int pairSum(ListNode head) &#123; Deque&lt;Integer> dq = new LinkedList&lt;>(); ListNode curr = new ListNode(); curr = head; while(curr != null)&#123; dq.add(curr.val); curr = curr.next; &#125; int max = Integer.MIN_VALUE; while(!dq.isEmpty() &amp;&amp; dq.size() >= 2)&#123; max = Math.max(max, dq.pollFirst() + dq.pollLast()); &#125; return max; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Linked-List/"}]},{"title":"Docker Practise - 2","slug":"computer-science/DevOps/Docker/Docker-Practise-2","date":"2023-05-16T11:41:31.000Z","updated":"2023-06-20T14:43:02.611Z","comments":true,"path":"computer-science/DevOps/Docker/Docker-Practise-2/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/Docker-Practise-2/","excerpt":"","text":"# 實作說明 在前一個實作中我們先創建了一個 images ubuntu ，在裡面安裝 nginx ，但其實我們只需要使用 nginx 而已，並不需要 ubuntu 這個作業系統。 所以接下來我們要實作撰寫一個 Dockerfile，在自己的專案中，run Dockerfile 進行部屬，而且不包含 ubuntu。 # 撰寫一個 Project 當然要現在馬上生出一個 project 有點費時，所以如果手邊沒有撰寫好的 project 也沒關係，接下來分兩部分來說: 已經有可以實作的 project 這個就很簡單，先進入 project 的資料夾。 沒有可實作的 project 這個其實也不難，創建一個新資料夾，名稱隨意，如果想不到可以用: [docker-test]，在裡面撰寫一個 index.html 。 以下是個簡單的 html 可以參考: index.html&lt;h1>My Project&lt;/h1> # 撰寫 nignx.conf 這個其實沒寫也沒關係，沒有寫就是原本 nignx.conf 的預設，寫了可以更改其原本預設。 server&#123; listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; index index.html; charset utf-8; access_log /var/log/nginx/access_log; error_log /var/log/nginx/error_log; &#125; 內容細節說明可以去看 docker practise - 1，那邊有稍微說明一下內容涵意。 # 創建一個 Dockerfile 的檔案 創建一個 Dockerfile 檔，沒有副檔名，純檔案。 Dockerfile 內容如下: FROM nginxMAINTAINER HsingYu# 複製一整個在根目錄專案的檔案進去COPY / /usr/share/nginx/html# 如果只有一個檔案，如: index.html 可以寫 # COPY index.html /usr/share/nginx/html# 把 nignx.conf 加入預設 conf 裡面COPY nginx.conf /etc/nginx/conf.d/default.conf# 容器對外連接 80 portEXPOSE 80這樣就完成撰寫 Dockerfile 了。 # 利用 Dockerfile 建立 images docker bulid -t [&quot;images name&quot;] . -t : 後面接為 images 命名的名稱，注意不可以是大寫字母，要是小寫喔～～ . : 指在這個地方下的 Dockerfile 建立完成會如下圖: # 執行建立的 images docker run -p 80:80 [&quot;images name&quot;] -p : 後面寫通信的 port 80:80 : 為了方便區分冒號 (:) 前後 port 代表的不同意思，接下來會以 8080:80 來解釋，容器將在端口 8080 上的主機上可用，但它與端口 80 上的容器（和應用程序）通信，簡單來說就是在 bowser 中輸入容器運行所在的 Docker 主機的 DNS 名稱或者 IP 位址，並在後面加上 port 8080，例如: localhost:8080 執行成功會如下圖: localhost port 80 不用特別寫，localhost:80 =&gt; localhost","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"}]},{"title":"Docker Practise - 1","slug":"computer-science/DevOps/Docker/Docker-Practise-1","date":"2023-05-16T11:32:34.000Z","updated":"2023-06-20T14:42:59.535Z","comments":true,"path":"computer-science/DevOps/Docker/Docker-Practise-1/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/Docker-Practise-1/","excerpt":"","text":"# 實作說明 當一個軟體完成後要進行發布網站，我們並不會使用絕對路徑，顯示檔案位置，會使用取得主機（hosting）和網域名稱（domain name）的方式來達到。 而他人只需要訪問你的 hosting IP 或為其申請的 domain name 來 request 資料。 而常見的有兩種工具來做: Apache nginx 舉個大家比較熟悉的例子就是 xampp， 可以將檔案丟進去，訪問 localhost 進行訪問。 但是因為 xampp 是一個類似於 LAMP 的環境， 他除了 Apache 以外，還包含了 phpmyadmin、PHP、Perl 等其他東西， 如果不需要用到 php 等東西，就會比較沒有必要。 # 創建一個 docker images ubuntudocker run -it -p 80:80 ubuntu:focal bash # 更新 apt apt update # 下載 nginx apt install nginx # 開啟 nginx nginx -s reload # 可能出現錯誤資訊: nginx: [error] open() &quot;/var/run/nginx.pid&quot; failed (2: No such file or directory) 解決方法: 輸入以下指令 nginx -c /etc/nginx/nginx.conf 查看 /etc/nginx/nginx.conf 修改內容 nano /etc/nginx/nginx.conf 將其中內容修改成下方 pid /var/run/nginx.pid; #pid /run/nginx.pid; pid /var/run/nginx.pid; 再試一次 nginx -s reload # 網頁連接設定 nano /etc/nginx/sites-available/default port 連接設定 根目錄檔案位置 預先載入檔案 server_name 用於設定 DNS 域名 # 最後將 APP 檔案加入根目錄檔案位置 原本顯示完整檔案位置 經過修改剩下 locolhost = 127.0.0.1 ^D = exit : 離開 container 如果在 Terminal 無法離開 container 再開起一個 Terminal docker ps : 檢查還未關閉的 container docker stop [container ID] : 這裡 container ID 可以打前兩個字就好","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"}]},{"title":"Docker Compose","slug":"computer-science/DevOps/Docker/Docker-Compose","date":"2023-05-16T11:29:28.000Z","updated":"2023-06-20T14:42:52.556Z","comments":true,"path":"computer-science/DevOps/Docker/Docker-Compose/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/Docker-Compose/","excerpt":"","text":"# Docker Compose # 為什麼要用 Docker Compose? 之前有介紹過使用 docker run 指令就可以把 Docker Container 啟動起來，但是如果我們要啟動很多個 Docker Container 時，就需要輸入很多次 docker run 指令。 另外 container 和 container 之間要做關聯的話也要記得它們之間要如何的連結 (link) Container，這樣在要啟動多個 Container 的情況下，就會顯得比較麻煩。 # 如何運作？ Docker-Compose: 寫一個 docker-compose.yml ，把所有要使用 Docker Image 寫上去，也可以把 Container 之間的關係連結 (link) 起來。 最後只要下 docker-compose up 指令，就可以把所有的 Docker Container 執行起來，這樣就可以很快速和方便的啟動多個 container。 # Docker Compose 常用指令 # 啟動所有的 Docker Container $ docker-compose up # 查看 Docker Container 的執行狀態 $ docker-compose ps # 看執行的 log $ docker-compose logs # 停止 docker-compose 執行的所有 Container $ docker-compose stop # 刪除 docker-compose 的所有 Container $ docker-compose rm # Docker Compose 實作 實作的部份主要就是要把 Docker-Compose 安裝起來 然後撰寫一個 docker-compose.yml 並且使用 docker-compose up ，指令把所有的 Docker Container 啟動起來 # 安裝 Docker-Compose # cd /usr/bin # wget https://github.com/docker/compose/releases/download/1.18.0/docker-compose-Linux-x86_64 # mv docker-compose-Linux-x86_64 docker-compose # chmod 755 docker-compose # 撰寫 docker-compose.yml version: '2' services: db: image: mysql environment: MYSQL_ROOT_PASSWORD: 123456 admin: image: adminer ports: - 8080:8080 主要的功能是要啟動 2 個 Docker Container，一個是 mysql 的 Container，另外一個是 admin 管理 mysql Web UI 的 container MYSQL_ROOT_PASSWORD 的環境變數用來設定登入 mysql 的密碼 參考網站: https://hub.docker.com/_/mysql/ # 啟動所有的 Docker Container $ docker-compose up -d -d 參數代表要執行在背景的方式 # 查看 Docker Container 的執行狀態 $ docker-compose ps # admin 執行 http://localhost:8080 其他指令可以參考官方網站: https://docs.docker.com/compose/compose-file/compose-file-v2/ # 參考文章 iT邦幫忙/@yangj26952 使用 Docker-Compose 啟動多個 Docker Container","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"}]},{"title":"Dockerfile","slug":"computer-science/DevOps/Docker/Docker_file","date":"2023-05-16T11:11:57.000Z","updated":"2023-06-20T14:42:49.497Z","comments":true,"path":"computer-science/DevOps/Docker/Docker_file/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/Docker_file/","excerpt":"","text":"# Dockerfile Dockerfile 由一行行命令語句組成，並且支援以 # 開頭的註解行。 Dockerfile 分為四部分： 基底映像檔資訊 維護者資訊 映像檔操作指令 容器啟動時執行指令。 # This dockerfile uses the ubuntu image # VERSION 2 - EDITION 1 # Author: docker_user # Command format: Instruction [arguments / command] .. # 基本映像檔，必須是第一個指令 FROM ubuntu# 維護者： docker_user &lt;docker_user at email.com> (@docker_user) MAINTAINER docker_user docker_user@email.com # 更新映像檔的指令 RUN echo \"deb http://archive.ubuntu.com/ubuntu/ raring main universe\" >> /etc/apt/sources.list RUN apt-get update &amp;&amp; apt-get install -y nginx RUN echo \"\\ndaemon off;\" >> /etc/nginx/nginx.conf # 建立新容器時要執行的指令 CMD /usr/sbin/nginx# Dockerfile 基本語法 # Example FROM centos:7MAINTAINER jackRUN yum install -y wgetRUN cd /ADD jdk-8u152-linux-x64.tar.gz /RUN wget http://apache.stu.edu.tw/tomcat/tomcat-7/v7.0.82/bin/apache-tomcat-7.0.82.tar.gzRUN tar zxvf apache-tomcat-7.0.82.tar.gzENV JAVA_HOME=/jdk1.8.0_152ENV PATH=$PATH:/jdk1.8.0_152/binCMD [\"/apache-tomcat-7.0.82/bin/catalina.sh\", \"run\"] FROM： 使用到的 Docker Image 名稱，今天使用 CentOS MAINTAINER： 用來說明，撰寫和維護這個 Dockerfile 的人是誰，也可以給 E-mail 的資訊 RUN： RUN 指令後面放 Linux 指令，用來執行安裝和設定這個 Image 需要的東西 ADD： 把 Local 的檔案複製到 Image 裡，如果是 tar.gz 檔複製進去 Image 時會順便自動解壓縮。Dockerfile 另外還有一個複製檔案的指令 COPY 未來還會再介紹 ENV： 用來設定環境變數 CMD： 在指行 docker run 的指令時會直接呼叫開啟 Tomcat Service # Dockerfile 實作 已經體驗過使用 Docker 的指令，把 Docker Image Pull 到 local，並且執行 container，然後在 container 上安裝 HTTP Service，就類似是在使用 VM。 直接進入 Docker Container 裡面下一些指令安裝程式和改設定檔，不夠自動化，可能需要常常的重覆在做同一件事，這樣會很沒效率。 寫 Dockerfile，只要下 docker build 的指令就可以把 Docker Image 建構起來，未來要使用就直接 Run 此 Image。 # 實作目標: 要做到在 Dockerfile 裡面，撰寫安裝 Java 和 Tomcat 的指令，包成 Docker Image， 之後只要呼叫到 docker run 指令，就可以把 Tomcat Service 啟動起來。 主要目的用來體驗如何撰寫 Dockerfile 和 Build Image 以及執行 Docker container。 記住要使用 WSL2 此虛擬機 來實作 Docker 可參考前面 安裝 Windows，或以下訊息 Docker 並非是一个通用的容器工具，它依賴於已存在並運行的 Linux 内核環境。 在 Windows 上部署 Docker 的方法都是先安装一个虛擬機，並在安装 Linux 系統的的虛擬機中運行 Docker。 # 第一步: 建立 Dockerfile 建立寫 Dockerfile 會用到的資料夾，指令如下 $ mkdir docker-test $ cd docker-test 下載 JDK 的安裝檔放在 docker-test 資料夾裡，使用的版本是 jdk-19.0.2 下載連結 https://download.java.net/java/GA/jdk19.0.2/fdb695a9d9064ad6b064dc6df578380c/7/GPL/openjdk-19.0.2_linux-x64_bin.tar.gz sudo apt install 將檔案移至路徑 \\wsl$\\Ubuntu\\home\\[user name]\\docker-test 撰寫 Dockerfile $ vi Dockerfile Dockerfile 的內容如下 FROM centos:7MAINTAINER HsingYu# 安裝 wget，yum 是 centos 的安裝指令RUN yum install -y wgetRUN cd /# 加入 jdk-19.0.2 壓縮檔案，加入後會自動解壓縮ADD openjdk-19.0.2_linux-x64_bin.tar.gz /# 下載 apache-tomcat-10.1.7.tar.gzRUN wget --no-check-certificate https://dlcdn.apache.org/tomcat/tomcat-10/v10.1.7/bin/apache-tomcat-10.1.7.tar.gz# 解壓縮 apache-tomcat-10.1.7.tar.gzRUN tar zxvf apache-tomcat-10.1.7.tar.gz# 設置 java 的環境變數ENV JAVA_HOME=/jdk-19.0.2ENV PATH=$PATH:/jdk-19.0.2/binCMD [\"/apache-tomcat-10.1.7/bin/catalina.sh\", \"run\"] 撰寫完 Dockerfile 之後資料夾的結構如下圖 或者將下載 jdk19.0.2 也寫入 Dockerfile FROM centos:7MAINTAINER HsingYuRUN yum install -y wgetRUN cd /RUN wget https://download.java.net/java/GA/jdk19.0.2/fdb695a9d9064ad6b064dc6df578380c/7/GPL/openjdk-19.0.2_linux-x64_bin.tar.gzRUN tar zxvf openjdk-19.0.2_linux-x64_bin.tar.gzRUN wget --no-check-certificate https://dlcdn.apache.org/tomcat/tomcat-10/v10.1.7/bin/apache-tomcat-10.1.7.tar.gzRUN tar zxvf apache-tomcat-10.1.7.tar.gzENV JAVA_HOME=/jdk-19.0.2ENV PATH=$PATH:/jdk-19.0.2/binCMD [\"/apache-tomcat-10.1.7/bin/catalina.sh\", \"run\"] # 第二步: Build Docker Image 預設在和 Dockerfile 檔案同層的資料夾底下輸入， docker build 指令，如下 $ docker build -t mytomcat . --no-cache 使用 --no-cache 的主要原因，是避免在 Build Docker image 時被 cache 住，而造成沒有 build 到修改過的 Dockerfile。 Build 完的結果如下圖： Build 完 Docker Image 之後，使用 docker images 指令查看是否有 build 成功如下圖 # 第三步: 在 Build 完 Docker Image 之後就可以執行 Docker Container，這時 Tomcat 的 Service 也會跟者被執行起來，指令如下 在瀏覽器跑 $ docker run -p 8080:8080 mytomcat 在虛擬機跑 $ docker run mytomcat Tomcat Service 會被執行起來的主要原因是在 Dockerfile 裡面有寫 CMD 指令，呼叫啟動 Tomcat Service # 第四步: 打開 Browser 確認 要打開 Browser 確認 Tomcat Service 有沒有被執行起來時，發現我們不知道 Docker Container 的 IP，這時侯只能使用 docker exec 進入 docker container 查詢 IP 。 要使用 docker exec 指令之前需要先知道 Container 的 ID 所以需要先使用 docker ps 指令查詢 Container ID，如下圖： 有了 IP 之後就可以打開 Browser 輸入 http://172.17.0.2:8080 URL 的位置，確認 Tomcat Service 是否有啟動，如下圖： 直接進入 Docker Container 去看 IP 的位址其實有點麻煩，會故意這樣 Daemon 主要的原因，是讓大家了解到我們把 Docker Container 執行啟來時並不會知道它的 IP 位址在哪，這需要透過設定有關於 Docker 的 Network 來解決這個問題。 目前使用最簡單的方法，就是在 run docker container 時用 Port 的 Mapping 來解決此問題，重新再一次 run docker container，指令如下： $ docker run -p 8080:8080 mytomcat Container 的 8080 port mapping 到 localhost 的 8080 port ，這樣只要輸入 http://localhost:8080 就可以看到 tomcat service 的 WebUI 畫面了。 # 參考文章 iT邦幫忙/@yangj26952 實作撰寫第一個 Dockerfile","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"}]},{"title":"基礎指令","slug":"computer-science/DevOps/Docker/基礎指令","date":"2023-05-16T10:57:42.000Z","updated":"2023-06-20T14:42:37.079Z","comments":true,"path":"computer-science/DevOps/Docker/基礎指令/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/%E5%9F%BA%E7%A4%8E%E6%8C%87%E4%BB%A4/","excerpt":"","text":"# 基礎指令 # Image 映像檔 常用指令 指令 說明 範例 search 搜尋 docker search [image_name] pull 下載 docker pull [image_name] images 查看目前 images (列表) docker images run 執行 docker run [-ti] [centos] [/bin/bash] rmi [image ID] 刪除 docker rmi [615cb40d5d19] build 建立 docker build [-t project .] login 登入 docker login [docker.okborn.com] push 上傳 docker push # Container 容器 常用指令 # Registry 倉庫 常用指令 # 基礎指令實作 # 實作目標： 先從 Docker Hub 上把 Ubuntu OS 的 image pull 到 local， 有了 image 之後就可以把 Docker container 執行起來， 然後進入到 container 裡面安裝和啟動 Apache 的 HTTP Service， 並且寫一個有 HelloWorld 字串的 HTML 檔案。 最後使用 Browser 連到 Docker Container 裡面的 HTTP Service， 確認 HelloWorld 的字串能正常的顯示出來。 # 實作的流程如下： 從 Docker Hub 下載 Docker Image 到 local 使用 Docker Image 啟動 Docker Container 並進入 Docker Container 的 terminal 在 Docker Container 裡面安裝 Apache 的 HTTP Service，並且寫一個 helloworld 的 html 檔 使用 Browser 連到 helloworld.html 確認 Docker Container 有成功的被啟動起來 # 第一步: 從 Docker Hub 下載 Docker Image 到 local 要下載 Docker Image 之前需要先搜尋一下，Docker Image 的 Name 是什麼，指令如下： $ docker search ubuntu -f is-official=true is-official=true 表示要搜尋是官方的 Docker image 就選擇星星數最多的 Name 為 ubuntu 找到了 ubuntu 的 Docker Image Name 之後，就可以把此 image pull 下來，指令如下： $ docker pull ubuntu 執行結果如下圖 要再一次確認 ubuntu 的 docker image 有沒有下載下來，可以使用以下的指令 $ docker images 執行結果如下圖 # 第二步: 有了 Docker Image 之後就可以把 container 執行起來了，並且進入 Docker Container 的 terminal 裡面 指令如下 $ docker run -it -p 8000:80 ubuntu /bin/bash 使用以上的指令就可以進入了 docker container 裡面的 terminal 可以再打開另外一個 terminal 視窗，輸入以下指令 $ docker ps -a 確認 docker container 有正常的執行，如下圖： 在要離開 docker container 的 terminal 時有一個坑。就是如果輸入 exit 指令時，container 會被關閉，如下圖： 如果不要停止 container 而要退出 docker container 的 terminal 需要輸入 ctrl + p 之後再輸入 ctrl + q 的按鍵，就不會把 container 關閉。 # 第三步: 在 docker container 裡面安裝和啟動 apache 的 http service，指令如下: root@a03f4fc98ea2:/# apt-get update root@a03f4fc98ea2:/# apt-get install -y apache2 root@a03f4fc98ea2:/# service apache2 start if it is success will show 簡單寫一個 hellowolrd.html 檔案放在 /var/www/html 的路徑下，指令如下: root@a03f4fc98ea2:/# echo &quot;HelloWorld&quot; &gt; /var/www/html/helloworld.html 使用 cat /etc/hosts 指令查看 docker container 的 IP 如下圖： 如果想要使用 ifconfig 指令，需要安裝 net-tools 工具指令如下: root@a03f4fc98ea2:/# apt-get install -y net-tools # 第四步: 使用 Linux 虛擬機 GUI browser 輸入 http://172.17.0.2/helloworld.html 的 URL 查看 helloworld.html 的檔案是否能正常的顯示。 使用 Window 本機的 browser 輸入 http://localhost:8000/helloworld.html 的 URL 查看 helloworld.html 的檔案是否能正常的顯示，畫面如下： # 參考文章 iT邦幫忙/@yangj26952 用簡單的例子來說明如何使用 Docker 指令","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"}]},{"title":"Docker-安裝","slug":"computer-science/DevOps/Docker/Docker-安裝","date":"2023-05-16T10:33:53.000Z","updated":"2023-06-20T14:44:05.007Z","comments":true,"path":"computer-science/DevOps/Docker/Docker-安裝/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/Docker-%E5%AE%89%E8%A3%9D/","excerpt":"","text":"# Windows Docker 並非是一个通用的容器工具，它依賴於已存在並運行的 Linux 内核環境。 在 Windows 上部署 Docker 的方法都是先安装一个虛擬機，並在安装 Linux 系統的的虛擬機中運行 Docker。 # 使用 WSL 在 Windows 上安裝 Linux 開發人員可以在 Windows 電腦上同時存取 Windows 和 Linux 的功能。 Windows 子系統 Linux 版 (WSL) 可讓開發人員直接在 Windows 上安裝 Linux 散發套件， (例如 Ubuntu、OpenSUSE、Type、Debian、Arch Linux 等) 並使用 Linux 應用程式、公用程式和 Bash 命令列工具，不需要傳統虛擬機器或雙佈設定的額外負荷。 # 必要條件 您必須 Windows 10 版本 2004 和更新版本執行， (組建 19041 和更新版本) 或 Windows 11。 檢查更新。 # 安裝 WSL 命令 開啟 PowerShell 或 Windows 命令提示字元 (cmd)，輸入命令，然後重新開機電腦。 wsl --install 啟用選用的 WSL 和虛擬機器平台元件 下載並安裝最新的 Linux 核心 將 WSL 2 設定為預設值 可能需要下載並安裝 Ubuntu Linux 發行版本 (重新開機) 您必須在此安裝程式期間重新開機電腦 若已有其他版本，可以以此指令來下載 Ubuntu wsl --install -d Ubuntu # 檢查 WSL 狀態 wsl --status 使用 wsl --install 命令安裝的新 Linux 安裝預設會設定為 WSL 2。 # 開啟 WSL wsl.exe # 設定 Linux 使用者名稱和密碼 系統會要求您為 Linux 發行版本建立使用者名稱和密碼。 此使用者名稱和密碼是每個各自 Linux 發行版本專屬，不會影響您的 Windows 使用者名稱。 請注意，在輸入 密碼時，畫面上不會顯示任何專案。 這稱為盲目輸入。 您不會看到您輸入的內容，這完全正常。 一旦您建立使用者名稱和密碼，帳戶就會是您散發套件的預設使用者，而且會在啟動時自動登入。 此帳戶將會被視為 Linux 系統管理員，並且能夠執行 sudo (超級使用者執行) 系統管理命令。 在 WSL 上執行的每個 Linux 發行版本都有自己的 Linux 使用者帳戶和密碼。 每當您新增散發套件、重新安裝或重設時，都必須設定 Linux 使用者帳戶。 若要變更或重設密碼，請開啟 Linux 發行版本，然後輸入命令： passwd 。 系統會要求您輸入目前的密碼，然後要求您輸入新密碼，然後確認您的新密碼。 # 使用 Docker 設定遠端開發容器 使用 WSL 2 (Windows 子系統 Linux 版 版本 2) 設定適用于 Windows 的 Docker Desktop。 # 必要條件 安裝 WSL，並為在 WSL 2 中執行的 Linux 發行版本設定使用者名稱和密碼。 安裝 Visual Studio Code (選擇性)。 這會提供最佳體驗，包括能夠在遠端 Docker 容器內撰寫程式碼和偵錯，並聯機到您的 Linux 散發套件。 安裝 Windows 終端機 (選擇性)。 這可提供最佳體驗，包括在同一個介面中自訂和開啟多個終端機的能力， (包括 Ubuntu、Debian、PowerShell、Azure CLI，或任何您想要使用)。 在 Docker Hub 註冊 Docker 識別碼， (選擇性)。 # 安裝 Docker Desktop 請先到 Docker 官網 https://www.docker.com/docker-windows 在 cmd 上輸入以下指令可以確認是否下載成功 開啟 Docker Desktop 確定已核取 [設定&gt; 一般] 中的 [使用 WSL 2 型引擎]。 移至 [設定&gt; 資源 &gt; WSL 整合]，從您想要啟用 Docker 整合的已安裝 WSL 2 散發套件中選取。 若要確認已安裝 Docker，請開啟 WSL 散發套件 (例如 Ubuntu) ，並輸入下列命令來顯示版本和組建編號： docker --version # 使用下列方式執行簡單的內建 Docker 映射，以測試您的安裝是否正常運作： docker run hello-world # 尋找 Docker 映射儲存體資料夾 Docker 會建立兩個散發資料夾來儲存資料： \\wsl$\\docker-desktop \\wsl$\\docker-desktop-data 您可以開啟 WSL Linux 發行版本並輸入： explorer.exe . 在 Windows 檔案總管中檢視資料夾，以找到這些資料夾。 輸入： \\\\wsl$","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Windows/"}]},{"title":"虛擬化技術","slug":"computer-science/DevOps/Docker/虛擬化技術","date":"2023-05-16T08:52:42.000Z","updated":"2023-06-20T14:42:43.555Z","comments":true,"path":"computer-science/DevOps/Docker/虛擬化技術/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/%E8%99%9B%E6%93%AC%E5%8C%96%E6%8A%80%E8%A1%93/","excerpt":"","text":"# 虛擬化技術 虛擬化要解決的問題是:「當我寫了一個程式，在我電腦上可以執行，但在別人電腦上就不行」。 # But why? 作業系統不同 硬體配置不同 簡單來說：我的程式可能剛好只跟我的電腦的環境相容。😢 # 何謂虛擬化技術？ 而虛擬化要做的就是模擬出一個環境，讓程式可以在不同硬體或作業系統上執行時，都以為自己在同一個環境中執行，以此來避免前面所述的問題。 目前常見用來比較的虛擬化技術有兩種: 在系統層級的虛擬化技術，稱虛擬機器（Virtual machine） 例如 : Virtual Box 。 在作業系統層級技術，此稱容器（Container） 例如 : Docker 。 # 虛擬機器 以作業系統為中心 傳統虛擬化的目標： 將一個應用程式所需的執行環境打包起來，建立一個獨立環境，方便在不同的硬體中移動。 虛擬機器是在系統層上虛擬化， 簡單來說， Virtual Box 就是一個可以讓你在作業系統（Host OS）上面再裝一個作業系統（Guest OS），然後讓兩個作業系統彼此不會打架的平台。 # 容器 以應用程式為中心 容器化的目標： 改善虛擬機器因為需要裝 Guest OS 導致啟動慢、佔較大記憶體的問題。 容器是在作業系統層上虛擬化， 透過 Container Manager 直接將一個應用程式所需的程式碼、函式庫打包， 建立資源控管機制隔離各個容器，並分配 Host OS 上的系統資源。 透過容器，應用程式不需要再另外安裝作業系統（Guest OS）也可以執行。 # VM vs. CONTAINER","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[]},{"title":"Docker Information","slug":"computer-science/DevOps/Docker/Docker-Information","date":"2023-05-16T07:52:43.000Z","updated":"2023-06-20T14:42:56.141Z","comments":true,"path":"computer-science/DevOps/Docker/Docker-Information/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/Docker-Information/","excerpt":"","text":"# 簡介 # 什麼是 Docker? Docker 是一個開源軟體，出現於 2013 年初，最初是 Dotcloud 公司內部的 Side-Project。 它基於 Google 公司推出的 Go 語言實作。(Dotcloud 公司後來改名為 Docker) # 為什麼要使用 Docker? 更有效率的利用資源 統一環境 對於 DevOps 的好處 使開發高效且可以預測 消除了重複的、平凡的配置任務，在整個開發生命週期中用於快速、簡單和可移植的應用程序開發。 Docker 想解決的問題: 改善傳統虛擬機器因為需要額外安裝作業系統（Guest OS），導致啟動慢、佔較大記憶體的問題。 Docker 要提供的解法： 以應用程式為核心虛擬化，取代傳統需要 Guest OS 的虛擬化技術。 # 概念 Docker 是一種工具，可用來建立、部署及執行使用容器的應用程式。 容器可讓開發人員封裝含有其所需全部元件 (程式庫、架構、相依性等) 的應用程式，且全部以一個套件的形式出貨。 使用容器可確保應用程式會以相同的方式執行，而不管任何自訂的設定或先前在執行該應用程式的電腦 (可能與用來撰寫和測試應用程式程式碼的電腦不同) 上安裝的程式庫。 這可讓開發人員專注於撰寫程式碼，而不需擔心程式碼將在其上執行的系統。 # Docker 三元素 要使用 Docker 時最重要的三個元素： 映像檔 (Image)、 容器 (Container)、 倉庫 (Repository)。 用一個簡單的比喻來解釋 : 如果映像檔是一個做蛋糕的模具，容器則是用該模具烤出來的蛋糕，而倉庫是用來集中放置模具們的收納櫃。 # Image 映像檔為一個唯獨的模板。 內可包含完整的 ubuntu 作業系統環境。 映像檔可用來快速生產 Docker 容器，並可重複產生。 映像檔可以透過 (撰寫由命令行構成的) Dockerfile 建立，或是開放公開下載的地方取得。 舉例來說，如果我今天想要一個 node.js 的執行環境跑我寫好的程式，我可以直接到上 Docker Hub 找到相對應的 node.js 映像檔 ，而不需要自己想辦法打包一個執行環境。 它是 Docker 的映像檔主要是一個唯讀的檔案， 是啟動 Docker container 要使用到的檔案。 另外 Docker 的 image 可以像是堆積木一樣， 一層一層的把 Docker image 堆起來。 如右圖： # Container 容器是由映像檔建立出來的實例。 Docker 即是利用容器來執行關鍵技術。 容器可以被啟動、開始、停止、刪除。 且容器與容器之間是相互隔離、保證安全的。 可以把容器看做是一個執行的應用程式加上執行它的簡易版 Linux 環境（包括 root 使用者權限、程式空間、使用者空間和網路空間等） Docker Container 是透過 Docker image 執行起來的 Process，同一個 Docker image 可以啟動多個 Docker Container。 Docker container 和 Docker container 之間的環境是隔離開離來的，不會發生 container1 開 8080 的 port，container2 開 8080 的 port 有衝到的問題 # Repository 倉庫是集中存放映像檔檔案的場所，每個倉庫中又包含了多個映像檔。 每個映像檔有不同的標籤（tag）。 倉庫分為公開倉庫（Public）和私有倉庫（Private）兩種形式 而最大的公開倉庫為 Docker Hub，裡面存放了大量的現成、實用映像檔供使用者下載。 而 Docker 倉庫註冊伺服器的概念就跟 Github 類似，你可以在上面建立多個倉庫，然後透過 push、pull 的方式上傳、存取。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[]},{"title":"2637. Promise Time Limit","slug":"coding/leetcode/Easy/2637-Promise-Time-Limit","date":"2023-05-16T07:21:24.000Z","updated":"2023-05-28T17:12:05.518Z","comments":true,"path":"coding/leetcode/Easy/2637-Promise-Time-Limit/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2637-Promise-Time-Limit/","excerpt":"","text":"⭐️ # 題目敘述 Given an asyncronous function fn and a time t in milliseconds, return a new time limited version of the input function. A time limited function is a function that is identical to the original unless it takes longer than t milliseconds to fullfill. In that case, it will reject with &quot;Time Limit Exceeded&quot; . Note that it should reject with a string, not an Error . # Example 1 Input: fn = async (n) =&gt; { await new Promise(res =&gt; setTimeout(res, 100)); return n * n; } inputs = [5] t = 50 Output: {&quot;rejected&quot;:&quot;Time Limit Exceeded&quot;,&quot;time&quot;:50} Explanation: The provided function is set to resolve after 100ms. However, the time limit is set to 50ms. It rejects at t=50ms because the time limit was reached. # Example 2 Input: fn = async (n) =&gt; { await new Promise(res =&gt; setTimeout(res, 100)); return n * n; } inputs = [5] t = 150 Output: {&quot;resolved&quot;:25,&quot;time&quot;:100} Explanation: The function resolved 5 * 5 = 25 at t=100ms. The time limit is never reached. # Example 3 Input: fn = async (a, b) =&gt; { await new Promise(res =&gt; setTimeout(res, 120)); return a + b; } inputs = [5,10] t = 150 Output: {&quot;resolved&quot;:15,&quot;time&quot;:120} Explanation: The function resolved 5 + 10 = 15 at t=120ms. The time limit is never reached. # Example 4 Input: fn = async () =&gt; { throw &quot;Error&quot;; } inputs = [] t = 1000 Output: {&quot;rejected&quot;:&quot;Error&quot;,&quot;time&quot;:0} Explanation: The function immediately throws an error. # 解題思路 Promise.race([arr]); : race 中的陣列哪一個 Function 先跑完，return 該 Function。 # Solution /** * @param &#123;Function&#125; fn * @param &#123;number&#125; t * @return &#123;Function&#125; */var timeLimit = function(fn, t) &#123; return async function(...args) &#123; const timeout = new Promise((resolved, reject) => &#123; setTimeout(() => reject(\"Time Limit Exceeded\"), t); &#125;); return Promise.race([fn(...args), timeout]); &#125;&#125;;/** * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100); * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms */ type Fn = (...params: any[]) => Promise&lt;any>;function timeLimit(fn: Fn, t: number): Fn &#123; return async function(...args) &#123; const timeout: Promise&lt;any> = new Promise((resolved: any, reject: any) => &#123; setTimeout(() => reject(\"Time Limit Exceeded\"), t); &#125;); return Promise.race([fn(...args), timeout]); &#125;&#125;;/** * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100); * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"24. Swap Nodes in Pairs","slug":"coding/leetcode/Medium/24-Swap-Nodes-in-Pairs","date":"2023-05-16T06:38:14.000Z","updated":"2023-05-28T17:13:19.789Z","comments":true,"path":"coding/leetcode/Medium/24-Swap-Nodes-in-Pairs/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/24-Swap-Nodes-in-Pairs/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.) # Example 1 Input: head = [1,2,3,4] Output: [2,1,4,3] # Example 2 Input: head = [] Output: [] # Example 3 Input: head = [1] Output: [1] # 解題思路 # Solution // Definition for singly-linked list.public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode ans = new ListNode(0); ans.next = head; ListNode curr = ans; while (curr.next != null &amp;&amp; curr.next.next != null) &#123; ListNode first = curr.next; ListNode second = curr.next.next; curr.next = second; first.next = second.next; second.next = first; curr = curr.next.next; &#125; return ans.next; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Linked List","slug":"Linked-List","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Linked-List/"},{"name":"Recursion","slug":"Recursion","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Recursion/"}]},{"title":"2621. Sleep","slug":"coding/leetcode/Easy/2621-Sleep","date":"2023-05-15T02:35:00.000Z","updated":"2023-05-28T17:11:46.917Z","comments":true,"path":"coding/leetcode/Easy/2621-Sleep/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2621-Sleep/","excerpt":"","text":"⭐️ # 題目敘述 Given a positive integer millis , write an asyncronous function that sleeps for millis milliseconds. It can resolve any value. # Example 1 Input: millis = 100 Output: 100 Explanation: It should return a promise that resolves after 100ms. let t = Date.now(); sleep(100).then(() =&gt; { console.log(Date.now() - t); // 100 }); # Example 2 Input: millis = 200 Output: 200 Explanation: It should return a promise that resolves after 200ms. # 解題思路 # Solution /** * @param &#123;number&#125; millis */async function sleep(millis) &#123; return new Promise(function(val)&#123; return setTimeout(val, millis); &#125;);&#125;/** * let t = Date.now() * sleep(100).then(() => console.log(Date.now() - t)) // 100 */ async function sleep(millis: number): Promise&lt;void> &#123; return new Promise(function(val: any): any&#123; return setTimeout(val, millis); &#125;);&#125;/** * let t = Date.now() * sleep(100).then(() => console.log(Date.now() - t)) // 100 */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"1721. Swapping Nodes in a Linked List","slug":"coding/leetcode/Medium/1721-Swapping-Nodes-in-a-Linked-List","date":"2023-05-15T01:48:06.000Z","updated":"2023-05-28T17:14:24.520Z","comments":true,"path":"coding/leetcode/Medium/1721-Swapping-Nodes-in-a-Linked-List/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1721-Swapping-Nodes-in-a-Linked-List/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given the head of a linked list, and an integer k . Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed). # Example 1 Input: head = [1,2,3,4,5], k = 2 Output: [1,4,3,2,5] # Example 2 Input: head = [7,9,6,6,7,8,3,0,9,5], k = 5 Output: [7,9,6,6,8,7,3,0,9,5] # 解題思路 # Solution // Definition for singly-linked list.public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; class Solution &#123; public ListNode swapNodes(ListNode head, int k) &#123; ListNode start = head, end = head; for (int i = 1; i &lt; k; i++) &#123; start = start.next; &#125; ListNode curr = start; while (curr.next != null) &#123; curr = curr.next; end = end.next; &#125; int temp = start.val; start.val = end.val; end.val = temp; return head; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Linked-List/"}]},{"title":"2666. Allow One Function Call","slug":"coding/leetcode/Easy/2666-Allow-One-Function-Call","date":"2023-05-12T03:26:20.000Z","updated":"2023-05-28T17:12:13.981Z","comments":true,"path":"coding/leetcode/Easy/2666-Allow-One-Function-Call/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2666-Allow-One-Function-Call/","excerpt":"","text":"⭐️ # 題目敘述 Given a function fn , return a new function that is identical to the original function except that it ensures fn is called at most once. The first time the returned function is called, it should return the same result as fn . Every subsequent time it is called, it should return undefined . # Example 1 Input: fn = (a,b,c) =&gt; (a + b + c), calls = [[1,2,3],[2,3,6]] Output: [{&quot;calls&quot;:1,&quot;value&quot;:6}] Explanation: const onceFn = once(fn); onceFn(1, 2, 3); // 6 onceFn(2, 3, 6); // undefined, fn was not called # Example 2 Input: fn = (a,b,c) =&gt; (a * b * c), calls = [[5,7,4],[2,3,6],[4,6,8]] Output: [{&quot;calls&quot;:1,&quot;value&quot;:140}] Explanation: const onceFn = once(fn); onceFn(5, 7, 4); // 140 onceFn(2, 3, 6); // undefined, fn was not called onceFn(4, 6, 8); // undefined, fn was not called # 解題思路 # Solution /** * @param &#123;Function&#125; fn * @return &#123;Function&#125; */var once = function(fn) &#123; let isCall = false; return function(...args)&#123; if(!isCall)&#123; isCall = true; return fn(...args); &#125; &#125;&#125;;/** * let fn = (a,b,c) => (a + b + c) * let onceFn = once(fn) * * onceFn(1,2,3); // 6 * onceFn(2,3,6); // returns undefined without calling fn */ function once&lt;T extends (...args: any[]) => any>(fn: T): ((...args: Parameters&lt;T>) => ReturnType&lt;T> | undefined) &#123; let isCall: Boolean = false; return function (...args) &#123; if(!isCall)&#123; isCall = true; return fn(...args); &#125; &#125;;&#125;/** * let fn = (a,b,c) => (a + b + c) * let onceFn = once(fn) * * onceFn(1,2,3); // 6 * onceFn(2,3,6); // returns undefined without calling fn */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"2140. Solving Questions With Brainpower","slug":"coding/leetcode/Medium/2140-Solving-Questions-With-Brainpower","date":"2023-05-12T02:48:50.000Z","updated":"2023-05-28T17:14:30.477Z","comments":true,"path":"coding/leetcode/Medium/2140-Solving-Questions-With-Brainpower/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2140-Solving-Questions-With-Brainpower/","excerpt":"","text":"⭐️ # 題目敘述 You are given a 0-indexed 2D integer array questions where questions[i] = [pointsi, brainpoweri] . The array describes the questions of an exam, where you have to process the questions in order (i.e., starting from question 0 ) and make a decision whether to solve or skip each question. Solving question i will earn you pointsi points but you will be unable to solve each of the next brainpoweri questions. If you skip question i , you get to make the decision on the next question. For example, given questions = [[3, 2], [4, 3], [4, 4], [2, 5]] : If question 0 is solved, you will earn 3 points but you will be unable to solve questions 1 and 2 . If instead, question 0 is skipped and question 1 is solved, you will earn 4 points but you will be unable to solve questions 2 and 3 . Return the maximum points you can earn for the exam. # Example 1: Input: questions = [[3,2],[4,3],[4,4],[2,5]] Output: 5 Explanation: The maximum points can be earned by solving questions 0 and 3. Solve question 0: Earn 3 points, will be unable to solve the next 2 questions Unable to solve questions 1 and 2 Solve question 3: Earn 2 points Total points earned: 3 + 2 = 5. There is no other way to earn 5 or more points. # Example 2: Input: questions = [[1,1],[2,2],[3,3],[4,4],[5,5]] Output: 7 Explanation: The maximum points can be earned by solving questions 1 and 4. Skip question 0 Solve question 1: Earn 2 points, will be unable to solve the next 2 questions Unable to solve questions 2 and 3 Solve question 4: Earn 5 points Total points earned: 2 + 5 = 7. There is no other way to earn 7 or more points. # 解題思路 # Solution class Solution &#123; public long mostPoints(int[][] questions) &#123; int n = questions.length; long[] dp = new long[n]; dp[n - 1] = questions[n - 1][0]; for (int i = n - 2; i >= 0; --i) &#123; dp[i] = questions[i][0]; int skip = questions[i][1]; if (i + skip + 1 &lt; n) &#123; dp[i] += dp[i + skip + 1]; &#125; // dp[i] = max(solve it, skip it) dp[i] = Math.max(dp[i], dp[i + 1]); &#125; return dp[0]; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"2629. Function Composition","slug":"coding/leetcode/Easy/2629-Function-Composition","date":"2023-05-11T01:58:09.000Z","updated":"2023-05-28T17:11:53.699Z","comments":true,"path":"coding/leetcode/Easy/2629-Function-Composition/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2629-Function-Composition/","excerpt":"","text":"⭐️ # 題目敘述 Given an array of functions [f1, f2, f3, ..., fn] , return a new function fn that is the function composition of the array of functions. The function composition of [f(x), g(x), h(x)] is fn(x) = f(g(h(x))) . The function composition of an empty list of functions is the identity function f(x) = x . You may assume each function in the array accepts one integer as input and returns one integer as output. # Example 1 Input: functions = [x =&gt; x + 1, x =&gt; x * x, x =&gt; 2 * x], x = 4 Output: 65 Explanation: Evaluating from right to left ... Starting with x = 4. 2 * (4) = 8 (8) * (8) = 64 (64) + 1 = 65 # Example 2 Input: functions = [x =&gt; 10 * x, x =&gt; 10 * x, x =&gt; 10 * x], x = 1 Output: 1000 Explanation: Evaluating from right to left ... 10 * (1) = 10 10 * (10) = 100 10 * (100) = 1000 # Example 3 Input: functions = [], x = 42 Output: 42 Explanation: The composition of zero functions is the identity function # 解題思路 # Solution /** * @param &#123;Function[]&#125; functions * @return &#123;Function&#125; */var compose = function(functions) &#123; return function(x) &#123; functions.reverse().foreach(fn => &#123; x = fn(x) &#125;); return x; &#125;&#125;;/** * const fn = compose([x => x + 1, x => 2 * x]) * fn(4) // 9 */ type F = (x: number) => number;function compose(functions: F[]): F &#123; return function(x): number &#123; functions.reverse().forEach((fn: F) => &#123; x = fn(x); &#125;); return x; &#125;&#125;;/** * const fn = compose([x => x + 1, x => 2 * x]) * fn(4) // 9 */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"1035. Uncrossed Lines","slug":"coding/leetcode/Medium/1035-Uncrossed-Lines","date":"2023-05-11T01:31:10.000Z","updated":"2023-05-28T17:14:03.411Z","comments":true,"path":"coding/leetcode/Medium/1035-Uncrossed-Lines/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1035-Uncrossed-Lines/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given two integer arrays nums1 and nums2 . We write the integers of nums1 and nums2 (in the order they are given) on two separate horizontal lines. We may draw connecting lines: a straight line connecting two numbers nums1[i] and nums2[j] such that: nums1[i] == nums2[j] , and the line we draw does not intersect any other connecting (non-horizontal) line. Note that a connecting line cannot intersect even at the endpoints (i.e., each number can only belong to one connecting line). Return the maximum number of connecting lines we can draw in this way. # Example 1: ![](https://hackmd.io/_uploads/rkIjNpKN3.png =400x) Input: nums1 = [1,4,2], nums2 = [1,2,4] Output: 2 Explanation: We can draw 2 uncrossed lines as in the diagram. We cannot draw 3 uncrossed lines, because the line from nums1[1] = 4 to nums2[2] = 4 will intersect the line from nums1[2]=2 to nums2[1]=2. # Example 2: Input: nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2] Output: 3 # Example 3: Input: nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1] Output: 2 # 解題思路 # Solution class Solution &#123; public int maxUncrossedLines(int[] nums1, int[] nums2) &#123; int n = nums1.length, m = nums2.length; int[][] dp = new int[n + 1][m + 1]; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; dp[i][j] = (nums1[i - 1] == nums2[j - 1] ? 1 + dp[i - 1][j - 1] : Math.max(dp[i][j - 1], dp[i - 1][j])); &#125; &#125; return dp[n][m]; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"2626. Array Reduce Transformation","slug":"coding/leetcode/Easy/2626-Array-Reduce-Transformation","date":"2023-05-10T01:49:13.000Z","updated":"2023-05-28T17:11:50.011Z","comments":true,"path":"coding/leetcode/Easy/2626-Array-Reduce-Transformation/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2626-Array-Reduce-Transformation/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer array nums , a reducer function fn , and an initial value init , return a reduced array. A reduced array is created by applying the following operation: val = fn(init, nums[0]) , val = fn(val, nums[1]) , val = fn(val, nums[2]) , ... until every element in the array has been processed. The final value of val is returned. If the length of the array is 0, it should return init . Please solve it without using the built-in Array.reduce method. # Example 1 Input: nums = [1,2,3,4] fn = function sum(accum, curr) { return accum + curr; } init = 0 Output: 10 Explanation: initially, the value is init=0. (0) + nums[0] = 1 (1) + nums[1] = 3 (3) + nums[2] = 6 (6) + nums[3] = 10 The final answer is 10. # Example 2: Input: nums = [1,2,3,4] fn = function sum(accum, curr) { return accum + curr * curr; } init = 100 Output: 130 Explanation: initially, the value is init=100. (100) + nums[0]^2 = 101 (101) + nums[1]^2 = 105 (105) + nums[2]^2 = 114 (114) + nums[3]^2 = 130 The final answer is 130. # Example 3: Input: nums = [] fn = function sum(accum, curr) { return 0; } init = 25 Output: 25 Explanation: For empty arrays, the answer is always init. # 解題思路 # Solution /** * @param &#123;number[]&#125; nums * @param &#123;Function&#125; fn * @param &#123;number&#125; init * @return &#123;number&#125; */var reduce = function(nums, fn, init) &#123; nums.forEach(function(num)&#123; init = fn(init, num); &#125;); return init;&#125;; type Fn = (accum: number, curr: number) => numberfunction reduce(nums: number[], fn: Fn, init: number): number &#123; nums.forEach(function(num)&#123; init = fn(init, num); &#125;); return init;&#125;; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"59. Spiral Matrix II","slug":"coding/leetcode/Medium/59-Spiral-Matrix-II","date":"2023-05-10T01:32:58.000Z","updated":"2023-05-28T17:13:26.635Z","comments":true,"path":"coding/leetcode/Medium/59-Spiral-Matrix-II/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/59-Spiral-Matrix-II/","excerpt":"","text":"⭐️ # 題目敘述 Given a positive integer n , generate an n x n matrix filled with elements from 1 to n^2 in spiral order. # Example 1: Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]] # Example 2: Input: n = 1 Output: [[1]] # 解題思路 # Solution class Solution &#123; public int[][] generateMatrix(int n) &#123; int[][] ans = new int[n][n]; int count = 1; int left = 0, right = n - 1, top = 0, bottom = n - 1; while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123; for (int i = left; i &lt;= right; i++) &#123; ans[top][i] = count++; &#125; top++; for (int i = top; i &lt;= bottom; i++) &#123; ans[i][right] = count++; &#125; right--; if (top &lt;= bottom) &#123; for (int i = right; i >= left; i--) &#123; ans[bottom][i] = count++; &#125; bottom--; &#125; if (left &lt;= right) &#123; for (int i = bottom; i >= top; i--) &#123; ans[i][left] = count++; &#125; left++; &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"}]},{"title":"2634. Filter Elements from Array","slug":"coding/leetcode/Easy/2634-Filter-Elements-from-Array","date":"2023-05-09T05:25:29.000Z","updated":"2023-05-28T17:11:57.691Z","comments":true,"path":"coding/leetcode/Easy/2634-Filter-Elements-from-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2634-Filter-Elements-from-Array/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer array arr and a filtering function fn , return a new array with a fewer or equal number of elements. The returned array should only contain elements where fn(arr[i], i) evaluated to a truthy value. Please solve it without the built-in Array.filter method. # Example 1: Input: arr = [0,10,20,30], fn = function greaterThan10(n) { return n &gt; 10; } Output: [20,30] Explanation: const newArray = filter(arr, fn); // [20, 30] The function filters out values that are not greater than 10 # Example 2: Input: arr = [1,2,3], fn = function firstIndex(n, i) { return i === 0; } Output: [1] Explanation: fn can also accept the index of each element In this case, the function removes elements not at index 0 # Example 3: Input: arr = [-2,-1,0,1,2], fn = function plusOne(n) { return n + 1 } Output: [-2,0,1,2] Explanation: Falsey values such as 0 should be filtered out # 解題思路 # Solution /** * @param &#123;number[]&#125; arr * @param &#123;Function&#125; fn * @return &#123;number[]&#125; */var filter = function(arr, fn) &#123; let ans = []; for (let i=0; i&lt;arr.length; i++) &#123; if (fn(arr[i], i))&#123; ans.push(arr[i]); &#125; &#125; return ans;&#125;; function filter(arr: number[], fn: (n: number, i: number) => any): number[] &#123; const ans: number[] = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (fn(arr[i], i))&#123; ans.push(arr[i]); &#125; &#125; return ans;&#125;; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"54. Spiral Matrix","slug":"coding/leetcode/Medium/54-Spiral-Matrix","date":"2023-05-09T04:53:03.000Z","updated":"2023-05-28T17:13:23.733Z","comments":true,"path":"coding/leetcode/Medium/54-Spiral-Matrix/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/54-Spiral-Matrix/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given an m x n matrix , return all elements of the matrix in spiral order. # Example 1: Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [1,2,3,6,9,8,7,4,5] # Example 2: Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] Output: [1,2,3,4,8,12,11,10,9,5,6,7] # 解題思路 # Solution import java.util.ArrayList;import java.util.List;class Solution &#123; public List&lt;Integer> spiralOrder(int[][] matrix) &#123; int rows = matrix.length; int cols = matrix[0].length; List&lt;Integer> ans = new ArrayList&lt;>(); if (rows == 0) &#123; return ans; &#125; int left = 0, right = cols - 1, top = 0, bottom = rows - 1; while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123; for (int i = left; i &lt;= right; i++) &#123; ans.add(matrix[top][i]); &#125; top++; for (int i = top; i &lt;= bottom; i++) &#123; ans.add(matrix[i][right]); &#125; right--; if (top &lt;= bottom) &#123; for (int i = right; i >= left; i--) &#123; ans.add(matrix[bottom][i]); &#125; bottom--; &#125; if (left &lt;= right) &#123; for (int i = bottom; i >= top; i--) &#123; ans.add(matrix[i][left]); &#125; left++; &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"}]},{"title":"2635. Apply Transform Over Each Element in Array","slug":"coding/leetcode/Easy/2635-Apply-Transform-Over-Each-Element-in-Array","date":"2023-05-08T02:04:46.000Z","updated":"2023-05-28T17:12:01.500Z","comments":true,"path":"coding/leetcode/Easy/2635-Apply-Transform-Over-Each-Element-in-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2635-Apply-Transform-Over-Each-Element-in-Array/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer array arr and a mapping function fn , return a new array with a transformation applied to each element. The returned array should be created such that returnedArray[i] = fn(arr[i], i) . Please solve it without the built-in Array.map method. # Example 1: Input: arr = [1,2,3], fn = function plusone(n) { return n + 1; } Output: [2,3,4] Explanation: const newArray = map(arr, plusone); // [2,3,4] The function increases each value in the array by one. # Example 2: Input: arr = [1,2,3], fn = function plusI(n, i) { return n + i; } Output: [1,3,5] Explanation: The function increases each value by the index it resides in. # Example 3: Input: arr = [10,20,30], fn = function constant() { return 42; } Output: [42,42,42] Explanation: The function always returns 42. # 解題思路 # Solution /** * @param &#123;number[]&#125; arr * @param &#123;Function&#125; fn * @return &#123;number[]&#125; */var map = function(arr, fn) &#123; return arr.map((val, index) => val = fn(val, index));&#125;; function map(arr: number[], fn: (n: number, i: number) => number): number[] &#123; return arr.map((val: number, idx: number) => val = fn(val, idx));&#125;; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"1572. Matrix Diagonal Sum","slug":"coding/leetcode/Easy/1572-Matrix-Diagonal-Sum","date":"2023-05-08T01:28:16.000Z","updated":"2023-05-28T17:11:33.541Z","comments":true,"path":"coding/leetcode/Easy/1572-Matrix-Diagonal-Sum/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1572-Matrix-Diagonal-Sum/","excerpt":"","text":"⭐️⭐️ # 題目敘述 Given a square matrix mat , return the sum of the matrix diagonals. Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal. # Example 1: Input: mat = [[1,2,3], [4,5,6], [7,8,9]] Output: 25 Explanation: Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25 Notice that element mat[1][1] = 5 is counted only once. # Example 2: Input: mat = [[1,1,1,1], [1,1,1,1], [1,1,1,1], [1,1,1,1]] Output: 8 # Example 3: Input: mat = [[5]] Output: 5 # 解題思路 # Solution class Solution &#123; public int diagonalSum(int[][] mat) &#123; int m = mat.length - 1; int ans = 0; for(int i = 0; i &lt;= m; i++)&#123; ans += mat[i][i]; ans += mat[i][m - i]; &#125; if(m % 2 == 0)&#123; ans -= mat[m / 2][m / 2]; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"}]},{"title":"2665. Counter II","slug":"coding/leetcode/Easy/2665-Counter-II","date":"2023-05-07T12:04:22.000Z","updated":"2023-05-28T17:12:09.382Z","comments":true,"path":"coding/leetcode/Easy/2665-Counter-II/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2665-Counter-II/","excerpt":"","text":"⭐️ # 題目敘述 Write a function createCounter . It should accept an initial integer init . It should return an object with three functions. The three functions are: increment() increases the current value by 1 and then returns it. decrement() reduces the current value by 1 and then returns it. reset() sets the current value to init and then returns it. # Example 1: Input: init = 5, calls = [&quot;increment&quot;,&quot;reset&quot;,&quot;decrement&quot;] Output: [6,5,4] Explanation: const counter = createCounter(5); counter.increment(); // 6 counter.reset(); // 5 counter.decrement(); // 4 # Example 2: Input: init = 0, calls = [&quot;increment&quot;,&quot;increment&quot;,&quot;decrement&quot;,&quot;reset&quot;,&quot;reset&quot;] Output: [1,2,1,0,0] Explanation: const counter = createCounter(0); counter.increment(); // 1 counter.increment(); // 2 counter.decrement(); // 1 counter.reset(); // 0 counter.reset(); // 0 # 解題思路 # Solution /** * @param &#123;integer&#125; init * @return &#123; increment: Function, decrement: Function, reset: Function &#125; */var createCounter = function(init) &#123; let counter = init; const increment = () => counter += 1; const decrement = () => counter -= 1; const reset = () => counter = init; return&#123;increment, decrement, reset&#125;;&#125;;/** * const counter = createCounter(5) * counter.increment(); // 6 * counter.reset(); // 5 * counter.decrement(); // 4 */ type ReturnObj = &#123; increment: () => number, decrement: () => number, reset: () => number,&#125;function createCounter(init: number): ReturnObj &#123; let counter: number = init; const increment = (): number => counter += 1; const decrement = (): number => counter -= 1; const reset = (): number => counter = init; return &#123;increment, decrement, reset&#125;;&#125;;/** * const counter = createCounter(5) * counter.increment(); // 6 * counter.reset(); // 5 * counter.decrement(); // 4 */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"1964. Find the Longest Valid Obstacle Course at Each Position","slug":"coding/leetcode/Hard/1964-Find-the-Longest-Valid-Obstacle-Course-at-Each-Position","date":"2023-05-07T08:40:52.000Z","updated":"2023-05-28T17:13:04.635Z","comments":true,"path":"coding/leetcode/Hard/1964-Find-the-Longest-Valid-Obstacle-Course-at-Each-Position/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/1964-Find-the-Longest-Valid-Obstacle-Course-at-Each-Position/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 You want to build some obstacle courses. You are given a 0-indexed integer array obstacles of length n , where obstacles[i] describes the height of the ith obstacle. For every index i between 0 and n - 1 (inclusive), find the length of the longest obstacle course in obstacles such that: You choose any number of obstacles between 0 and i inclusive. You must include the ith obstacle in the course. You must put the chosen obstacles in the same order as they appear in obstacles . Every obstacle (except the first) is taller than or the same height as the obstacle immediately before it. Return an array ans of length n , where ans[i] is the length of the longest obstacle course for index i as described above. # Example 1: Input: obstacles = [1,2,3,2] Output: [1,2,3,3] Explanation: The longest valid obstacle course at each position is: i = 0: [1], [1] has length 1. i = 1: [1,2], [1,2] has length 2. i = 2: [1,2,3], [1,2,3] has length 3. i = 3: [1,2,3,2], [1,2,2] has length 3. # Example 2: Input: obstacles = [2,2,1] Output: [1,2,1] Explanation: The longest valid obstacle course at each position is: i = 0: [2], [2] has length 1. i = 1: [2,2], [2,2] has length 2. i = 2: [2,2,1], [1] has length 1. # Example 3: Input: obstacles = [3,1,5,6,4,2] Output: [1,1,2,3,2,2] Explanation: The longest valid obstacle course at each position is: i = 0: [3], [3] has length 1. i = 1: [3,1], [1] has length 1. i = 2: [3,1,5], [3,5] has length 2. [1,5] is also valid. i = 3: [3,1,5,6], [3,5,6] has length 3. [1,5,6] is also valid. i = 4: [3,1,5,6,4], [3,4] has length 2. [1,4] is also valid. i = 5: [3,1,5,6,4,2], [1,2] has length 2. # 解題思路 # Solution class Solution &#123; public int[] longestObstacleCourseAtEachPosition(int[] obstacles) &#123; int n = obstacles.length; int length = 0; int[] result = new int[n]; int[] sub = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; int left = 0, right = length; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (sub[mid] &lt;= obstacles[i]) left = mid + 1; else right = mid; &#125; result[i] = left + 1; if (length == left) length++; sub[left] = obstacles[i]; &#125; return result; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Binary Indexed Tree","slug":"Binary-Indexed-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Indexed-Tree/"}]},{"title":"1498. Number of Subsequences That Satisfy the Given Sum Condition","slug":"coding/leetcode/Medium/1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition","date":"2023-05-06T05:21:16.000Z","updated":"2023-05-28T17:14:16.976Z","comments":true,"path":"coding/leetcode/Medium/1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an array of integers nums and an integer target . Return the number of non-empty subsequences of nums such that the sum of the minimum and maximum element on it is less or equal to target . Since the answer may be too large, return it modulo 10^9 + 7 . # Example 1: Input: nums = [3,5,6,7], target = 9 Output: 4 Explanation: There are 4 subsequences that satisfy the condition. [3] -&gt; Min value + max value &lt;= target (3 + 3 &lt;= 9) [3,5] -&gt; (3 + 5 &lt;= 9) [3,5,6] -&gt; (3 + 6 &lt;= 9) [3,6] -&gt; (3 + 6 &lt;= 9) # Example 2: Input: nums = [3,3,6,8], target = 10 Output: 6 Explanation: There are 6 subsequences that satisfy the condition. (nums can have repeated numbers). [3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6] # Example 3: Input: nums = [2,3,3,4,6,7], target = 12 Output: 61 Explanation: There are 63 non-empty subsequences, two of them do not satisfy the condition ([6,7], [7]). Number of valid subsequences (63 - 2 = 61). # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public int numSubseq(int[] nums, int target) &#123; int n = nums.length; int mod = 1000000007; int ans = 0; Arrays.sort(nums); int[] count = new int[n]; count[0] = 1; for (int i = 1; i &lt; n; i++) &#123; count[i] = (count[i - 1] * 2) % mod; &#125; int left = 0, right = n - 1; while (left &lt;= right) &#123; if (nums[left] + nums[right] &lt;= target) &#123; ans = (ans + count[right - left]) % mod; left++; &#125; else &#123; right--; &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"}]},{"title":"2620. Counter","slug":"coding/leetcode/Easy/2620-Counter","date":"2023-05-06T03:23:28.000Z","updated":"2023-05-28T17:11:43.153Z","comments":true,"path":"coding/leetcode/Easy/2620-Counter/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2620-Counter/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer n , return a counter function. This counter function initially returns n and then returns 1 more than the previous value every subsequent time it is called ( n , n + 1 , n + 2 , etc). # Example 1: Input: n = 10 [&quot;call&quot;,&quot;call&quot;,&quot;call&quot;] Output: [10,11,12] Explanation: counter() = 10 // The first time counter() is called, it returns n. counter() = 11 // Returns 1 more than the previous time. counter() = 12 // Returns 1 more than the previous time. # Example 2: Input: n = -2 [&quot;call&quot;,&quot;call&quot;,&quot;call&quot;,&quot;call&quot;,&quot;call&quot;] Output: [-2,-1,0,1,2] Explanation: counter() initially returns -2. Then increases after each sebsequent call. # 解題思路 # Solution /** * @param &#123;number&#125; n * @return &#123;Function&#125; counter */var createCounter = function(n) &#123; let counter = n - 1; return function() &#123; counter += 1; return counter; &#125;;&#125;;/** * const counter = createCounter(10) * counter() // 10 * counter() // 11 * counter() // 12 */ function createCounter(n: number): () => number &#123; let counter = n - 1; return function() &#123; counter += 1; return counter; &#125;&#125;/** * const counter = createCounter(10) * counter() // 10 * counter() // 11 * counter() // 12 */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"1456. Maximum Number of Vowels in a Substring of Given Length","slug":"coding/leetcode/Medium/1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length","date":"2023-05-05T02:32:53.000Z","updated":"2023-05-28T17:14:14.097Z","comments":true,"path":"coding/leetcode/Medium/1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length/","excerpt":"","text":"⭐️⭐️ # 題目敘述 Given a string s and an integer k , return the maximum number of vowel letters in any substring of s with length k . Vowel letters in English are 'a' , 'e' , 'i' , 'o' , and 'u' . # Example 1: Input: s = &quot;abciiidef&quot;, k = 3 Output: 3 Explanation: The substring &quot;iii&quot; contains 3 vowel letters. # Example 2: Input: s = &quot;aeiou&quot;, k = 2 Output: 2 Explanation: Any substring of length 2 contains 2 vowels. # Example 3: Input: s = &quot;leetcode&quot;, k = 3 Output: 2 Explanation: &quot;lee&quot;, &quot;eet&quot; and &quot;ode&quot; contain 2 vowels. # 解題思路 # Solution class Solution &#123; public int maxVowels(String s, int k) &#123; int ans = 0; String temp = s.substring(0, k); for (char t : temp.toCharArray()) &#123; if (isVowel(t))&#123; ans++; &#125; &#125; int cur = ans; for (int i = k; i &lt; s.length(); i++) &#123; if (isVowel(s.charAt(i))) cur++; if (isVowel(s.charAt(i - k))) cur--; ans = Math.max(ans, cur); &#125; return ans; &#125; public boolean isVowel(char c) &#123; if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') return true; return false; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"2667. Create Hello World Function","slug":"coding/leetcode/Easy/2667-Create-Hello-World-Function","date":"2023-05-05T01:26:51.000Z","updated":"2023-05-28T17:12:17.463Z","comments":true,"path":"coding/leetcode/Easy/2667-Create-Hello-World-Function/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2667-Create-Hello-World-Function/","excerpt":"","text":"⭐️ # 題目敘述 Write a function createHelloWorld . It should return a new function that always returns &quot;Hello World&quot; . # Example 1: Input: args = [] Output: &quot;Hello World&quot; Explanation: const f = createHelloWorld(); f(); // &quot;Hello World&quot; The function returned by createHelloWorld should always return &quot;Hello World&quot;. # Example 2: Input: args = [{},null,42] Output: &quot;Hello World&quot; Explanation: const f = createHelloWorld(); f({}, null, 42); // &quot;Hello World&quot; Any arguments could be passed to the function but it should still always return &quot;Hello World&quot;. # 解題思路 # Solution /** * @return &#123;Function&#125; */var createHelloWorld = function() &#123; return function(...args) &#123; return \"Hello World\"; &#125;&#125;;/** * const f = createHelloWorld(); * f(); // \"Hello World\" */ function createHelloWorld() &#123; return function(...args): string &#123; return \"Hello World\"; &#125;;&#125;;/** * const f = createHelloWorld(); * f(); // \"Hello World\" */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"649. Dota2 Senate","slug":"coding/leetcode/Medium/649-Dota2-Senate","date":"2023-05-04T01:30:30.000Z","updated":"2023-05-28T17:13:43.680Z","comments":true,"path":"coding/leetcode/Medium/649-Dota2-Senate/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/649-Dota2-Senate/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 In the world of Dota2, there are two parties: the Radiant and the Dire. The Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights: Ban one senator's right: A senator can make another senator lose all his rights in this and all the following rounds. Announce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game. Given a string senate representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party. Then if there are n senators, the size of the given string will be n . The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure. Suppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be &quot;Radiant&quot; or &quot;Dire&quot; . # Example 1: Input: senate = &quot;RD&quot; Output: &quot;Radiant&quot; Explanation: The first senator comes from Radiant and he can just ban the next senator's right in round 1. And the second senator can't exercise any rights anymore since his right has been banned. And in round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote. # Example 2: Input: senate = &quot;RDD&quot; Output: &quot;Dire&quot; Explanation: The first senator comes from Radiant and he can just ban the next senator's right in round 1. And the second senator can't exercise any rights anymore since his right has been banned. And the third senator comes from Dire and he can ban the first senator's right in round 1. And in round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote. # 解題思路 # Solution import java.util.LinkedList;import java.util.Queue;class Solution &#123; public String predictPartyVictory(String senate) &#123; int n = senate.length(); Queue&lt;Integer> rQueue = new LinkedList&lt;>(); Queue&lt;Integer> dQueue = new LinkedList&lt;>(); for (int i = 0; i &lt; n; i++) &#123; if (senate.charAt(i) == 'R') &#123; rQueue.add(i); &#125; else &#123; dQueue.add(i); &#125; &#125; while (!rQueue.isEmpty() &amp;&amp; !dQueue.isEmpty()) &#123; int rTurn = rQueue.poll(); int dTurn = dQueue.poll(); if (dTurn &lt; rTurn) &#123; dQueue.add(dTurn + n); &#125; else &#123; rQueue.add(rTurn + n); &#125; &#125; return rQueue.isEmpty() ? \"Dire\" : \"Radiant\"; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Queue","slug":"Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Queue/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"2215. Find the Difference of Two Arrays","slug":"coding/leetcode/Easy/2215-Find-the-Difference-of-Two-Arrays","date":"2023-05-03T01:24:55.000Z","updated":"2023-05-28T17:11:40.373Z","comments":true,"path":"coding/leetcode/Easy/2215-Find-the-Difference-of-Two-Arrays/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2215-Find-the-Difference-of-Two-Arrays/","excerpt":"","text":"⭐️ # 題目敘述 Given two 0-indexed integer arrays nums1 and nums2 , return a list answer of size 2 where: answer[0] is a list of all distinct integers in nums1 which are not present in nums2 . answer[1] is a list of all distinct integers in nums2 which are not present in nums1 . Note that the integers in the lists may be returned in any order. # Example 1: Input: nums1 = [1,2,3], nums2 = [2,4,6] Output: [[1,3],[4,6]] Explanation: For nums1, nums1[1] = 2 is present at index 0 of nums2, whereas nums1[0] = 1 and nums1[2] = 3 are not present in nums2. Therefore, answer[0] = [1,3]. For nums2, nums2[0] = 2 is present at index 1 of nums1, whereas nums2[1] = 4 and nums2[2] = 6 are not present in nums2. Therefore, answer[1] = [4,6]. # Example 2: Input: nums1 = [1,2,3,3], nums2 = [1,1,2,2] Output: [[3],[]] Explanation: For nums1, nums1[2] and nums1[3] are not present in nums2. Since nums1[2] == nums1[3], their value is only included once and answer[0] = [3]. Every integer in nums2 is present in nums1. Therefore, answer[1] = []. # 解題思路 # Solution import java.util.ArrayList;import java.util.List;class Solution &#123; public List&lt;List&lt;Integer>> findDifference(int[] nums1, int[] nums2) &#123; List&lt;List&lt;Integer>> ans = new ArrayList&lt;>(); List&lt;Integer> map1 = new ArrayList&lt;>(), map2 = new ArrayList&lt;>(); for(int n : nums1) map1.add(n); for(int n : nums2) map2.add(n); List&lt;Integer> temp1 = new ArrayList&lt;>(); for(int n : nums1)&#123; if(!map2.contains(n) &amp;&amp; !temp1.contains(n))&#123; temp1.add(n); &#125; &#125; ans.add(temp1); List&lt;Integer> temp2 = new ArrayList&lt;>(); for(int n : nums2)&#123; if(!map1.contains(n) &amp;&amp; !temp2.contains(n))&#123; temp2.add(n); &#125; &#125; ans.add(temp2); return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"}]},{"title":"1822. Sign of the Product of an Array","slug":"coding/leetcode/Easy/1822-Sign-of-the-Product-of-an-Array","date":"2023-05-02T04:00:20.000Z","updated":"2023-05-28T17:11:36.435Z","comments":true,"path":"coding/leetcode/Easy/1822-Sign-of-the-Product-of-an-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1822-Sign-of-the-Product-of-an-Array/","excerpt":"","text":"⭐️ # 題目敘述 There is a function signFunc(x) that returns: 1 if x is positive. -1 if x is negative. 0 if x is equal to 0 . You are given an integer array nums . Let product be the product of all values in the array nums . Return signFunc(product) . # Example 1: Input: nums = [-1,-2,-3,-4,3,2,1] Output: 1 Explanation: The product of all values in the array is 144, and signFunc(144) = 1 # Example 2: Input: nums = [1,5,0,2,-3] Output: 0 Explanation: The product of all values in the array is 0, and signFunc(0) = 0 # Example 3: Input: nums = [-1,1,-1,1,-1] Output: -1 Explanation: The product of all values in the array is -1, and signFunc(-1) = -1 # 解題思路 # Solution class Solution &#123; public int arraySign(int[] nums) &#123; int sign = 1; for(int num : nums)&#123; if(num == 0) return 0; if(num &lt; 0) sign *= -1; &#125; return sign; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"}]},{"title":"1491. Average Salary Excluding the Minimum and Maximum Salary","slug":"coding/leetcode/Easy/1491-Average-Salary-Excluding-the-Minimum-and-Maximum-Salary","date":"2023-05-01T05:46:14.000Z","updated":"2023-05-28T17:11:30.154Z","comments":true,"path":"coding/leetcode/Easy/1491-Average-Salary-Excluding-the-Minimum-and-Maximum-Salary/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1491-Average-Salary-Excluding-the-Minimum-and-Maximum-Salary/","excerpt":"","text":"⭐️ # 題目敘述 You are given an array of unique integers salary where salary[i] is the salary of the ith employee. Return the average salary of employees excluding the minimum and maximum salary. Answers within 10-5 of the actual answer will be accepted. # Example 1: Input: salary = [4000,3000,1000,2000] Output: 2500.00000 Explanation: Minimum salary and maximum salary are 1000 and 4000 respectively. Average salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500 # Example 2: Input: salary = [1000,2000,3000] Output: 2000.00000 Explanation: Minimum salary and maximum salary are 1000 and 3000 respectively. Average salary excluding minimum and maximum salary is (2000) / 1 = 2000 # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public double average(int[] salary) &#123; Arrays.sort(salary); long sum = 0; for(int i = 1; i &lt; salary.length - 1; i++)&#123; sum += salary[i]; &#125; return sum / (salary.length - 2 * 1.0); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"}]},{"title":"1579. Remove Max Number of Edges to Keep Graph Fully Traversable","slug":"coding/leetcode/Hard/1579-Remove-Max-Number-of-Edges-to-Keep-Graph-Fully-Traversable","date":"2023-04-30T03:18:16.000Z","updated":"2023-05-28T17:12:53.476Z","comments":true,"path":"coding/leetcode/Hard/1579-Remove-Max-Number-of-Edges-to-Keep-Graph-Fully-Traversable/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/1579-Remove-Max-Number-of-Edges-to-Keep-Graph-Fully-Traversable/","excerpt":"","text":"⭐️ # 題目敘述 Alice and Bob have an undirected graph of n nodes and three types of edges: Type 1: Can be traversed by Alice only. Type 2: Can be traversed by Bob only. Type 3: Can be traversed by both Alice and Bob. Given an array edges where edges[i] = [typei, ui, vi] represents a bidirectional edge of type typei between nodes ui and vi , find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes. Return the maximum number of edges you can remove, or return -1 if Alice and Bob cannot fully traverse the graph. # Example 1: Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]] Output: 2 Explanation: If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2. # Example 2: Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]] Output: 0 Explanation: Notice that removing any edge will not make the graph fully traversable by Alice and Bob. # Example 3: Input: n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]] Output: -1 Explanation: In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable. # 解題思路 # Solution 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"}]},{"title":"1697. Checking Existence of Edge Length Limited Paths","slug":"coding/leetcode/Hard/1697-Checking-Existence-of-Edge-Length-Limited-Paths","date":"2023-04-29T06:04:59.000Z","updated":"2023-05-28T17:12:56.399Z","comments":true,"path":"coding/leetcode/Hard/1697-Checking-Existence-of-Edge-Length-Limited-Paths/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/1697-Checking-Existence-of-Edge-Length-Limited-Paths/","excerpt":"","text":"⭐️ # 題目敘述 An undirected graph of n nodes is defined by edgeList , where edgeList[i] = [ui, vi, disi] denotes an edge between nodes ui and vi with distance disi . Note that there may be multiple edges between two nodes. Given an array queries , where queries[j] = [pj, qj, limitj] , your task is to determine for each queries[j] whether there is a path between pj and qj such that each edge on the path has a distance strictly less than limitj . Return a boolean array answer , where answer.length == queries.length and the jth value of answer is true if there is a path for queries[j] is true , and false otherwise. # Example 1: Input: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]] Output: [false,true] Explanation: The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16. For the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query. For the second query, there is a path (0 -&gt; 1 -&gt; 2) of two edges with distances less than 5, thus we return true for this query. # Example 2: Input: n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]] Output: [true,false] Exaplanation: The above figure shows the given graph. # 解題思路 # Solution 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"}]},{"title":"839. Similar String Groups","slug":"coding/leetcode/Hard/839-Similar-String-Groups","date":"2023-04-28T01:29:37.000Z","updated":"2023-05-28T17:12:46.778Z","comments":true,"path":"coding/leetcode/Hard/839-Similar-String-Groups/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/839-Similar-String-Groups/","excerpt":"","text":"⭐️ # 題目敘述 Two strings X and Y are similar if we can swap two letters (in different positions) of X , so that it equals Y . Also two strings X and Y are similar if they are equal. For example, &quot;tars&quot; and &quot;rats&quot; are similar (swapping at positions 0 and 2 ), and &quot;rats&quot; and &quot;arts&quot; are similar, but &quot;star&quot; is not similar to &quot;tars&quot; , &quot;rats&quot; , or &quot;arts&quot; . Together, these form two connected groups by similarity: &#123;&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;&#125; and &#123;&quot;star&quot;&#125; . Notice that &quot;tars&quot; and &quot;arts&quot; are in the same group even though they are not similar. Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group. We are given a list strs of strings where every string in strs is an anagram of every other string in strs . How many groups are there? # Example 1: Input: strs = [&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;] Output: 2 # Example 2: Input: strs = [&quot;omv&quot;,&quot;ovm&quot;] Output: 1 # 解題思路 # Solution 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"319. Bulb Switcher","slug":"coding/leetcode/Medium/319-Bulb-Switcher","date":"2023-04-27T01:54:17.000Z","updated":"2023-05-28T17:13:35.713Z","comments":true,"path":"coding/leetcode/Medium/319-Bulb-Switcher/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/319-Bulb-Switcher/","excerpt":"","text":"⭐️ # 題目敘述 There are n bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Return the number of bulbs that are on after n rounds. # Example 1: Input: n = 3 Output: 1 Explanation: At first, the three bulbs are [off, off, off]. After the first round, the three bulbs are [on, on, on]. After the second round, the three bulbs are [on, off, on]. After the third round, the three bulbs are [on, off, off]. So you should return 1 because there is only one bulb is on. # Example 2: Input: n = 0 Output: 0 # Example 3: Input: n = 1 Output: 1 # 解題思路 # Solution class Solution &#123; public int bulbSwitch(int n) &#123; return (int)Math.sqrt(n); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"},{"name":"Brainteaser","slug":"Brainteaser","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Brainteaser/"}]},{"title":"uva 10156 - Sala-ma-Sond, A Nice Little Pond","slug":"coding/cpe/One Star/uva-10156-Sala-ma-Sond-A-Nice-Little-Pond","date":"2023-04-26T04:59:49.000Z","updated":"2023-05-28T17:11:10.580Z","comments":true,"path":"coding/cpe/One Star/uva-10156-Sala-ma-Sond-A-Nice-Little-Pond/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10156-Sala-ma-Sond-A-Nice-Little-Pond/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 And the turtles, of course...all the turtles are free As turtles, and, maybe, all creatures should be. Of course, the turtles aren’t completely free. In particular, they aren’t free to swim where other turtles are swimming. To learn more about the swimming behaviour of turtles you decide to write a computer simulation of a pond and the turtles swimming in it. For simplicity, you represent the pond as a rectangular grid, with turtles occupying positions at points on the grid. If the pond is an N × M grid, a position on the grid may be represented by a pair of integer coordinates (i, j) , with 0 ≤ i &lt; N and 0 ≤ j &lt; M . The grid is aligned with its first dimension running north-south and its second dimension running east-west. Coordinate values increase to the south and the east. A turtle swimming in the pond may be requested to move to the adjacent grid position in one of eight directions: N , S , E , W , NE , NW , SE , SW . If the request would cause the turtle to move off the grid or cause it to move onto a grid position occupied by another turtle, the request is ignored. Otherwise, the turtle happily obeys the movement request. (Turtles are easy to push around.) # Input The input consist of several data sets. Each data set begins with a description of the pond and the initial location of the turtles. The first line of the input consists of four integers separated by one or more spaces. The first integer specifies the size of the pond in the north-south direction (N) , the second integer specifies the size of the pond in the east-west direction (M) , the third integer specifies the number of turtles in the pond (T) and the fourth integer indicates the number of turtle movement requests (K) . This first line is followed by T lines, each providing information on a single turtle. Each line of turtle information consists of three integers separated by one or more spaces. The first integer specifies a turtle id, the second integer specifies an initial grid position for the turtle along the northsouth dimension, and the third integer specifies an initial grid position for the turtle along the east-west dimension. All turtles will be located at valid grid positions; no two turtles will be located at the same grid position; turtle ids are in the range one to ten thousand; the maximum size of the grid in either dimension is sixty; the minimum size is two. Following the description of the pond and its initial turtle configuration, the remainder of the input, consists of a sequence of K turtle movement requests, one per line. Each movement request consists of a turtle id followed by a movement direction, and indicates that the specified turtle should be requested to move one grid position in the specified direction. The turtle id and movement direction are separated by one or more spaces. The movement direction is one of: ‘N’ , ‘S’ , ‘E’ , ‘W’ , ‘NE’ , ‘NW’ , ‘SE’ , ‘SW’ . The turtle requests should be processed sequentially starting from the initial pond configuration given in the input. # Output The output is a graphical representation of the pond configuration for each data set after all turtle movement requests have been processed. A picture of the pond is rendered using ASCII characters. Beginning with the most northerly row, each row of the grid is represented by a single line in the output. Grid positions along a row are represented by character positions in the output line. The final position of a turtle is marked with an asterisk (‘*’) ; space characters are used to fill empty grid positions. If the output is displayed as text on a computer screen or printed page, the result is a map of turtle positions in the pond, with north toward the top, east toward the right, and west toward the left. Spaces should be generated only when required for positioning turtles; output lines should not have trailing spaces. Print a blank line after each data set. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 4 4 3 4 1 0 0 2 0 2 3 3 3 1 S 2 W 2 W 1 SE 4 4 3 4 1 0 0 2 0 2 3 3 3 2 W 2 W 1 S 1 SW # Sample Output # 解題技巧 # Solution","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"258. Add Digits","slug":"coding/leetcode/Easy/258-Add-Digits","date":"2023-04-26T01:27:56.000Z","updated":"2023-05-28T17:11:19.669Z","comments":true,"path":"coding/leetcode/Easy/258-Add-Digits/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/258-Add-Digits/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer num , repeatedly add all its digits until the result has only one digit, and return it. # Example 1: Input: num = 38 Output: 2 Explanation: The process is 38 --&gt; 3 + 8 --&gt; 11 11 --&gt; 1 + 1 --&gt; 2 Since 2 has only one digit, return it. # Example 2: Input: num = 0 Output: 0 # 解題思路 # Solution class Solution &#123; public int addDigits(int num) &#123; while(num >= 10)&#123; String str = Integer.toString(num); num = 0; for(int i = 0; i &lt; str.length(); i++)&#123; num += Integer.parseInt(str.substring(i, i + 1)); &#125; &#125; return num; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Number-Theory/"}]},{"title":"uva 10126 - Zipf's Law","slug":"coding/cpe/One Star/uva-10126-Zipf-s-Law","date":"2023-04-25T03:01:38.000Z","updated":"2023-05-28T17:11:05.905Z","comments":true,"path":"coding/cpe/One Star/uva-10126-Zipf-s-Law/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10126-Zipf-s-Law/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 無本題 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Harvard linguistics professor George Kingsley Zipf (1902-1950) observed that the frequency of the k-th most common word in a text is roughly proportional to 1/k . He justified his observations in a book titled Human behavior and the principle of least effort published in 1949. While Zipf’s rationale has largely been discredited, the principle still holds, and others have afforded it a more sound mathematical basis. You are to find all the words occurring n times in an English text. A word is a sequence of letters. Words are separated by non-letters. Capitalization should be ignored. A word can be of any length that an English word can be. # Input Input consists of several test cases. The first line of each case contains a single positive integer n . Several lines of text follow which will contain no more than 10000 words. The text for each case is terminated by a single line containing EndOfText . EndOfText does not appear elsewhere in the input and is not considered a word. # Output For each test case, output the words which occur n times in the input text, one word per line, lower case, in alphabetical order. If there are no such words in input, output the following line: There is no such word. Leave a blank line between cases. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 2 In practice, the difference between theory and practice is always greater than the difference between theory and practice in theory. - Anonymous Man will occasionally stumble over the truth, but most of the time he will pick himself up and continue on. - W. S. L. Churchill EndOfText # Sample Output between difference in will # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while(sc.hasNextInt())&#123; int N = sc.nextInt(); sc.nextLine(); Map&lt;String, Integer> map = new HashMap&lt;>(); String str = sc.nextLine(); while(!str.equals(\"EndOfText\"))&#123; String[] arr = str.split(\"[^A-Za-z]\"); for(int i = 0; i &lt; arr.length; i++)&#123; if(arr[i].length() != 0)&#123; arr[i] = arr[i].toLowerCase(); if(map.containsKey(arr[i]))&#123; map.put(arr[i], map.get(arr[i]) + 1); &#125;else&#123; map.put(arr[i], 1); &#125; &#125; &#125; str = sc.nextLine(); &#125; boolean isOutput = false; for(String s : new TreeSet&lt;String>(map.keySet()))&#123; if(map.get(s) == N)&#123; System.out.println(s); isOutput = true; &#125; &#125; if(!isOutput)&#123; System.out.println(\"There is no such word.\"); &#125; if(sc.hasNextInt())&#123; System.out.println(); &#125; &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"2336. Smallest Number in Infinite Set","slug":"coding/leetcode/Medium/2336-Smallest-Number-in-Infinite-Set","date":"2023-04-25T02:20:39.000Z","updated":"2023-05-28T17:14:33.343Z","comments":true,"path":"coding/leetcode/Medium/2336-Smallest-Number-in-Infinite-Set/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2336-Smallest-Number-in-Infinite-Set/","excerpt":"","text":"⭐️⭐️ # 題目敘述 You have a set which contains all positive integers [1, 2, 3, 4, 5, ...] . Implement the SmallestInfiniteSet class: SmallestInfiniteSet() Initializes the SmallestInfiniteSet object to contain all positive integers. int popSmallest() Removes and returns the smallest integer contained in the infinite set. void addBack(int num) Adds a positive integer num back into the infinite set, if it is not already in the infinite set. # Example 1: Input [&quot;SmallestInfiniteSet&quot;, &quot;addBack&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;, &quot;addBack&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;] [[], [2], [], [], [], [1], [], [], []] Output [null, null, 1, 2, 3, null, 1, 4, 5] Explanation SmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet(); smallestInfiniteSet.addBack(2); // 2 is already in the set, so no change is made. smallestInfiniteSet.popSmallest(); // return 1, since 1 is the smallest number, and remove it from the set. smallestInfiniteSet.popSmallest(); // return 2, and remove it from the set. smallestInfiniteSet.popSmallest(); // return 3, and remove it from the set. smallestInfiniteSet.addBack(1); // 1 is added back to the set. smallestInfiniteSet.popSmallest(); // return 1, since 1 was added back to the set and // is the smallest number, and remove it from the set. smallestInfiniteSet.popSmallest(); // return 4, and remove it from the set. smallestInfiniteSet.popSmallest(); // return 5, and remove it from the set. # 解題思路 # Solution import java.util.PriorityQueue;class SmallestInfiniteSet &#123; PriorityQueue&lt;Integer> pQ; public SmallestInfiniteSet() &#123; pQ = new PriorityQueue&lt;>(); for(int i = 1; i &lt;= 1000; i++)&#123; pQ.add(i); &#125; &#125; public int popSmallest() &#123; int num = pQ.poll(); return num; &#125; public void addBack(int num) &#123; if(!pQ.contains(num))&#123; pQ.add(num); &#125; &#125;&#125;/** * Your SmallestInfiniteSet object will be instantiated and called as such: * SmallestInfiniteSet obj = new SmallestInfiniteSet(); * int param_1 = obj.popSmallest(); * obj.addBack(num); */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Design","slug":"Design","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Design/"}]},{"title":"uva 10101 - Bangla Numbers","slug":"coding/cpe/One Star/uva-10101-Bangla-Numbers","date":"2023-04-24T11:10:12.000Z","updated":"2023-05-28T17:11:01.338Z","comments":true,"path":"coding/cpe/One Star/uva-10101-Bangla-Numbers/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10101-Bangla-Numbers/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Bangla numbers normally use ’kuti’ (10000000) , ’lakh’ (100000) , ’hajar’ (1000) , ’shata’ (100) while expanding and converting to text. You are going to write a program to convert a given number to text with them. # Input The input file may contain several test cases. Each case will contain a non-negative number ≤ 999999999999999 . # Output For each case of input, you have to output a line starting with the case number with four digits adjustment followed by the converted text. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 23764 45897458973958 # Sample Output 1. 23 hajar 7 shata 64 2. 45 lakh 89 hajar 7 shata 45 kuti 89 lakh 73 hajar 9 shata 58 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static long kuti = 10000000; public static long lakh = 100000; public static long hajar = 1000; public static long shata = 100; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int line = 0; while(sc.hasNextLong())&#123; long num = sc.nextLong(); System.out.printf(\"%4d.\", ++line); if(num == 0)&#123; System.out.print(\" 0\"); &#125;else&#123; calculate(num); &#125; System.out.println(); &#125; sc.close(); &#125; public static void calculate(long num)&#123; if(num == 0) return ; if(num >= kuti)&#123; calculate(num/kuti); System.out.print(\" kuti\"); calculate(num%kuti); &#125;else if(num >= lakh)&#123; System.out.print(\" \" + num/lakh + \" lakh\"); calculate(num%lakh); &#125;else if(num >= hajar)&#123; System.out.print(\" \" + num/hajar + \" hajar\"); calculate(num%hajar); &#125;else if(num >= shata)&#123; System.out.print(\" \" + num/shata + \" shata\"); calculate(num%shata); &#125;else&#123; System.out.print(\" \" + num); &#125; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"1046. Last Stone Weight","slug":"coding/leetcode/Easy/1046-Last-Stone-Weight","date":"2023-04-24T02:48:10.000Z","updated":"2023-05-28T17:11:24.051Z","comments":true,"path":"coding/leetcode/Easy/1046-Last-Stone-Weight/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1046-Last-Stone-Weight/","excerpt":"","text":"⭐️ # 題目敘述 You are given an array of integers stones where stones[i] is the weight of the ith stone. We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x &lt;= y . The result of this smash is: If x == y , both stones are destroyed, and If x != y , the stone of weight x is destroyed, and the stone of weight y has new weight y - x . At the end of the game, there is at most one stone left. Return the weight of the last remaining stone. If there are no stones left, return 0 . # Example 1: Input: stones = [2,7,4,1,8,1] Output: 1 Explanation: We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then, we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then, we combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone. # Example 2: Input: stones = [1] Output: 1 # 解題思路 # Solution import java.util.Comparator;import java.util.PriorityQueue;class Solution &#123; public int lastStoneWeight(int[] stones) &#123; if(stones.length == 0) return 0; PriorityQueue&lt;Integer> pQ = new PriorityQueue&lt;>(Comparator.reverseOrder()); for(int s : stones)&#123; pQ.add(s); &#125; while(pQ.size() >= 2)&#123; int first = pQ.poll(); int second = pQ.poll(); pQ.add(first - second); &#125; return pQ.peek(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"}]},{"title":"uva 10093 - An Easy Problem!","slug":"coding/cpe/One Star/uva-10093-An-Easy-Problem","date":"2023-04-22T15:31:50.000Z","updated":"2023-05-28T17:10:56.864Z","comments":true,"path":"coding/cpe/One Star/uva-10093-An-Easy-Problem/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10093-An-Easy-Problem/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 無本題 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Have you heard the fact “The base of every normal number system is 10” ? Of course, I am not talking about number systems like Stern Brockot Number System. This problem has nothing to do with this fact but may have some similarity. You will be given an N based integer number R and you are given the guaranty that R is divisible by (N − 1) . You will have to print the smallest possible value for N . The range for N is 2 ≤ N ≤ 62 and the digit symbols for 62 based number is ( 0..9 and A..Z and a..z ). Similarly, the digit symbols for 61 based number system is ( 0..9 and A..Z and a..y ) and so on. # Input Each line in the input file will contain an integer (as defined in mathematics) number of any integer base (2..62) . You will have to determine what is the smallest possible base of that number for the given conditions. No invalid number will be given as input. # Output If number with such condition is not possible output the line ‘such number is impossible!’ For each line of input there will be only a single line of output. The output will always be in decimal number system. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 3 5 A # Sample Output 4 6 11 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) &#123; String str = sc.nextLine(); char arr[] = str.toCharArray(); int max = 1; int sum = 0; int i; for (char c : arr) &#123; int curr = 0; if (c >= 'A' &amp;&amp; c &lt;= 'Z') &#123; curr = c - 'A' + 10; &#125; else if (c >= 'a' &amp;&amp; c &lt;= 'z') &#123; curr = c - 'a' + 36; &#125; else if (c >= '0' &amp;&amp; c &lt;= '9') &#123; curr = c - '0'; &#125; if (max &lt; curr) &#123; max = curr; &#125; sum += curr; &#125; for (i = max; i &lt; 62; i++) &#123; if (sum % i == 0) &#123; System.out.println(i + 1); break; &#125; &#125; if (i == 62) &#123; System.out.println(\"such number is impossible!\"); &#125; &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"uva 10082 - WERTYU","slug":"coding/cpe/One Star/uva-10082-WERTYU","date":"2023-04-21T08:16:29.000Z","updated":"2023-05-28T17:10:52.653Z","comments":true,"path":"coding/cpe/One Star/uva-10082-WERTYU/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10082-WERTYU/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 A common typing error is to place the hands on the keyboard one row to the right of the correct position. So ‘Q’ is typed as ‘W’ and ‘J’ is typed as ‘K’ and so on. You are to decode a message typed in this manner. # Input Input consists of several lines of text. Each line may contain digits , spaces , upper case letters (except Q, A, Z) , or punctuation shown above [except back-quote (‘)] . Keys labelled with words [Tab, BackSp, Control, etc.] are not represented in the input. # Output You are to replace each letter or punction symbol by the one immediately to its left on the ‘QWERTY’ keyboard shown above. Spaces in the input should be echoed in the output. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input O S, GOMR YPFSU/ # Sample Output I AM FINE TODAY. # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String hashTable = \"`1234567890-=QWERTYUIOP[]\\\\ASDFGHJKL;'ZXCVBNM,./\"; while(sc.hasNextLine())&#123; String str = sc.nextLine(); for(int i = 0; i &lt; str.length(); i++)&#123; char c = str.charAt(i); if(c == ' ') System.out.print(\" \"); for(int j = 0; j &lt; hashTable.length(); j++)&#123; if(c == hashTable.charAt(j))&#123; System.out.print(hashTable.charAt(j - 1)); &#125; &#125; &#125; System.out.println(); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"uva 10079 - Pizza Cutting","slug":"coding/cpe/One Star/uva-10079-Pizza-Cutting","date":"2023-04-21T07:38:33.000Z","updated":"2023-05-28T17:10:49.455Z","comments":true,"path":"coding/cpe/One Star/uva-10079-Pizza-Cutting/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10079-Pizza-Cutting/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 When someone calls Ivan lazy, he claims that it is his intelligence that helps him to be so. If his intelligence allows him to do something at less physical effort, why should he exert more? He also claims that he always uses his brain and tries to do some work at less effort; this is not his laziness, rather this is his intellectual smartness. Once Ivan was asked to cut a pizza into seven pieces to distribute it among his friends. (Size of the pieces may not be the same. In fact, his piece will be larger than the others.) He thought a bit, and came to the conclusion that he can cut it into seven pieces by only three straight cuts through the pizza with a pizza knife. Accordingly, he cut the pizza in the following way (guess which one is Ivan’s piece): One of his friends, who never believed in Ivan’s smartness, was startled at this intelligence. He thought, if Ivan can do it, why can’t my computer? So he tried to do a similar (but not exactly as Ivan’s, for Ivan will criticize him for stealing his idea) job with his computer. He wrote a program that took the number of straight cuts one makes through the pizza, and output a number representing the maximum number of pizza pieces it will produce. Your job here is to write a similar program. It is ensured that Ivan’s friend won’t criticize you for doing the same job he did. # Input The input file will contain a single integer N (0 ≤ N ≤ 210000000) in each line representing the number of straight line cuts one makes through the pizza. A negative number terminates the input. # Output Output the maximum number of pizza pieces the given number of cuts can produce. Each line should contain only one output integer without any leading or trailing space. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 5 10 -100 # Sample Output 16 56 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); long n = sc.nextLong(); while(n >= 0 &amp;&amp; n &lt;= 210000000)&#123; System.out.println(1 + (n * (n + 1) / 2)); n = sc.nextLong(); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"uva 10062 - Tell me the frequencies!","slug":"coding/cpe/One Star/uva-10062-Tell-me-the-frequencies","date":"2023-04-21T06:11:42.000Z","updated":"2023-05-28T17:10:45.924Z","comments":true,"path":"coding/cpe/One Star/uva-10062-Tell-me-the-frequencies/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10062-Tell-me-the-frequencies/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Given a line of text you will have to find out the frequencies of the ASCII characters present in it. The given lines will contain none of the first 32 or last 128 ASCII characters. Of course lines may end with \\n and \\r but always keep those out of consideration. # Input Several lines of text are given as input. Each line of text is considered as a single input. Maximum length of each line is 1000 . # Output Print the ASCII value of the ASCII characters which are present and their frequency according to the given format below. A blank line should separate each set of output. Print the ASCII characters in the ascending order of their frequencies. If two characters are present the same time print the information of the ASCII character with higher ASCII value first. Input is terminated by end of file. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input AAABBC 122333 # Sample Output 67 1 66 2 65 3 49 1 50 2 51 3 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) &#123; String str = sc.nextLine(); Ascii[] list = new Ascii[130]; for (int i = 0; i &lt; 130; i++) &#123; list[i] = new Ascii(i); &#125; for (int i = 0; i &lt; str.length(); i++) &#123; int c = str.charAt(i); list[c].count++; &#125; Arrays.sort(list, new Comparator&lt;Ascii>() &#123; @Override public int compare(Ascii a, Ascii b) &#123; if (a.count == b.count) return b.ascii - a.ascii; return a.count - b.count; &#125; &#125;); for(int i = 0; i &lt; 130; i++)&#123; if(list[i].count != 0)&#123; System.out.println(list[i].ascii + \" \" + list[i].count); &#125; &#125; if(sc.hasNextLine())&#123; System.out.println(); &#125; &#125; sc.close(); &#125;&#125;class Ascii &#123; public int ascii; public int count; public Ascii(int a) &#123; ascii = a; count = 0; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"879. Profitable Schemes","slug":"coding/leetcode/Hard/879-Profitable-Schemes","date":"2023-04-21T01:21:14.000Z","updated":"2023-05-28T17:12:50.593Z","comments":true,"path":"coding/leetcode/Hard/879-Profitable-Schemes/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/879-Profitable-Schemes/","excerpt":"","text":"⭐️ # 題目敘述 There is a group of n members, and a list of various crimes they could commit. The ith crime generates a profit[i] and requires group[i] members to participate in it. If a member participates in one crime, that member can't participate in another crime. Let's call a profitable scheme any subset of these crimes that generates at least minProfit profit, and the total number of members participating in that subset of crimes is at most n . Return the number of schemes that can be chosen. Since the answer may be very large, return it modulo 10^9 + 7 . # Example 1: Input: n = 5, minProfit = 3, group = [2,2], profit = [2,3] Output: 2 Explanation: To make a profit of at least 3, the group could either commit crimes 0 and 1, or just crime 1. In total, there are 2 schemes. # Example 2: Input: n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8] Output: 7 Explanation: To make a profit of at least 5, the group could commit any crimes, as long as they commit one. There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2). # 解題思路 # Solution class Solution &#123; public int mod = (int) 1e9 + 7; public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) &#123; int[][] dp = new int[n + 1][minProfit + 1]; dp[0][0] = 1; for (int k = 1; k &lt;= group.length; k++) &#123; int g = group[k - 1]; int p = profit[k - 1]; for (int i = n; i >= g; i--) &#123; for (int j = minProfit; j >= 0; j--) &#123; dp[i][j] = (dp[i][j] + dp[i - g][Math.max(0, j - p)]) % mod; &#125; &#125; &#125; int sum = 0; for (int i = 0; i &lt;= n; i++) &#123; sum = (sum + dp[i][minProfit]) % mod; &#125; return sum; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"uva 10057 - A mid-summer night’s dream","slug":"coding/cpe/One Star/uva-10057-A-mid-summer-night’s-dream","date":"2023-04-20T06:31:15.000Z","updated":"2023-05-28T17:10:41.708Z","comments":true,"path":"coding/cpe/One Star/uva-10057-A-mid-summer-night’s-dream/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10057-A-mid-summer-night%E2%80%99s-dream/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 30.000 seconds # 題目 This is year 2200AD . Science has progressed a lot in two hundred years. Two hundred years is mentioned here because this problem is being sent back to 2000AD with the help of time machine. Now it is possible to establish direct connection between man and computer CPU. People can watch other peoples dream on 3D displayer (That is the monitor today) as if they were watching a movie. One problem in this century is that people have become so dependent on computers that their analytical ability is approaching zero. Computers can now read problems and solve them automatically. But they can solve only difficult problems. There are no easy problems now. Our chief scientist is in great trouble as he has forgotten the number of his combination lock. For security reasons computers today cannot solve combination lock related problems. In a mid-summer night the scientist has a dream where he sees a lot of unsigned integer numbers flying around. He records them with the help of his computer, Then he has a clue that if the numbers are (X1, X2, . . . , Xn) he will have to find an integer number A (This A is the combination lock code) such that (∣X1−A∣+∣X2−A∣+...+∣Xn−A∣)(|X_1 − A| + |X_2 − A| + . . . + |X_n − A|) (∣X1​−A∣+∣X2​−A∣+...+∣Xn​−A∣) is minimum. # Input Input will contain several blocks. Each block will start with a number n (0 &lt; n ≤ 1000000) indicating how many numbers he saw in the dream. Next there will be n numbers. All the numbers will be less that 65536 . The input will be terminated by end of file # Output For each set of input there will be one line of output. That line will contain the minimum possible value for A . Next it will contain how many numbers are there in the input that satisfy the property of A (The summation of absolute deviation from A is minimum). And finally you have to print how many possible different integer values are there for A (these values need not be present in the input). These numbers will be separated by single space. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 2 10 10 4 1 2 2 4 # Sample Output 10 2 1 2 2 1 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while(sc.hasNextInt())&#123; int line = sc.nextInt(); int[] arr = new int[line]; for(int i = 0; i &lt; line; i++)&#123; arr[i] = sc.nextInt(); &#125; Arrays.sort(arr); int min1, min2; if(line % 2 == 0)&#123; min1 = arr[line / 2 - 1]; min2 = arr[line / 2]; &#125;else&#123; min1 = arr[line / 2]; min2 = arr[line / 2]; &#125; int count = 0; for(int i = 0; i &lt; line; i++)&#123; if(arr[i] == min1 || arr[i] == min2)&#123; count++; &#125; &#125; int all = min2 - min1 + 1; System.out.println(min1 + \" \" + count + \" \" + all); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"662. Maximum Width of Binary Tree","slug":"coding/leetcode/Medium/662-Maximum-Width-of-Binary-Tree","date":"2023-04-20T01:23:38.000Z","updated":"2023-05-28T17:13:46.976Z","comments":true,"path":"coding/leetcode/Medium/662-Maximum-Width-of-Binary-Tree/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/662-Maximum-Width-of-Binary-Tree/","excerpt":"","text":"⭐️⭐️ # 題目敘述 Given the root of a binary tree, return the maximum width of the given tree. The maximum width of a tree is the maximum width among all levels. The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation. It is guaranteed that the answer will in the range of a 32-bit signed integer. # Example 1: Input: root = [1,3,2,5,3,null,9] Output: 4 Explanation: The maximum width exists in the third level with length 4 (5,3,null,9). # Example 2: Input: root = [1,3,2,5,null,null,9,6,null,7] Output: 7 Explanation: The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7). # Example 3: Input: root = [1,3,2,5] Output: 2 Explanation: The maximum width exists in the second level with length 2 (3,2). # 解題思路 # Solution import javafx.util.Pair;import java.util.ArrayDeque;import java.util.Deque;// Definition for a binary tree node.public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode() &#123;&#125; TreeNode(int val) &#123; this.val = val; &#125; TreeNode(int val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125;&#125;class Solution &#123; public int widthOfBinaryTree(TreeNode root) &#123; if(root == null) return 0; int ans = 0; Deque&lt;Pair&lt;TreeNode, Integer>> deque = new ArrayDeque&lt;>(); deque.add(new Pair&lt;>(root, 0)); while(!deque.isEmpty())&#123; int len = deque.size(); int start = deque.peekFirst().getValue(); int end = deque.peekLast().getValue(); ans = Math.max(ans, end - start + 1); for(int i = 0; i &lt; len; i++)&#123; Pair&lt;TreeNode, Integer> node = deque.pop(); TreeNode curr = node.getKey(); int index = node.getValue(); if(curr.left != null) deque.add(new Pair&lt;>(curr.left, 2 * index)); if(curr.right != null) deque.add(new Pair&lt;>(curr.right, 2 * index + 1)); &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Tree","slug":"Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Tree/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Tree/"}]},{"title":"uva 10056 - What is the Probability?","slug":"coding/cpe/One Star/uva-10056-What-is-the-Probability","date":"2023-04-19T12:43:28.000Z","updated":"2023-05-28T17:10:38.824Z","comments":true,"path":"coding/cpe/One Star/uva-10056-What-is-the-Probability/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10056-What-is-the-Probability/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Probability has always been an integrated part of computer algorithms. Where the deterministic algorithms have failed to solve a problem in short time, probabilistic algorithms have come to the rescue. In this problem we are not dealing with any probabilistic algorithm. We will just try to determine the winning probability of a certain player. A game is played by throwing a dice like thing (it should not be assumed that it has six sides like an ordinary dice). If a certain event occurs when a player throws the dice (such as getting a 3, getting green side on top or whatever) he is declared the winner. There can be N such player. So the first player will throw the dice, then the second and at last the N-th player and again the first player and so on. When a player gets the desired event he or she is declared winner and playing stops. You will have to determine the winning probability of one (The I-th) of these players. # Input Input will contain an integer S (S ≤ 1000) at first, which indicates how many sets of inputs are there. The next S lines will contain S sets of inputs. Each line contain an integer N (N ≤ 1000) which denotes the number players, a floating point number p which indicates the probability of the happening of a successful event in a single throw (If success means getting 3 then p is the probability of getting 3 in a single throw. For a normal dice the probability of getting 3 is 1/6 ), and I (I ≤ N) the serial of the player whose winning probability is to be determined (Serial no varies from 1 to N ). You can assume that no invalid probability (p) value will be given as input. # Output For each set of input, output in a single line the probability of the I-th player to win. The output floating point number will always have four digits after the decimal point as shown in the sample output. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 2 2 0.166666 1 2 0.166666 2 # Sample Output 0.5455 0.4545 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int S = sc.nextInt(); for(int i = 0; i &lt; S; i++)&#123; int n = sc.nextInt(); double p = sc.nextDouble(); int ith = sc.nextInt(); double q = 1 - p; if(p == 0)&#123; System.out.printf(\"%.4f\\n\", 0.0); &#125;else&#123; System.out.printf(\"%.4f\\n\", Math.pow(q, ith - 1) * p / (1 - Math.pow(q, n))); &#125; &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"uva 10055 - Hashmat the Brave Warrior","slug":"coding/cpe/One Star/uva-10055-Hashmat-the-Brave-Warrior","date":"2023-04-19T12:18:23.000Z","updated":"2023-05-28T17:10:36.208Z","comments":true,"path":"coding/cpe/One Star/uva-10055-Hashmat-the-Brave-Warrior/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10055-Hashmat-the-Brave-Warrior/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Hashmat is a brave warrior who with his group of young soldiers moves from one place to another to fight against his opponents. Before Fighting he just calculates one thing, the difference between his soldier number and the opponent’s soldier number. From this difference he decides whether to fight or not. Hashmat’s soldier number is never greater than his opponent. # Input The input contains two numbers in every line. These two numbers in each line denotes the number soldiers in Hashmat’s army and his opponent’s army or vice versa. The input numbers are not greater than 232. Input is terminated by ‘End of File’ . # Output For each line of input, print the difference of number of soldiers between Hashmat’s army and his opponent’s army. Each output should be in seperate line. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 10 12 10 14 100 200 # Sample Output 2 4 100 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while(sc.hasNextLong())&#123; long a = sc.nextLong(); long b = sc.nextLong(); System.out.println(Math.abs(a - b)); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"uva 10050 - Hartals","slug":"coding/cpe/One Star/uva-10050-Hartals","date":"2023-04-19T10:58:20.000Z","updated":"2023-05-28T17:10:12.302Z","comments":true,"path":"coding/cpe/One Star/uva-10050-Hartals/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10050-Hartals/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 A social research organization has determined a simple set of parameters to simulate the behavior of the political parties of our country. One of the parameters is a positive integer h (called the hartal parameter) that denotes the average number of days between two successive hartals (strikes) called by the corresponding party. Though the parameter is far too simple to be flawless, it can still be used to forecast the damages caused by hartals. The following example will give you a clear idea: Consider three political parties. Assume h1 = 3 , h2 = 4 and h3 = 8 where hi is the hartal parameter for party i (i = 1, 2, 3) . Now, we will simulate the behavior of these three parties for N = 14 days. One must always start the simulation on a Sunday and assume that there will be no hartals on weekly holidays (on Fridays and Saturdays). The simulation above shows that there will be exactly 5 hartals (on days 3 , 4 , 8 , 9 and 12 ) in 14 days. There will be no hartal on day 6 since it is a Friday. Hence we lose 5 working days in 2 weeks. In this problem, given the hartal parameters for several political parties and the value of N , your job is to determine the number of working days we lose in those N days. # Input The first line of the input consists of a single integer T giving the number of test cases to follow. The first line of each test case contains an integer N (7 ≤ N ≤ 3650) giving the number of days over which the simulation must be run. The next line contains another integer P (1 ≤ P ≤ 100) representing the number of political parties in this case. The ith of the next P lines contains a positive integer hi (which will never be a multiple of 7 ) giving the hartal parameter for party i (1 ≤ i ≤ P) . # Output For each test case in the input output the number of working days we lose. Each output must be on a separate line. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 2 14 3 3 4 8 100 4 12 15 25 40 # Sample Output 5 15 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for(int i = 0; i &lt; T; i++)&#123; int day = sc.nextInt(); int P = sc.nextInt(); int[] hartals = new int[day + 1]; for(int j = 0; j &lt; P; j++)&#123; int temp = sc.nextInt(); int index = temp; while(index &lt;= day)&#123; hartals[index]++; index += temp; &#125; &#125; int ans = 0; for(int j = 1; j &lt; day + 1; j++)&#123; if(j % 7 != 6 &amp;&amp; j % 7 != 0 &amp;&amp; hartals[j] != 0)&#123; ans++; &#125; &#125; System.out.println(ans); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"uva 10041 - Vito's Family","slug":"coding/cpe/One Star/uva-10041-Vito-s-Family","date":"2023-04-19T10:27:10.000Z","updated":"2023-05-28T17:10:06.412Z","comments":true,"path":"coding/cpe/One Star/uva-10041-Vito-s-Family/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10041-Vito-s-Family/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The world-known gangster Vito Deadstone is moving to New York. He has a very big family there, all of them living in Lamafia Avenue. Since he will visit all his relatives very often, he is trying to find a house close to them. Vito wants to minimize the total distance to all of them and has blackmailed you to write a program that solves his problem. # Input The input consists of several test cases. The first line contains the number of test cases. For each test case you will be given the integer number of relatives r (0 &lt; r &lt; 500) and the street numbers (also integers) s1, s2, . . . , si, . . . , sr where they live (0 &lt; si &lt; 30000 ) . Note that several relatives could live in the same street number. # Output For each test case your program must write the minimal sum of distances from the optimal Vito’s house to each one of his relatives. The distance between two street numbers si and sj is dij = | si − sj | . 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 2 2 2 4 3 2 4 6 # Sample Output 2 4 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int Line = sc.nextInt(); for(int i = 0; i &lt; Line; i++)&#123; int r = sc.nextInt(); int[] s = new int[r]; for(int j = 0; j &lt; r; j++)&#123; s[j] = sc.nextInt(); &#125; Arrays.sort(s); int house = s[r / 2]; int distance = 0; for(int j = 0; j &lt; r; j++)&#123; distance += Math.abs(house - s[j]); &#125; System.out.println(distance); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"uva 10038 - Jolly Jumpers","slug":"coding/cpe/One Star/uva-10038-Jolly-Jumpers","date":"2023-04-19T10:03:18.000Z","updated":"2023-05-28T17:10:29.922Z","comments":true,"path":"coding/cpe/One Star/uva-10038-Jolly-Jumpers/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10038-Jolly-Jumpers/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 A sequence of n &gt; 0 integers is called a jolly jumper if the absolute values of the difference between successive elements take on all the values 1 through n − 1 . For instance, 1 4 2 3 is a jolly jumper, because the absolutes differences are 3 , 2 , and 1 respectively. The definition implies that any sequence of a single integer is a jolly jumper. You are to write a program to determine whether or not each of a number of sequences is a jolly jumper. # Input Each line of input contains an integer n ≤ 3000 followed by n integers representing the sequence. # Output For each line of input, generate a line of output saying ‘Jolly’ or ‘Not jolly’ . 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 4 1 4 2 3 5 1 4 2 -1 6 # Sample Output Jolly Not jolly # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while(sc.hasNextInt())&#123; int N = sc.nextInt(); int[] hashTable = new int[N]; int[] num = new int[N]; boolean jolly = true; for(int i = 0; i &lt; N; i++)&#123; num[i] = sc.nextInt(); &#125; for(int i = 0; i &lt; N - 1; i++)&#123; int temp = (int)Math.abs(num[i] - num[i + 1]); if(temp >= 1 &amp;&amp; temp &lt;= N - 1)&#123; hashTable[temp]++; if(hashTable[temp] > 1)&#123; jolly = false; break; &#125; &#125;else&#123; jolly = false; break; &#125; &#125; System.out.println((jolly ? \"Jolly\" : \"Not jolly\")); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"CPE 49題","slug":"CPE-49題","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE-49%E9%A1%8C/"}]},{"title":"uva 10019 - Funny Encryption Method","slug":"coding/cpe/One Star/uva-10019-Funny-Encryption-Method","date":"2023-04-19T08:53:23.000Z","updated":"2023-05-28T17:09:58.862Z","comments":true,"path":"coding/cpe/One Star/uva-10019-Funny-Encryption-Method/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10019-Funny-Encryption-Method/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 無本題 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 A student from ITESM Campus Monterrey plays with a new encryption method for numbers. These method consist of the following steps: Steps : Example Read the number N to encrypt : M = 265 Interpret N as a decimal number : X1 = 265 (decimal) Convert the decimal interpretation of N to its binary representation : X1 = 100001001 (binary) Let b1 be equal to the number of 1’s in this binary representation : b1 = 3 Interpret N as a Hexadecimal number : X2 = 265 (hexadecimal) Convert the hexadecimal interpretation of N to its binary representation : X2 = 1001100101 Let b2 be equal to the number of 1’s in the last binary representation : b2 = 5 The encryption is the result of M xor (b1 ∗ b2) : 265 xor (3*5) = 262 This student failed Computational Organization, thats why this student asked the judges of ITESM Campus Monterrey internal ACM programming Contest to ask for the numbers of 1’s bits of this two representations so that he can continue playing. You have to write a program that read a Number and give as output the number b1 and b2 # Input The first line will contain a number N which is the number of cases that you have to process. Each of the following N Lines (0 &lt; N ≤ 1000) will contain the number M (0 &lt; M ≤ 9999, in decimal representation) which is the number the student wants to encrypt. # Output You will have to output N lines, each containing the number b1 and b2 in that order, separated by one space corresponding to that lines number to crypt 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 3 265 111 1234 # Sample Output 3 5 6 3 5 5 # 解題技巧 # Solution Main.javaimport java.math.BigInteger;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); for(int i = 0; i &lt; N; i++)&#123; String M = sc.next(); String X1 = (new BigInteger(M, 10)).toString(2); String X2 = (new BigInteger(M, 16)).toString(2); int b1 = 0; int b2 = 0; for(int j = 0; j &lt; X1.length(); j++)&#123; if(X1.charAt(j) == '1') b1++; &#125; for(int j = 0; j &lt; X2.length(); j++)&#123; if(X2.charAt(j) == '1') b2++; &#125; System.out.println(b1 + \" \" + b2); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"uva 10018 - Reverse and Add","slug":"coding/cpe/One Star/uva-10018-Reverse-and-Add","date":"2023-04-19T08:15:30.000Z","updated":"2023-05-28T17:09:54.339Z","comments":true,"path":"coding/cpe/One Star/uva-10018-Reverse-and-Add/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10018-Reverse-and-Add/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The “reverse and add” method is simple: choose a number, reverse its digits and add it to the original. If the sum is not a palindrome (which means, it is not the same number from left to right and right to left), repeat this procedure. In this particular case the palindrome ‘9339’ appeared after the 4th addition. This method leads to palindromes in a few step for almost all of the integers. But there are interesting exceptions. 196 is the first number for which no palindrome has been found. It is not proven though, that there is no such a palindrome. You must write a program that give the resulting palindrome and the number of iterations (additions) to compute the palindrome. You might assume that all tests data on this problem: will have an answer , will be computable with less than 1000 iterations (additions), will yield a palindrome that is not greater than 4,294,967,295. # Input The first line will have a number N (0 &lt; N ≤ 100) with the number of test cases, the next N lines will have a number P to compute its palindrome. # Output For each of the N tests you will have to write a line with the following data : minimum number of iterations(additions) to get to the palindrome and the resulting palindrome itself separated by one space. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 3 195 265 750 # Sample Output 4 9339 5 45254 3 6666 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); for (int i = 0; i &lt; N; i++) &#123; String P = sc.next(); boolean check = false; int count = 0; while (!check) &#123; StringBuffer temp = new StringBuffer(P); temp = temp.reverse(); String reverseP = temp.toString(); String nextP = Long.toString(Long.parseLong(P) + Long.parseLong(reverseP)); for (int j = 0; j &lt; nextP.length() / 2; j++) &#123; if (nextP.charAt(nextP.length() - 1 - j) != nextP.charAt(j)) &#123; check = false; break; &#125;else&#123; check = true; &#125; &#125; if(nextP.length() == 1)&#123; check = true; &#125; P = nextP; count++; &#125; System.out.println(count + \" \" + P); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"uva 10008 - What’s Cryptanalysis?","slug":"coding/cpe/One Star/uva-10008-What’s-Cryptanalysis","date":"2023-04-19T03:48:29.000Z","updated":"2023-05-28T17:09:50.442Z","comments":true,"path":"coding/cpe/One Star/uva-10008-What’s-Cryptanalysis/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-10008-What%E2%80%99s-Cryptanalysis/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Cryptanalysis is the process of breaking someone else’s cryptographic writing. This sometimes involves some kind of statistical analysis of a passage of (encrypted) text. Your task is to write a program which performs a simple analysis of a given text. # Input The first line of input contains a single positive decimal integer n. This is the number of lines which follow in the input. The next n lines will contain zero or more characters (possibly including whitespace). This is the text which must be analyzed. # Output Each line of output contains a single uppercase letter, followed by a single space, then followed by a positive decimal integer. The integer indicates how many times the corresponding letter appears in the input text. Upper and lower case letters in the input are to be considered the same. No other characters must be counted. The output must be sorted in descending count order; that is, the most frequent letter is on the first output line, and the last line of output indicates the least frequent letter. If two letters have the same frequency, then the letter which comes first in the alphabet must appear first in the output. If a letter does not appear in the text, then that letter must not appear in the output. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 3 This is a test. Count me 1 2 3 4 5. Wow!!!! Is this question easy? # Sample Output S 7 T 6 I 5 E 4 O 3 A 2 H 2 N 2 U 2 W 2 C 1 M 1 Q 1 Y 1 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); sc.nextLine(); Alp[] alp = new Alp[26]; for(int i = 0; i &lt; 26; i++)&#123; alp[i] = new Alp((char)(i + 'A')); &#125; for(int i = 0; i &lt; n; i++)&#123; String str = sc.nextLine(); for(int j = 0; j &lt; str.length(); j++)&#123; char a = str.charAt(j); if(a >= 'A' &amp;&amp; a &lt;= 'Z')&#123; alp[(int)a - 'A'].add();; &#125; if(a >= 'a' &amp;&amp; a &lt;= 'z')&#123; alp[(int)a - 'a'].add();; &#125; &#125; &#125; Arrays.sort(alp, new Comparator&lt;Alp>() &#123; @Override public int compare(Alp a, Alp b) &#123; if (a.count == b.count) return a.letter - b.letter; return b.count - a.count; &#125; &#125;); for(Alp a : alp)&#123; if(a.count != 0)&#123; System.out.println(a.letter + \" \" + a.count); &#125;else&#123; break; &#125; &#125; sc.close(); &#125;&#125;class Alp&#123; public char letter; public int count; public Alp(char l)&#123; letter = l; count = 0; &#125; public void add()&#123; count++; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"1372. Longest ZigZag Path in a Binary Tree","slug":"coding/leetcode/Medium/1372-Longest-ZigZag-Path-in-a-Binary-Tree","date":"2023-04-19T01:58:24.000Z","updated":"2023-05-28T17:14:11.429Z","comments":true,"path":"coding/leetcode/Medium/1372-Longest-ZigZag-Path-in-a-Binary-Tree/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1372-Longest-ZigZag-Path-in-a-Binary-Tree/","excerpt":"","text":"⭐️⭐️ # 題目敘述 You are given the root of a binary tree. A ZigZag path for a binary tree is defined as follow: Choose any node in the binary tree and a direction (right or left). If the current direction is right, move to the right child of the current node; otherwise, move to the left child. Change the direction from right to left or from left to right. Repeat the second and third steps until you can't move in the tree. Zigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0). Return the longest ZigZag path contained in that tree. # Example 1 Input: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1] Output: 3 Explanation: Longest ZigZag path in blue nodes (right -&gt; left -&gt; right). # Example 2 Input: root = [1,1,1,null,1,null,null,1,1,null,1] Output: 4 Explanation: Longest ZigZag path in blue nodes (left -&gt; right -&gt; left -&gt; right). # Example 3: Input: root = [1] Output: 0 # 解題思路 # Solution class Solution &#123; int ans = 0; public int longestZigZag(TreeNode root) &#123; dfs(root, false, 0); dfs(root, true, 0); return ans; &#125; public void dfs(TreeNode node, boolean goLeft, int steps) &#123; if (node == null) &#123; return ; &#125; ans = Math.max(ans, steps); if (goLeft) &#123; dfs(node.left, false, steps + 1); dfs(node.right, true, 1); &#125; else &#123; dfs(node.left, false, 1); dfs(node.right, true, steps + 1); &#125; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Tree","slug":"Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Tree/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Tree/"}]},{"title":"1431. Kids With the Greatest Number of Candies","slug":"coding/leetcode/Easy/1431-Kids-With-the-Greatest-Number-of-Candies","date":"2023-04-17T01:49:25.000Z","updated":"2023-05-28T17:11:27.510Z","comments":true,"path":"coding/leetcode/Easy/1431-Kids-With-the-Greatest-Number-of-Candies/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1431-Kids-With-the-Greatest-Number-of-Candies/","excerpt":"","text":"⭐️ # 題目敘述 There are n kids with candies. You are given an integer array candies , where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies , denoting the number of extra candies that you have. Return a boolean array result of length n , where result[i] is true if, after giving the ith kid all the extraCandies , they will have the greatest number of candies among all the kids, or false otherwise. Note that multiple kids can have the greatest number of candies. # Example 1: Input: candies = [2,3,5,1,3], extraCandies = 3 Output: [true,true,true,false,true] Explanation: If you give all extraCandies to: Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids. Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids. Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids. Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids. Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids. # Example 2: Input: candies = [4,2,1,1,2], extraCandies = 1 Output: [true,false,false,false,false] Explanation: There is only 1 extra candy. Kid 1 will always have the greatest number of candies, even if a different kid is given the extra candy. # Example 3: Input: candies = [12,1,12], extraCandies = 10 Output: [true,false,true] # 解題思路 # Solution import java.util.ArrayList;import java.util.List;class Solution &#123; public List&lt;Boolean> kidsWithCandies(int[] candies, int extraCandies) &#123; int max = 0; for(int candy : candies)&#123; max = Math.max(candy, max); &#125; List&lt;Boolean> ans = new ArrayList&lt;>(); for(int candy : candies)&#123; int temp = candy + extraCandies; ans.add(temp &lt; max ? false : true); &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"}]},{"title":"uva 1587 - Box","slug":"coding/cpe/One Star/uva-1587-Box","date":"2023-04-15T13:16:47.000Z","updated":"2023-05-28T17:09:46.822Z","comments":true,"path":"coding/cpe/One Star/uva-1587-Box/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-1587-Box/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Ivan works at a factory that produces heavy machinery. He has a simple job — he knocks up wooden boxes of different sizes to pack machinery for delivery to the customers. Each box is a rectangular parallelepiped. Ivan uses six rectangular wooden pallets to make a box. Each pallet is used for one side of the box. Joe delivers pallets for Ivan. Joe is not very smart and often makes mistakes — he brings Ivan pallets that do not fit together to make a box. But Joe does not trust Ivan. It always takes a lot of time to explain Joe that he has made a mistake. Fortunately, Joe adores everything related to computers and sincerely believes that computers never make mistakes. Ivan has decided to use this for his own advantage. Ivan asks you to write a program that given sizes of six rectangular pallets tells whether it is possible to make a box out of them. # Input Input file contains several test cases. Each of them consists of six lines. Each line describes one pallet and contains two integer numbers w and h (1 ≤ w, h ≤ 10 000) — width and height of the pallet in millimeters respectively. # Output For each test case, print one output line. Write a single word ‘POSSIBLE’ to the output file if it is possible to make a box using six given pallets for its sides. Write a single word ‘IMPOSSIBLE’ if it is not possible to do so. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 1345 2584 2584 683 2584 1345 683 1345 683 1345 2584 683 1234 4567 1234 4567 4567 4321 4322 4567 4321 1234 4321 1234 # Sample Output POSSIBLE IMPOSSIBLE # 解題技巧 # Solution Main.javaimport java.util.*;class Box &#123; public int x, y; public Box(int x, int y) &#123; this.x = x; this.y = y; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNextInt()) &#123; Box[] box = new Box[6]; for (int i = 0; i &lt; 6; i++) &#123; int L = sc.nextInt(); int W = sc.nextInt(); box[i] = new Box(Math.max(L, W), Math.min(L, W)); &#125; Arrays.sort(box, new Comparator&lt;Box>() &#123; @Override public int compare(Box a, Box b) &#123; if (a.x == b.x) return a.y - b.y; return a.x - b.x; &#125; &#125;); boolean isBox = false; if (box[0].y == box[1].y &amp;&amp; box[1].y == box[2].y &amp;&amp; box[2].y == box[3].y &amp;&amp; box[2].x == box[3].x &amp;&amp; box[3].x == box[4].x &amp;&amp; box[4].x == box[5].x &amp;&amp; box[0].x == box[1].x &amp;&amp; box[1].x == box[4].y &amp;&amp; box[4].y == box[5].y) &#123; isBox = true; &#125; System.out.println(isBox ? \"POSSIBLE\" : \"IMPOSSIBLE\"); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"uva 1585 - Score","slug":"coding/cpe/One Star/uva-1585-Score","date":"2023-04-15T06:30:55.000Z","updated":"2023-05-28T17:09:43.986Z","comments":true,"path":"coding/cpe/One Star/uva-1585-Score/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-1585-Score/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 There is an objective test result such as “OOXXOXXOOO” . An ‘O’ means a correct answer of a problem and an ‘X’ means a wrong answer. The score of each problem of this test is calculated by itself and its just previous consecutive ‘O’s only when the answer is correct. For example, the score of the 10th problem is 3 that is obtained by itself and its two previous consecutive ‘O’s . Therefore, the score of “OOXXOXXOOO” is 10 which is calculated by “1+2+0+0+1+0+0+1+2+3” . You are to write a program calculating the scores of test results. # Input Your program is to read from standard input. The input consists of T test cases. The number of test cases T is given in the first line of the input. Each test case starts with a line containing a string composed by ‘O’ and ‘X’ and the length of the string is more than 0 and less than 80 . There is no spaces between ‘O’ and ‘X’ . # Output Your program is to write to standard output. Print exactly one line for each test case. The line is to contain the score of the test case. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 5 OOXXOXXOOO OOXXOOXXOO OXOXOXOXOXOXOX OOOOOOOOOO OOOOXOOOOXOOOOX # Sample Output 10 9 7 55 30 # 解題技巧 檢查 result 每一題是否正確。 'O' : 加上該題分數。 'X' : 則該題零分。 該題分數：前一題如果正確當前該題分數比前一題多一。 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for(int i = 0; i &lt; T; i++)&#123; String result = sc.next(); int curr = 1; boolean check = false; int ans = 0; for(int j = 0; j &lt; result.length(); j++)&#123; if(result.charAt(j) == 'X')&#123; check = false; curr = 1; &#125;else &#123; if(check)&#123; curr++; &#125; ans += curr; check = true; &#125; &#125; System.out.println(ans); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"2218. Maximum Value of K Coins From Piles","slug":"coding/leetcode/Hard/2218-Maximum-Value-of-K-Coins-From-Piles","date":"2023-04-15T04:01:24.000Z","updated":"2023-05-28T17:13:10.218Z","comments":true,"path":"coding/leetcode/Hard/2218-Maximum-Value-of-K-Coins-From-Piles/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/2218-Maximum-Value-of-K-Coins-From-Piles/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 There are n piles of coins on a table. Each pile consists of a positive number of coins of assorted denominations. In one move, you can choose any coin on top of any pile, remove it, and add it to your wallet. Given a list piles , where piles[i] is a list of integers denoting the composition of the ith pile from top to bottom, and a positive integer k , return the maximum total value of coins you can have in your wallet if you choose exactly k coins optimally. # Example 1: Input: piles = [[1,100,3],[7,8,9]], k = 2 Output: 101 Explanation: The above diagram shows the different ways we can choose k coins. The maximum total we can obtain is 101. # Example 2: Input: piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7 Output: 706 Explanation: The maximum total can be obtained if we choose all coins from the last pile. # 解題思路 # Solution import java.util.Arrays;import java.util.List;class Solution &#123; public int maxValueOfCoins(List&lt;List&lt;Integer>> piles, int k) &#123; int[][] dp = new int[piles.size() + 1][k + 1]; Arrays.fill(dp[0], 0); for (int i = 1; i &lt;= piles.size(); i++) &#123; dp[i][0] = 0; &#125; for (int i = 1; i &lt;= piles.size(); i++) &#123; for (int j = 1; j &lt;= k; j++) &#123; int curr = 0; for (int x = 0; x &lt; Math.min(piles.get(i - 1).size(), j); x++) &#123; curr += piles.get(i - 1).get(x); dp[i][j] = Math.max(dp[i][j], curr + dp[i - 1][j - x - 1]); &#125; dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]); &#125; &#125; return dp[piles.size()][k]; &#125;&#125; 單字 denoting 表示 to represent something 片語 & 搭配詞 assorted denominations 個種面額","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"}]},{"title":"516. Longest Palindromic Subsequence","slug":"coding/leetcode/Medium/516-Longest-Palindromic-Subsequence","date":"2023-04-14T17:08:29.000Z","updated":"2023-05-28T17:13:38.961Z","comments":true,"path":"coding/leetcode/Medium/516-Longest-Palindromic-Subsequence/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/516-Longest-Palindromic-Subsequence/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a string s , find the longest palindromic subsequence's length in s . A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. # Example 1: Input: s = &quot;bbbab&quot; Output: 4 Explanation: One possible longest palindromic subsequence is &quot;bbbb&quot;. # Example 2: Input: s = &quot;cbbd&quot; Output: 2 Explanation: One possible longest palindromic subsequence is &quot;bb&quot;. # 解題思路 # Solution class Solution &#123; public int longestPalindromeSubseq(String s) &#123; int n = s.length(); int[] dp = new int[n]; for (int i = n - 1; i >= 0; i--) &#123; int[] newdp = new int[n]; newdp[i] = 1; for (int j = i + 1; j &lt; n; j++) &#123; if (s.charAt(i) == s.charAt(j)) &#123; newdp[j] = 2 + dp[j-1]; &#125; else &#123; newdp[j] = Math.max(dp[j], newdp[j-1]); &#125; &#125; dp = newdp; &#125; return dp[n-1]; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"946. Validate Stack Sequences","slug":"coding/leetcode/Medium/946-Validate-Stack-Sequences","date":"2023-04-13T01:21:33.000Z","updated":"2023-05-28T17:13:58.465Z","comments":true,"path":"coding/leetcode/Medium/946-Validate-Stack-Sequences/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/946-Validate-Stack-Sequences/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given two integer arrays pushed and popped each with distinct values, return true if this could have been the result of a sequence of push and pop operations on an initially empty stack, or false otherwise. # Example 1: Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1] Output: true Explanation: We might do the following sequence: push(1), push(2), push(3), push(4), pop() -&gt; 4, push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1 # Example 2: Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2] Output: false Explanation: 1 cannot be popped before 2. # 解題思路 # Solution import java.util.Stack;class Solution &#123; public boolean validateStackSequences(int[] pushed, int[] popped) &#123; Stack&lt;Integer> stack = new Stack&lt;>(); int index = 0; for(int p : pushed)&#123; stack.push(p); while(!stack.isEmpty() &amp;&amp; stack.peek() == popped[index])&#123; stack.pop(); index++; &#125; &#125; return stack.isEmpty(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"}]},{"title":"71. Simplify Path","slug":"coding/leetcode/Medium/71-Simplify-Path","date":"2023-04-12T03:22:17.000Z","updated":"2023-05-28T17:13:29.304Z","comments":true,"path":"coding/leetcode/Medium/71-Simplify-Path/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/71-Simplify-Path/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a string path , which is an absolute path (starting with a slash '/' ) to a file or directory in a Unix-style file system, convert it to the simplified canonical path. In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//' ) are treated as a single slash '/' . For this problem, any other format of periods such as '...' are treated as file/directory names. The canonical path should have the following format: The path starts with a single slash '/'. Any two directories are separated by a single slash '/'. The path does not end with a trailing '/'. The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..') Return the simplified canonical path. # Example 1: Input: path = &quot;/home/&quot; Output: &quot;/home&quot; Explanation: Note that there is no trailing slash after the last directory name. # Example 2: Input: path = &quot;/../&quot; Output: &quot;/&quot; Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. # Example 3: Input: path = &quot;/home//foo/&quot; Output: &quot;/home/foo&quot; Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. # 解題思路 # Solution import java.util.Stack;class Solution &#123; public String simplifyPath(String path) &#123; Stack&lt;String> stack = new Stack&lt;>(); for (String str : path.split(\"/\")) &#123; if (!stack.isEmpty() &amp;&amp; str.equals(\"..\")) &#123; stack.pop(); &#125; else if (!str.equals(\".\") &amp;&amp; !str.equals(\"\") &amp;&amp; !str.equals(\"..\")) &#123; stack.add(str); &#125; &#125; StringBuilder ans = new StringBuilder(); for (String str : stack) &#123; ans.append(\"/\").append(str); &#125; return ans.length() == 0 ? \"/\" : ans.toString(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"}]},{"title":"2390. Removing Stars From a String","slug":"coding/leetcode/Medium/2390-Removing-Stars-From-a-String","date":"2023-04-11T03:05:05.000Z","updated":"2023-05-28T17:14:35.475Z","comments":true,"path":"coding/leetcode/Medium/2390-Removing-Stars-From-a-String/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2390-Removing-Stars-From-a-String/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given a string s , which contains stars * . In one operation, you can: Choose a star in s . Remove the closest non-star character to its left, as well as remove the star itself. Return the string after all stars have been removed. Note: The input will be generated such that the operation is always possible. It can be shown that the resulting string will always be unique. # Example 1: Input: s = &quot;leet**cod*e&quot; Output: &quot;lecoe&quot; Explanation: Performing the removals from left to right: The closest character to the 1st star is 't' in &quot;leet**cod*e&quot; . s becomes &quot;lee*cod*e&quot; . The closest character to the 2nd star is 'e' in &quot;lee*cod*e&quot; . s becomes &quot;lecod*e&quot; . The closest character to the 3rd star is 'd' in &quot;lecod*e&quot; . s becomes &quot;lecoe&quot; . There are no more stars, so we return &quot;lecoe&quot; . # Example 2: Input: s = &quot;erase*****&quot; Output: &quot;&quot; Explanation: The entire string is removed, so we return an empty string. # 解題思路 # Solution import java.util.Stack;class Solution &#123; public String removeStars(String s) &#123; char[] toChar = s.toCharArray(); Stack&lt;Character> stack = new Stack&lt;>(); for(int i = 0; i &lt; s.length(); i++)&#123; if(toChar[i] == '*')&#123; stack.pop(); &#125;else &#123; stack.add(toChar[i]); &#125; &#125; String ans = \"\"; while(!stack.isEmpty())&#123; ans = stack.pop() + ans; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"}]},{"title":"20. Valid Parentheses","slug":"coding/leetcode/Easy/20-Valid-Parentheses","date":"2023-04-10T01:44:58.000Z","updated":"2023-05-28T17:11:16.873Z","comments":true,"path":"coding/leetcode/Easy/20-Valid-Parentheses/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/20-Valid-Parentheses/","excerpt":"","text":"⭐️ # 題目敘述 Given a string s containing just the characters '(' , ')' , '&#123;' , '&#125;' , '[' and ']' , determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type. # Example 1: Input: s = &quot;()&quot; Output: true # Example 2: Input: s = &quot;(){}&quot; Output: true # Example 3: Input: s = &quot;(]&quot; Output: false # 解題思路 利用 stack。 # Solution import java.util.Stack;class Solution &#123; public boolean isValid(String s) &#123; if (s.length() % 2 != 0) &#123; return false; &#125; Stack&lt;Character> stack = new Stack&lt;>(); for (char c : s.toCharArray()) &#123; switch(c)&#123; case '(': case '&#123;': case '[': stack.push(c); break; case ')': if(stack.isEmpty() || stack.pop() != '(') return false; break; case '&#125;': if(stack.isEmpty() || stack.pop() != '&#123;') return false; break; case ']': if(stack.isEmpty() || stack.pop() != '[') return false; break; &#125; &#125; return (stack.isEmpty()); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"}]},{"title":"uva 1368 - DNA Consensus String","slug":"coding/cpe/One Star/uva-1368-DNA-Consensus-String","date":"2023-04-09T20:31:59.000Z","updated":"2023-05-28T17:09:41.178Z","comments":true,"path":"coding/cpe/One Star/uva-1368-DNA-Consensus-String/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-1368-DNA-Consensus-String/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 DNA (Deoxyribonucleic Acid) is the molecule which contains the genetic instructions. It consists of four different nucleotides, namely Adenine, Thymine, Guanine, and Cytosine as shown in Figure 1. If we represent a nucleotide by its initial character, a DNA strand can be regarded as a long string (sequence of characters) consisting of the four characters A, T, G, and C. For example, assume we are given some part of a DNA strand which is composed of the following sequence of nucleotides: “Thymine-Adenine-Adenine-Cytosine-Thymine-Guanine-CytosineCytosine-Guanine-Adenine-Thymine” Then we can represent the above DNA strand with the string “TAACTGCCGAT.” The biologist Prof. Ahn found that a gene X commonly exists in the DNA strands of five different kinds of animals, namely dogs, cats, horses, cows, and monkeys. He also discovered that the DNA sequences of the gene X from each animal were very alike. See Figure 2. Prof. Ahn thought that humans might also have the gene X and decided to search for the DNA sequence of X in human DNA. However, before searching, he should define a representative DNA sequence of gene X because its sequences are not exactly the same in the DNA of the five animals. He decided to use the Hamming distance to define the representative sequence. The Hamming distance is the number of different characters at each position from two strings of equal length. For example, assume we are given the two strings “AGCAT” and “GGAAT.” The Hamming distance of these two strings is 2 because the 1st and the 3rd characters of the two strings are different. Using the Hamming distance, we can define a representative string for a set of multiple strings of equal length. Given a set of strings S = {s1, . . . , sm} of length n, the consensus error between a string y of length n and the set S is the sum of the Hamming distances between y and each si in S. If the consensus error between y and S is the minimum among all possible strings y of length n, y is called a consensus string of S. For example, given the three strings “AGCAT” “AGACT” and “GGAAT” the consensus string of the given strings is “AGAAT” because the sum of the Hamming distances between “AGAAT” and the three strings is 3 which is minimal. (In this case, the consensus string is unique, but in general, there can be more than one consensus string.) We use the consensus string as a representative of the DNA sequence. For the example of Figure 2 above, a consensus string of gene X is “GCAAATGGCTGTGCA” and the consensus error is 7. # Input Your program is to read from standard input. The input consists of T test cases. The number of test cases T is given in the first line of the input. Each test case starts with a line containing two integers m and n which are separated by a single space. The integer m (4 ≤ m ≤ 50) represents the number of DNA sequences and n (4 ≤ n ≤ 1000) represents the length of the DNA sequences, respectively. In each of the next m lines, each DNA sequence is given. # Output Your program is to write to standard output. Print the consensus string in the first line of each case and the consensus error in the second line of each case. If there exists more than one consensus string, print the lexicographically smallest consensus string. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 3 5 8 TATGATAC TAAGCTAC AAAGATCC TGAGATAC TAAGATGT 4 10 ACGTACGTAC CCGTACGTAG GCGTACGTAT TCGTACGTAA 6 10 ATGTTACCAT AAGTTACGAT AACAAAGCAA AAGTTACCTT AAGTTACCAA TACTTACCAA # Sample Output TAAGATAC 7 ACGTACGTAA 6 AAGTTACCAA 12 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int T = sc.nextInt(); // ACGT Map&lt;Character, Integer> toInt = new HashMap&lt;>(); Map&lt;Integer, Character> toChar = new HashMap&lt;>(); toInt.put('A', 0); toChar.put(0, 'A'); toInt.put('C', 1); toChar.put(1, 'C'); toInt.put('G', 2); toChar.put(2, 'G'); toInt.put('T', 3); toChar.put(3, 'T'); for (int i = 0; i &lt; T; i++) &#123; int m = sc.nextInt(); int n = sc.nextInt(); char[][] DNA = new char[m][n]; int[][] count = new int[n][4]; for (int j = 0; j &lt; m; j++) &#123; DNA[j] = sc.next().toCharArray(); for (int k = 0; k &lt; n; k++) &#123; count[k][toInt.get(DNA[j][k])]++; &#125; &#125; int sum = 0; for (int j = 0; j &lt; n; j++) &#123; int max = -1; int index = -1; for (int k = 3; k >= 0; k--) &#123; if (count[j][k] >= max) &#123; max = count[j][k]; index = k; &#125; &#125; System.out.print(toChar.get(index)); sum += m - max; &#125; System.out.println(); System.out.println(sum); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"1857. Largest Color Value in a Directed Graph","slug":"coding/leetcode/Hard/1857-Largest-Color-Value-in-a-Directed-Graph","date":"2023-04-09T04:05:26.000Z","updated":"2023-05-28T17:12:59.257Z","comments":true,"path":"coding/leetcode/Hard/1857-Largest-Color-Value-in-a-Directed-Graph/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/1857-Largest-Color-Value-in-a-Directed-Graph/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 There is a directed graph of n colored nodes and m edges. The nodes are numbered from 0 to n - 1 . You are given a string colors where colors[i] is a lowercase English letter representing the color of the ith node in this graph (0-indexed). You are also given a 2D array edges where edges[j] = [aj, bj] indicates that there is a directed edge from node aj to node bj . A valid path in the graph is a sequence of nodes x1 -&gt; x2 -&gt; x3 -&gt; ... -&gt; xk such that there is a directed edge from xi to xi+1 for every 1 &lt;= i &lt; k . The color value of the path is the number of nodes that are colored the most frequently occurring color along that path. Return the largest color value of any valid path in the given graph, or -1 if the graph contains a cycle. # Example 1: Input: colors = &quot;abaca&quot;, edges = [[0,1],[0,2],[2,3],[3,4]] Output: 3 Explanation: The path 0 -&gt; 2 -&gt; 3 -&gt; 4 contains 3 nodes that are colored &quot;a&quot; (red in the above image) . # Example 2: Input: colors = &quot;a&quot;, edges = [[0,0]] Output: -1 Explanation: There is a cycle from 0 to 0. # 解題思路 # Solution import java.util.ArrayList;import java.util.LinkedList;import java.util.List;import java.util.Queue;class Solution &#123; public int largestPathValue(String colors, int[][] edges) &#123; List&lt;List&lt;Integer>> graph = new ArrayList&lt;>(); int length = colors.length(); int inDegree[] = new int[length]; int colorsDP[][] = new int[length][26]; int visited = 0; for (int i = 0; i &lt; length; i++) &#123; graph.add(new ArrayList&lt;>()); &#125; for (int i = 0; i &lt; edges.length; i++) &#123; int start = edges[i][0]; int end = edges[i][1]; graph.get(start).add(end); inDegree[end]++; &#125; Queue&lt;Integer> queue = new LinkedList&lt;>(); for (int i = 0; i &lt; inDegree.length; i++) &#123; if (inDegree[i] == 0) &#123; queue.add(i); &#125; &#125; while (!queue.isEmpty()) &#123; int parent = queue.poll(); int parentColor = colors.charAt(parent) - 'a'; colorsDP[parent][parentColor] = colorsDP[parent][parentColor] + 1; for (Integer child : graph.get(parent)) &#123; inDegree[child]--; if (inDegree[child] == 0) &#123; queue.add(child); &#125; for (int i = 0; i &lt; 26; i++) &#123; colorsDP[child][i] = Math.max(colorsDP[child][i], colorsDP[parent][i]); &#125; &#125; visited++; &#125; if (visited != length) return -1; int maxColor = 0; for (int i = 0; i &lt; colorsDP.length; i++) &#123; for (int j = 0; j &lt; 26; j++) &#123; maxColor = Math.max(maxColor, colorsDP[i][j]); &#125; &#125; return maxColor; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Topological Sort","slug":"Topological-Sort","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Topological-Sort/"},{"name":"Memoization","slug":"Memoization","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Memoization/"}]},{"title":"uva 1237 - Expert Enough?","slug":"coding/cpe/One Star/uva-1237-Expert-Enough","date":"2023-04-08T16:27:36.000Z","updated":"2023-05-28T17:09:37.556Z","comments":true,"path":"coding/cpe/One Star/uva-1237-Expert-Enough/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-1237-Expert-Enough/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Auto-mobile Charting &amp; Manufacturing (ACM) is a company that specializes in manufacturing automobile spare parts. Being one of the leading automotive companies in the world, ACM are sure to keep up the latest information in that world. In the 100-year anniversary of the company, ACM compiled a huge list of range of prices of any automobiles ever recorded in the history. ACM then wants to develop a program that they called Automobile Expert System or AES for short. The program receives a price P as an input, and searches through the database for a car maker in which P falls in their range of lowest price L and highest price H of car they ever made. The program then output the car maker name. If the database contains no or more than one car maker that satisfies the query, the program produce output ‘UNDETERMINED’ (without quotes). Not so expert, huh? You are about to develop that program for ACM. # Input The input begins with a line containing an integer T (T ≤ 10) , the number of test cases follow. Each case begins with the size of the database D (D &lt; 10000) . The next each of D lines contains M , L and H (0 &lt; L &lt; H &lt; 1000000) which are the name of the maker (contains no whitespace and will never exceeds 20 characters), the car’s lowest price the maker ever made, and the car’s highest price the maker ever made respectively. Then there is the number of query Q (Q &lt; 1000) follows. Each of the next Q lines contains an integer P (0 &lt; P &lt; 1000000) , the query price. # Output Output for each query should be one line containing the name of the maker, or the string ‘UNDETERMINED’ (without quotes) if there is no maker or more than one maker that satisfies the query. You should separate output for different case by one empty line. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 1 4 HONDA 10000 45000 PEUGEOT 12000 44000 BMW 30000 75900 CHEVROLET 7000 37000 4 60000 7500 5000 10000 # Sample Output BMW CHEVROLET UNDETERMINED UNDETERMINED # 解題技巧 # Solution Java I/O 加速 Main.javaimport java.util.*;import java.io.*;public class Main &#123; public static void main(String[] args) &#123; InputStream inputStream = System.in; OutputStream outputStream = System.out; Scanner in = new Scanner(inputStream); PrintWriter out = new PrintWriter(outputStream); CPE slove = new CPE(); slove.slover(1, in, out); out.close(); &#125; static class CPE &#123; public void slover(int testNumber, Scanner in, PrintWriter out) &#123; int T = in.nextInt(); for (int i = 0; i &lt; T; i++) &#123; if (i != 0) &#123; out.println(); &#125; int D = in.nextInt(); Map&lt;int[], String> map = new HashMap&lt;>(); for (int j = 0; j &lt; D; j++) &#123; String M = in.next(); int[] LH = new int[2]; LH[0] = in.nextInt(); LH[1] = in.nextInt(); map.put(LH, M); &#125; int Q = in.nextInt(); for (int j = 0; j &lt; Q; j++) &#123; ArrayList&lt;String> ans = new ArrayList&lt;>(); int P = in.nextInt(); for (int[] m : map.keySet()) &#123; if (m[0] &lt;= P &amp;&amp; m[1] >= P) &#123; ans.add(map.get(m)); if(ans.size() > 1) break; &#125; &#125; if (ans.size() == 1) &#123; out.println(ans.get(0)); &#125; else &#123; out.println(\"UNDETERMINED\"); &#125; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"uva 1225 - Digit Counting","slug":"coding/cpe/One Star/uva-1225-Digit-Counting","date":"2023-04-08T08:25:23.000Z","updated":"2023-05-28T17:09:33.946Z","comments":true,"path":"coding/cpe/One Star/uva-1225-Digit-Counting/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-1225-Digit-Counting/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Trung is bored with his mathematics homeworks. He takes a piece of chalk and starts writing a sequence of consecutive integers starting with 1 to N (1 &lt; N &lt; 10000) . After that, he counts the number of times each digit (0 to 9) appears in the sequence. For example, with N = 13 , the sequence is: 1234567891011121312345678910111213 12345678910111213 In this sequence, 0 appears once , 1 appears 6 times , 2 appears 2 times , 3 appears 3 times , and each digit from 4 to 9 appears once . After playing for a while, Trung gets bored again. He now wants to write a program to do this for him. Your task is to help him with writing this program. # Input The input file consists of several data sets. The first line of the input file contains the number of data sets which is a positive integer and is not bigger than 20 . The following lines describe the data sets. For each test case, there is one single line containing the number N . # Output For each test case, write sequentially in one line the number of digit 0, 1, . . . 9 separated by a space. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 2 3 13 # Sample Output 0 1 1 1 0 0 0 0 0 0 1 6 2 2 1 1 1 1 1 1 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int data = sc.nextInt(); for(int i = 0; i &lt; data; i++)&#123; int N = sc.nextInt(); int[] ans = new int[10]; for(int j = 1; j &lt;= N; j++)&#123; String str = Integer.toString(j); for(int l = 0; l &lt; str.length(); l++)&#123; ans[str.charAt(l) - '0']++; &#125; &#125; for(int j = 0; j &lt; 10; j++)&#123; if(j != 0)&#123; System.out.print(\" \"); &#125; System.out.print(ans[j]); &#125; System.out.println(); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"133. Clone Graph","slug":"coding/leetcode/Medium/133-Clone-Graph","date":"2023-04-08T03:40:24.000Z","updated":"2023-05-28T17:13:32.628Z","comments":true,"path":"coding/leetcode/Medium/133-Clone-Graph/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/133-Clone-Graph/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Each node in the graph contains a value ( int ) and a list ( List[Node] ) of its neighbors. class Node &#123; public int val; public List&lt;Node&gt; neighbors; &#125; Test case format: For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1 , the second node with val == 2 , and so on. The graph is represented in the test case using an adjacency list. An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph. The given node will always be the first node with val = 1 . You must return the copy of the given node as a reference to the cloned graph. # Example 1: Input: adjList = [[2,4],[1,3],[2,4],[1,3]] Output: [[2,4],[1,3],[2,4],[1,3]] Explanation: There are 4 nodes in the graph. 1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4). 2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3). 3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4). 4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3). # Example 2: Input: adjList = [[]] Output: [[]] Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors. # Example 3: Input: adjList = [] Output: [] Explanation: This an empty graph, it does not have any nodes. # 解題思路 # Solution import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;// Definition for a Node.class Node &#123; public int val; public List&lt;Node> neighbors; public Node() &#123; val = 0; neighbors = new ArrayList&lt;Node>(); &#125; public Node(int _val) &#123; val = _val; neighbors = new ArrayList&lt;Node>(); &#125; public Node(int _val, ArrayList&lt;Node> _neighbors) &#123; val = _val; neighbors = _neighbors; &#125;&#125;class Solution &#123; Map&lt;Node, Node> map = new HashMap&lt;>(); public Node cloneGraph(Node node) &#123; if (node == null) return null; if (map.containsKey(node)) return map.get(node); map.put(node, new Node(node.val)); for (Node val : node.neighbors) &#123; map.get(node).neighbors.add(cloneGraph(val)); &#125; return map.get(node); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"}]},{"title":"Reading Highlights 1: Uber: The Worlds Modern Taxi","slug":"language/english/Reading Highlights/Reading-Highlights-1-Uber-The-Worlds-Modern-Taxi","date":"2023-04-07T04:26:45.000Z","updated":"2023-08-15T17:08:28.387Z","comments":true,"path":"language/english/Reading Highlights/Reading-Highlights-1-Uber-The-Worlds-Modern-Taxi/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/language/english/Reading%20Highlights/Reading-Highlights-1-Uber-The-Worlds-Modern-Taxi/","excerpt":"","text":"⭐️⭐️⭐️⭐️ # Uber: The World's Modern Taxi A new taxi trend is taking over the world. Uber doesn't have a long history, but it has proven it's here to stay by providing major benefits and a competitive spirit. Travis Kalanick and Garrett Camp launched the Uber transportation app in 2009 in San Francisco, California, US. In May 2011, it started spreading to other American cities. In December of the same year, it expanded into its first international city - Pairs, France. Uber now operates in 58 countries and 300 cities across the globe. It's worth an estimated US$50 billion. Uber combines the traditional taxi ride with the morden technology of the 21st century. All Uber transactions are handled electronically; the app finds you a drive, navigates, and processes the paymemt. The only interaction you have with the driver is pleasant conversation. Using Uber is slightly different from a normal taxi ride because you can estimate the cost of your ride before you decide to hire a drive and split the fare with other passengers. Additionally, the app can send a text message with your Uber ride information to friends or family, adding an element of safety to your ride. Despite its many advantages, Uber has its critics. Some goverments have banned the app because its drivers aren't properly trained or insured. On February 19, Uber was declared illegal in Taiwan The goverment said that the drivers had violated the Highway Act and Transportation Management Regulations. Taxi companies have also opposed Uber, as they've lost business because of Uber's cheap rates and fast reaponse time. Protestes against Uber have become common, locally and internationally. It remains to be seen whether Uber's many advantages will win out against traditional taxis. Which one would you choose to take a ride in? # 段落大意 第一段: 告知主題是要闡述 new Taxi 第二段 Uber 發展史 第三段 Uber 的運作模式，好處等等 第四段 Uber 的問題或不足 # Reading Questions Which of the following statements about Uber is TRUE? It is illegal in some countries. It was started by a US taxi driver in 2009. It is more popular abroad than in the US. It operates through a control center. According to the passage, how does Uber work? Ubers can share the ride with other passengers. Ubers pay the transportation fare directly to the drivers. Ubers can negotiate the cost of the ride with the driver. Users have to register in paper from before using the service. Compared with normal taxis, Uber is all of the following EXCEPT . more advanced greener less costly more convenient What is one criticism of Uber based on the passage? The drivers don't show up fast enough. The drivers are not paid enough. The drivers lack sufficient training. The customer service is lousy.","categories":[{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"Reading Highlight","slug":"language/english/Reading-Highlight","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/Reading-Highlight/"}],"tags":[{"name":"英文 Reading Highlights","slug":"英文-Reading-Highlights","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87-Reading-Highlights/"}]},{"title":"1020. Number of Enclaves","slug":"coding/leetcode/Medium/1020-Number-of-Enclaves","date":"2023-04-07T01:25:06.000Z","updated":"2023-05-28T17:14:01.074Z","comments":true,"path":"coding/leetcode/Medium/1020-Number-of-Enclaves/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1020-Number-of-Enclaves/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an m x n binary matrix grid , where 0 represents a sea cell and 1 represents a land cell. A move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid . Return the number of land cells in grid for which we cannot walk off the boundary of the grid in any number of moves. # Example 1: Input: grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] Output: 3 Explanation: There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary. # Example 2: Input: grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]] Output: 0 Explanation: All 1s are either on the boundary or can reach the boundary. # 解題思路 # Solution class Solution &#123; public int numEnclaves(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; int ans = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if ((i == 0 || j == 0 || i == m - 1 || j == n - 1) &amp;&amp; grid[i][j] == 1) &#123; dfs(i, j, m, n, grid); &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j] == 1) &#123; ans++; &#125; &#125; &#125; return ans; &#125; public void dfs(int x, int y, int m, int n, int[][] grid) &#123; grid[x][y] = 0; int[] dirx = &#123; 0, 1, 0, -1 &#125;; int[] diry = &#123; -1, 0, 1, 0 &#125;; for (int i = 0; i &lt; 4; i++) &#123; int r = x + dirx[i]; int c = y + diry[i]; if (r >= 0 &amp;&amp; r &lt; m &amp;&amp; c >= 0 &amp;&amp; c &lt; n &amp;&amp; grid[r][c] == 1) &#123; dfs(r, c, m, n, grid); &#125; &#125; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"}]},{"title":"uva 948 - Fibonaccimal Base","slug":"coding/cpe/One Star/uva-948-Fibonaccimal-Base","date":"2023-04-06T16:50:47.000Z","updated":"2023-05-28T17:09:30.900Z","comments":true,"path":"coding/cpe/One Star/uva-948-Fibonaccimal-Base/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-948-Fibonaccimal-Base/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The well known Fibonacci sequence is obtained by starting with 0 and 1 and then adding the two last numbers to get the next one. For example the third number in the sequence is 1 (1=1+0) , the forth is 2 (2=1+1) , the fifth is 3 (3=2+1) and so on. i 0 1 2 3 4 5 6 7 8 9 Fib(i) 0 1 1 2 3 5 8 13 21 34 Figure 1 - The first numbers in the Fibonacci sequence The sequence appears on many things in our life, in nature, and has a great significance. Among other things, do you know that all positive integer numbers can be represented as a sum of numbers in the Fibonacci sequence? More than that, all positive integers can be represented as a sum of a set of Fibonacci numbers, that is, numbers from the sequence, without repetition. For example: 13 can be the sum of the sets &#123;13&#125; , &#123;5,8&#125; or &#123;2,3,8&#125; and 17 is represented by &#123;1,3,13&#125; or &#123;1,3,5,8&#125; . Since all numbers have this property (do you want to try to prove this for yourself?) this set could be a nice way to use as a &quot;base&quot; to represent the number. But, as we have seen, some numbers have more than one set whose sum is the number. How can we solve that? Simple! If we add the constraint that the sets cannot have two consecutive Fibonacci numbers, than we have a unique representation for each number! This restriction is because the sum of any two consecutive Fibonacci numbers is just the following Fibonacci number. Now that we know all this we can prepare a nice way to represent any positive integer. We will use a binary sequence (just zeros and ones) to do that. For example, 17 = 1 + 3 + 13 (remember that no two consecutive Fibonacci numbers can be used). Let’s write a zero for each Fibonacci number that is not used and one for each one that is used, starting at the right. Then, 17 = 100101 . See figure 2 for a detailed explanation. In this representation we should not have zeros at the left, this is, we should only write starting with the first one. In order for you to understand better, note that in this scheme, not using two consecutive Fibonacci numbers means that the binary sequence will not have two consecutive ones. When we use this representation for a number we say that we are using the Fibonaccimal base, and we write it like 17 = 100101 (fib) . 17 = 1 0 0 1 0 1 13 + 3 + 1 = 13 8 5 3 2 1 Figure 2 - Explaining the representation of 17 in Fibonaccimal base Given a set of numbers in decimal base, your task is to write them in the Fibonaccimal base. # Input The first line of input contains a single number N , representing the quantity of numbers that follow (1 ≤ N ≤ 500) . Than follow exactly N lines, each one containing a single positive integer smaller than 100 000 000 . These numbers can come in any order. # Output You should output a single line for each of the N integers in the input, with the format 'DEC_BASE = FIB_BASE (fib)' . DEC_BASE is the original number in decimal base and FIB_BASE is its representation in Fibonaccimal base. See the sample output for an example. 單字 ** ** !! !! 片語 & 搭配詞 !! !! # Sample Input 10 1 2 3 4 5 6 7 8 9 10 # Sample Output 1 = 1 (fib) 2 = 10 (fib) 3 = 100 (fib) 4 = 101 (fib) 5 = 1000 (fib) 6 = 1001 (fib) 7 = 1010 (fib) 8 = 10000 (fib) 9 = 10001 (fib) 10 = 10010 (fib) # 解題技巧 這題的解法跟 uva 763 - Fibinary Numbers 基本上一樣，可以連結過去參考。 但是要注意以下幾點區別: 題目提到輸入數值不會大於 100000000 ，所以這裡使用動態陣列來計算 fib 直到數值超過 100000000 。 如果 fib[index] &lt; num ，表示他的值是對於 num 目前最大可以寫入 1 的，如果 fib[index] &gt; num 或 num == 0 表示其值為 0 ，依照此將 num 數值轉換成 Fibonaccimal base。 雖然 num 的數值不會超過 int(32 bits) 的範圍，但是轉成 Fibonaccimal base 後會，所以最後輸出要以 BigInteger 來輸出。 # Solution Main.javaimport java.math.BigInteger;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); ArrayList&lt;Integer> fib = new ArrayList&lt;>(); fib.add(1); fib.add(1); int index = 2; while(fib.get(index - 2) + fib.get(index - 1) &lt;= 100000000)&#123; fib.add(fib.get(index - 2) + fib.get(index - 1)); index++; &#125; int fibSize = fib.size() - 1; int N = sc.nextInt(); for(int i = 0; i &lt; N; i++)&#123; int num = sc.nextInt(); System.out.print(num + \" = \"); String ans = \"\"; for(int j = fibSize; j > 0; j--)&#123; int temp = fib.get(j); if(temp > num || num == 0)&#123; ans += \"0\"; &#125; else &#123; ans += \"1\"; num -= temp; &#125; &#125; System.out.println(new BigInteger(ans) + \" (fib)\"); &#125; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"1254. Number of Closed Islands","slug":"coding/leetcode/Medium/1254-Number-of-Closed-Islands","date":"2023-04-06T05:47:04.000Z","updated":"2023-05-28T17:14:07.878Z","comments":true,"path":"coding/leetcode/Medium/1254-Number-of-Closed-Islands/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1254-Number-of-Closed-Islands/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a 2D grid consists of 0s (land) and 1s (water). An island is a maximal 4-directionally connected group of 0s and a closed island is an island totally (all left, top, right, bottom) surrounded by 1s . Return the number of closed islands. # Example 1: Input: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]] Output: 2 Explanation: Islands in gray are closed because they are completely surrounded by water (group of 1s). # Example 2: Input: grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]] Output: 1 # Example 3: Input: grid = [[1,1,1,1,1,1,1],[1,0,0,0,0,0,1],[1,0,1,1,1,0,1],[1,0,1,0,1,0,1], [1,0,1,1,1,0,1],[1,0,0,0,0,0,1],[1,1,1,1,1,1,1]] Output: 2 # 解題思路 利用 dfs(Depth-First Search) 去檢查如果該陣列為 0 ，他前後左右是否會碰到 1 ，如果碰到邊界表示封閉，如果碰到 0 再繼續找。 # Solution class Solution &#123; public int closedIsland(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; boolean[][] visit = new boolean[m][n]; int ans = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j] == 0 &amp;&amp; !visit[i][j]) &#123; if(dfs(i, j, m, n, grid, visit)) ans++; &#125; &#125; &#125; return ans; &#125; public boolean dfs(int x, int y, int m, int n, int[][] grid, boolean[][] visit) &#123; if (x &lt; 0 || x >= m || y &lt; 0 || y >= n) &#123; return false; &#125; if (grid[x][y] == 1 || visit[x][y]) &#123; return true; &#125; visit[x][y] = true; boolean isClosed = true; int[] dirx = &#123;0, 1, 0, -1&#125;; int[] diry = &#123;-1, 0, 1, 0&#125;; for (int i = 0; i &lt; 4; i++) &#123; int r = x + dirx[i]; int c = y + diry[i]; isClosed &amp;= dfs(r, c, m, n, grid, visit); &#125; return isClosed; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"}]},{"title":"uva 913 - Joana and the Odd Numbers","slug":"coding/cpe/One Star/uva-913-Joana-and-the-Odd-Numbers","date":"2023-04-05T21:44:56.000Z","updated":"2023-05-28T17:09:27.574Z","comments":true,"path":"coding/cpe/One Star/uva-913-Joana-and-the-Odd-Numbers/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-913-Joana-and-the-Odd-Numbers/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Joana loves playing with odd numbers. In the other day, she started writing, in each line, an odd number of odd numbers. It looked as follows: 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 ... On a certain line Joana wrote 55 odd numbers. Can you discover the sum of the last three numbers written in that line? Can you do this more generally for a given quantity of odd numbers? Given the number N of odd numbers in a certain line, your task is to determine the sum of the last three numbers of that line. # Input The input is a sequence of lines, one odd number N (1 &lt; N &lt; 1000000000) per line # Output For each input line write the sum of the last three odd numbers written by Joana in that line with N numbers. This sum is guaranteed to be less than 263. 單字 certain 肯定 having no doubt or knowing exactly that something is true, or known to be true, correct, exact, or effective generally 一般地 usually, or in most situations quantity 數量 + of the amount or number of something, especially that can be measured guaranteed 保證 used to say that something is sure to happen or be true # Sample Input 3 5 7 # Sample Output 15 45 87 # 解題方法 這題基本上就是一題數學題，需要思考的有以下幾個問題: 如何將題目給的該行數字的個數 -&gt; 轉換成為第幾行 從個數轉換為是第幾行其實很容易，依照規律我們可以發現每一行的個數都為 N = line * 2 - 1 ，如果要算出 line 只需要兩個等式交換， line = (N + 1) / 2 。 藉由得知該行 -&gt; 算出最後一個數字 我們可以從前幾行看出 line 加上前面所有數字的個數是 line * line 個數字，但因為所有數字都是奇數，因此要計算最後一個奇數要將個數乘兩倍，再減去最後一個偶數，求得最後一個奇數，因此可以寫作 2 * (line * line) - 1 。 最後用最後一個數字算出後三個的總和。 需要特別注意的是題目提到的: This sum is guaranteed to be less than 263. 表示答案可能無法用 int (32 bits) 表示，但是可以用 long (64 bits) 表示。 ❗️這裡的 long 是指 java 程式語言體系中的，如果是 c++ 需要以 long long 表示。 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while(sc.hasNextLong())&#123; long N = sc.nextLong(); long line = (N + 1)/2; long lastNum = 2 * (line * line) - 1; long ans = lastNum + lastNum - 2 + lastNum - 4; System.out.println(ans); &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"2439. Minimize Maximum of Array","slug":"coding/leetcode/Medium/2439-Minimize-Maximum-of-Array","date":"2023-04-05T03:58:41.000Z","updated":"2023-05-28T17:14:40.044Z","comments":true,"path":"coding/leetcode/Medium/2439-Minimize-Maximum-of-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2439-Minimize-Maximum-of-Array/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given a 0-indexed array nums comprising of n non-negative integers. In one operation, you must: Choose an integer i such that 1 &lt;= i &lt; n and nums[i] &gt; 0 . Decrease nums[i] by 1. Increase nums[i - 1] by 1. Return the minimum possible value of the maximum integer of nums after performing any number of operations. # Example 1: Input: nums = [3,7,1,6] Output: 5 Explanation: One set of optimal operations is as follows: Choose i = 1, and nums becomes [4,6,1,6]. Choose i = 3, and nums becomes [4,6,2,5]. Choose i = 1, and nums becomes [5,5,2,5]. The maximum integer of nums is 5. It can be shown that the maximum number cannot be less than 5. Therefore, we return 5. # Example 2: Input: nums = [10,1] Output: 10 Explanation: It is optimal to leave nums as is, and since 10 is the maximum value, we return 10. # 解題思路 在題目敘述中我們可以知道， nums 這個陣列無法將前面較大的數值向後移，只能將後面的數值向前移動。 因此我們可以藉由 prefix sum 來計算到目前的總值，除以現在的陣列數目，得到平均值利用高斯取頂 (ceiling function) ⇒\\Rightarrow⇒ 得到當前 subArray 數目的最大值 並與前面的最大值比較: 如果比較大 ⇒\\Rightarrow⇒ 就代表後面的值可以再向前移動。 如果比較小 ⇒\\Rightarrow⇒ 就表示雖然平均最大值可能有更小的，但是前面的值不可以往後移，因此不採用。 # Algorithm Initialize ans = 0 and prefixSum = 0 . Iterate over nums , for each index i : Update the prefix sum as prefixSum += nums[i] . Check the maximum value we can obtain by averaging prefixSum into i + 1 evenly using ceiling division. Take the larger one from ans and the result from the previous integer division. Return ans # Solution class Solution &#123; public int minimizeArrayValue(int[] nums) &#123; long prefixSum = 0; int ans = 0; for(int i = 0; i &lt; nums.length; i++)&#123; prefixSum += nums[i]; ans = Math.max(ans, (int)Math.ceil(prefixSum * 1.0 / (i + 1))); &#125; return ans; &#125;&#125; 單字 decrease 減少 to become less, or to make something become less increase 增加 to (make something) become larger in amount or size 片語 & 搭配詞 comprising of 包括","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"}]},{"title":"uva 865 - Substitution Cypher","slug":"coding/cpe/One Star/uva-865-Substitution-Cypher","date":"2023-04-04T17:26:41.000Z","updated":"2023-05-28T17:09:23.459Z","comments":true,"path":"coding/cpe/One Star/uva-865-Substitution-Cypher/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-865-Substitution-Cypher/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Substitution cyphers are the simplest of cyphers where the letters of one alphabet are substituted for the letters of another alphabet. In one form or another, they’ve been in use for over 2000 years. # Input The input begins with a single positive integer on a line by itself indicating the number of the cases following, each of them as described below. This line is followed by a blank line, and there is also a blank line between two consecutive inputs. a line containing the plaintext alphabet a line containing the substitution alphabet several lines of text # Output For each test case, the output must follow the description below. The outputs of two consecutive cases will be separated by a blank line. a line containing the substitution alphabet a line containing the plaintext alphabet the converted lines of text Please note: All lines will be at most 64 characters, plus a trailing end-of-line character. Pass through all characters not found in the plaintext alphabet. 單字 substitution 代換 the use of one person or thing instead of another cyphers 密碼 = other spelling of cipher a system of writing that prevents most people from understanding the message indicating 表明 to show, point, or make clear in another way below 以下 in a lower position (than), under converted 轉換 having changed in form or character, or been made suitable for a different use trailing 尾隨 Trailing plants grow along the ground or over the surface of something 片語 & 搭配詞 plaintext 純文字 Pass through 通過 # Sample Input 1 abcdefghijklmnopqrstuvwxyz zyxwvutsrqponmlkjihgfedcba Shar’s Birthday: The birthday is October 6th, but the party will be Saturday, October 5. It’s my 24th birthday and the first one in some years for which I’ve been employed. Plus, I have new clothes. So I have cause to celebrate. More importantly, though, we’ve cleaned the house! The address is 506-D Albert Street. Extra enticement for CS geeks: there are several systems in the house, and the party is conveniently scheduled for 3 hours after the second CSC programming contest ends (not to mention, within easy walking distance)! # Sample Output zyxwvutsrqponmlkjihgfedcba abcdefghijklmnopqrstuvwxyz Sszi’h Brigswzb: Tsv yrigswzb rh Oxglyvi 6gs, yfg gsv kzigb droo yv Szgfiwzb, Oxglyvi 5. Ig’h nb 24gs yrigswzb zmw gsv urihg lmv rm hlnv bvzih uli dsrxs I’ev yvvm vnkolbvw. Pofh, I szev mvd xolgsvh. Sl I szev xzfhv gl xvovyizgv. Mliv rnkligzmgob, gslfts, dv’ev xovzmvw gsv slfhv! Tsv zwwivhh rh 506-D Aoyvig Sgivvg. Ecgiz vmgrxvnvmg uli CS tvvph: gsviv ziv hvevizo hbhgvnh rm gsv slfhv, zmw gsv kzigb rh xlmevmrvmgob hxsvwfovw uli 3 slfih zugvi gsv hvxlmw CSC kiltiznnrmt xlmgvhg vmwh (mlg gl nvmgrlm, drgsrm vzhb dzoprmt wrhgzmxv)! # 解題方法 利用前兩行創建一個 HashMap 的表格，紀錄密碼間的字元轉換。 在之後的字串讀進來之後進行分析，如果字串中的字元有在 HashMap 中表示要進行密碼轉換，如過沒有就直接輸出。 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int T = sc.nextInt(); sc.nextLine(); int index = 0; Map&lt;Character, Character> map = new HashMap&lt;>(); while(sc.hasNextLine())&#123; String str = sc.nextLine(); if(str.equals(\"\") &amp;&amp; index != T)&#123; if(index != 0)&#123; System.out.println(); &#125; map = new HashMap&lt;>(); String plaintext = sc.nextLine(); String substitution = sc.nextLine(); for(int i = 0; i &lt; plaintext.length(); i++)&#123; map.put(plaintext.charAt(i), substitution.charAt(i)); &#125; index++; System.out.println(substitution); System.out.println(plaintext); &#125;else&#123; for(int i = 0; i &lt; str.length(); i++)&#123; if(map.containsKey(str.charAt(i)))&#123; System.out.print(map.get(str.charAt(i))); &#125;else&#123; System.out.print(str.charAt(i)); &#125; &#125; System.out.println(); &#125; &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"uva 763 - Fibinary Numbers","slug":"coding/cpe/One Star/uva-763-Fibinary-Numbers","date":"2023-04-04T05:16:52.000Z","updated":"2023-05-28T17:09:20.691Z","comments":true,"path":"coding/cpe/One Star/uva-763-Fibinary-Numbers/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-763-Fibinary-Numbers/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The standard interpretation of the binary number 1010 is 8 + 2 = 10 . An alternate way to view the sequence “1010” is to use Fibonacci numbers as bases instead of powers of two. For this problem, the terms of the Fibonacci sequence are: 1,2,3,5,8,13,21,...1, 2, 3, 5, 8, 13, 21, . . . 1,2,3,5,8,13,21,... Where each term is the sum of the two preceding terms (note that there is only one 1 in the sequence as defined here). Using this scheme, the sequence “1010” could be interpreted as 1·5+0·3+1·2+0·1 = 7 . This representation is called a Fibinary number. Note that there is not always a unique Fibinary representation of every number. For example the number 10 could be represented as either 8 + 2 (10010) or as 5 + 3 + 2 (1110) . To make the Fibinary representations unique, larger Fibonacci terms must always be used whenever possible (i.e. disallow 2 adjacent 1’s). Applying this rule to the number 10 , means that 10 would be represented as 8+2 (10010) . Write a program that takes two valid Fibinary numbers and prints the sum in Fibinary form. # Input The input file contains several test cases with a blank line between two consecutive. Each test case consists in two lines with Fibinary numbers. These numbers will have at most 100 digits. # Output For each test case, print the sum of the two input numbers in Fibinary form. It must be a blank line between two consecutive outputs. 單字 interpretation 解釋 an explanation or opinion of what something means alternate 備用 to happen or exist one after the other repeatedly sequence 順序 a series of related things or events, or the order in which they follow each other terms 條款、項 the conditions that are part of an agreement or arrangement, or the features of an activity or idea scheme 方案 an organized plan for doing something, especially something dishonest or illegal that will bring a good result for you consecutive 連續的 Consecutive events, numbers, etc. follow one after another without an interruption 片語 & 搭配詞 instead of 代替 preceding terms 前項 # Sample Input 10010 1 10000 1000 10000 10000 # Sample Output 10100 100000 100100 # 解題方法 先以 dp 的方式計算 Fibonacci numbers: fib[1 ~ 101] 的值，要注意的點是 fib 後面的值會超過 long (64 bits) 可以表示的範圍，所以這邊使用 BigInteger 的方式來計算數值。 在用 fib[index] * (char == '1' ? 1 : 0) ，計算出兩個數的 sum ，在藉由比較 fib[index] 和 sum 的值。 如果 fib[index] &lt; sum ，表示他的值是對於 sum 目前最大可以寫入 1 的，如果 fib[index] &gt; sum 或 sum == 0 表示其值為 0 ，依照此將 sum 數值轉換成 Fibonacci numbers as bases。 # Solution Main.javaimport java.math.BigInteger;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); ArrayList&lt;BigInteger> fib = new ArrayList&lt;>(); fib.add(new BigInteger(\"1\")); fib.add(new BigInteger(\"1\")); for(int i = 2; i &lt;= 105; i++)&#123; fib.add(fib.get(i - 2).add(fib.get(i - 1))); &#125; while(sc.hasNext())&#123; String x = sc.next(); String y = sc.next(); BigInteger sum = new BigInteger(\"0\"); int index = 1; for(int i = x.length() - 1; i >= 0; i--)&#123; BigInteger temp = (x.charAt(i) == '1' ? new BigInteger(\"1\") : new BigInteger(\"0\")); sum = sum.add(fib.get(index).multiply(temp)); index++; &#125; index = 1; for(int i = y.length() - 1; i >= 0; i--)&#123; BigInteger temp = (y.charAt(i) == '1' ? new BigInteger(\"1\") : new BigInteger(\"0\")); sum = sum.add(fib.get(index).multiply(temp)); index++; &#125; String ans = \"\"; for(int i = 105; i > 0; i--)&#123; if(sum.equals(new BigInteger(\"0\")) || fib.get(i).compareTo(sum) == 1)&#123; ans = ans + \"0\"; &#125; else &#123; ans = ans + \"1\"; sum = sum.subtract(fib.get(i)); &#125; &#125; System.out.println(new BigInteger(ans)); if(sc.hasNext())&#123; System.out.println(); &#125; &#125; sc.close(); &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"2405. Optimal Partition of String","slug":"coding/leetcode/Medium/2405-Optimal-Partition-of-String","date":"2023-04-04T04:02:30.000Z","updated":"2023-05-28T17:14:37.750Z","comments":true,"path":"coding/leetcode/Medium/2405-Optimal-Partition-of-String/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2405-Optimal-Partition-of-String/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a string s , partition the string into one or more substrings such that the characters in each substring are unique. That is, no letter appears in a single substring more than once. Return the minimum number of substrings in such a partition. Note that each character should belong to exactly one substring in a partition. # Example 1: Input: s = &quot;abacaba&quot; Output: 4 Explanation: Two possible partitions are (&quot;a&quot;,&quot;ba&quot;,&quot;cab&quot;,&quot;a&quot;) and (&quot;ab&quot;,&quot;a&quot;,&quot;ca&quot;,&quot;ba&quot;). It can be shown that 4 is the minimum number of substrings needed. # Example 2: Input: s = &quot;ssssss&quot; Output: 6 Explanation: The only valid partition is (&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;). # 解題思路 # Solution Solution.javaclass Solution &#123; public int partitionString(String s) &#123; int[] hashTable = new int[26]; int ans = 0; for(int i = 0; i &lt; s.length(); i++)&#123; int temp = s.charAt(i) - 'a'; if(hashTable[temp] == 1)&#123; hashTable = new int[26]; ans++; hashTable[temp]++; &#125;else&#123; hashTable[temp]++; &#125; &#125; return ans + 1; &#125;&#125; 單字 exactly 確切地 used when you are giving or asking for information that is completely correct","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"881. Boats to Save People","slug":"coding/leetcode/Medium/881-Boats-to-Save-People","date":"2023-04-03T08:26:41.000Z","updated":"2023-05-28T17:13:56.031Z","comments":true,"path":"coding/leetcode/Medium/881-Boats-to-Save-People/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/881-Boats-to-Save-People/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit . Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit . Return the minimum number of boats to carry every given person. # Example 1 Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2) # Example 2 Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3) # Example 3 Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) # 解題思路 # Solution Solution.javaimport java.util.Arrays;class Solution &#123; public int numRescueBoats(int[] people, int limit) &#123; Arrays.sort(people); int ans = 0; int left = 0, right = people.length - 1; while (left &lt;= right) &#123; if (people[left] + people[right--] &lt;= limit) &#123; left++; &#125; ans++; &#125; return ans; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"}]},{"title":"uva 737 - Gleaming the Cubes","slug":"coding/cpe/One Star/uva-737-Gleaming-the-Cubes","date":"2023-04-03T05:10:16.000Z","updated":"2023-05-28T17:09:17.011Z","comments":true,"path":"coding/cpe/One Star/uva-737-Gleaming-the-Cubes/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/uva-737-Gleaming-the-Cubes/","excerpt":"","text":"⭐️ # 題目連結 ZeroJudge 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 As chief engineer of the Starship Interprize, the task of repairing the hyperstellar, cubic, transwarpedout software has fallen on your shoulders. Simply put, you must compute the volume of the intersection of anywhere from 2 to 1000 cubes. # Input and Output The input data file consists of several sets of cubes for which the volume of their intersections must be computed. The first line of the data file contains a number (from 2 to 1000 ) which indicates the number of cubes which follow, one cube per line. Each line which describes a cube contains four integers. The first three integers are the x , y and z coordinates of the corner of a cube, and the fourth integer is the positive distance which the cube extends in each of the three directions (parallel to the x , y , and z axes) from that corner. Following the data for the first set of cubes will be a number which indicates how many cubes are in a second set, followed by the cube descriptions for the second set, again one per line. Following this will be a third set, and so on. Your program should continue to process sets of cubes, outputting the volume of their intersections to the output file, one set per line, until a zero is read for the number of cubes. Note that the data file will always contain at least one set of cubes, and every set will contain at least 2 and at most 1000 cubes. For any given set of cubes, the volume of their intersections will not exceed 1,000,000 units. 單字 intersections 相交 an occasion when two lines cross, or the place where this happens indicates 表示 to show, point, or make clear in another way exceed 超過 to be greater than a number or amount, or to go past an allowed limit 片語 & 搭配詞 Following A(sth) for B(sth) 在 B 之後的 A # Sample Input 2 0 0 0 10 9 1 1 5 3 0 0 0 10 9 1 1 5 8 2 2 3 0 # Sample Output 25 9 # 解題方法 分別存放所有體積 x , y , z 的最大值和 x + L , y + L , z + L 的最小值，最後後項減前項，三者相乘及為 ans ，若 ans &lt; 0 ， ans = 0 。 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); while (n != 0) &#123; int FX = 0, FY = 0, FZ = 0; int SX = Integer.MAX_VALUE, SY = Integer.MAX_VALUE, SZ = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) &#123; int x = sc.nextInt(); int y = sc.nextInt(); int z = sc.nextInt(); int L = sc.nextInt(); FX = Math.max(FX, x); SX = Math.min(SX, x + L); FY = Math.max(FY, y); SY = Math.min(SY, y + L); FZ = Math.max(FZ, z); SZ = Math.min(SZ, z + L); &#125; int ans = (SX - FX) * (SY - FY) * (SZ - FZ); System.out.println((ans &lt; 0 ? 0 : ans)); n = sc.nextInt(); &#125; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-04-02T12:45:48.000Z","updated":"2023-04-03T05:07:21.357Z","comments":true,"path":"hello-world/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. # Quick Start # Create a new post h$ hexo new \"My New Post\"More info: Writing # Run server h$ hexo serverMore info: Server # Generate static files h$ hexo generateMore info: Generating # Deploy to remote sites h$ hexo deployMore info: Deployment","categories":[],"tags":[{"name":"Hello World","slug":"Hello-World","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hello-World/"}]}],"categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"},{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"文法","slug":"language/english/文法","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E6%96%87%E6%B3%95/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"},{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Note","slug":"computer-science/Note","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Note/"},{"name":"program-language","slug":"computer-science/program-language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/"},{"name":"C Programming Language","slug":"computer-science/program-language/C-Programming-Language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/C-Programming-Language/"},{"name":"PHP","slug":"computer-science/program-language/PHP","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/PHP/"},{"name":"Framework","slug":"computer-science/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Framework/"},{"name":"Java Spring Boot","slug":"computer-science/Framework/Java-Spring-Boot","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Framework/Java-Spring-Boot/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"},{"name":"Vue","slug":"computer-science/Framework/Vue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Framework/Vue/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"},{"name":"Reading Highlight","slug":"language/english/Reading-Highlight","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/Reading-Highlight/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Queue","slug":"Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Queue/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Monotonic Queue","slug":"Monotonic-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Monotonic-Queue/"},{"name":"英文文法","slug":"英文文法","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Linked-List/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Divide-and-Conquer/"},{"name":"Quickselect","slug":"Quickselect","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Quickselect/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Web","slug":"Web","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Web/"},{"name":"Tree","slug":"Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Tree/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Tree/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bit-Manipulation/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"前端框架","slug":"前端框架","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Shortest Path","slug":"Shortest-Path","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Shortest-Path/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"},{"name":"CPE","slug":"CPE","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE/"},{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Windows","slug":"Windows","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Windows/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"},{"name":"Recursion","slug":"Recursion","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Recursion/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"},{"name":"Binary Indexed Tree","slug":"Binary-Indexed-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Indexed-Tree/"},{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"},{"name":"Brainteaser","slug":"Brainteaser","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Brainteaser/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Number-Theory/"},{"name":"Design","slug":"Design","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Design/"},{"name":"CPE 49題","slug":"CPE-49題","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/CPE-49%E9%A1%8C/"},{"name":"Topological Sort","slug":"Topological-Sort","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Topological-Sort/"},{"name":"Memoization","slug":"Memoization","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Memoization/"},{"name":"英文 Reading Highlights","slug":"英文-Reading-Highlights","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87-Reading-Highlights/"},{"name":"Hello World","slug":"Hello-World","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hello-World/"}]}