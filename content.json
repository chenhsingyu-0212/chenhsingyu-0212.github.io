{"meta":{"title":"","subtitle":"We are the dreamers. We make it happen 'cause we can see it.","description":"謝謝你來，謝謝你還在","author":"Hsing Yu","url":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io","root":"/"},"pages":[{"title":"Hello!","date":"2024-01-22T08:35:19.128Z","updated":"2024-01-22T08:35:19.128Z","comments":true,"path":"about/index.html","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/about/index.html","excerpt":"","text":"# Hsing Yu 陳幸妤 在努力學習各種技術，完成所有夢想與理想，成為自己的那曙光！ 路漫漫其修遠兮， 吾將上下而求索。 每日目標 leetcode 1 題 CPE 10 題 英文 1 篇 這個網站目前是為了督促我自己養成讀英文跟寫程式的習慣，之後會再寫一些整理的技術或我在學的一些東西。 # 簡介 性別：女 生日: 2003/02/12 星座：水瓶座 興趣：排球、美術設計、書法 專長：游泳、機器人、資訊工程 (人工智慧、網頁) # 經歷 國立彰化女子高級中學 國立台中教育大學 資訊工程學系 (特殊選材) 大三 # 參與專案 &amp; 系統經歷 2021 國立彰化高中資優鑑定報名系統 2021 彰化高中學生會選舉投票系統 2021 國立馬祖高級中學網站 2021~ 至今 國教署 Q&amp;A 系統 2022~ 至今 台中教育大學資工系網站 =&gt; 主要負責網路管理 / 系統維護 2023.02~ 至今 進階程式設計課程自動評分系統 - 專案負責人 (撰寫程式中) =&gt; 整體專案 2023.06 MyJob 工作排成網站 2023.06~11 即時通訊服務研析暨開發委託研究案 / 數位韌性專案 IM / 學校產學合作專案 2023.07~2023.08 項目管理系統 2023.10~2023.11 智慧農業應用：茶捲葉蛾危害等級智慧辨識系統 2023.10~ 至今 探討生成式 AI 輔助學習軟體系統開發之學習成效 -- 以物件導向程式教學為例: GAIOOP 系統 2023.12~2025.06 電腦暗棋競賽程式開發 (畢業專題) 2023.12~2025.06 台灣麻將 AI 程式開發 (預計申請的計畫) # 比賽 &amp; 獎項 2018 全國智能車挑戰賽 2018-2019 FIRST 機器人大賽台灣選拔賽 — 研究品質獎全國第一名 (作品：太空中的家鄉味) 彰化縣 108 學年教育盃機器人競賽 — 高中競賽組佳作 2019 WRO 中南區賽高中競賽組 (機器人計分 / 計時賽) 2019 WRO 國際奧林匹亞機器人全國總決賽 — 高中創意組佳作 (作品：AI 智能交通小幫手) 台灣青年黑客松 6th — APP 組 (作品：防疫下的共享經濟) 2020 AI 智慧應用新世代人才培育計畫 高中職生 AI 扎根系列活動 AI 線上課程、AI 實作一日營 綜合表現卓越 - 全台成績前 80 AI 實作一日營 表現傑出 - 實作 AWS DeepRacer 成績前 4 2022 NCPC 全國大專電腦軟體設計競賽 初賽 2022 國立台中教育大學 菁英獎 2023 TOPC - ICPC Asia Taiwan Online Programming Contest 2023 ITSA 全國大專校院程式設計極客挑戰賽 晉級決賽 2023 資安技能金盾獎 初賽 2023 NASA International Space Apps Challenge 2023 全國大專院校產學創新實作競賽 (組別: D. 人工智慧及其應用，作品：茶捲葉蛾危害等級智慧辨識系統) - 佳作 # 各種檢定 2023.10.17 CPE: 4 題 (2.9%) # 參與團隊 2019~2020 國立彰化女子高級中學 電腦研習社 (機器人組與軟程組) - 社長 2019~ 至今 彰化資訊志工隊 - 隊員 2021~ 至今 國立台中教育大學空手道社 - 社員 2021~2023 國立台中教育大學資工系女子排球隊 - 副隊長 2023.07~2023.08 上海電腦軟體技術開發中心 - 軟體開發實習生 2023~ 至今 國立台中教育大學白帽社 - 社員 # 活動經歷 講師 2021 鹿鳴國中假日班 Webduino 課程 2021~2022 彰化女中學期課後程式加強課程 C++ 程式語言 2022 國立馬祖高中、桃園市立新屋高中 新興科技認知推廣計畫 - VR 體驗活動 2022 國立台中教育大學「程式戰鬥營」教學 C 程式語言 2023 國立南投高級商業職業學校 新興科技認知推廣計畫 - VR 體驗活動 主辦人 彰化女中 2019、2020 C++ 寒暑假研習課 (共 6 場)、學期課後程式加強課程 主辦人、課堂協助指導 2020 彰中彰女電研聯合寒訓 主辦人、課堂協助指導 2021 舉辦大成國中寒假資訊科學營隊 協助教導 2019、2020 國中生機器人學園 (共 2 場) 2021 草湖國中寒假營隊 2022 芬園國中寒假營隊 2023 國立南投高級商業職業學校 Ai2 教學 學習探討 2020 高中人才培育計畫交大人工智慧與深度學習 (學習 AI 和深度學習的演進，機器學習的定義，線性模型推廣淺層神經網路，如何訓練神經網路) 結業成績: 98 2020Ewant 高中自主學習 交大生活中的機器人科技 (學習機器人的發展及未來應用) 結業成績: 98 2020 高中職生 AI 扎根系列活動 (學習 AI 基礎知識與實作 AWS DeepRacer) 2020 教育部資訊安全人才培育計畫 (學習 Linux、基礎資安分析實務、基礎程式逆向工程) 參與活動 2020 SITCON 學生計算機年會 # 完成的人生挑戰 2022 武嶺看日出 2022 台灣環島 2023 獨自出國實習 (上海) 2023 泳渡日月潭 # 待續..."}],"posts":[{"title":"206. Reverse Linked List","slug":"coding/leetcode/Easy/206-Reverse-Linked-List","date":"2024-03-21T04:54:08.000Z","updated":"2024-03-21T04:57:00.108Z","comments":true,"path":"coding/leetcode/Easy/206-Reverse-Linked-List/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/206-Reverse-Linked-List/","excerpt":"","text":"⭐️ # 題目敘述 Given the head of a singly linked list, reverse the list, and return the reversed list. # Example 1 Input: head = [1,2,3,4,5] Output: [5,4,3,2,1] # Example 2 Input: head = [1,2] Output: [2,1] # Example 3 Input: head = [] Output: [] ListNode 的 class 內容 ListNode// Definition for singly-linked list.public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; # 解題思路 # Solution class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode prev = null; ListNode curr = new ListNode(); ListNode next = new ListNode(); curr = head; while(curr != null)&#123; next = curr.next; curr.next = prev; prev = curr; curr = next; &#125; return prev; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Linked List","slug":"Linked-List","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Linked-List/"},{"name":"Recursion","slug":"Recursion","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Recursion/"}]},{"title":"1669. Merge In Between Linked Lists","slug":"coding/leetcode/Medium/1669-Merge-In-Between-Linked-Lists","date":"2024-03-20T05:11:24.000Z","updated":"2024-03-20T05:29:02.133Z","comments":true,"path":"coding/leetcode/Medium/1669-Merge-In-Between-Linked-Lists/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1669-Merge-In-Between-Linked-Lists/","excerpt":"","text":"⭐️⭐️ # 題目敘述 You are given two linked lists: list1 and list2 of sizes n and m respectively. Remove list1 's nodes from the ath node to the bth node, and put list2 in their place. The blue edges and nodes in the following figure indicate the result: Build the result list and return its head. # Example 1 Input: list1 = [10,1,13,6,9,5], a = 3, b = 4, list2 = [1000000,1000001,1000002] Output: [10,1,13,1000000,1000001,1000002,5] Explanation: We remove the nodes 3 and 4 and put the entire list2 in their place. The blue edges and nodes in the above figure indicate the result. # Example 2 Input: list1 = [0,1,2,3,4,5,6], a = 2, b = 5, list2 = [1000000,1000001,1000002,1000003,1000004] Output: [0,1,1000000,1000001,1000002,1000003,1000004,6] Explanation: The blue edges and nodes in the above figure indicate the result. ListNode 的 class 內容 ListNode// Definition for singly-linked list.public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; # 解題思路 # Solution class Solution &#123; public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) &#123; ListNode head = new ListNode(); head.next = list1; ListNode prev = head; for (int i = 0; i &lt; a; i++) &#123; prev = prev.next; &#125; ListNode next = prev; for (int i = 0; i &lt; b - a + 1; i++) &#123; next = next.next; &#125; prev.next = list2; while (list2.next != null) &#123; list2 = list2.next; &#125; list2.next = next.next; return head.next; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Linked List","slug":"Linked-List","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Linked-List/"}]},{"title":"621. Task Scheduler","slug":"coding/leetcode/Medium/621-Task-Scheduler","date":"2024-03-19T08:47:22.000Z","updated":"2024-03-19T12:14:04.564Z","comments":true,"path":"coding/leetcode/Medium/621-Task-Scheduler/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/621-Task-Scheduler/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an array of CPU tasks , each represented by letters A to Z, and a cooling time, n . Each cycle or interval allows the completion of one task. Tasks can be completed in any order, but there's a constraint: identical tasks must be separated by at least n intervals due to cooling time. ​Return the minimum number of intervals required to complete all tasks. # Example 1 Input: tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2 Output: 8 Explanation: A possible sequence is: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B. After completing task A, you must wait two cycles before doing A again. The same applies to task B. In the 3rd interval, neither A nor B can be done, so you idle. By the 4th cycle, you can do A again as 2 intervals have passed. # Example 2 Input: tasks = [&quot;A&quot;,&quot;C&quot;,&quot;A&quot;,&quot;B&quot;,&quot;D&quot;,&quot;B&quot;], n = 1 Output: 6 Explanation: A possible sequence is: A -&gt; B -&gt; C -&gt; D -&gt; A -&gt; B. With a cooling interval of 1, you can repeat a task after just one other task. # Example 3 Input: tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;, &quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 3 Output: 10 Explanation: A possible sequence is: A -&gt; B -&gt; idle -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; idle -&gt; A -&gt; B. There are only two types of tasks, A and B, which need to be separated by 3 intervals. This leads to idling twice between repetitions of these tasks. # 解題思路 # Solution import java.util.HashMap;import java.util.Map;class Solution &#123; public int leastInterval(char[] tasks, int n) &#123; Map&lt;Character, Integer> map = new HashMap&lt;>(); for (char c : tasks) &#123; map.put(c, map.getOrDefault(c, 0) + 1); &#125; int max = 0; int maxCount = 0; for (int count : map.values()) &#123; if (count > max) &#123; max = count; maxCount = 1; &#125; else if (count == max) &#123; maxCount++; &#125; &#125; int block = max - 1; int blockLength = n - (maxCount - 1); int emptySlots = block * blockLength; int availableTasks = tasks.length - max * maxCount; int idles = Math.max(0, emptySlots - availableTasks); return tasks.length + idles; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Counting","slug":"Counting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Counting/"}]},{"title":"452. Minimum Number of Arrows to Burst Balloons","slug":"coding/leetcode/Medium/452-Minimum-Number-of-Arrows-to-Burst-Balloons","date":"2024-03-18T03:01:48.000Z","updated":"2024-03-18T11:37:02.236Z","comments":true,"path":"coding/leetcode/Medium/452-Minimum-Number-of-Arrows-to-Burst-Balloons/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/452-Minimum-Number-of-Arrows-to-Burst-Balloons/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend . You do not know the exact y-coordinates of the balloons. Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &lt;= x &lt;= xend . There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path. Given the array points , return the minimum number of arrows that must be shot to burst all balloons. # Example 1 Input: points = [[10,16],[2,8],[1,6],[7,12]] Output: 2 Explanation: The balloons can be burst by 2 arrows: Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6]. Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12]. # Example 2 Input: points = [[1,2],[3,4],[5,6],[7,8]] Output: 4 Explanation: One arrow needs to be shot for each balloon for a total of 4 arrows. # Example 3 Input: points = [[1,2],[2,3],[3,4],[4,5]] Output: 2 Explanation: The balloons can be burst by 2 arrows: Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3]. Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5]. # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public int findMinArrowShots(int[][] points) &#123; if (points.length == 0) return 0; int ans = 0; long end = Long.MIN_VALUE; Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1])); for (int[] p : points) &#123; if (p[0] > end) &#123; end = p[1]; ans++; &#125; &#125; return ans; &#125;&#125; #include &lt;vector>#include \"../../../../../mingw64/include/c++/12.3.0/bits/algorithmfwd.h\"#include &lt;climits>using namespace std;class Solution &#123;public: static bool cmp(vector&lt;int>&amp; a, vector&lt;int>&amp; b) &#123; return a[1] &lt; b[1]; // ascending order &#125; int findMinArrowShots(vector&lt;vector&lt;int>>&amp; points) &#123; if (points.size() == 0) &#123; return 0; &#125; int arrows = 0; long long min = LLONG_MIN; sort(points.begin(), points.end(), cmp); for (int i = 0; i &lt; points.size(); i++) &#123; if (points[i][0] > min) &#123; arrows++; min = points[i][1]; &#125; &#125; return arrows; &#125;&#125;; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"}]},{"title":"57. Insert Interval","slug":"coding/leetcode/Medium/57-Insert-Interval","date":"2024-03-17T06:03:29.000Z","updated":"2024-03-17T06:11:56.074Z","comments":true,"path":"coding/leetcode/Medium/57-Insert-Interval/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/57-Insert-Interval/","excerpt":"","text":"⭐️⭐️ # 題目敘述 You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti . You are also given an interval newInterval = [start, end] that represents the start and end of another interval. Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary). Return intervals after the insertion. Note that you don't need to modify intervals in-place. You can make a new array and return it. # Example 1 Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] # Example 2 Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. # 解題思路 # Solution import java.util.ArrayList;import java.util.List;class Solution &#123; public int[][] insert(int[][] intervals, int[] newInterval) &#123; List&lt;int[]> ans = new ArrayList&lt;>(); int index = 0; while(index &lt; intervals.length &amp;&amp; intervals[index][1] &lt; newInterval[0]) &#123; ans.add(intervals[index++]); &#125; while(index &lt; intervals.length &amp;&amp; intervals[index][0] &lt;= newInterval[1]) &#123; newInterval[0] = Math.min(newInterval[0], intervals[index][0]); newInterval[1] = Math.max(newInterval[1], intervals[index][1]); index++; &#125; ans.add(newInterval); while(index &lt; intervals.length) &#123; ans.add(intervals[index++]); &#125; return ans.toArray(new int[0][2]); &#125;&#125; #include &lt;vector>using namespace std;class Solution &#123; public: vector&lt;vector&lt;int>> insert(vector&lt;vector&lt;int>>&amp; intervals, vector&lt;int>&amp; newInterval) &#123; vector&lt;vector&lt;int>> res; int idx = 0; int size = intervals.size(); while (idx &lt; size &amp;&amp; intervals[idx][1] &lt; newInterval[0]) &#123; res.push_back(intervals[idx++]); &#125; while (idx &lt; size &amp;&amp; intervals[idx][0] &lt;= newInterval[1]) &#123; newInterval[0] = min(newInterval[0], intervals[idx][0]); newInterval[1] = max(newInterval[1], intervals[idx][1]); idx++; &#125; res.push_back(newInterval); while (idx &lt; size) &#123; res.push_back(intervals[idx++]); &#125; return res; &#125;&#125;; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"}]},{"title":"525. Contiguous Array","slug":"coding/leetcode/Medium/525-Contiguous-Array","date":"2024-03-16T03:58:00.000Z","updated":"2024-03-16T04:27:36.449Z","comments":true,"path":"coding/leetcode/Medium/525-Contiguous-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/525-Contiguous-Array/","excerpt":"","text":"⭐️ # 題目敘述 Given a binary array nums , return the maximum length of a contiguous subarray with an equal number of 0 and 1 . # Example 1 Input: nums = [0,1] Output: 2 Explanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1. # Example 2 Input: nums = [0,1,0] Output: 2 Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1. # 解題思路 # Solution import java.util.HashMap;import java.util.Map;class Solution &#123; public int findMaxLength(int[] nums) &#123; int len = nums.length; int[] prefixSum = new int[len + 1]; for (int i = 1; i &lt;= len; i++) &#123; prefixSum[i] = prefixSum[i - 1] + (nums[i - 1] == 0 ? -1 : 1); &#125; int max = 0; Map&lt;Integer, Integer> map = new HashMap&lt;>(); for (int i = 0; i &lt;= len; i++) &#123; if (map.containsKey(prefixSum[i])) &#123; max = Math.max(max, i - map.get(prefixSum[i])); &#125; else &#123; map.put(prefixSum[i], i); &#125; &#125; return max; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"}]},{"title":"238. Product of Array Except Self","slug":"coding/leetcode/Medium/238-Product-of-Array-Except-Self","date":"2024-03-15T08:03:19.000Z","updated":"2024-03-15T11:20:14.989Z","comments":true,"path":"coding/leetcode/Medium/238-Product-of-Array-Except-Self/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/238-Product-of-Array-Except-Self/","excerpt":"","text":"⭐️⭐️ # 題目敘述 Given an integer array nums , return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i] . The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation. # Example 1 Input: nums = [1,2,3,4] Output: [24,12,8,6] # Example 2 Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] # 解題思路 # Solution class Solution &#123; public int[] productExceptSelf(int[] nums) &#123; int n = nums.length; int[] prefixSum = new int[n]; int[] suffixSum = new int[n]; int[] res = new int[n]; prefixSum[0] = 1; suffixSum[n - 1] = 1; for(int i = 0; i &lt; n - 1; i++)&#123; prefixSum[i + 1] = prefixSum[i] * nums[i]; suffixSum[n - i - 2] = suffixSum[n - i - 1] * nums[n - i - 1]; &#125; for(int i = 0; i &lt; n; i++)&#123; res[i] = prefixSum[i] * suffixSum[i]; &#125; return res; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"}]},{"title":"930. Binary Subarrays With Sum","slug":"coding/leetcode/Medium/930-Binary-Subarrays-With-Sum","date":"2024-03-14T05:46:08.000Z","updated":"2024-03-14T05:53:44.919Z","comments":true,"path":"coding/leetcode/Medium/930-Binary-Subarrays-With-Sum/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/930-Binary-Subarrays-With-Sum/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a binary array nums and an integer goal , return the number of non-empty subarrays with a sum goal . A subarray is a contiguous part of the array. # Example 1 Input: nums = [1,0,1,0,1], goal = 2 Output: 4 Explanation: The 4 subarrays are bolded and underlined below: [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] # Example 2 Input: nums = [0,0,0,0,0], goal = 0 Output: 15 # 解題思路 # Solution import java.util.HashMap;import java.util.Map;class Solution &#123; public int numSubarraysWithSum(int[] nums, int goal) &#123; int n = nums.length; int[] prefixSum = new int[n + 1]; for (int i = 0; i &lt; n; i++) &#123; prefixSum[i + 1] = prefixSum[i] + nums[i]; &#125; Map&lt;Integer, Integer> count = new HashMap&lt;>(); int ans = 0; for (int i = 0; i &lt; n + 1; i++) &#123; ans += count.getOrDefault(prefixSum[i] - goal, 0); count.put(prefixSum[i], count.getOrDefault(prefixSum[i], 0) + 1); &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"}]},{"title":"1171. Remove Zero Sum Consecutive Nodes from Linked List","slug":"coding/leetcode/Medium/1171-Remove-Zero-Sum-Consecutive-Nodes-from-Linked-List","date":"2024-03-12T05:42:48.000Z","updated":"2024-03-12T05:50:45.116Z","comments":true,"path":"coding/leetcode/Medium/1171-Remove-Zero-Sum-Consecutive-Nodes-from-Linked-List/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1171-Remove-Zero-Sum-Consecutive-Nodes-from-Linked-List/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given the head of a linked list, we repeatedly delete consecutive sequences of nodes that sum to 0 until there are no such sequences. After doing so, return the head of the final linked list. You may return any such answer. (Note that in the examples below, all sequences are serializations of ListNode objects.) # Example 1 Input: head = [1,2,-3,3,1] Output: [3,1] Note: The answer [1,2,1] would also be accepted. # Example 2 Input: head = [1,2,3,-3,4] Output: [1,2,4] # Example 3 Input: head = [1,2,3,-3,-2] Output: [1] ListNode 的 class 內容 ListNode// Definition for singly-linked list.public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; # 解題思路 # Solution import java.util.LinkedList;class Solution &#123; public ListNode removeZeroSumSublists(ListNode head) &#123; LinkedList&lt;Integer> list = new LinkedList&lt;>(); while (head != null) &#123; list.add(head.val); head = head.next; &#125; for (int i = 0; i &lt; list.size(); i++) &#123; int sum = 0; for (int j = i; j &lt; list.size(); j++) &#123; sum += list.get(j); if (sum == 0) &#123; for (int k = j; k >= i; k--) &#123; list.remove(k); &#125; i = -1; break; &#125; &#125; &#125; if(list.size() == 0) return null; ListNode result = new ListNode(); ListNode temp = result; for (int i = 0; i &lt; list.size(); i++) &#123; temp.val = list.get(i); if (i != list.size() - 1) &#123; temp.next = new ListNode(); temp = temp.next; &#125; &#125; return result; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Linked-List/"}]},{"title":"791. Custom Sort String","slug":"coding/leetcode/Medium/791-Custom-Sort-String","date":"2024-03-11T05:37:00.000Z","updated":"2024-03-11T06:25:11.313Z","comments":true,"path":"coding/leetcode/Medium/791-Custom-Sort-String/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/791-Custom-Sort-String/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given two strings order and s . All the characters of order are unique and were sorted in some custom order previously. Permute the characters of s so that they match the order that order was sorted. More specifically, if a character x occurs before a character y in order , then x should occur before y in the permuted string. Return any permutation of s that satisfies this property. # Example 1 Input: order = &quot;cba&quot;, s = &quot;abcd&quot; Output: &quot;cbad&quot; Explanation: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; appear in order, so the order of &quot;a&quot;, &quot;b&quot;, &quot;c&quot; should be &quot;c&quot;, &quot;b&quot;, and &quot;a&quot;. Since &quot;d&quot; does not appear in order, it can be at any position in the returned string. &quot;dcba&quot;, &quot;cdba&quot;, &quot;cbda&quot; are also valid outputs. # Example 2 Input: order = &quot;bcafg&quot;, s = &quot;abcd&quot; Output: &quot;bcad&quot; Explanation: The characters &quot;b&quot;, &quot;c&quot;, and &quot;a&quot; from order dictate the order for the characters in s. The character &quot;d&quot; in s does not appear in order, so its position is flexible. Following the order of appearance in order, &quot;b&quot;, &quot;c&quot;, and &quot;a&quot; from s should be arranged as &quot;b&quot;, &quot;c&quot;, &quot;a&quot;. &quot;d&quot; can be placed at any position since it's not in order. The output &quot;bcad&quot; correctly follows this rule. Other arrangements like &quot;bacd&quot; or &quot;bcda&quot; would also be valid, as long as &quot;b&quot;, &quot;c&quot;, &quot;a&quot; maintain their order. # 解題思路 # Solution import java.util.HashMap;class Solution &#123; public String customSortString(String order, String s) &#123; StringBuilder result = new StringBuilder(); HashMap&lt;Character, Integer> mp = new HashMap&lt;>(); for (char c : s.toCharArray()) &#123; mp.put(c, mp.getOrDefault(c, 0) + 1); &#125; for (char c : order.toCharArray()) &#123; if (mp.containsKey(c)) &#123; result.append(String.valueOf(c).repeat(Math.max(0, mp.get(c)))); mp.remove(c); &#125; &#125; for (char c : mp.keySet()) &#123; result.append(String.valueOf(c).repeat(Math.max(0, mp.get(c)))); &#125; return result.toString(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"349. Intersection of Two Arrays","slug":"coding/leetcode/Easy/349-Intersection-of-Two-Arrays","date":"2024-03-10T03:34:13.000Z","updated":"2024-03-10T03:51:46.806Z","comments":true,"path":"coding/leetcode/Easy/349-Intersection-of-Two-Arrays/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/349-Intersection-of-Two-Arrays/","excerpt":"","text":"⭐️ # 題目敘述 Given two integer arrays nums1 and nums2 , return an array of their intersection. Each element in the result must be unique and you may return the result in any order. # Example 1 Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2] # Example 2 Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4] Explanation: [4,9] is also accepted. # 解題思路 # Solution import java.util.ArrayList;import java.util.Arrays;class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; ArrayList&lt;Integer> result = new ArrayList&lt;>(); Arrays.sort(nums1); Arrays.sort(nums2); for(int i = 0, j = 0; i &lt; nums1.length &amp;&amp; j &lt; nums2.length;) &#123; if(nums1[i] == nums2[j]) &#123; if(result.size() == 0 || result.get(result.size() - 1) != nums1[i]) &#123; result.add(nums1[i]); &#125; i++; j++; &#125; else if(nums1[i] &lt; nums2[j]) &#123; i++; &#125; else &#123; j++; &#125; &#125; return result.stream().mapToInt(i -> i).toArray(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"}]},{"title":"2540. Minimum Common Value","slug":"coding/leetcode/Easy/2540-Minimum-Common-Value","date":"2024-03-09T02:09:32.000Z","updated":"2024-03-09T02:22:52.606Z","comments":true,"path":"coding/leetcode/Easy/2540-Minimum-Common-Value/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2540-Minimum-Common-Value/","excerpt":"","text":"⭐️ # 題目敘述 Given two integer arrays nums1 and nums2 , sorted in non-decreasing order, return the minimum integer common to both arrays. If there is no common integer amongst nums1 and nums2 , return -1 . Note that an integer is said to be common to nums1 and nums2 if both arrays have at least one occurrence of that integer. # Example 1 Input: nums1 = [1,2,3], nums2 = [2,4] Output: 2 Explanation: The smallest element common to both arrays is 2, so we return 2. # Example 2 Input: nums1 = [1,2,3,6], nums2 = [2,3,4,5] Output: 2 Explanation: There are two common elements in the array 2 and 3 out of which 2 is the smallest, so 2 is returned. # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public int getCommon(int[] nums1, int[] nums2) &#123; Arrays.sort(nums1); Arrays.sort(nums2); for(int i = 0, j = 0; i &lt; nums1.length &amp;&amp; j &lt; nums2.length; ) &#123; if(nums1[i] == nums2[j]) &#123; return nums1[i]; &#125; else if(nums1[i] &lt; nums2[j]) &#123; i++; &#125; else &#123; j++; &#125; &#125; return -1; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"}]},{"title":"Makefile 語法","slug":"computer-science/program-language/Makefile-語法","date":"2024-03-08T16:57:27.000Z","updated":"2024-03-11T14:05:23.996Z","comments":true,"path":"computer-science/program-language/Makefile-語法/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/program-language/Makefile-%E8%AA%9E%E6%B3%95/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # What is Makefile? 在開始介紹 Makefile 語法前，我們先來了解一下到底什麼是 Make，而 Makefile 又是什麼？ make 是一個指令，它會讀取 makefile 檔案中的內容，自動化編譯軟體。 makefile 是一個檔案，它描述了軟體的編譯規則。 簡單來說，make 和 makefile 的關係就像是廚師和食譜： make 是廚師，負責按照食譜（makefile）烹飪（編譯）軟體。 makefile 是食譜，它告訴廚師（make）如何烹飪（編譯）軟體。 如若要編譯小型的程式，可以利用簡單的指令進行編譯或是 shell script 進行編譯，但是如果程式較大或是包含大量 header、library 時，就可以考慮是否要使用 makefile。 # Makefile 的優點 可以自動化編譯過程。 根據 target、rule 和檔案修改時間進行判斷，哪些需要重新編譯，只重新編譯必要檔案，節省時間。 可以將程式分成好幾個模組，方便管理。 並提高編譯的準確性 # 一些 Makefile 的使用範例 編譯 C/C++ 程式 編譯 Java 程式 編譯 Python 程式 建置 Linux 核心 建置其他軟體 # Make 的工作流程 讀取 makefile 檔案 Make 會讀取 makefile 檔案中的內容，獲取編譯規則。makefile 檔案是一個文字檔案，它包含以下內容： 目標：編譯的目標，例如可執行檔案、物件檔案、或其他檔案。 規則：編譯規則，描述如何編譯目標。 變量：變量用於存儲常量或其他值，可以讓 makefile 更加簡潔易讀。 分析目標 Make 會分析目標，確定需要編譯哪些檔案。目標可以是可執行檔案、物件檔案、或其他檔案。 檢查檔案修改時間 Make 會檢查檔案修改時間，判斷哪些檔案需要重新編譯。如果檔案的修改時間晚於其依賴檔案的修改時間，則該檔案需要重新編譯。 執行編譯命令 Make 會根據編譯規則，執行編譯命令。編譯命令可以是任何 shell 命令，例如 gcc、javac、或其他編譯器命令。 輸出結果 Make 會輸出編譯結果，例如編譯成功或失敗的信息。 # Makefile 主要內容 Makefile 主要包含以下幾項東西：顯式規則、隱式規則、變量定義、文件指示和註釋。 # 顯示規則 明確指定了如何編譯目標。顯式規則包含以下兩部分： 目標：要編譯的目標。 命令：編譯命令。 以下是一個顯示規則的範例: hello: hello.o gcc -o hello hello.o這個規則描述如何編譯 hello 可執行檔案。 它指定了 hello 可執行檔案的依賴檔案是 hello.o 物件檔案，並使用 gcc 命令編譯 hello 可執行檔案。 # 隱式規則 隱式規則由 make 自動推導，不需要在 makefile 檔案中明確指定。隱式規則通常用於編譯常見的檔案類型，例如 C/C++ 原始碼檔案、Java 原始碼檔案、或 Python 原始碼檔案。 以下是一個隱式規則的範例： %.o: %.c gcc -c %.c這個規則描述如何編譯 C/C++ 原始碼檔案。它指定了 .o 物件檔案的依賴檔案是 .c 原始碼檔案，並且使用 gcc 命令編譯 .o 物件檔案。 # 變數定義 變量用於存儲常量或其他值，可以讓 makefile 更加簡潔易讀。 以下是一個變量定義的範例： CC = gcc這個變量定義了 CC 變量，其值是 gcc 命令。 # 文件指示 文件指示用於包含其他 makefile 檔案。 以下是一個文件指示的範例： include foo.mk這個文件指示包含 foo.mk 檔案。 # 註釋與換行 makefile 註釋 makefile 中的註釋可以用來添加說明文字，提高 makefile 檔案的可讀性。 makefile 中的註釋有兩種： 單行註釋 單行註釋以 # 號開始，一直持續到行尾。 以下是一個單行註釋的範例： # 這個 makefile 檔案用於編譯一個簡單的 C 程式 多行註釋 多行註釋以 /* 開始，以 */ 結尾。 以下是一個多行註釋的範例： /*這個 makefile 檔案用於編譯一個簡單的 C 程式它包含以下三個目標：* hello：編譯 hello.c 檔案，生成 hello 可執行檔案。* hello.o：編譯 hello.c 檔案，生成 hello.o 物件檔案。* clean：清除所有編譯產生的檔案。*/ makefile 換行 makefile 中的換行符用於分隔不同的命令或規則。 makefile 中的換行符有兩種： 硬換行 硬換行符由 \\ 轉義符表示。 以下是一個硬換行的範例： hello: hello.o \\ gcc -o hello hello.o 軟換行 軟換行符由空格或製表符表示。 以下是一個軟換行的範例： hello: hello.o gcc -o hello hello.o # 顯示規則 最重要的是 Makefile 規則，詳細如下: 目標 (target): 一個目標檔，可以是 Object 檔，也可以是執行檔，還可以是一個標籤。 依賴 (Dependency, Prerequisites): 要產生目標檔 (target) 所依賴哪些檔。 命令 (Command): 建立專案時需要執行的 shell 命令。命令部分的每行的縮進必須要使用 Tab 鍵而不能使用多個空格。 target(要生成的文件): dependencies(被依賴的文件) 命令 1 命令 2 ... 命令 n# 命令前面用的是「tab」而非空格。# 可以使用「\\」表示續行。注意，「\\」之後不能有空格。像 clean 這種沒有被第一個目標文件直接或間接關聯，那麼它後面所定義的命令將不會被自動執行，不過我們可以顯式要求 make 執行。即 make clean。 .PHONY 會將目標設成假目標，使 make 目錄下沒有目標檔案或目標檔案為最新時，仍可執行 make &lt;target&gt;。.PHONY 寫法也可以讓程式設計師知道哪些工作目標不是針對檔案，增加可讀性。 Make 預設的假工作目標有 all, install, clean, distclean, TAGS, info 和 check。 一個常用的情況是 make clean，因為 clean 標籤下的 rm 命令並不產生 clean 文件： .PHONY: cleanclean: rm *.o# 變數使用 變數宣告時要使用 = 或 := 給予初始值 (注意兩者在代換時稍有不同)，如 obj = hello.o foo.o，取用時寫成 (obj) 或 {obj}。 # 自動化變數 $@ 工作目標檔名 $&lt; 第一個必要條件的檔名 $^ 所有必要條件的檔名，並以空格隔開這些檔名 (這份清單已移除重複的檔名) $* 工作目標的主檔名 # 萬用字元 Makefile 中所用的萬用字元是 % ，代表所有可能的字串，前後可接指定的字串來表示某些固定樣式 (pattern) 的字串。 例如 %.c 表示結尾是 .c 的所有字串。 # 特別字元 @ 不要顯示執行的命令 因執行 make 命令後會在終端機印出正在執行的命令 - 表示即使該行命令出錯，也不會中斷後續的動作執行 而 make 只要遇到任何錯誤就會中斷執行。 但像是在進行 clean 時，也許根本沒有任何檔案可以 clean，因而 rm 會傳回錯誤值，因而導致 make 中斷執行。 我們可以利用 - 來關閉錯誤中斷功能，讓 make 不會因而中斷。 # 範例 CC := gccOBJS := a.o b.o c.oall: test%.o: %.c $(CC) -c -o $@ $&lt;test: $(OBJS) $(CC) -o $@ $^.PHONY: cleanclean: @echo \"Clean...\" -rm *.o# GCC 參數 gcc 有使用許多的參數，意思如下： -c : 編譯但不進行鏈結 -ansi : 程式要求依據 ansi 標準，增加可移植性。 -I : 追加 include 檔案的搜尋路徑 -Wall : 編譯時顯示所有的警告訊息 -g : 編入除錯資訊 (要使用 GDB 除錯一定要加)。 -O ：表示最佳化的程度，預設是 -O1，可以指定 -O2 或 -O3，數字越大最佳化程度越高。 all: main# 使用的編譯器CC = g++# 安裝位置INSTDIR = /usr/local/bin# include 文件所在位置INCLUDE = .# 開發過程中使用的選項CFLAGS = -g -Wall -ansi# 用於發行時的選項# CFLAGS = -O -Wall -ansiOBJS = a.o b.o c.o# 本地庫MYLIB = mpilib.a%.o: %.c %.h $(CC) -I$(INCLUDE) $(CFLAGS) -c -o $@ $&lt;main: $(OBJS) $(CC) -o $@ $^.PHONY: cleanclean: @echo \"Clean...\" rm -f *.oinstall: main @if [ -d $(INSTDIR) ]; \\ then \\ cp main $(INSTDIR);\\ chmod a+x $(INSTDIR)/main;\\ chmod og-w $(INSTDIR)/main;\\ echo \"Installed in $(INSTDIR)\";\\ else \\ echo \"Sorry, $(INSTDIR) does not exist\";\\ fi# 安裝 Make 在 windows 上安裝 make 可以利用 chocolatey https://community.chocolatey.org/packages/make 參考 chocolatey 官網安裝 chocolatey 利用管理員權限運行 power shell，並輸入以下指令 > Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))接著在 power shell 在輸入命令，安裝 make > choco install make# Make 指令 將 makefile 寫好後就可以在其目錄底下，用以下指令進行編譯 $ make# Make 指令中定義變數 $ make CC=gcc 當命令行中的定義跟 makefile 中的定義有衝突時，以命令行中的定義為準 在 makefile 文件之外使用時，定義必須作為單個參數進行傳遞，所以要避免使用空格 如要使用空格，需要使用引號 $ make \"CC = gcc\"# Make 不同 filename 的 makefile $ make -f [filename] filename 可以替換成要編譯的 makefile 的名稱 # 指定在並行模式下構建目標 $ make -j [N] N ：指定要使用的處理器數量。默認情況下，Make 會使用所有可用的處理器。 可以提高構建速度，尤其是在使用多核處理器時。 可以更有效地利用系統資源。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"}],"tags":[]},{"title":"3005. Count Elements With Maximum Frequency","slug":"coding/leetcode/Easy/3005-Count-Elements-With-Maximum-Frequency","date":"2024-03-08T07:50:12.000Z","updated":"2024-03-09T02:12:23.072Z","comments":true,"path":"coding/leetcode/Easy/3005-Count-Elements-With-Maximum-Frequency/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/3005-Count-Elements-With-Maximum-Frequency/","excerpt":"","text":"⭐️ # 題目敘述 You are given an array nums consisting of positive integers. Return the total frequencies of elements in nums such that those elements all have the maximum frequency. The frequency of an element is the number of occurrences of that element in the array. # Example 1 Input: nums = [1,2,2,3,1,4] Output: 4 Explanation: The elements 1 and 2 have a frequency of 2 which is the maximum frequency in the array. So the number of elements in the array with maximum frequency is 4. # Example 2 Input: nums = [1,2,3,4,5] Output: 5 Explanation: All elements of the array have a frequency of 1 which is the maximum. So the number of elements in the array with maximum frequency is 5. # 解題思路 # Solution import java.util.HashMap;import java.util.Map;class Solution &#123; public int maxFrequencyElements(int[] nums) &#123; Map&lt;Integer, Integer> map = new HashMap&lt;>(); int max = 0; for(int num : nums)&#123; map.put(num, map.getOrDefault(num, 0) + 1); max = Math.max(max, map.get(num)); &#125; int res = 0; for(int key : map.keySet())&#123; if(map.get(key) == max)&#123; res += max; &#125; &#125; return res; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Counting","slug":"Counting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Counting/"}]},{"title":"876. Middle of the Linked List","slug":"coding/leetcode/Easy/876-Middle-of-the-Linked-List","date":"2024-03-07T08:56:50.000Z","updated":"2024-03-09T02:14:24.879Z","comments":true,"path":"coding/leetcode/Easy/876-Middle-of-the-Linked-List/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/876-Middle-of-the-Linked-List/","excerpt":"","text":"⭐️ # 題目敘述 Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node. # Example 1 Input: head = [1,2,3,4,5] Output: [3,4,5] Explanation: The middle node of the list is node 3. # Example 2 Input: head = [1,2,3,4,5,6] Output: [4,5,6] Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one. ListNode 的 class 內容 ListNode// Definition for singly-linked list.public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; # 解題思路 # Solution class Solution &#123; public ListNode middleNode(ListNode head) &#123; List&lt;Integer> list = new ArrayList&lt;>(); ListNode current = head; while (current != null) &#123; list.add(current.val); current = current.next; &#125; int size = list.size(); int mid = size / 2; ListNode result = new ListNode(list.get(mid)); ListNode temp = result; for (int i = mid + 1; i &lt; size; i++) &#123; temp.next = new ListNode(list.get(i)); temp = temp.next; &#125; return result; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Linked List","slug":"Linked-List","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Linked-List/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"}]},{"title":"948. Bag of Tokens","slug":"coding/leetcode/Medium/948-Bag-of-Tokens","date":"2024-03-04T05:16:52.000Z","updated":"2024-03-04T06:51:10.905Z","comments":true,"path":"coding/leetcode/Medium/948-Bag-of-Tokens/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/948-Bag-of-Tokens/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You start with an initial power of power , an initial score of 0 , and a bag of tokens given as an integer array tokens , where each tokens[i] donates the value of tokeni. Your goal is to maximize the total score by strategically playing these tokens. In one move, you can play an unplayed token in one of the two ways (but not both for the same token): Face-up: If your current power is at least tokens[i] , you may play tokeni, losing tokens[i] power and gaining 1 score. Face-down: If your current score is at least 1 , you may play tokeni, gaining tokens[i] power and losing 1 score. Return the maximum possible score you can achieve after playing any number of tokens. # Example 1 Input: tokens = [100], power = 50 Output: 0 Explanation: Since your score is 0 initially, you cannot play the token face-down. You also cannot play it face-up since your power (50) is less than tokens[0] (100). # Example 2 Input: tokens = [200,100], power = 150 Output: 1 Explanation: Play token1 (100) face-up, reducing your power to 50 and increasing your score to 1. There is no need to play token0, since you cannot play it face-up to add to your score. The maximum score achievable is 1. # Example 3 Input: tokens = [100,200,300,400], power = 200 Output: 2 Explanation: Play the tokens in this order to get a score of 2: Play token0 (100) face-up, reducing power to 100 and increasing score to 1. Play token3 (400) face-down, increasing power to 500 and reducing score to 0. Play token1 (200) face-up, reducing power to 300 and increasing score to 1. Play token2 (300) face-up, reducing power to 0 and increasing score to 2. The maximum score achievable is 2. # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public int bagOfTokensScore(int[] tokens, int power) &#123; int score = 0; Arrays.sort(tokens); int max = 0; int left = 0, right = tokens.length - 1; while(left &lt;= right)&#123; if(power >= tokens[left])&#123; power -= tokens[left]; score++; left++; max = Math.max(max, score); &#125;else if(score > 0)&#123; power += tokens[right]; score--; right--; &#125;else&#123; break; &#125; &#125; return max; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"}]},{"title":"787. Cheapest Flights Within K Stops","slug":"coding/leetcode/Medium/787-Cheapest-Flights-Within-K-Stops","date":"2024-02-23T11:43:13.000Z","updated":"2024-02-23T12:01:47.187Z","comments":true,"path":"coding/leetcode/Medium/787-Cheapest-Flights-Within-K-Stops/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/787-Cheapest-Flights-Within-K-Stops/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei . You are also given three integers src , dst , and k , return the cheapest price from src to dst with at most k stops. If there is no such route, return -1 . # Example 1 Input: n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1 Output: 700 Explanation: The graph is shown above. The optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700. Note that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops. # Example 2 Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1 Output: 200 Explanation: The graph is shown above. The optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200. # Example 3 Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0 Output: 500 Explanation: The graph is shown above. The optimal path with no stops from city 0 to 2 is marked in red and has cost 500. # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) &#123; int[] price = new int[n]; Arrays.fill(price, 100000); price[src] = 0; for (int i = 0; i &lt;= k; i++) &#123; int[] temp = new int[n]; Arrays.fill(temp, 100000); temp[src] = 0; for (int[] flight : flights) &#123; temp[flight[1]] = Math.min(temp[flight[1]], price[flight[0]] + flight[2]); &#125; price = temp; &#125; return (price[dst] >= 100000) ? -1 : price[dst]; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Shortest Path","slug":"Shortest-Path","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Shortest-Path/"}]},{"title":"997. Find the Town Judge","slug":"coding/leetcode/Easy/997-Find-the-Town-Judge","date":"2024-02-22T09:33:41.000Z","updated":"2024-02-22T10:01:56.798Z","comments":true,"path":"coding/leetcode/Easy/997-Find-the-Town-Judge/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/997-Find-the-Town-Judge/","excerpt":"","text":"⭐️ # 題目敘述 In a town, there are n people labeled from 1 to n . There is a rumor that one of these people is secretly the town judge. If the town judge exists, then: The town judge trusts nobody. Everybody (except for the town judge) trusts the town judge. There is exactly one person that satisfies properties 1 and 2. You are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi . If a trust relationship does not exist in trust array, then such a trust relationship does not exist. Return the label of the town judge if the town judge exists and can be identified, or return -1 otherwise. # Example 1 Input: n = 2, trust = [[1,2]] Output: 2 # Example 2 Input: n = 3, trust = [[1,3],[2,3]] Output: 3 # Example 3 Input: n = 3, trust = [[1,3],[2,3],[3,1]] Output: -1 # 解題思路 # Solution class Solution &#123; public int findJudge(int n, int[][] trust) &#123; int[] townJudge = new int[n]; int[] hastrust = new int[n]; for (int i = 0; i &lt; trust.length; i++) &#123; hastrust[trust[i][0] - 1]++; townJudge[trust[i][1] - 1]++; &#125; for (int i = 0; i &lt; n; i++) &#123; if (townJudge[i] == n - 1 &amp;&amp; hastrust[i] == 0) &#123; return i + 1; &#125; &#125; return -1; &#125;&#125; #include &lt;vector>#include &lt;string.h>using namespace std;class Solution &#123; public: int findJudge(int n, vector&lt;vector&lt;int>>&amp; trust) &#123; int townJudge[n]; memset(townJudge, 0, n * sizeof(int)); int hasTrust[n]; memset(hasTrust, 0, n * sizeof(int)); for (int i = 0; i &lt; trust.size(); i++) &#123; hasTrust[trust[i][0] - 1]++; townJudge[trust[i][1] - 1]++; &#125; for (int i = 0; i &lt; n; i++) &#123; if (townJudge[i] == n - 1 &amp;&amp; hasTrust[i] == 0) &#123; return i + 1; &#125; &#125; return -1; &#125;&#125;; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"}]},{"title":"201. Bitwise AND of Numbers Range","slug":"coding/leetcode/Medium/201-Bitwise-AND-of-Numbers-Range","date":"2024-02-21T01:21:36.000Z","updated":"2024-02-21T02:14:05.424Z","comments":true,"path":"coding/leetcode/Medium/201-Bitwise-AND-of-Numbers-Range/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/201-Bitwise-AND-of-Numbers-Range/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given two integers left and right that represent the range [left, right] , return the bitwise AND of all numbers in this range, inclusive. # Example 1 Input: left = 5, right = 7 Output: 4 # Example 2 Input: left = 0, right = 0 Output: 0 # Example 3 Input: left = 1, right = 2147483647 Output: 0 # 解題思路 # Solution class Solution &#123; public int rangeBitwiseAnd(int left, int right) &#123; int count = 0; while (left &lt; right) &#123; left >>= 1; right >>= 1; count++; &#125; return left &lt;&lt; count; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bit-Manipulation/"}]},{"title":"268. Missing Number","slug":"coding/leetcode/Easy/268-Missing-Number","date":"2024-02-20T06:37:46.000Z","updated":"2024-02-20T09:02:28.072Z","comments":true,"path":"coding/leetcode/Easy/268-Missing-Number/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/268-Missing-Number/","excerpt":"","text":"⭐️ # 題目敘述 Given an array nums containing n distinct numbers in the range [0, n] , return the only number in the range that is missing from the array. # Example 1 Input: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums. # Example 2 Input: nums = [0,1] Output: 2 Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums. # Example 3 Input: nums = [9,6,4,2,3,5,7,0,1] Output: 8 Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums. # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public int missingNumber(int[] nums) &#123; Arrays.sort(nums); for(int i = 0; i &lt; nums.length; i++)&#123; if(i != nums[i]) return i; &#125; return nums.length; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bit-Manipulation/"},{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"}]},{"title":"231. Power of Two","slug":"coding/leetcode/Easy/231-Power-of-Two","date":"2024-02-19T04:02:11.000Z","updated":"2024-02-19T11:53:32.687Z","comments":true,"path":"coding/leetcode/Easy/231-Power-of-Two/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/231-Power-of-Two/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer n , return true if it is a power of two. Otherwise, return false . An integer n is a power of two, if there exists an integer x such that n == 2^x . # Example 1 Input: n = 1 Output: true Explanation: 20 = 1 # Example 2 Input: n = 16 Output: true Explanation: 24 = 16 # Example 3 Input: n = 3 Output: false # 解題思路 # Solution class Solution &#123; public boolean isPowerOfTwo(int n) &#123; return n > 0 &amp;&amp; (n &amp; (n - 1)) == 0; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bit-Manipulation/"},{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"},{"name":"Recursion","slug":"Recursion","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Recursion/"}]},{"title":"2149. Rearrange Array Elements by Sign","slug":"coding/leetcode/Medium/2149-Rearrange-Array-Elements-by-Sign","date":"2024-02-14T03:47:19.000Z","updated":"2024-02-14T04:17:55.717Z","comments":true,"path":"coding/leetcode/Medium/2149-Rearrange-Array-Elements-by-Sign/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2149-Rearrange-Array-Elements-by-Sign/","excerpt":"","text":"⭐️⭐️ # 題目敘述 You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers. You should rearrange the elements of nums such that the modified array follows the given conditions: Every consecutive pair of integers have opposite signs. For all integers with the same sign, the order in which they were present in nums is preserved. The rearranged array begins with a positive integer. Return the modified array after rearranging the elements to satisfy the aforementioned conditions. # Example 1 Input: nums = [3,1,-2,-5,2,-4] Output: [3,-2,1,-5,2,-4] Explanation: The positive integers in nums are [3,1,2]. The negative integers are [-2,-5,-4]. The only possible way to rearrange them such that they satisfy all conditions is [3,-2,1,-5,2,-4]. Other ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or more conditions. # Example 2 Input: nums = [-1,1] Output: [1,-1] Explanation: 1 is the only positive integer and -1 the only negative integer in nums. So nums is rearranged to [1,-1]. # 解題思路 # Solution class Solution &#123; public int[] rearrangeArray(int[] nums) &#123; int len = nums.length; int[] ans = new int[len]; int i = 0, j = 1; for(int k = 0; k &lt; len; k++)&#123; if(nums[k] > 0)&#123; ans[i] = nums[k]; i += 2; &#125;else&#123; ans[j] = nums[k]; j += 2; &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"}]},{"title":"2108. Find First Palindromic String in the Array","slug":"coding/leetcode/Easy/2108-Find-First-Palindromic-String-in-the-Array","date":"2024-02-13T05:12:26.000Z","updated":"2024-02-13T05:24:34.214Z","comments":true,"path":"coding/leetcode/Easy/2108-Find-First-Palindromic-String-in-the-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2108-Find-First-Palindromic-String-in-the-Array/","excerpt":"","text":"⭐️ # 題目敘述 Given an array of strings words , return the first palindromic string in the array. If there is no such string, return an empty string &quot;&quot; . A string is palindromic if it reads the same forward and backward. # Example 1 Input: words = [&quot;abc&quot;,&quot;car&quot;,&quot;ada&quot;,&quot;racecar&quot;,&quot;cool&quot;] Output: &quot;ada&quot; Explanation: The first string that is palindromic is &quot;ada&quot;. Note that &quot;racecar&quot; is also palindromic, but it is not the first. # Example 2 Input: words = [&quot;notapalindrome&quot;,&quot;racecar&quot;] Output: &quot;racecar&quot; Explanation: The first and only string that is palindromic is &quot;racecar&quot;. # Example 3 Input: words = [&quot;def&quot;,&quot;ghi&quot;] Output: &quot;&quot; Explanation: There are no palindromic strings, so the empty string is returned. # 解題思路 # Solution class Solution &#123; public String firstPalindrome(String[] words) &#123; boolean isPalindrome = true; for (int i = 0; i &lt; words.length; i++) &#123; isPalindrome = true; for (int j = 0; j &lt; words[i].length() / 2; j++) &#123; if (words[i].charAt(j) != words[i].charAt(words[i].length() - j - 1)) &#123; isPalindrome = false; break; &#125; &#125; if (isPalindrome) &#123; return words[i]; &#125; &#125; return \"\"; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"}]},{"title":"169. Majority Element","slug":"coding/leetcode/Easy/169-Majority-Element","date":"2024-02-12T03:20:40.000Z","updated":"2024-02-12T03:28:45.142Z","comments":true,"path":"coding/leetcode/Easy/169-Majority-Element/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/169-Majority-Element/","excerpt":"","text":"⭐️ # 題目敘述 Given an array nums of size n , return the majority element. The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array. # Example 1 Input: nums = [3,2,3] Output: 3 # Example 2 Input: nums = [2,2,1,1,1,2,2] Output: 2 # 解題思路 # Solution import java.util.HashMap;import java.util.Map;class Solution &#123; public int majorityElement(int[] nums) &#123; Map&lt;Integer, Integer> map = new HashMap&lt;>(); int max = 0; int ans = 0; for(int i = 0; i &lt; nums.length; i++)&#123; int tmp = map.getOrDefault(nums[i], 0) + 1; map.put(nums[i], tmp); if(max &lt; tmp)&#123; max = tmp; ans = nums[i]; &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Divide-and-Conquer/"},{"name":"Counting","slug":"Counting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Counting/"}]},{"title":"279. Perfect Squares","slug":"coding/leetcode/Medium/279-Perfect-Squares","date":"2024-02-08T06:16:07.000Z","updated":"2024-02-08T07:17:36.502Z","comments":true,"path":"coding/leetcode/Medium/279-Perfect-Squares/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/279-Perfect-Squares/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given an integer n , return the least number of perfect square numbers that sum to n . A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1 , 4 , 9 , and 16 are perfect squares while 3 and 11 are not. # Example 1 Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4. # Example 2 Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public int numSquares(int n) &#123; int[] dp = new int[n + 1]; Arrays.fill(dp, Integer.MAX_VALUE); dp[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; int min_val = Integer.MAX_VALUE; for (int j = 1; j * j &lt;= i; j++) &#123; min_val = Math.min(min_val, dp[i - j * j] + 1); &#125; dp[i] = min_val; &#125; return dp[n]; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"}]},{"title":"深度強化式學習","slug":"computer-science/Artificial-Intelligence/深度強化式學習","date":"2024-02-07T12:11:29.000Z","updated":"2024-03-16T05:43:03.247Z","comments":true,"path":"computer-science/Artificial-Intelligence/深度強化式學習/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Artificial-Intelligence/%E6%B7%B1%E5%BA%A6%E5%BC%B7%E5%8C%96%E5%BC%8F%E5%AD%B8%E7%BF%92/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Artificial-Intelligence","slug":"computer-science/Artificial-Intelligence","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Artificial-Intelligence/"}],"tags":[{"name":"Deep Reinforcement Learning","slug":"Deep-Reinforcement-Learning","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Deep-Reinforcement-Learning/"},{"name":"Reinforcement Learning","slug":"Reinforcement-Learning","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Reinforcement-Learning/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Deep-Learning/"}]},{"title":"AlphaZero 演算法","slug":"computer-science/Artificial-Intelligence/AlphaZero-演算法","date":"2024-02-07T12:08:16.000Z","updated":"2024-03-16T05:43:05.841Z","comments":true,"path":"computer-science/Artificial-Intelligence/AlphaZero-演算法/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Artificial-Intelligence/AlphaZero-%E6%BC%94%E7%AE%97%E6%B3%95/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Artificial-Intelligence","slug":"computer-science/Artificial-Intelligence","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Artificial-Intelligence/"}],"tags":[{"name":"Deep Reinforcement Learning","slug":"Deep-Reinforcement-Learning","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Deep-Reinforcement-Learning/"},{"name":"Reinforcement Learning","slug":"Reinforcement-Learning","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Reinforcement-Learning/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Deep-Learning/"},{"name":"MCTS","slug":"MCTS","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/MCTS/"}]},{"title":"451. Sort Characters By Frequency","slug":"coding/leetcode/Medium/451-Sort-Characters-By-Frequency","date":"2024-02-07T04:32:32.000Z","updated":"2024-02-07T06:06:56.046Z","comments":true,"path":"coding/leetcode/Medium/451-Sort-Characters-By-Frequency/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/451-Sort-Characters-By-Frequency/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a string s , sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string. Return the sorted string. If there are multiple answers, return any of them. # Example 1 Input: s = &quot;tree&quot; Output: &quot;eert&quot; Explanation: 'e' appears twice while 'r' and 't' both appear once. So 'e' must appear before both 'r' and 't'. Therefore &quot;eetr&quot; is also a valid answer. # Example 2 Input: s = &quot;cccaaa&quot; Output: &quot;aaaccc&quot; Explanation: Both 'c' and 'a' appear three times, so both &quot;cccaaa&quot; and &quot;aaaccc&quot; are valid answers. Note that &quot;cacaca&quot; is incorrect, as the same characters must be together. # Example 3 Input: s = &quot;Aabb&quot; Output: &quot;bbAa&quot; Explanation: &quot;bbaA&quot; is also a valid answer, but &quot;Aabb&quot; is incorrect. Note that 'A' and 'a' are treated as two different characters. # 解題思路 # Solution import java.util.HashMap;import java.util.Map;import java.util.PriorityQueue;class Solution &#123; public String frequencySort(String s) &#123; Map&lt;Character, Integer> map = new HashMap&lt;>(); for (char c : s.toCharArray()) &#123; map.put(c, map.getOrDefault(c, 0) + 1); &#125; PriorityQueue&lt;Map.Entry&lt;Character, Integer>> pq = new PriorityQueue&lt;>( (a, b) -> b.getValue() - a.getValue() ); pq.addAll(map.entrySet()); StringBuilder ans = new StringBuilder(); while (!pq.isEmpty()) &#123; Map.Entry&lt;Character, Integer> entry = pq.poll(); ans.append(String.valueOf(entry.getKey()).repeat(entry.getValue())); &#125; return ans.toString(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Counting","slug":"Counting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Counting/"},{"name":"Bucket Sort","slug":"Bucket-Sort","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bucket-Sort/"}]},{"title":"電腦對局導論","slug":"computer-science/Artificial-Intelligence/電腦對局導論","date":"2024-02-05T11:05:15.000Z","updated":"2024-03-21T11:28:16.961Z","comments":true,"path":"computer-science/Artificial-Intelligence/電腦對局導論/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Artificial-Intelligence/%E9%9B%BB%E8%85%A6%E5%B0%8D%E5%B1%80%E5%B0%8E%E8%AB%96/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 電腦對局概論 研究人工智慧的過程中，漸漸發覺有些智慧的行為同時可以被人類和電腦所表現出來，但有些行為僅有人類或電腦才比較能夠呈現，亦即只有某一方能夠將這樣的智慧行為表現的淋凜盡致，例如: 電腦程式可以透過複雜的演算法，快速認證文件之數位簽名，可視為人類難以擁有的智慧行為之一。 人類可以經由閱讀文章內容，推敲出文章可能的作者是誰，即是人類行為難以被電腦取代的例證。 # Turing 測試 Alan Turing 在 1950 年提出 Turing Test 定義何謂智慧行為。 利用特的定問題分別詢問受測電腦及人，詢問時觀測者無法得知回答是來自受測電腦或人，如果觀測者無法區分答案是來自人或是受測電腦，則認定此受測電腦可以模仿人類行為，同時也判定其具有智慧。 # 歷史 18 世紀的第一個西洋棋機器人 西洋棋殘局自動機 (Chess) 東方的相關研究 (Go) # 學術研究 # 早期 (1970 年之前) 讓機器學會下棋之前，人類必須先分析自己在下棋時所產生的想法與觀念，將「思考」這件事情，變得更加理論化。 早期弈棋程式的演算法: 最小最大化搜尋 (Minimax search) Alpha-Beta 切捨 (Alpha-Beta pruning) 其演算法的概念就是源自於模擬人類下棋的行為。 觀察到人類在弈棋的過程中，並不會將每一個著手所造成的可能因素全部列入考慮中，而是自私對每個著手作簡略的勝率分析，從中選擇自己認為勝率最高的前幾個著手，並作深入的思考與選擇，而勝率最低的著手則會直接地被捨棄。 以象棋 (Chinese Chess) 為例，如果棋手已經找到一條吃王的路徑，那麼對他來說，這條路徑可以帶給他最大的益處，他就會著重於這條路的思考，看看有無破綻。 在沒完成這條路細算之前，不會考慮其他著手的可能性。 最小最大化搜尋、Alpha-Beta 切捨就是利用這樣的特性，給予不同盤面分數，並切割掉盤面分數較差的著手。 # 初期 (1970 ~ 1980 年) 演算法為最為粗暴的暴力搜尋演算法 (brute-force search algorithm)，讓電腦直接搜尋所有可移動的著手、對於搜尋的技巧、著手的選擇等相關知識，並沒有深入的了解與分析。 要讓點腦提升的方式，著重於電腦硬體設備的提升，電腦硬體設備愈強，能夠搜尋的深度就愈深，電腦棋力就愈強。 # 中期 (1980 ~ 1990 年) 由於電腦硬體的加速已經無法再有所突破，所以開始關注弈棋程式結合對局技巧的相關分析與演算法的研究。 # 近期 (1990 年至今) 窮舉法 (exhaustive search method) 平行化 (parallelization) 演算法的理論與新的想法 年代蒙地卡羅模擬法 (Monte-Carlo simulation) 1990 年代蒙地卡羅模擬法 (Monte-Carlo simulation): 蒙地卡羅模擬法有著和過去演算法完全不同的概念，他是透過統計、抽樣並結合猜測所出現的演算法，但是當蒙地卡羅模擬法被提出來的時候，電腦硬體因為效能不佳，並沒有辦法完整地呈現模擬的精巧，直到 2004 年後，硬體設備更加成熟時，才得以被完整實作並實際運用。 將蒙地卡羅模擬法的概念運用在弈棋程式上，有著相當驚人的成效：日本的電腦圍棋程式 Zen 利用蒙地卡羅模擬法，在 2012 年以讓四子的規則勝了一位九段棋士，宣告了電腦圍棋研究的新里程碑，直至今日，蒙地卡羅模擬法弈是相當蓬勃發展的研究方向之一。 只是近年來電腦圍棋程式的發展受限於蒙地卡羅法而未有新的理論突破，棋力增進的速度陷入瓶頸。 直到 Google DeepMind 團隊利用圖形處理器 (graphics processing unit，簡稱 GPU)，以類神經網路 (neural network) 為基底，開始讓對局系統進行深度學習 (deep learning)。 在 2015 年壓倒性打敗當時職業二段的歐洲圍棋職業冠軍的樊麾 (Hui Fan)，更在 2016 年 3 月以 4:1 打敗當時獲得多次世界冠軍的韓國職業九段棋手李世乭 (Sedol Lee)，更在 2017 年 5 月擊敗世界排名第一的中國棋手柯傑 (Jie Ke)，揭開電腦圍棋對局程式研究的新頁。 # 對局遊戲 # 對局分類 對局的分類方式，除了以對局人數的不同，可以分為單人對局 (single player games)、雙人對局 (two player games)、多人對局 (multi-player games) 外，同時也會根據對局性質、規則等特性，以對局資訊是否透明，或是程度上的不同，用二分法來歸類。 以對局資訊傳達的完整性可分為: 完美資訊 (perfect information) 所有玩家知道所有對局資訊，例如西洋棋、象棋 不完美資訊 (imperfect information) 只有特定玩家知道特定訊息，例如：麻將、橋牌等，每個玩家的手牌只有自己知道 以玩家對於對局規則的理解程度可以分為: 資訊完全 (complete information): 所有玩家知道所有對局進行的規則，例如西洋棋、象棋等 資訊不完全 (incomplete information): 有些規則步回告訴玩家，例如大富翁遊戲中，有可能會因為玩家在對局過程中，因為不同的抽牌結果，而改變對局規則，另外在拍賣 (aution) 對局中，玩家無從得知對手競標的策略和考慮方向 以對局本身是否帶有機率性可以分為: 確定性 (deterministic): 玩家可以掌握全盤對局狀態及進行 機率性 (stochastic): 對局時包含機率成分，玩家不能完全控制棋局的進行，例如必須在對局進行過程中擲骰子的對局 將對局分類的好處在於同一個分類的對局具有部分相同的性質，對於解題方式的選擇雖然會因為對局特性地不同而有所改變，但其基本特性應該大同小異，主要的解法仍可以通用 # 複雜度 對局以參與人數可以分為單人對局與多人對局。 單人對局通常稱為謎題 (puzzle)，而謎題的設計最好是只有一個正確的解答，例如數獨 (Sudoku)，其目的在於單人對局的完成，不須藉由其他人來得知對局中的資訊，因此對局的設計者通常會設計單一的解決方法，讓使用者可以了解到是否完成了對局成功的條件。然而這種對局複雜度通常為 NP 完備 (NP-complete)，例如接龍、數獨。目前觀察到一個謎題必須至少要有 NP 完備的難度才會耐玩。 雙人對局如黑白棋或奧賽羅棋、象棋、圍棋等，其複雜度就相當高，黑白棋或奧賽羅棋的複雜度屬於 PSPACE 完備 (PSPACE-complete)，而西洋棋和圍棋的複雜度屬於 EXPTIME 完備 (EXPTIME-complete) # 雙人對局概論 # 由西洋棋論雙人對局程式之設計 # 棋局類對局複雜度 對局樹複雜度 一種由上而下的觀點 狀態空間複雜度 一種由下而上的觀點 # 棋局三階段 棋局可以被分成三個階段: 開局 (opening game)、中局 (middle game)、殘局 (end game) # 開局 自對弈開始約 10 回合左右為開局階段，主要目的是將棋子移動到有利的位置，部屬陣型，以利中局的戰鬥 # 中局 開局完成後，即進入中局階段，是一盤棋主要戰鬥的過程，雙方在廝殺過程，可能直接勝利，也有可能在攻守時經過子力交換而進入殘局 因此中局的要點，一種是取得形勢上的優勢而快速取勝，一種是得到子力上或兵種上的優勢而進入有利殘局 # 殘局 而進入殘局後，以有限的兵力組成有效的攻擊或是防禦陣型，是殘局重要的課題 # 審局函數","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Artificial-Intelligence","slug":"computer-science/Artificial-Intelligence","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Artificial-Intelligence/"}],"tags":[{"name":"MCTS","slug":"MCTS","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/MCTS/"},{"name":"Alpha-Beta","slug":"Alpha-Beta","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Alpha-Beta/"}]},{"title":"387. First Unique Character in a String","slug":"coding/leetcode/Easy/387-First-Unique-Character-in-a-String","date":"2024-02-05T10:43:55.000Z","updated":"2024-02-05T11:03:08.177Z","comments":true,"path":"coding/leetcode/Easy/387-First-Unique-Character-in-a-String/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/387-First-Unique-Character-in-a-String/","excerpt":"","text":"⭐️ # 題目敘述 Given a string s , find the first non-repeating character in it and return its index. If it does not exist, return -1 . # Example 1 Input: s = &quot;leetcode&quot; Output: 0 # Example 2 Input: s = &quot;loveleetcode&quot; Output: 2 # Example 3 Input: s = &quot;aabb&quot; Output: -1 # 解題思路 # Solution import java.util.HashMap;import java.util.Map;class Solution &#123; public int firstUniqChar(String s) &#123; Map&lt;Character, Integer> map = new HashMap&lt;>(); for(int i = 0; i &lt; s.length(); i++)&#123; map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1); &#125; for(int i = 0; i &lt; s.length(); i++)&#123; if(map.get(s.charAt(i)) == 1)&#123; return i; &#125; &#125; return -1; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Queue","slug":"Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Queue/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Counting","slug":"Counting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Counting/"}]},{"title":"1043. Partition Array for Maximum Sum","slug":"coding/leetcode/Medium/1043-Partition-Array-for-Maximum-Sum","date":"2024-02-03T06:22:14.000Z","updated":"2024-02-03T07:43:19.904Z","comments":true,"path":"coding/leetcode/Medium/1043-Partition-Array-for-Maximum-Sum/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1043-Partition-Array-for-Maximum-Sum/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given an integer array arr , partition the array into (contiguous) subarrays of length at most k . After partitioning, each subarray has their values changed to become the maximum value of that subarray. Return the largest sum of the given array after partitioning. Test cases are generated so that the answer fits in a 32-bit integer. # Example 1 Input: arr = [1,15,7,9,2,5,10], k = 3 Output: 84 Explanation: arr becomes [15,15,15,9,10,10,10] # Example 2 Input: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4 Output: 83 # Example 3 Input: arr = [1], k = 1 Output: 1 # 解題思路 # Solution class Solution &#123; public int maxSumAfterPartitioning(int[] arr, int k) &#123; int dp[] = new int[arr.length + 1]; for (int index = arr.length - 1; index >= 0; index--) &#123; int max = Integer.MIN_VALUE; int ans = Integer.MIN_VALUE; int len = 0; for (int i = index; i &lt; index + k &amp;&amp; i &lt; arr.length; i++) &#123; len++; max = Math.max(max, arr[i]); ans = Math.max(ans, len * max + dp[i + 1]); &#125; dp[index] = ans; &#125; return dp[0]; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"1291. Sequential Digits","slug":"coding/leetcode/Medium/1291-Sequential-Digits","date":"2024-02-02T01:49:31.000Z","updated":"2024-02-02T02:00:17.456Z","comments":true,"path":"coding/leetcode/Medium/1291-Sequential-Digits/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1291-Sequential-Digits/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 An integer has sequential digits if and only if each digit in the number is one more than the previous digit. Return a sorted list of all the integers in the range [low, high] inclusive that have sequential digits. # Example 1 Input: low = 100, high = 300 Output: [123,234] # Example 2 Input: low = 1000, high = 13000 Output: [1234,2345,3456,4567,5678,6789,12345] # 解題思路 # Solution import java.util.ArrayList;import java.util.Collections;import java.util.List;class Solution &#123; public List&lt;Integer> sequentialDigits(int low, int high) &#123; List&lt;Integer> ans = new ArrayList&lt;>(); for(int i = 1; i &lt;= 9; i++)&#123; int num = i; int next = i + 1; while (num &lt;= high &amp;&amp; next &lt;= 9) &#123; num = num * 10 + next; next = next + 1; if(num >= low &amp;&amp; num &lt;= high)&#123; ans.add(num); &#125; &#125; &#125; Collections.sort(ans); return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Enumeration","slug":"Enumeration","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Enumeration/"}]},{"title":"2966. Divide Array Into Arrays With Max Difference","slug":"coding/leetcode/Medium/2966-Divide-Array-Into-Arrays-With-Max-Difference","date":"2024-02-01T11:36:47.000Z","updated":"2024-02-01T11:58:45.080Z","comments":true,"path":"coding/leetcode/Medium/2966-Divide-Array-Into-Arrays-With-Max-Difference/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2966-Divide-Array-Into-Arrays-With-Max-Difference/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an integer array nums of size n and a positive integer k . Divide the array into one or more arrays of size 3 satisfying the following conditions: Each element of nums should be in exactly one array. The difference between any two elements in one array is less than or equal to k . Return a 2D array containing all the arrays. If it is impossible to satisfy the conditions, return an empty array. And if there are multiple answers, return any of them. # Example 1 Input: nums = [1,3,4,8,7,9,3,5,1], k = 2 Output: [[1,1,3],[3,4,5],[7,8,9]] Explanation: We can divide the array into the following arrays: [1,1,3], [3,4,5] and [7,8,9]. The difference between any two elements in each array is less than or equal to 2. Note that the order of elements is not important. # Example 2 Input: nums = [1,3,3,2,7,3], k = 3 Output: [] Explanation: It is not possible to divide the array satisfying all the conditions. # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public int[][] divideArray(int[] nums, int k) &#123; int size = nums.length; if(size % 3 != 0)&#123; return new int[0][0]; &#125; Arrays.sort(nums); int[][] ans = new int[(size / 3)][3]; for(int i = 0, j = 0; j &lt; (size / 3); i += 3, j++)&#123; if(i + 2 &lt; size &amp;&amp; nums[i + 2] - nums[i] &lt;= k)&#123; ans[j][0] = nums[i]; ans[j][1] = nums[i + 1]; ans[j][2] = nums[i + 2]; &#125;else&#123; return new int[0][0]; &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"}]},{"title":"739. Daily Temperatures","slug":"coding/leetcode/Medium/739-Daily-Temperatures","date":"2024-01-31T09:57:46.000Z","updated":"2024-01-31T10:36:13.227Z","comments":true,"path":"coding/leetcode/Medium/739-Daily-Temperatures/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/739-Daily-Temperatures/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead. # Example 1 Input: temperatures = [73,74,75,71,69,72,76,73] Output: [1,1,4,2,1,1,0,0] # Example 2 Input: temperatures = [30,40,50,60] Output: [1,1,1,0] # Example 3 Input: temperatures = [30,60,90] Output: [1,1,0] # 解題思路 # Solution import java.util.Arrays;import java.util.Stack;class Solution &#123; public int[] dailyTemperatures(int[] temperatures) &#123; int n = temperatures.length; int[] answers = new int[n]; Arrays.fill(answers, 0); Stack&lt;Integer> s = new Stack&lt;>(); for(int i = 0; i &lt; n; i++)&#123; while(!s.isEmpty() &amp;&amp; temperatures[s.peek()] &lt; temperatures[i])&#123; answers[s.peek()] = i - s.pop(); &#125; s.push(i); &#125; return answers; &#125;&#125; #include &lt;vector>#include &lt;stack>using namespace std;class Solution &#123; public: vector&lt;int> dailyTemperatures(vector&lt;int>&amp; temperatures) &#123; int n = temperatures.size(); vector&lt;int> answers(n); stack&lt;int> stack; for(int i = 0; i &lt; n; i++)&#123; while (!stack.empty() &amp;&amp; temperatures[stack.top()] &lt; temperatures[i]) &#123; answers[stack.top()] = i - stack.top(); stack.pop(); &#125; stack.push(i); &#125; return answers; &#125;&#125;; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"Monotonic Stack","slug":"Monotonic-Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Monotonic-Stack/"},{"name":"nullArray","slug":"nullArray","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/nullArray/"}]},{"title":"150. Evaluate Reverse Polish Notation","slug":"coding/leetcode/Medium/150-Evaluate-Reverse-Polish-Notation","date":"2024-01-30T06:23:24.000Z","updated":"2024-01-30T07:02:55.434Z","comments":true,"path":"coding/leetcode/Medium/150-Evaluate-Reverse-Polish-Notation/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/150-Evaluate-Reverse-Polish-Notation/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation. Evaluate the expression. Return an integer that represents the value of the expression. Note that: The valid operators are '+' , '-' , '*' , and '/' . Each operand may be an integer or another expression. The division between two integers always truncates toward zero. There will not be any division by zero. The input represents a valid arithmetic expression in a reverse polish notation. The answer and all the intermediate calculations can be represented in a 32-bit integer. # Example 1 Input: tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;] Output: 9 Explanation: ((2 + 1) * 3) = 9 # Example 2 Input: tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;] Output: 6 Explanation: (4 + (13 / 5)) = 6 # Example 3 Input: tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;&quot;,&quot;/&quot;,&quot;&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;] Output: 22 Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 # 解題思路 # Solution import java.util.*;class Solution &#123; public int evalRPN(String[] tokens) &#123; ArrayList&lt;Integer> arr = new ArrayList&lt;>(); for(int i = 0; i &lt; tokens.length; i++)&#123; if(tokens[i].equals(\"+\") || tokens[i].equals(\"-\") || tokens[i].equals(\"*\") || tokens[i].equals(\"/\"))&#123; int temp = math(arr.get(arr.size() - 2),arr.get(arr.size() - 1),tokens[i]); arr.remove(arr.size() - 1); arr.remove(arr.size() - 1); arr.add(temp); &#125; else&#123; arr.add(Integer.parseInt(tokens[i])); &#125; &#125; return arr.get(0); &#125; public int math(int a, int b, String s) &#123; switch (s) &#123; case \"+\": return a + b; case \"-\": return a - b; case \"*\": return a * b; case \"/\": return a / b; &#125; return 0; &#125;&#125; #include &lt;string>#include &lt;vector>#include &lt;iostream>using namespace std;class Solution &#123; public: int evalRPN(vector&lt;string>&amp; tokens) &#123; vector&lt;int> arr; for (int i = 0; i &lt; tokens.size(); i++) &#123; if (tokens[i] == \"+\" || tokens[i] == \"-\" || tokens[i] == \"*\" || tokens[i] == \"/\") &#123; int tmp = math(arr[arr.size() - 2], arr[arr.size() - 1], tokens[i]); arr.pop_back(); arr.pop_back(); arr.push_back(tmp); &#125; else &#123; arr.push_back(stoi(tokens[i])); &#125; &#125; return arr[0]; &#125; int math(int a, int b, string s) &#123; switch (s[0]) &#123; case '+': return a + b; case '-': return a - b; case '*': return a * b; case '/': return a / b; &#125; return 0; &#125;&#125;; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"}]},{"title":"232. Implement Queue using Stacks","slug":"coding/leetcode/Easy/232-Implement-Queue-using-Stacks","date":"2024-01-29T05:12:25.000Z","updated":"2024-01-29T05:27:20.630Z","comments":true,"path":"coding/leetcode/Easy/232-Implement-Queue-using-Stacks/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/232-Implement-Queue-using-Stacks/","excerpt":"","text":"⭐️ # 題目敘述 Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue ( push , peek , pop , and empty ). Implement the MyQueue class: void push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue. boolean empty() Returns true if the queue is empty, false otherwise. Notes: You must use only standard operations of a stack, which means only push to top , peek/pop from top , size , and is empty operations are valid. Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations. # Example 1 Input [&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;] [[], [1], [2], [], [], []] Output [null, null, null, 1, 1, false] Explanation MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false # 解題思路 # Solution import java.util.ArrayList;class MyQueue &#123; private int front; private int rear; private ArrayList&lt;Integer> queue = new ArrayList&lt;>(); public MyQueue() &#123; this.front = 0; this.rear = 0; &#125; public int getFront() &#123; return this.front; &#125; public int getRear() &#123; return this.rear; &#125; public void setFront(int f) &#123; this.front = f; &#125; public void setRear(int r) &#123; this.rear = r; &#125; public void push(int x) &#123; queue.add(x); setRear(getRear() + 1); &#125; public int pop() &#123; int temp = queue.get(0); queue.remove(0); setFront(getFront() + 1); return temp; &#125; public int peek() &#123; int temp = queue.get(0); return temp; &#125; public boolean empty() &#123; return getFront() == getRear(); &#125;&#125;/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */ #include &lt;vector>using namespace std;class MyQueue &#123; private: int front; int rear; vector&lt;int> queue; public: MyQueue() &#123; this->front = 0; this->rear = 0; &#125; int getFront() &#123; return this->front; &#125; int getRear() &#123; return this->rear; &#125; void setFront(int f) &#123; this->front = f; &#125; void setRear(int r) &#123; this->rear = r; &#125; void push(int x) &#123; queue.push_back(x); setRear(getRear() + 1); &#125; int pop() &#123; int tmp = queue[getFront()]; setFront(getFront() + 1); return tmp; &#125; int peek() &#123; int tmp = queue[getFront()]; return tmp; &#125; bool empty() &#123; return getFront() == getRear(); &#125;&#125;;/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->peek(); * bool param_4 = obj->empty(); */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Queue","slug":"Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Queue/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"Design","slug":"Design","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Design/"}]},{"title":"629. K Inverse Pairs Array","slug":"coding/leetcode/Hard/629-K-Inverse-Pairs-Array","date":"2024-01-27T02:37:51.000Z","updated":"2024-01-27T03:54:43.748Z","comments":true,"path":"coding/leetcode/Hard/629-K-Inverse-Pairs-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/629-K-Inverse-Pairs-Array/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 For an integer array nums , an inverse pair is a pair of integers [i, j] where 0 &lt;= i &lt; j &lt; nums.length and nums[i] &gt; nums[j] . Given two integers n and k, return the number of different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs. Since the answer can be huge, return it modulo 10^9 + 7 . # Example 1 Input: n = 3, k = 0 Output: 1 Explanation: Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pairs. # Example 2 Input: n = 3, k = 1 Output: 2 Explanation: The array [1,3,2] and [2,1,3] have exactly 1 inverse pair. # 解題思路 # Solution class Solution &#123; private static final int MOD = 1000000007; public static int kInversePairs(int n, int k) &#123; int[][] dp = new int[n + 1][k + 1]; for (int i = 0; i &lt;= n; i++) &#123; dp[i][0] = 1; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= k; j++) &#123; dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % MOD; if (j >= i) &#123; dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + MOD) % MOD; &#125; &#125; &#125; return dp[n][k]; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"576. Out of Boundary Paths","slug":"coding/leetcode/Medium/576-Out-of-Boundary-Paths","date":"2024-01-26T03:42:18.000Z","updated":"2024-01-26T05:51:35.963Z","comments":true,"path":"coding/leetcode/Medium/576-Out-of-Boundary-Paths/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/576-Out-of-Boundary-Paths/","excerpt":"","text":"⭐️⭐️⭐️⭐️ # 題目敘述 There is an m x n grid with a ball. The ball is initially at the position [startRow, startColumn] . You are allowed to move the ball to one of the four adjacent cells in the grid (possibly out of the grid crossing the grid boundary). You can apply at most maxMove moves to the ball. Given the five integers m , n , maxMove , startRow , startColumn , return the number of paths to move the ball out of the grid boundary. Since the answer can be very large, return it modulo 10^9 + 7 . # Example 1 Input: m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0 Output: 6 # Example 2 Input: m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1 Output: 12 # 解題思路 # Solution class Solution &#123; public int findPaths(int m, int n, int N, int x, int y) &#123; final int MOD = (int) (1e9 + 7); int[][] dp = new int[m][n]; dp[x][y] = 1; int count = 0; for (int moves = 1; moves &lt;= N; moves++) &#123; int[][] tmp = new int[m][n]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i == m - 1) count = (count + dp[i][j]) % MOD; if (j == n - 1) count = (count + dp[i][j]) % MOD; if (i == 0) count = (count + dp[i][j]) % MOD; if (j == 0) count = (count + dp[i][j]) % MOD; tmp[i][j] = (((i > 0 ? dp[i - 1][j] : 0) + (i &lt; m - 1 ? dp[i + 1][j] : 0)) % MOD + ((j > 0 ? dp[i][j - 1] : 0) + (j &lt; n - 1 ? dp[i][j + 1] : 0)) % MOD) % MOD; &#125; &#125; dp = tmp; &#125; return count; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"1143. Longest Common Subsequence","slug":"coding/leetcode/Medium/1143-Longest-Common-Subsequence","date":"2024-01-25T03:07:04.000Z","updated":"2024-01-25T03:38:17.046Z","comments":true,"path":"coding/leetcode/Medium/1143-Longest-Common-Subsequence/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1143-Longest-Common-Subsequence/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given two strings text1 and text2 , return the length of their longest common subsequence. If there is no common subsequence, return 0 . A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, &quot;ace&quot; is a subsequence of &quot;abcde&quot; . A common subsequence of two strings is a subsequence that is common to both strings. # Example 1 Input: text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; Output: 3 Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3. # Example 2 Input: text1 = &quot;abc&quot;, text2 = &quot;abc&quot; Output: 3 Explanation: The longest common subsequence is &quot;abc&quot; and its length is 3. # Example 3 Input: text1 = &quot;abc&quot;, text2 = &quot;def&quot; Output: 0 Explanation: There is no such common subsequence, so the result is 0. # 解題思路 # Solution class Solution &#123; public int longestCommonSubsequence(String text1, String text2) &#123; int[][] DP = new int[text1.length()+1][text2.length()+1]; for (int i = 1; i &lt;= text1.length(); i++) &#123; for (int j = 1; j &lt;= text2.length(); j++) &#123; if (text1.substring(i - 1, i).equals(text2.substring(j - 1, j))) &#123; DP[i][j] = DP[i - 1][j - 1] + 1; &#125; else &#123; DP[i][j] = Math.max(DP[i - 1][j], DP[i][j - 1]); &#125; &#125; &#125; return DP[text1.length()][text2.length()]; &#125;&#125; #include &lt;string>#include &lt;string.h>using namespace std;class Solution &#123; public: int longestCommonSubsequence(string text1, string text2) &#123; int len1 = text1.size(); int len2 = text2.size(); int DP[len1 + 1][len2 + 1]; memset(DP, 0, sizeof DP); for (int i = 1; i &lt;= len1; i++) &#123; for (int j = 1; j &lt;= len2; j++) &#123; if (text1[i - 1] == text2[j - 1]) &#123; DP[i][j] = DP[i - 1][j - 1] + 1; &#125; else &#123; DP[i][j] = max(DP[i - 1][j], DP[i][j - 1]); &#125; &#125; &#125; return DP[len1][len2]; &#125;&#125;; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"1457. Pseudo-Palindromic Paths in a Binary Tree","slug":"coding/leetcode/Medium/1457-Pseudo-Palindromic-Paths-in-a-Binary-Tree","date":"2024-01-24T02:04:05.000Z","updated":"2024-01-24T05:24:08.347Z","comments":true,"path":"coding/leetcode/Medium/1457-Pseudo-Palindromic-Paths-in-a-Binary-Tree/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1457-Pseudo-Palindromic-Paths-in-a-Binary-Tree/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be pseudo-palindromic if at least one permutation of the node values in the path is a palindrome. Return the number of pseudo-palindromic paths going from the root node to leaf nodes. # Example 1 Input: root = [2,3,1,3,1,null,1] Output: 2 Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome). # Example 2 Input: root = [2,1,1,1,3,null,null,null,null,null,1] Output: 1 Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome). # Example 3 Input: root = [9] Output: 1 TreeNode 的 class 內容 TreeNode// Definition for a binary tree node.public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode() &#123; &#125; TreeNode(int val) &#123; this.val = val; &#125; TreeNode(int val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125;&#125; # 解題思路 # Solution import java.util.Stack;class Solution &#123; private int ans; public int pseudoPalindromicPaths(TreeNode root) &#123; ans = 0; Stack&lt;Object[]> stack = new Stack&lt;>(); stack.push(new Object[]&#123;root, 0&#125;); while (!stack.isEmpty()) &#123; Object[] tmp = stack.pop(); TreeNode curr = (TreeNode) tmp[0]; int val = (int) tmp[1]; if(curr != null)&#123; val = val ^ (1 &lt;&lt; curr.val); if(curr.left == null &amp;&amp; curr.right == null)&#123; if((val &amp; (val - 1)) == 0)&#123; ans++; &#125; &#125;else&#123; stack.push(new Object[]&#123;curr.left, val&#125;); stack.push(new Object[]&#123;curr.right, val&#125;); &#125; &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bit-Manipulation/"},{"name":"Tree","slug":"Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Tree/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Tree/"}]},{"title":"1239. Maximum Length of a Concatenated String with Unique Characters","slug":"coding/leetcode/Medium/1239-Maximum-Length-of-a-Concatenated-String-with-Unique-Characters","date":"2024-01-23T02:31:55.000Z","updated":"2024-01-23T03:23:46.655Z","comments":true,"path":"coding/leetcode/Medium/1239-Maximum-Length-of-a-Concatenated-String-with-Unique-Characters/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1239-Maximum-Length-of-a-Concatenated-String-with-Unique-Characters/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an array of strings arr . A string s is formed by the concatenation of a subsequence of arr that has unique characters. Return the maximum possible length of s . A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. # Example 1 Input: arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;] Output: 4 Explanation: All the valid concatenations are: &quot;&quot; &quot;un&quot; &quot;iq&quot; &quot;ue&quot; &quot;uniq&quot; (&quot;un&quot; + &quot;iq&quot;) &quot;ique&quot; (&quot;iq&quot; + &quot;ue&quot;) Maximum length is 4. # Example 2 Input: arr = [&quot;cha&quot;,&quot;r&quot;,&quot;act&quot;,&quot;ers&quot;] Output: 6 Explanation: Possible longest valid concatenations are &quot;chaers&quot; (&quot;cha&quot; + &quot;ers&quot;) and &quot;acters&quot; (&quot;act&quot; + &quot;ers&quot;). # Example 3 Input: arr = [&quot;abcdefghijklmnopqrstuvwxyz&quot;] Output: 26 Explanation: The only string in arr has all 26 characters. # 解題思路 # Solution import java.util.ArrayList;import java.util.List;class Solution &#123; public int maxLength(List&lt;String> arr) &#123; List&lt;Integer> list = new ArrayList&lt;>(); list.add(0); int res = 0; for (String str : arr) &#123; int strValue = 0, checkSame = 0; for (char c : str.toCharArray()) &#123; checkSame |= strValue &amp; (1 &lt;&lt; (c - 'a')); strValue |= 1 &lt;&lt; (c - 'a'); &#125; if (checkSame > 0) continue; for (int i = list.size() - 1; i >= 0; i--) &#123; if ((list.get(i) &amp; strValue) > 0) continue; list.add(list.get(i) | strValue); res = Math.max(res, Integer.bitCount(list.get(i) | strValue)); &#125; &#125; return res; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bit-Manipulation/"},{"name":"Backtracking","slug":"Backtracking","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Backtracking/"}]},{"title":"645. Set Mismatch","slug":"coding/leetcode/Easy/645-Set-Mismatch","date":"2024-01-22T03:17:58.000Z","updated":"2024-01-22T03:34:51.284Z","comments":true,"path":"coding/leetcode/Easy/645-Set-Mismatch/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/645-Set-Mismatch/","excerpt":"","text":"⭐️ # 題目敘述 You have a set of integers s , which originally contains all the numbers from 1 to n . Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number. You are given an integer array nums representing the data status of this set after the error. Find the number that occurs twice and the number that is missing and return them in the form of an array. # Example 1 Input: nums = [1,2,2,4] Output: [2,3] # Example 2 Input: nums = [1,1] Output: [1,2] # 解題思路 # Solution import java.util.ArrayList;class Solution &#123; public int[] findErrorNums(int[] nums) &#123; int len = nums.length; int[] mark = new int[len]; ArrayList&lt;Integer> arr = new ArrayList&lt;>(); for(int i = 0; i &lt; len; i++)&#123; mark[nums[i] - 1]++; if(mark[nums[i] - 1] == 2)&#123; arr.add(nums[i]); &#125; &#125; for(int i = 0; i &lt; len; i++)&#123; if(mark[i] == 0)&#123; arr.add(i + 1); &#125; &#125; return arr.stream().mapToInt(i -> i).toArray(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bit-Manipulation/"}]},{"title":"198. House Robber","slug":"coding/leetcode/Medium/198-House-Robber","date":"2024-01-21T05:31:57.000Z","updated":"2024-01-21T06:31:14.235Z","comments":true,"path":"coding/leetcode/Medium/198-House-Robber/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/198-House-Robber/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. # Example 1 Input: nums = [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. # Example 2 Input: nums = [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. # 解題思路 # Solution class Solution &#123; public int rob(int[] nums) &#123; int max = 0; for (int i = 2; i &lt; nums.length; i++) &#123; if (i - 3 &lt; 0) &#123; max = nums[i - 2]; &#125; else &#123; max = Math.max(nums[i - 2], nums[i - 3]); &#125; nums[i] = nums[i] + max; &#125; max = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (max &lt; nums[i]) &#123; max = nums[i]; &#125; &#125; return max; &#125;&#125; #include &lt;vector>#include &lt;math.h>using namespace std;class Solution &#123;public: int rob(vector&lt;int>&amp; nums) &#123; int res = 0; for (int i = 2; i &lt; nums.size(); i++) &#123; if (i - 3 &lt; 0) &#123; res = nums[i - 2]; &#125; else &#123; res = max(nums[i - 2], nums[i - 3]); &#125; nums[i] = nums[i] + res; &#125; res = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; if (res &lt; nums[i]) &#123; res = nums[i]; &#125; &#125; return res; &#125;&#125;; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"平常的台日麻將規則","slug":"平常的台日麻將規則","date":"2024-01-20T08:51:05.000Z","updated":"2024-01-21T12:04:52.027Z","comments":true,"path":"平常的台日麻將規則/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/%E5%B9%B3%E5%B8%B8%E7%9A%84%E5%8F%B0%E6%97%A5%E9%BA%BB%E5%B0%87%E8%A6%8F%E5%89%87/","excerpt":"","text":"# 臺灣麻將規則 由於我們是要寫麻將對局，不是要當賭神😝，所以我這裡只列出幾個需要關注的內容，一些過於細節的就不多加描述。 # 排組介紹 一副麻將總共 144 張牌 136 張基本牌，每種各四張 1 ~ 9 萬 1 ~ 9 條 1 ~ 9 筒 中、發、白 東、南、西、北 4 張花牌 梅、蘭、竹、菊 4 張四季牌 春、夏、秋、冬 # 動作 抓位: 每圈開始前，大家把東、南、西、北風牌放到桌上，並且蓋上，四家任意各拿一張牌後，依照所拿到的風牌決定座位，就叫做「麻將抓位」。 補花: 摸進花牌時，便由莊家開始，依逆時鐘方向，大家依次於牌疊的後方補足跟花牌相等的牌，不補牌或者補完牌的時候，你可以說「過補」或「請補」。 打牌: 把你不要的牌支打進海底，就叫做「打牌」。 摸牌: 上家打牌後，無吃、碰 (不可明槓上家出的牌，因此不考慮槓的情形) 時，就可以再摸一張牌，就叫做「摸牌」。 吃牌: 當牌的組合無法自摸獲得時，可拿上家丟出來的牌來組成順子，公開表示放於自己左邊。 碰牌: 當你手中有兩支牌和別人打出的牌相同時，就可叫「碰」，又稱為「碰牌」。 槓牌: 明槓、暗槓、加槓 明槓: 他家打牌之後，如果你手上有三張跟那被打出的牌支一樣的，就可以「槓牌」，這種槓牌叫做「明槓」 。此外，上家出的牌不可用來明槓。 暗槓: 如果是手內摸有四張相同的牌，取出槓牌，則叫做「暗槓」 加槓: 如果是已經碰牌了，卻又再摸入一張相同的牌支，也可以叫槓牌 — 這種槓牌叫作「加槓」 流局: 最後剩下 8 疊（16 張）牌為流局，就是平手意思，莊家則繼續連莊。 # 胡牌 胡牌是要將自己手上的 16 張 ＋ 1 張新摸進來的牌湊出 5 組對子跟 1 對眼睛。 對子可以分成: 順子: 同花色接續的數字，例如 345 萬、123 條、789 筒。 刻子: 相同數字花色，例如：三張 1 筒、三張東風牌、三張紅中牌、三張 2 萬。 眼睛是指: 兩張同花色相同數字的牌，例如兩張西風、兩張白皮、兩張 9 條。 胡牌又可分成兩種: 自摸: 如果是自己摸進來的牌而湊齊，則稱為「自摸」，則其他三家皆輸。 放槍: 如果是因為其他玩家丟出的牌而湊齊，則丟牌的人稱為「放槍」，只有丟牌即放槍者算輸。 # 臺數 可以參考有圖解 一臺 說明 莊家 做莊家者，無論胡牌或放槍都多算一臺 連莊 莊家胡牌或是流局，稱為連莊 拉莊 莊家胡牌或流局即為連莊，連莊即有拉莊家算一臺 門清 胡牌時，沒有吃牌、碰牌、明槓 不求 完全沒吃牌也沒碰牌，且胡牌的牌由自己摸進 自摸 胡牌的牌由自己摸進 風牌 拿自己所屬的風位的刻子，以開門為東風逆時針依序為東、南、西、北 花牌 與風牌計臺方式相同，以開門為東風逆時針依序為東 (梅、春)、南 (蘭、夏)、西 (竹、秋)、北 (菊、東)。符合自己的方位時，花牌一張即一臺 搶槓 聽牌時，因別人加槓而加槓那張牌，恰巧是可以胡的牌 三元牌 中、發、白任一連刻子 獨聽 邊張、中洞、單吊 槓上開花 因摸到花牌、暗槓或加槓而補牌，補牌後恰巧胡牌 河底撈魚 胡別人丟出的最後一張牌 海底撈月 摸牌牆最後一張牌，而自摸者多計一臺，因摸到花牌或加槓造成其結果為最後一張牌時，亦以海底撈月計之 # 日本麻將規則","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"}],"tags":[]},{"title":"907. Sum of Subarray Minimums","slug":"coding/leetcode/Medium/907-Sum-of-Subarray-Minimums","date":"2024-01-20T03:46:44.000Z","updated":"2024-01-20T08:02:24.488Z","comments":true,"path":"coding/leetcode/Medium/907-Sum-of-Subarray-Minimums/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/907-Sum-of-Subarray-Minimums/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given an array of integers arr, find the sum of min(b) , where b ranges over every (contiguous) subarray of arr . Since the answer may be large, return the answer modulo 10^9 + 7 . # Example 1 Input: arr = [3,1,2,4] Output: 17 Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1. Sum is 17. # Example 2 Input: arr = [11,81,94,43,3] Output: 444 # 解題思路 # Solution import java.util.Stack;class Solution &#123; public int sumSubarrayMins(int[] arr) &#123; final int MOD = (int) 1e9 + 7; Stack&lt;Integer> stack = new Stack&lt;>(); long sum = 0; for (int i = 0; i &lt;= arr.length; i++) &#123; while (!stack.empty() &amp;&amp; (i == arr.length || arr[stack.peek()] >= arr[i])) &#123; int mid = stack.pop(); int leftBoundary = stack.empty() ? -1 : stack.peek(); int rightBoundary = i; long count = (mid - leftBoundary) * (rightBoundary - mid) % MOD; sum += (count * arr[mid]) % MOD; sum %= MOD; &#125; stack.push(i); &#125; return (int) sum; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"Monotonic Stack","slug":"Monotonic-Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Monotonic-Stack/"}]},{"title":"931. Minimum Falling Path Sum","slug":"coding/leetcode/Medium/931-Minimum-Falling-Path-Sum","date":"2024-01-19T08:35:04.000Z","updated":"2024-01-20T03:46:08.668Z","comments":true,"path":"coding/leetcode/Medium/931-Minimum-Falling-Path-Sum/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/931-Minimum-Falling-Path-Sum/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given an n x n array of integers matrix , return the minimum sum of any falling path through matrix . A falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1) , (row + 1, col) , or (row + 1, col + 1) . # Example 1 Input: matrix = [[2,1,3],[6,5,4],[7,8,9]] Output: 13 Explanation: There are two falling paths with a minimum sum as shown. # Example 2 Input: matrix = [[-19,57],[-40,-5]] Output: -59 Explanation: The falling path with a minimum sum is shown. # 解題思路 # Solution class Solution &#123; public int minFallingPathSum(int[][] matrix) &#123; int size = matrix.length; int min = Integer.MAX_VALUE; for (int i = 1; i &lt; size; i++) &#123; for (int j = 0; j &lt; size; j++) &#123; min = matrix[i - 1][j]; if (j > 0) &#123; min = Math.min(matrix[i - 1][j - 1], min); &#125; if (j &lt; size - 1) &#123; min = Math.min(matrix[i - 1][j + 1], min); &#125; matrix[i][j] = matrix[i][j] + min; &#125; &#125; min = Integer.MAX_VALUE; for (int i = 0; i &lt; size; i++) &#123; if (min > matrix[size - 1][i]) &#123; min = matrix[size - 1][i]; &#125; &#125; return min; &#125;&#125; #include &lt;bits/stdc++.h>using namespace std;class Solution &#123;public: int minFallingPathSum(vector&lt;vector&lt;int>>&amp; matrix) &#123; int size = matrix.size(); int ans = INT_MAX; for (int i = 1; i &lt; size; i++) &#123; for (int j = 0; j &lt; size; j++) &#123; ans = matrix[i - 1][j]; if (j > 0) &#123; ans = min(matrix[i - 1][j - 1], ans); &#125; if (j &lt; size - 1) &#123; ans = min(matrix[i - 1][j + 1], ans); &#125; matrix[i][j] = matrix[i][j] + ans; &#125; &#125; ans = INT_MAX; for (int i = 0; i &lt; size; i++) &#123; if (ans > matrix[size - 1][i]) &#123; ans = matrix[size - 1][i]; &#125; &#125; return ans; &#125;&#125;; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"}]},{"title":"70. Climbing Stairs","slug":"coding/leetcode/Easy/70-Climbing-Stairs","date":"2024-01-18T09:18:48.000Z","updated":"2024-01-18T10:02:21.516Z","comments":true,"path":"coding/leetcode/Easy/70-Climbing-Stairs/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/70-Climbing-Stairs/","excerpt":"","text":"⭐️ # 題目敘述 You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? # Example 1 Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1 step + 1 step 2 steps # Example 2 Input: n = 3 Output: 3 Explanation: There are three ways to climb to the top. 1 step + 1 step + 1 step 1 step + 2 steps 2 steps + 1 step # 解題思路 利用 DP 來解決: DP 是一種動態編程，我們解決第一個小問題，然後當我們處理下一個問題或下一步時，我們只需使用先前計算的值，就可以求出答案。 先初始化陣列，爬 0 層樓梯只有一個方法，爬 1 層也只有一個方法。 接下來，爬 2 層就可以有 2 種 1 step + 1 step 2 step 爬 3 層是 3 種 1 step + 2 step 2 step + 1 step 1 step + 1 step + 1 step 爬 4 層是 5 種 1 step + 2 step + 1 step 2 step + 1 step + 1 step 1 step + 1 step + 2 step 2 step + 2 step 1 step + 1 step + 1 step + 1 step 經過觀察，可以統整出是利用最後兩個數值相加求解，如同: F (n) = F (n - 1) + F (n - 2)。 # Solution class Solution &#123; public int climbStairs(int n) &#123; int[] arr = new int[n + 1]; arr[0] = 1; arr[1] = 1; for(int i = 2; i &lt;= n; i++)&#123; arr[i] = arr[i-1] + arr[i-2]; &#125; return arr[n]; &#125;&#125; class Solution &#123;public: int climbStairs(int n) &#123; int arr[n + 1]; arr[0] = 1; arr[1] = 1; for(int i = 2; i &lt;= n; i++)&#123; arr[i] = arr[i-1] + arr[i-2]; &#125; return arr[n]; &#125;&#125;; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Memoization","slug":"Memoization","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Memoization/"},{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"}]},{"title":"380. Insert Delete GetRandom O(1)","slug":"coding/leetcode/Medium/380-Insert-Delete-GetRandom-O-1","date":"2024-01-16T03:05:44.000Z","updated":"2024-01-18T09:20:37.502Z","comments":true,"path":"coding/leetcode/Medium/380-Insert-Delete-GetRandom-O-1/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/380-Insert-Delete-GetRandom-O-1/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Implement the RandomizedSet class: RandomizedSet() Initializes the RandomizedSet object. bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise. bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise. int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned. You must implement the functions of the class such that each function works in average O(1) time complexity. # Example 1 Input [&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;] [[], [1], [2], [2], [], [1], [2], []] Output [null, true, false, true, 2, true, false, 2] Explanation RandomizedSet randomizedSet = new RandomizedSet(); randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully. randomizedSet.remove(2); // Returns false as 2 does not exist in the set. randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2]. randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly. randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2]. randomizedSet.insert(2); // 2 was already in the set, so return false. randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2. # 解題思路 # Solution import java.util.HashSet;import java.util.Iterator;import java.util.Random;import java.util.Set;class RandomizedSet &#123; Set&lt;Integer> set; public RandomizedSet() &#123; set = new HashSet&lt;>(); &#125; public boolean insert(int val) &#123; if (set.contains(val)) &#123; return false; &#125; set.add(val); return true; &#125; public boolean remove(int val) &#123; if (set.contains(val)) &#123; set.remove(val); return true; &#125; return false; &#125; public int getRandom() &#123; Random rand = new Random(); int randNum = rand.nextInt(set.size()); int i = 0; for (Iterator&lt;Integer> it = set.iterator(); it.hasNext();) &#123; Integer num = it.next(); if(i == randNum)&#123; return (int) num; &#125; i++; &#125; return 0; &#125;&#125;/** * Your RandomizedSet object will be instantiated and called as such: * RandomizedSet obj = new RandomizedSet(); * boolean param_1 = obj.insert(val); * boolean param_2 = obj.remove(val); * int param_3 = obj.getRandom(); */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"},{"name":"Design","slug":"Design","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Design/"},{"name":"Randomized","slug":"Randomized","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Randomized/"}]},{"title":"2225. Find Players With Zero or One Losses","slug":"coding/leetcode/Medium/2225-Find-Players-With-Zero-or-One-Losses","date":"2024-01-15T03:35:46.000Z","updated":"2024-01-15T06:20:17.422Z","comments":true,"path":"coding/leetcode/Medium/2225-Find-Players-With-Zero-or-One-Losses/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2225-Find-Players-With-Zero-or-One-Losses/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match. Return a list answer of size 2 where: answer[0] is a list of all players that have not lost any matches. answer[1] is a list of all players that have lost exactly one match. The values in the two lists should be returned in increasing order. Note: You should only consider the players that have played at least one match. The testcases will be generated such that no two matches will have the same outcome. # Example 1 Input: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]] Output: [[1,2,10],[4,5,7,8]] Explanation: Players 1, 2, and 10 have not lost any matches. Players 4, 5, 7, and 8 each have lost one match. Players 3, 6, and 9 each have lost two matches. Thus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8]. # Example 2 Input: matches = [[2,3],[1,3],[5,4],[6,4]] Output: [[1,2,5,6],[]] Explanation: Players 1, 2, 5, and 6 have not lost any matches. Players 3 and 4 each have lost two matches. Thus, answer[0] = [1,2,5,6] and answer[1] = []. # 解題思路 # Solution import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;class Solution &#123; public List&lt;List&lt;Integer>> findWinners(int[][] matches) &#123; List&lt;List&lt;Integer>> ans = new ArrayList&lt;>(); List&lt;Integer> noLost = new ArrayList&lt;>(); List&lt;Integer> oneLost = new ArrayList&lt;>(); Map&lt;Integer, Integer> map = new HashMap&lt;>(); for(int[] matche : matches)&#123; if(!map.containsKey(matche[0]))&#123; map.put(matche[0], 0); &#125; if(!map.containsKey(matche[1]))&#123; map.put(matche[1], 1); &#125;else if(map.get(matche[1]) == 0)&#123; map.put(matche[1], 1); &#125;else&#123; map.put(matche[1], 2); &#125; &#125; for(int m : map.keySet())&#123; if(map.get(m) == 0)&#123; noLost.add(m); &#125;else if(map.get(m) == 1)&#123; oneLost.add(m); &#125; &#125; Collections.sort(noLost); Collections.sort(oneLost); ans.add(noLost); ans.add(oneLost); return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Counting","slug":"Counting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Counting/"}]},{"title":"1657. Determine if Two Strings Are Close","slug":"coding/leetcode/Medium/1657-Determine-if-Two-Strings-Are-Close","date":"2024-01-14T03:59:52.000Z","updated":"2024-01-14T06:48:37.826Z","comments":true,"path":"coding/leetcode/Medium/1657-Determine-if-Two-Strings-Are-Close/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1657-Determine-if-Two-Strings-Are-Close/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Two strings are considered close if you can attain one from the other using the following operations: Operation 1: Swap any two existing characters. For example, abcde -&gt; aecdb Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character. For example, aacabb -&gt; bbcbaa (all a 's turn into b 's, and all b 's turn into a 's) You can use the operations on either string as many times as necessary. Given two strings, word1 and word2 , return true if word1 and word2 are close, and false otherwise. # Example 1 Input: word1 = &quot;abc&quot;, word2 = &quot;bca&quot; Output: true Explanation: You can attain word2 from word1 in 2 operations. Apply Operation 1: &quot;abc&quot; -&gt; &quot;acb&quot; Apply Operation 1: &quot;acb&quot; -&gt; &quot;bca&quot; # Example 2 Input: word1 = &quot;a&quot;, word2 = &quot;aa&quot; Output: false Explanation: It is impossible to attain word2 from word1, or vice versa, in any number of operations. # Example 3 Input: word1 = &quot;cabbba&quot;, word2 = &quot;abbccc&quot; Output: true Explanation: You can attain word2 from word1 in 3 operations. Apply Operation 1: &quot;cabbba&quot; -&gt; &quot;caabbb&quot; Apply Operation 2: &quot;caabbb&quot; -&gt; &quot;baaccc&quot; Apply Operation 2: &quot;baaccc&quot; -&gt; &quot;abbccc&quot; # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public boolean closeStrings(String word1, String word2) &#123; int[] freq1 = new int[26]; int[] freq2 = new int[26]; for (char ch : word1.toCharArray()) &#123; freq1[ch - 'a']++; &#125; for (char ch : word2.toCharArray()) &#123; freq2[ch - 'a']++; &#125; for (int i = 0; i &lt; 26; i++) &#123; if ((freq1[i] == 0 &amp;&amp; freq2[i] != 0) || (freq1[i] != 0 &amp;&amp; freq2[i] == 0)) &#123; return false; &#125; &#125; Arrays.sort(freq1); Arrays.sort(freq2); for (int i = 0; i &lt; 26; i++) &#123; if (freq1[i] != freq2[i]) &#123; return false; &#125; &#125; return true; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Counting","slug":"Counting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Counting/"}]},{"title":"1347. Minimum Number of Steps to Make Two Strings Anagram","slug":"coding/leetcode/Medium/1347-Minimum-Number-of-Steps-to-Make-Two-Strings-Anagram","date":"2024-01-13T03:15:52.000Z","updated":"2024-01-13T16:01:13.201Z","comments":true,"path":"coding/leetcode/Medium/1347-Minimum-Number-of-Steps-to-Make-Two-Strings-Anagram/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1347-Minimum-Number-of-Steps-to-Make-Two-Strings-Anagram/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given two strings of the same length s and t . In one step you can choose any character of t and replace it with another character. Return the minimum number of steps to make t an anagram of s . An Anagram of a string is a string that contains the same characters with a different (or the same) ordering. # Example 1 Input: s = &quot;bab&quot;, t = &quot;aba&quot; Output: 1 Explanation: Replace the first 'a' in t with b, t = &quot;bba&quot; which is anagram of s. # Example 2 Input: s = &quot;leetcode&quot;, t = &quot;practice&quot; Output: 5 Explanation: Replace 'p', 'r', 'a', 'i' and 'c' from t with proper characters to make t anagram of s. # Example 3 Input: s = &quot;anagram&quot;, t = &quot;mangaar&quot; Output: 0 Explanation: &quot;anagram&quot; and &quot;mangaar&quot; are anagrams. # 解題思路 # Solution public class Solution &#123; public int minSteps(String s, String t) &#123; int[] countS = new int[26]; int[] countT = new int[26]; for (char ch : s.toCharArray()) &#123; countS[ch - 'a']++; &#125; for (char ch : t.toCharArray()) &#123; countT[ch - 'a']++; &#125; int steps = 0; for (int i = 0; i &lt; 26; i++) &#123; steps += Math.abs(countS[i] - countT[i]); &#125; return steps / 2; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Counting","slug":"Counting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Counting/"}]},{"title":"AI 基礎介紹","slug":"computer-science/Artificial-Intelligence/AI-基礎介紹","date":"2024-01-12T06:21:35.000Z","updated":"2024-02-02T04:01:37.785Z","comments":true,"path":"computer-science/Artificial-Intelligence/AI-基礎介紹/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Artificial-Intelligence/AI-%E5%9F%BA%E7%A4%8E%E4%BB%8B%E7%B4%B9/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # What is AI? 能夠如同人類進行智慧處理的技術、機器 # 人工智能認知狀態 強人工智慧: 可能擁有人類的自我意識，具有超越人類的可能性 弱人工智慧: 可能會取代部分的人類能力，但沒辦法取代全部 # 人工智慧發展階段 機器學習: 進行適當的處理，就可以根據輸入資料預測數值、最佳化。 深度學習: 輸入資料不經過處理，讓電腦自己擷取特徵，來獲取最後的結果。 # 機器學習 Machine Learning 讓電腦有更高的辨識程度，需要決定要依據哪個基準 (參數) 運作。 機器學習能夠根據輸入資料，自動決定 (學習) 作為最正確的行為，之前是利用記住全部資料的記憶學習，但無法解答未知的資料。 利用大數據資料反覆訓練，讓未知的資料也能得到解答。 # 詳細程序 電腦接收輸入資料，使用學習模型輸出運算結果。 學習模型訓練的過程中，會去比較預期的輸出 (標籤、監督訊號) 與學習模型的運算結果，來修正學習模型。 經過反覆修正後，完成學習模型，將最後的模型保存，結束學習的處理。 # 處理的問題 可以分成兩類: 分類: 找出資料在哪個類別，分成一個個群組，無視群組的細微差異。例如：貓和狗是兩個不同群組。 迴歸: 發掘資料傾向，把資料認為是一個群組，比較組內差異。例如：年紀可以由長到幼。 # 基本工作程序 整體設計 將問題轉為公式 設計系統 蒐集資料 機器學習的設計 選擇機器學習的演算法 資料變形與特徵工程 模型的學習 驗證與評估預測結果 調整超參數 運用 系統的運用 # 監督式學習 Supervised learning 將輸入資料做一些標籤，並利用已知答案的資料進行訓練，學習模型會依據已知答案的資料去比對自己的回答是否正確，做一些調整，直到訓練完成。 # 非監督式學習 Unsupervised learning 不對資料進行標示，由機器自己去對每個資料捕捉資料特徵，重點在於學習資料本身的特徵。 # 強化學習 沒有特別明確的解答，以一些報酬描述該動作的優劣，使機器選擇高報酬的動作，重點是學習最佳的動作。 # 深度學習 Deep Learning 深度學習是指利用模仿大腦神經網路的類神經網路學習模型的機器學習，由輸入層與輸出層之間的「隱藏層」增加深度，能夠自動擷取最佳特徵量。 隱藏層: 將輸入層接收的資料以各種方式傳遞下去，最後轉為有助於輸出層的形式。 # Machine Learning vs. Deep Learning 深度學習也是機器學習的一種，但不同的地方在於，不是由人類加工輸入資料，幫助學習模型推出答案，而是學習模型自行擷取「特徵量」來學習。 原來機器學習的瓶頸在於，我們人類關注到的特徵未必與電腦的特徵相同，或是無法描述精確到位，使電腦比較難回答準確、細微答案，如：我們人類其時很難準確描述聲音 A 與 聲音 B 得區別。 舉🌰: 如果是要分辨狗與貓 機器學習的輸入資料我們就需要為它標註，哪類是狗，哪類是貓。 深度學習擇是我們直接將原生資料給它，不加以描述，自行擷取特徵。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Artificial-Intelligence","slug":"computer-science/Artificial-Intelligence","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Artificial-Intelligence/"}],"tags":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Deep-Learning/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Machine-Learning/"}]},{"title":"1704. Determine if String Halves Are Alike","slug":"coding/leetcode/Easy/1704-Determine-if-String-Halves-Are-Alike","date":"2024-01-12T05:56:09.000Z","updated":"2024-01-12T06:07:42.592Z","comments":true,"path":"coding/leetcode/Easy/1704-Determine-if-String-Halves-Are-Alike/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1704-Determine-if-String-Halves-Are-Alike/","excerpt":"","text":"⭐️ # 題目敘述 You are given a string s of even length. Split this string into two halves of equal lengths, and let a be the first half and b be the second half. Two strings are alike if they have the same number of vowels ( 'a' , 'e' , 'i' , 'o' , 'u' , 'A' , 'E' , 'I' , 'O' , 'U' ). Notice that s contains uppercase and lowercase letters. Return true if a and b are alike. Otherwise, return false . # Example 1 Input: s = &quot;book&quot; Output: true Explanation: a = &quot;bo&quot; and b = &quot;ok&quot;. a has 1 vowel and b has 1 vowel. Therefore, they are alike. # Example 2 Input: s = &quot;textbook&quot; Output: false Explanation: a = &quot;text&quot; and b = &quot;book&quot;. a has 1 vowel whereas b has 2. Therefore, they are not alike. Notice that the vowel o is counted twice. # 解題思路 # Solution class Solution &#123; public boolean halvesAreAlike(String s) &#123; if(s.length() % 2 != 0)&#123; return false; &#125; int subLen = s.length() / 2; String a = s.substring(0, subLen); String b = s.substring(subLen, s.length()); a = a.replaceAll(\"[aeiouAEIOU]\", \"\"); b = b.replaceAll(\"[aeiouAEIOU]\", \"\"); return a.length() == b.length(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Counting","slug":"Counting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Counting/"}]},{"title":"麻將 AI 對局","slug":"computer-science/Artificial-Intelligence/麻將對局","date":"2024-01-11T14:30:41.000Z","updated":"2024-02-14T09:53:32.226Z","comments":true,"path":"computer-science/Artificial-Intelligence/麻將對局/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Artificial-Intelligence/%E9%BA%BB%E5%B0%87%E5%B0%8D%E5%B1%80/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 前言 這是一份關於計畫的紀錄，由我的指導教授與學長提供的資料開始進行研究，主要是要撰寫一個基於深度學習與強化學習麻將對局的程式，希望可以寫出一個臺灣麻將與日本麻將。 # 參考論文 應用深度學習與強化學習於臺灣麻將對局程式之研究 Research on Applying Deepp Learning and Reinforcement Learning to Taiwanese Mahjong Program 指導教授：黃國展 撰寫者：陳昕斈 # 麻將研究摘要 麻將是一個多人不完美信息遊戲，使整場遊戲隨機性高而複雜，提供許多不確定性，如：隱藏信息、偶然性、同時移動。 日本麻將已經引入深度神經網路，如: Microsoft Suphx，但臺灣大多基於傳統啟發方式或遊戲樹搜尋方法，因此由我學長開啟研究，而我接續下去。 學長的研究 基於神經網路模型，評估三種作法: 監督式學習 強化式學習 神經網路模型與蒙地卡羅模擬相結合的整合式方法 實驗結果: 深度強化學習比起單純監督式學習能夠有更好的性能，但仍然無法與傳統的樹搜尋方法相比，因此直接用深度神經網路模型取代傳統搜尋數方法（如: Expectimax 和蒙地卡羅模擬）不好。 整合式比較可行，將深度神經網路模型，應用於有效引導搜尋樹的過程。 麻將對接平臺 日本麻將：天鳳 臺灣麻將：交通大學提供的伺服器平臺 知名麻將程式 日本麻將 微軟麻將 AI「Microsoft Suphx」（Super Phoenix） 臺灣麻將 Rowlet VeryLongCat SimCat FatesGate Seofon_v2 # Introduction # 策略選擇臺灣麻將 vs. 日本麻將 日本麻將規則更加複雜，包含很多小規則與細節，注重策略與技巧，需要更深入的思考、運用牌紀、記憶力、策略以及靈活的頭腦。 臺灣麻將風格更加迅速和競爭，注重胡牌和計分，要積極的態度與競爭心。 最佳的贏法: 日本麻將: 希望可以胡較大的番數，獲得較多的分數，較不注重自摸 不會特別希望是自摸，因為算分方式是，自己依舊獲得 胡牌番數的分數，而其他人扣除 胡牌番數的分數 / 3 的分數 因為上述規則，對手需要更加去思考，盡量丟出不讓你胡牌的牌，讓自己就算沒有獲勝，也不會損失太多或是流局 臺灣麻將: 比較不注重番數，因為自摸效益更大，更希望可以自摸 自摸的分數計算方式是，自己可以獲得 胡牌臺數的分數 * 3，而其他人扣除 胡牌臺數的分數 因為上規則，會更希望快速組成牌組，期望可以自摸，更以快速獲勝的方式，來減少放槍的機率，從而不注重胡牌番數 臺灣麻將的策略導向是：追求快速獲勝，試圖找到最快的贏牌策略，以取代可能由於丟棄一張滿足其他玩家贏牌條件的牌而帶來的潛在負面影響，玩家傾向於將個人成功置於丟棄可能使對手受益的牌所帶來的損失之上。 # 技術概述 相比較其他臺灣麻將程式（依賴啟發式方法、樹搜尋方法、模擬方法），研究把監督式深度學習和強化式學習引入的潛力。 基於 Suphx &amp; 卷積神經網絡。 整合了由深度強化學習訓練的神經網絡模型，以及 SimCat 提出的 flatMC 模擬方法。 神經網絡模型在模擬過程中有效地過濾和選擇樹節點，減少了無效模擬的次數。 # Background and Related Works # 臺灣麻將比賽 每年有三次比賽，分別由三個不同的學術組織主辦: 臺灣電腦遊戲協會 （TCGA，Taiwan Computer Game Association） 臺灣人工智慧協會 （TAAI，Technologies and Applications of Artificial Intelligence） 國際電腦遊戲協會 （ICGA，International Computer Games Association） 比賽規則三個相同。 四名玩家共參加 384 輪比賽，不考慮連勝，以最終得分決定勝負。 計分系統為獲勝玩家分配 1000 分的基本分，每個獎勵積分提供 500 分。 獎勵積分算法: 案例 獎金積分 說明 莊家 1 做莊家者，獲勝多算一分，其他人獲勝也多算一分 門清 1 胡牌時，沒有吃牌、碰牌、明槓 自摸 1 胡牌的牌由自己摸進 斷么九 1 沒有一、九或東、南、西、北、白板、發財、紅中的情況下獲勝 海底撈月 1 摸牌牆最後一張牌，在流局前，而自摸者多計一臺，因摸到槓牌造成其結果為最後一張牌時，亦以海底撈月計之 門風刻 1 拿自己所屬的風位的刻子，以開門為東風逆時針依序為東、南、西、北 三元牌 1 中、發、白任一個刻子 雙龍袍 1 在一個牌局中，有兩個相同花色的序數，如：一萬兩萬三萬有兩組 槓上開花 1 因摸到暗槓或加槓而補牌，補牌後恰巧胡牌 搶槓 1 聽牌時，因別人加槓而加槓那張牌，恰巧是可以胡的牌 全求 2 贏牌時只剩下一張對子，其餘牌均為吃牌、碰牌或槓牌 平胡 2 只用序數牌獲勝，不使用碰牌、槓牌或是字牌，也不能為獨聽或自摸 混帶么 2 所有的順子、刻子和眼睛都至少有一張一、九或字牌 三色同順 2 以三個相同順序的順子取勝，每個順子來自不同款式，如果手牌完全隱藏，則獲得雙倍積分（4 分） 一條龍 2 以一種花色的完整順字（從 1 到 9）取勝，如果手牌完全隱藏，則獲得雙倍積分（4 分） 雙雙龍抱 2 以兩對有兩個相同花色的序數取勝，如：一萬、兩萬、三萬有兩組和五筒、六筒、七筒有兩組 三暗刻 2 有三個暗藏的刻子，包括暗槓 三色同刻 2 以三個相同數字的刻子或是槓取勝，每個序列來自不同款式 門清自摸 3 以全暗手和自摸取勝 碰碰胡 4 以全部刻子和槓取勝 混一色 4 手牌中除字牌外僅有一種花色牌 純帶么 4 所有的順子、刻子和眼睛都至少有一張一、九 混老頭 4 牌面中只有一、九和字牌所組成，所以不可能有順子，不計碰碰胡 小三元 4 擁有中、白、發，任組成 2 組刻子（三張相同）和 1 組眼睛（兩張相同）之牌型 四暗刻 6 指 4 組暗刻或暗槓組成的胡牌 四槓子 6 胡牌只需要 4 個暗槓加上 1 個眼睛，所以胡牌時是 4 * 4 + 2 = 18 張牌 大三元 8 胡牌時有中、發、白三元牌，三副刻子的情況 小四喜 8 胡牌時有「風牌」的三副刻子及眼睛 清一色 8 由一種花色的序數排組成的牌型 字一色 8 胡牌完全由字牌「東、南、西、北、中、發、白」所組成 五暗刻 8 胡牌時手中有五副刻子，包括暗槓，計碰碰胡 清老頭 8 牌面中只有一、九所組成，所以不可能有順子，不計碰碰胡 大四喜 16 胡牌時有四副「風刻」組成的牌 天胡 16 只適用於莊家，當莊家在牌局第一輪抓完後立即胡牌，不計門清、自摸、獨聽、槓上開花，其餘另計 地胡 16 適用於莊家之外其他玩家，在第一輪抓玩牌就自模，不計自摸、門清、不求人，其餘另計 人胡 16 牌局一開始，第一輪內還沒摸牌前，沒有發生吃、碰、槓的情況就胡他人的牌，不另計門清之外，其餘都另計 特殊隨機規則: 為減少麻將中隨機性帶來的運氣影響，每組牌要打四輪，由四位玩家輪流進行，這樣可以確保每位玩家至少有一次獲得同一套牌的機會。 違例規則: 每個動作無論是打牌還是摸牌，都有三秒時間限制，如果玩家超過這一個時間限制，將受到懲罰，不可以在該回合中做任何選擇，具體如下: 他的所有棄牌將被隨機決定。 他的吃牌、碰牌、槓牌會被跳過。 這種懲罰會阻止玩家獲勝，也會增加其他玩家獲勝的機會，所以避免超過時限至關重要。 # 比賽規則 與傳統臺灣麻將規則相似，但是沒有花牌規則。 由坐在方桌四個方向的四名玩家進行遊戲，對特定玩家而言，坐在其右邊的玩家稱為下家，左邊的玩家稱為上家，對面的玩家稱為對家。 臺灣麻將總共使用 136 張牌，由 34 張不同牌各四張組成。 分成 3 種花色與 7 種特殊牌: 一萬～九萬: ![Imgur]（https://i.imgur.com/P2PSCZi.png） 一筒～九筒: ![Imgur]（https://i.imgur.com/ZXiWekT.png） 一條～九條: ![Imgur]（https://i.imgur.com/SXoCvif.png） 字牌：東、南、西、北、白板、發財、紅中 ！[Imgur]（https://i.imgur.com/HIz257H.png） 開局前布置 每輪開始都會先建造牌牆，牌牆的牌面朝下堆疊，認了玩家都不知道最初牌的信息。 堆疊方式是總共有 4 堆，每一堆由 2 個牌疊一起為單位，有 17 個，四堆最後會在四名玩家前面呈現正方形排列。 開局摸牌 每位玩家開局會先抽 16 張牌作為起手牌，起手牌由莊家擲 3 個骰子，用骰子決定起手牌的抽取位置。 從摸牌的位置開始，玩家由逆時針方向輪流摸牌，直到他們手中牌集滿 16 張為止，牌牆則按順時針方向抽取。 開始遊玩 每輪遊戲，四名玩家按逆時針方向輪流進行摸牌和打牌，抽到的牌為玩家的一部分，屬於玩家的私人信息，打牌則是從玩家手中選一張牌丟掉，成為公開信息。 其他動作: 除了上述的摸牌和打牌的動作，還有以下幾種: 打牌: 把你不要的牌支打進海底，就叫做「打牌」。 摸牌: 上家打牌後，無吃、碰 （ 不可明槓上家出的牌，因此不考慮槓的情形 ） 時，就可以再摸一張牌，就叫做「摸牌」。 吃牌: 當牌的組合無法自摸獲得時，可拿上家丟出來的牌來組成順子，公開表示放於自己左邊。 碰牌: 當你手中有兩支牌和別人打出的牌相同時，就可叫「碰」，又稱為「碰牌」。 槓牌: 明槓、暗槓、加槓 明槓: 他家打牌之後，如果你手上有三張跟那被打出的牌支一樣的，就可以「槓牌」，這種槓牌叫做「明槓」 。此外，上家出的牌不可用來明槓。 暗槓: 如果是手內摸有四張相同的牌，取出槓牌，則叫做「暗槓」 加槓: 如果是已經碰牌了，卻又再摸入一張相同的牌支，也可以叫槓牌 — 這種槓牌叫作「加槓」 打牌是公開於牌池，摸牌則是不公開放置於自己抽的牌中。 上述的吃牌、碰牌、明槓、加槓，都是公開的訊息，應置於自己抽牌的前面，而暗槓的牌是不公開的，但也應該置於自己抽牌的前面。 當摸牌、吃牌、碰牌後，都需要打牌，在輪到下一位玩家繼續遊戲，如過是三種槓牌，都需要在牌牆末端抽一張牌，後再打牌。 每位玩家依照順序，直至牌牆只剩下 16 張牌為止，若沒有贏家，表示該局和局，若在這之前有人達到胡牌條件，表示他為這場獲勝者。 胡牌條件: 胡牌是要將自己手上的 16 張 ＋ 1 張新摸進來的牌湊出 5 組對子跟 1 對眼睛。 對子可以分成: 順子: 同花色接續的數字，例如 345 萬、123 條、789 筒。 刻子: 相同數字花色，例如：三張 1 筒、三張東風牌、三張紅中牌、三張 2 萬。 眼睛是指: 兩張同花色相同數字的牌，例如兩張西風、兩張白皮、兩張 9 條。 胡牌又可分成兩種: 自摸: 如果是自己摸進來的牌而湊齊，則稱為「自摸」，則其他三家皆輸。 放槍: 如果是因為其他玩家丟出的牌而湊齊，則丟牌的人稱為「放槍」，只有丟牌即放槍者算輸。 計算分數是在胡牌之後進行的，由兩個規則決定分數：基本規則和獎勵規則。 基本規則: 決定了只需獲勝就可以獲得的基本分數。 獎勵規則: 在滿足某些特殊條件時，可以累積額外的分數。 獲勝牌局的最終得分是通過基本規則和獎勵規則獲得總分，計算出獲勝牌局的分數後，在不是自摸的情況下，只有放槍的玩家需要支付給獲勝的玩家，在自摸的情況下，所有玩家都需要向獲勝玩家支付點數，因此自摸利潤相當於非自摸的三倍。 # 近期比賽中的臺灣麻將人工智慧程式 # VeryLongCat 介紹 是國立陽明交通大學開發的，在 2020 年、2021 年 TCGA、2021 年、2022 年 TAAI 和 2022 年 ICGA 比賽中獲得冠軍。 在其他未獲得冠軍的比賽中，也保持著前三名，可以說是近年來臺灣麻將的霸主。 技術 VeryLongCat 是利用 Expectimax 搜索演算法建構一個搜索深度為 n 的樹，目的是找到獲勝期望值最高的棄牌候選者。 n 值通常根據 MTW 或 MTW 加 1 的數量確定。 樹擴展過程中的每一步都包括兩個階段：抽牌和棄牌。 在抽牌階段，從某個節點擴展出的子節點代表所有可能的抽牌結果，即牌牆中剩餘的牌型。 如果子節點的手牌符合獲勝條件，則返回值為 1。 如果為滿足獲勝條件，樹會繼續擴展，值到達到預定深度 n，此時如果仍未滿獲勝條件，返回值為 0。 在棄牌階段，從一個節點擴展出的子節點代表所有棄牌選擇，即玩家手中的不同牌型。樹形擴展階段結束後，返回階段開始，每個子節點的返回值是所獲得的返回值與從牌池中抽出該張牌的概率乘積。 最後，將選擇期望值的最高棄牌候選者進行操作。 潛在的問題 儘管 VeryLongCat 證明了 Expectimax 搜尋演算法的有效性，但他面臨著另一個挑戰，即無法在歸地時間內完成擴展，結果將不是完整的。 這就限制了 Expectimax 搜尋演算法在時間有限的比賽中的適用性。 因此在存在單張牌（即在數值或花色上，範圍在正負兩之內沒有其他相符的牌）時避免使用 Expectimax 搜尋算法。 # SimCat 介紹 國立陽明交通大學開發的另一個臺灣麻將程式。 在 2020 年 TAAI 、2020 年 ICGA 比賽中獲得冠軍，2023 年 TCGA、2021 年 TAAI、2021 年、2022 年 ICGA 比賽中獲得亞軍。 技術 SimCat 引入了 Flat Monte Carlo（flatMC），以確定勝率最高的行動。 FlatMC 的配置如下，𝑚 和 𝑛 兩個參數，𝑚 代表單次模擬的深度，而 𝑛 是模擬的次數。 FLatMC 是蒙地卡羅模擬（MCS）的一種，是一種常用於解決難以分析處理問題的統計方法，通過隨機抽樣生成大量樣本，並對這些樣本進行分析，以解決問題。 蒙特卡羅模擬（MCS）具有廣泛的應用，常見於數學、科學、經濟和工程領域。它也被廣泛應用於遊戲程序中。 在 SimCat 的 FlatMC 中，首先識別潛在的出牌選擇，每個可能的出牌都會進行 𝑛 次模擬。在深度為 𝑚 的模擬中，記錄成功完成的次數（即贏得局面的次數）。獲勝次數最多的行動被視為勝率最高。 在每次模擬中，玩家最多可以抽取 𝑚 張牌，由變數 𝑖 表示，範圍從 0 到 𝑚 。 因此，模擬過程中維護一個狀態變數 𝑆𝑖，表示第 𝑖 次抽牌後的狀態，其中包含至少一套手牌信息。𝑆0 表示初始手牌。 在每次模擬中，從牌池中抽取四張牌，分別為 𝑡𝑙、𝑡𝑂、𝑡𝑈 和 𝑡𝐶。前三張牌 𝑡𝑙、𝑡𝑂、𝑡𝑈 分別代表玩家左對手、對面對手和右對手的出牌，而 𝑡𝐶 代表玩家抽到的牌。 如果玩家的當前手牌，加上 𝑡𝑙、𝑡𝑂、𝑡𝑈，滿足贏牌的條件，則呼叫後更新的手牌被儲存在 𝑆𝑖+1 中。 𝑆𝑖+1 也儲存了玩家在抽牌 𝑡𝐶 後的手牌。模擬僅檢查 𝑆𝑖 中的每一手牌是否滿足贏牌的條件，而不考慮出牌。 如果在 𝑖 超過 𝑚 後未達成贏牌手牌，則認為模擬失敗，勝利次數保持不變。 SimCat 還處理了多餘塊的情境，將兩張牌綁在一起並在進行額外深度為 𝑚 + 1 的模擬之前將其丟棄。 # FatesGate 介紹 由國立台北大學開發的臺灣麻將程式。 與 VeryLongCat 和 SimCat 相比，FatesGate 是一個相對較新的臺灣麻將項目，近兩年才參加比賽。 不過也在 2022 年 TAAI 獲得亞軍、2022 年 ICGA 獲得季軍，表現也相當不錯。 技術 與 SimCat 相似，他主要利用蒙地卡羅模擬（MCS），並採用基於規則的方法來減少棄牌候選者，並盡量減少無效模擬。 FatesGate 引入了計算獲勝條件進度的優化方法。 在棄牌階段，他採用深度優先搜索方法（DFS）來搜索所有可能的分牌組合，考慮了對子、不完整的對子、眼和單張牌的狀態，以確定最合適的拆分方法，從而選擇有效的棄牌候選者。 如果遇到牌塊過多的情況，他還會應用額外的分配規則。 此外，FatesGate 還採用了一種防禦策略，在牌池剩餘 R 張牌時，抵禦對手的贏牌。 # Seofon_v2 介紹 由國立臺灣師範大學開發的臺灣麻將程式。 其前身 Zei 在 2020 年 TCGA、2020 年 ICGA、2020 年 TAAI 比賽獲得亞軍。 另一位前身 Seofon 則是在 2021 年 ICGA 比賽獲得冠軍，2021 年 TCGA 和 2022 TAAI 分別獲的亞軍和季軍。 而 Seofon_v2 在 2022 TAAI 比賽中獲得亞軍，進一步鞏固了他在臺灣麻將中的地位。 技術 他繼承了 Zei 和 Seofon 的方法，即利用數據庫查詢來快速確定獲勝條件的進展情況，並評估不同選擇對獲勝可能性的影響，從而找出有希望的棄牌候選者。 Seofon_v2 利用評估功能為每個棄牌候選者分配分數，並根據這些分數做出判斷。 他還加入臺灣麻將特有的策略，例如：提高獲得高分牌的概率和處理槓的概念。 設計策略是通過利用防禦招式和根據棄牌信息尋找安全牌，避免成為對手的致勝目標。 潛在的問題 Seofon_v2 主要是依靠數據庫查詢來快速確定獲勝條件的進度，並將這種方法與人類專業知識開發的規則方法相結合。 雖然這種方法能使人工智能擁有接近人類麻將玩家的技能，但他在為人工智能程式提供超越人類遊戲能力的機會相對有限。 # 日本麻將的深度強化學習 目前大多數臺灣麻將人工智慧程式依賴啟發式方法、樹搜索方法和模擬方法為主，尚未使用深度強化學習的相關方法。不過新興的深度強化學習算法已成功應用於許多其他遊戲，並取得了優於人類頂尖選手的顯著性能，如：日本麻將。 # 深度學習和強化學習 深度學習（DL）是機器學習中一個相對較新的分支，他利用深度神經網路（DNN）來解決的各種問題。 神經網路由多層組成，包括接收輸入信息的輸入層、產生輸出訊息的輸出層以及輸入輸出層之前的若干的隱藏層。 每一層都由多個神經元組成，這些神經元從上一層接收信息，經過加權求和後，每個神經元產生一個輸出。 神經網路的構造允許使用反向傳播，根據預測輸出與實驗結果之間的差異自動調整神經網路的權重。 DNN 通常是指具有更多隱藏層的神經網路，這樣可以更有效地學習輸入數據中包含的基本信息，從而提高性能。 與需要專家知識進行特徵提取的傳統機器學習方法相比，DL 通過反向傳播算法實現了自動特徵學習。 雖然 DL 通常需要更多計算，但隨著近年來 GPU 技術的成熟，這些重大挑戰已得到解決。 因此，人們提出了各種 DNN 模型來解決不同應用領域的機器學習問題。 例如：卷積神經網路 (CNN) 通過卷積運算用於圖像分析中的特徵提取、遞歸神經網路 (RNN) 能夠處理序列信息並捕捉序列中元素之間的關係。 除了 DL 外，之前一些關於遊戲人工智慧的研究還將 DL 與強化學習 (RL) 結合起來，這一領域現在被稱為深度強化學習 (Deep Reinforement Learning，DRL)，以進一步提高遊戲性能。 監督式學習、非監督式學習和強化學習是機器學習的三大分支。 強化式學習不同於監督式學習無需對資料進行標記。 非監督式學習主要專注於解決聚類分析、關聯規則和維度縮減的問題。 強化學習則主要關注決策問題，研究智能代理如何在環進中採取最優的行動，以最大限度的提高積累獎金的概念。 強化式學習的基本框架，由五個部分組成：代理、環境、狀態、行動和獎勵。 在強化學習中，代理通過與環境的交互作用進行迭代學習。 在環境的每個狀態下，代理都會根據狀態信息和決策決定下一步行動。 然後，環境根據所採取的行動更新狀態，並向代理提供獎勵。 強化學習以模型學習的目標能夠被劃分成兩大類: Model-based 和 Model-free。 Model-based Agent 依靠學習 state 在 action 下的轉換 透過了解 environment 的運行，並透過演算法對策略進行規劃 較適用於簡單的 environment，在一些複雜的 environment 中準確性可能會較差，且 model-based 在模型的建立需要較大量的數據和計算成本 Model-Free 又能分為: Value-based 與 Policy-based。 Value-based Value-based 透過學習價值函數去估計累計獎勵，並透過此價值函數去找出最有價值的行動 常見的 Value-based 比如 Q-learning 與 Deep Q-Network 由於 Value-based 是透過價值函數去找出策略，容易在策略中忽略細節 Policy-based Policy-based 是直接讓 Agent 學習行動的策略，通常會將 action 的選擇以條件蓋率分佈呈現，並透過疊帶更新參數來更新策略 常見策略優化方法有 policy gradient 與 Proximal Policy Optimization Policy-based 直接學習策略模型更能夠去學習細節以及發現隱含的規則 比起 Value-based，在複雜的麻將遊戲中 Policy-based 更適用 這一部分感覺可以探討？ 在強化學習中，每個 State-Action Pair 的確切價值是強化學習中的一個核心概念，通常用 Q 值（動作值）表示。 Q 值表示在給定狀態 s 下，執行動作 a 的預期累積回報。 具體而言，對於每個狀態 s 和每個可能的動作 a，都有一個對應的 Q 值，記為 Q (s, a)。 確切的 Q 值取決於環境的動態特性和回報，而這些信息在開始時通常是未知的。 強化學習的目標之一是通過與環境的交互學習這些 Q 值。 主要有兩種方法來進行這種學習： Model-Based Methods： 透過建立對環境的模型，學習模型的動態特性和回報，進而計算確切的 Q 值。然後，代理（學習系統）可以使用這些 Q 值來做出最佳的動作選擇。 Model-Free Methods： 不建立對環境的明確模型，而是通過與環境的交互，使用試錯法來逼近 Q 值。其中，著名的方法包括 Q 學習（Q-Learning）和深度 Q 網絡（Deep Q Network, DQN）。 深度強化學習已被廣泛應用於各個領域，特別是在遊戲方面，它往往能取得最先進的性能，這方面的例子包括 AlphaGo，以及後來的 AlphaGo Zero、AlphaZero 和 MuZero 等模型，他們都是深度強化學習的著名應用。 MuZero 的特點是能夠自動學習環境模型，這種能力對於具有複雜事件和交互的畫面遊戲來說非常有利，因為再此類遊戲中，環境模型很難建立，或者模擬環境需要大量計算，不過傳統的策略遊戲來說，這種能力並不是必需的。 傳統遊戲，如：國際象棋，可以輕鬆建構和模擬環境模型遊戲規則，對於這些策略遊戲，AlphaZero 可能是一個更適合的框架。 # AlphaZero 作為遊戲的通用學習算法 AlphaZero 是 DeepMind 於 2018 年提出的一種深度強化學習方法 (Deep Reinforcement learning Method)，AlphaZero 延續並優化了 AlphaGo Zero 的作法並且增加其通用性使其能應用於更多的領域比如說象棋或將棋。。 AlphaZero 使用的主要技術包括 DCNN (Deep Convolutional Neural Network，深度卷積神經網路)、MCTS (Monte Carlo Tree Search，蒙地卡羅樹搜尋) 和 RL (Reinforcement Learning，強化學習)。 採用 DCNN 對策略函數（Policy Function）和價值函數（Value Function）進行建模 策略函數定義了在給定狀態下選擇每個可能動作的概率分佈 價值函數衡量了在某個狀態下執行動作的長期回報期望值。 DCNN 模型用於輔助 MCTS 的應用。 使用深度卷積神經網絡（DCNN）等深度學習模型來逼近真實的策略函數或價值函數。 這些函數通常是未知的，因為在面對複雜的環境時，我們無法直接知道在每個狀態下應該選擇哪個動作，或者每個 State-Action Pair 的確切價值是多少。 MCTS 是 MCS 的延伸，MCTS 是一個迭代的過程，包括四個階段: selection (選擇)、expansion (擴展)、simulation (模擬) 和 backpropagation (反向傳播)。 在選擇階段，DCNN 模型提供的策略函數和價值函數被用來輔助節點選擇。 在模擬階段，價值函數用於評估節點價值，即遊戲狀態。 學習參考文件 AlphaZero 利用 RL，不需要專家資料集進行監督式訓練，從零開始進行訓練，在整個訓練過程中，策略函數和價值函數會逐步改善，最終超越人類水平。 # 日本麻將 AI Suphx 以往許多關於博弈人工智能的研究都在 DL 模型中使用了 CNN。 CNN 在各種棋類遊戲 (如：國際象棋和圍棋) 中分析博弈狀態並做出有效決策方面表現出卓越的能力，這是因為棋類遊戲的結構狀態與二維圖像相對應，而二維圖像正是 CNN 所擅長的。因此，在之前關於日本麻將人工智慧的研究中心，提出了一種平面結構，將麻將遊戲狀態轉換為適合 CNN 得形式。 建議平面結構安排麻將遊戲狀態，例如：主要方法是將麻將場面資訊展開成 4 × 34 的形式，其中 34 表示所有的牌型種類，4 代表每種牌各有 4 張，這個矩陣僅會有 0 跟 1 組成，當這個種類的牌存在則會在 plane 中多填一個 1，要被填入的 1 會從上而下填入。 這個版面會用於表現單一資訊，比如手牌或某位玩家的棄牌。 而將多數的場面資訊收集下來轉換成許多 Planes 之後，便能將這些 Planes 作為 CNN 的輸入，用於深度神經網路的訓練。 Suphx 是微軟亞洲研究院開發的日本麻將人工智能。它主要架構採用了 CNN，並結合了監督式學習和強化學習技術，目前，Suphx 代表了日本麻將人工智能的最先進水平。 在監督式學習的部分，Suphx 收集了所需的資料集訓練，來源於日本麻計平台「天鳳」。 它還採用了上述平面結構作為輸入數據格式，具體來說，Suphx 將三維 N × 4 × 34 數據中的平面串聯成二維 4N × 34 格式。 它針對麻將中的五種不同動作分別訓練模型：棄牌、叫牌、碰牌、槓牌以及日本麻將規則特有的立直這五個行動都各自訓練一個模型。 在監督式學習階段之後，以強化式學習進行訓練，Suphx 在訓練中使用了擁有完整的全局資訊的 Oracle agent 來幫助日本麻將環境不易收斂的問題，完整的全局資訊包含原本無法被 Normal agent 能夠得到的資訊，並且在訓練的過程中 Oracle agent 會逐漸失去完整的全局資訊並逐漸成為 Normal agent。 此外，Suphx 提出 parametric Monte-Carlo policy adaption (pMCPA) 來解決 Monte Carlo Tree Search 無法直接適用於日本麻將的問題，pMCPA 會在開局時對於初始手牌進行模擬，並根據模擬出來的結果去調整 offline policy，讓 policy 能夠更適用於每一局的真實情況。 儘管 Suphx 取得了巨大的成功，但其所使用的資源也是非常龐大的，比如在 RL 階段中每個 agent 都訓練了 1.5 million games，並個別使用了 44 GPUs 以及兩天的時間，這導致要重現她的成功是相對困難的。 # An Integrated Approach to Taiwanese Mahjong 接下來介紹我們開發的臺灣麻將人工智能程式 Rowlet 的研究工作，該程序在 TCGA 2023 臺灣麻將比賽中獲得了冠軍。 在麻將中，主要有五個動作：棄牌、叫牌、碰牌、槓牌和胡牌。 儘管所有的動作都對最終的遊戲結果產生影響，但棄牌是最為關鍵的一個，並成為許多先前研究工作的焦點。 本論文中，也將把重點放在如何做出最佳棄牌決策上。 Rowlet 採用了一種混合方法來建構其臺灣麻將人工智能能力，它將監督式學習和強化學習與現有的常用方法 (如: flatMC) 相結合。 # 神經網路架構和輸入資料結構 在輸入表示方面，採用基於平面的方法，類似於 Suphx，利用二維資料格式。 然而，由於臺灣麻將與日本麻將在一些遊戲規則上有所不同，相應的人工智慧程式通常也會採用不同的策略。 在日本麻將中，策略通常圍繞防守戰術展開，需要解決各種問題 而臺灣麻將程式通常採用更快速的決策原則 因此，與針對日本麻將開發的 Suphx 相比，我們輸入信息相對簡單。 我們模型的輸入包括九種信息：玩家的手牌、四位玩家的棄牌和四位玩家的叫牌。 這些輸入訊息結構為 [36 × 34] 平面結構。 在我們的研究工作中，還測試了另一種更簡潔的表示方式，僅包括玩家的手牌和玩家視野之外的牌 因此具有 [8 × 34] 的結構。 我們研究中使用的神經網絡架構受到 Suphx 的啟發，採用 CNN 作為核心模型。 典型的 CNN (卷積神經網絡) 由四個部分組成: convolutional layer (卷積)、pooling layer (池化)、activation function (激活函數，線性整流單元 Rectified Linear Unit，ReLU) 和 fully connected layer (全連接層)。 Convolutional layer 是 CNN 的主要核心，通過卷積操作從輸入數據中提取特徵，它減少了參數的數量並提高了模型的性能。 Pooling layer 通過提取重要信息來減小特徵圖的大小，有效地減少計算的複雜性而不損失重要信息。 Activation function 引入非線性到模型中，通過捕捉複雜的關係，發揮了提高模型容量的關鍵作用。 Fully connected layer 通常用於 CNN 的最後幾層，它將前幾層的數據扁平化並執行最終的分類。 學習參考文件 Rowlet 中使用的神經網絡架構，該架構使用了兩種類型的核心：長度為 3 的一維核心和大小為 256 × 1 的二維核心。 輸入數據首先在卷積層中與一維核心進行卷積。 從這個操作中計算得到的狀態被記錄下來，然後後續的操作重複 50 次。 這個操作包括兩次使用一維核心的卷積，並且專注於單一維度。 在每個卷積層之後，輸出與先前記錄的狀態連接在一起。 在這個重複的操作之後，使用二維核心進行降維。 降維後的數據然後通過兩個全連接層，分別具有 1232 和 300 個節點。 最後，輸出層生成 34 個值，每個值代表播放特定牌的優先級。 較高的值表示播放相應牌的優先級較高。 # 監督式學習 與日本麻將不同，目前沒有公開可用的臺灣麻將監督式學習的數據集。 因此，我們通過以下方式自行生成數據集。 首先，我們開發了一個臺灣麻將程序，該程序使用了期望最大搜索算法來進行牌的棄牌，就像 VeryLongCat 中一樣。 然後，四個代理運行相同基於期望最大搜索的程序進行一系列遊戲，以記錄遊戲狀態和對它們所做決策的數據，作為監督式學習的數據集。 表 3.1 中顯示的手牌總數為 1,245,615。 雖然如表 3.1 所示，分佈不均勻，但它忠實地反映了在實際遊戲中更有可能棄牌榮譽牌和靠近一和九的牌。 因此，在進行監督式學習時，我們從數據集中隨機選擇了 40,000 個實例。 # 強化式學習 從前一節描述的監督式學習中訓練的神經網絡模型開始，進行了強化學習以進一步提升模型的能力。 對於第 3.1 節描述的兩種輸入數據結構，即 [36×34] 和 [8×34]。 我們在執行強化學習時選擇了 [36×34]，因為我們認為它可以提供更多的遊戲狀態信息，因此可能有助於學習複雜的策略，相較於 [8×34] 的結構。 我們選擇了 policy gradient method (策略梯度方法) 來進行強化學習。 為了解決潛在的收斂速度慢的問題，我們使用了並行處理來在每次參數更新期間盡可能增加遊戲記錄的數量。 為了在策略梯度方法中引入探索，我們使用了 softmax 函數將模型的輸出轉換為選擇動作的概率分佈。 為了防止神經網絡模型輸出玩家手中不存在的選擇，我們應用了遮罩技術來過濾掉手中不存在的牌。 在強化學習中，關於獎勵的設計，我們旨在基於快速棄牌和防守對手贏牌的原則來訓練模型。 快速棄牌原則進一步分為三個部分: 第一部分涉及在玩家獲勝時分配更大的正獎勵，因為通過贏牌來追求勝利是這個遊戲中最關鍵的規則。 第二部分考慮到探索過程中固有的隨機性，這可能使獲得贏牌手牌變得困難。為了應對這一問題，我們設計了一個基於牌組合的獎勵機制。 當玩家的牌組合增加時，給予小的正獎勵。 相反，如果牌組合減少，給予小的負獎勵。 使用較小幅度的獎勵旨在防止模型過於關注牌組合獎勵，而忽略了贏牌的最重要獎勵。 另外當玩家叫牌成功增加搭數依然會給予這個 reward 原因是雖然這個決定並不是由棄牌 model 去完成，但一個優秀的棄牌決策仍然能夠增加發生能增加搭數叫牌的可能性 此外，當由於牌組合減少而給出負獎勵時，這個負獎勵不會向後傳播到先前的動作。 我們認為牌組合的減少是此動作中的明顯錯誤，並且極有可能與先前的動作無關。 第三部分是針對延遲的贏牌手牌的負獎勵，以防止模型僅追求贏牌手牌而忽略速度，即快速贏牌原則。 具體來說，當玩家手中的一些牌與被棄的牌組成胡牌條件時，會給予小的負獎勵。 然而，這個負獎勵只在第一次檢測到時給予，同樣的我們不希望模型因為迴避這個負向 reward 而違背我們原本希望其學習的策略。 防放槍相對簡單: 當對手基於玩家的棄牌動作宣告贏牌手牌時，會給予玩家較大的負獎勵。 然而，這個負獎勵不會向後傳播到先前的動作，因為這些動作並不直接導致失敗，前面動作被假設為正確的。 # Taiwan Mahjong AI Rowlet 受到 AlphaZero 的啟發，我們的臺灣麻將 AI 程序 Rowlet 使用神經網絡模型來協助在 MCS 過程中進行選擇，其中 Simcat 的 flatMC 被採用作模擬技術，並且使用並行處理以減少計算時間。 圖 3.2 描述了 Rowlet 確定其下一步動作的過程。 Figure 3.2 Flowchart of Rowlet’s decision process after drawing 該過程始於抽牌。 然後，它檢查是否滿足贏牌條件。 在 Rowlet 的設計中，如果滿足贏牌條件，它直接選擇宣告贏牌手牌。 如果不滿足，則繼續進入下一階段，檢查手牌是否符合加槓或暗槓的條件。 當滿足加槓或暗槓的條件時，Rowlet 評估是否執行相應的操作。 在評估過程中，它分別識別執行和不執行槓操作的手牌配置，並計算每種情況下的最高贏牌機率。 最高贏牌機率的計算包括兩個步驟。 首先，諮詢神經網絡模型以選擇 K 個候選牌進行棄牌。 其次，應用修改後的 flatMC 算法來模擬這 K 個候選牌的遊戲，並確定具有最高贏牌機率的操作。 隨後，Rowlet 比較執行和不執行槓操作的最高贏牌機率，並根據比較結果決定是否繼續執行該操作。 如果執行槓操作，玩家將重新抽一張牌並回到圖 3.2 中的第一個狀態。 如果不執行，則繼續到棄牌決策階段。 圖 3.3 描述了 Rowlet 在其他玩家棄牌後如何確定其下一步動作。 Figure 3.3 Flowchart of Rowlet’s call tile decision 它涉及檢查三個條件：滿足贏牌條件，滿足碰牌條件和滿足吃牌條件。 如果滿足贏牌條件，Rowlet 直接宣告贏牌手牌。 如果滿足碰牌或吃牌的條件，過程進入決策階段，以確定是否執行相應的操作。 用於碰牌和吃牌的決策方法與用於槓牌的方法相似。 它計算最高贏牌機率，並相應地採取行動。 # Discard Decision 在棄牌決策過程中，Rowlet 採用 SimCat 的 flatMC 的改進版本，對以下兩個方面進行了修改： 檢查是否可以使用其他玩家的棄牌贏牌 對於使用其他玩家的棄牌贏牌的檢查發生在已棄牌的牌 𝑡𝐿，𝑡𝑂 和 𝑡𝑈 的模擬過程中。 Rowlet 檢查其他玩家棄牌的這些牌是否能夠有助於滿足其贏牌條件，如果條件滿足，則立即返回勝利。 檢查抽到的牌是否可用於暗槓 對於抽到的牌是否可用於暗槓的檢查處理的是當手牌 𝑆𝑖 中的一張牌 𝑠 滿足與抽到的牌 𝑡𝐶 形成暗槓的條件時的情況。 在實際遊戲中，選擇暗槓允許玩家直接抽一張額外的牌，然而，在原始的 flatMC 中，對這部分沒有給予特殊注意。 不處理暗槓可能會低估牌 𝑠 的潛在贏牌數。 為了解決這個問題，Rowlet 使用循環來重複檢查，將牌 𝑠 添加到抽到的牌 𝑡𝐶 是否滿足暗槓的條件。 每次條件滿足時，Rowlet 將 𝑠 存儲到一個新的狀態，表示下一次迭代不選擇暗槓，並將參數更新到 𝑆𝑖+1。 然後，Rowlet 從 𝑆𝑖 中移除參與暗槓的四張牌，更新 𝑡𝐶，並返回檢查階段。 OneSim 是 SimCat 的 flatMC 中單次模擬的功能，以下是 Rowlet 中使用的改進版本。 改進的贏牌條件檢查在 8~10 行，改進的暗槓檢查在 21~26 行。 通過使用 [8 x 34] 輸入結構，進行監督式學習的神經網絡來過濾棄牌的候選牌。 在模擬中，僅考慮具有更高值的前 k 個輸出。 與原始的 flatMC 相比，我們改進的 flatMC 中 𝑚 的值設置為 MTW 加一。 因為我們當直接把 𝑚 設定為 MTW 時，模型不會選擇轉牌 (放棄最快胡牌機會，但是能增加比較多進張數後的胡牌機會)。 通過將 𝑚 設置為 MTW 的總數加一，我們觀察到 flatMC 的輸出與神經網絡輸出之間的相關性，如圖 3.4 所示。 我們注意到 flatMC 所做的選擇中，絕大多數可以在神經網絡的前 5 個輸出中找到。 此外，我們觀察到，當手牌中有多個孤立的牌時，flatMC 傾向於對這些孤立的牌收斂到相似的結果。 然而，根據頂尖玩家的經驗，這些孤立的牌可能仍然存在差異，這可能在 MTW 加二次迭代後顯現。 圖 3.4 比較了神經網絡輸出的記錄序列和 flatMC 在 1,000 場比賽中的選擇，其中在 flatMC 中將 𝑚 設置為 MTW 加一，𝑛 設置為 10,000。 Figure 3.4 Comparison of flatMC and neural network outputs 在這 1,000 場比賽中，共有 10,771 手帶有孤立牌，而有 26,127 手沒有孤立牌。 在沒有孤立牌的手中，約有 92% 由 flatMC 做出的選擇可以在神經網絡的前三個輸出中找到，而神經網絡的前五個輸出涵蓋了約 98% flatMC 的選擇。 然而，在存在孤立牌的情況下，神經網絡的前三個輸出對 flatMC 選擇的覆蓋率下降到 81%，而神經網絡的前五個輸出涵蓋了 93% flatMC 的選擇。 根據上述觀察，當存在孤立牌時，Rowlet 使用基於規則的方法來篩選棄牌的候選牌。 具體而言，Rowlet 使用與 VeryLongCat 相同的方法來識別所有孤立的牌，並根據它們的等級進行優先排序，對榮譽牌和靠近一和九的牌給予更大的重視。 此外，在我們的觀察中，即使 flatMC 的選擇超出了神經網絡的前七個輸出，僅探索前五個輸出可能已足夠達到同樣好的結果。 例如，在我們的實驗中，考慮一手牌，其中的牌是 𝐶3𝐶4𝐶5𝐷4𝐷5𝐷7𝐷7𝐵2𝐵3𝐵4𝐵5𝐵6𝐵7𝐵8 ，flatMC 的選擇是 𝐵5，在神經網絡中是第六個輸出，其中所有牌的排名順序是 𝐵2, 𝐵8, 𝐷7, 𝐵3, 𝐷4, 𝐵5, 𝐵6, 𝐷5, 𝐶3, 𝐵7, 𝐵4, 𝐶5, 𝐶4。我們選擇了前十個選擇，對每個進行了模擬，使用 flatMC 進行了 𝑛 = 10,000 次模擬。 每個棄牌候選在 10,000 次模擬中實現獲勝手的次數顯示在圖 3.5 中。 可以觀察到，具有最高勝率的棄牌候選是 𝐵2, 𝐵8 和 𝐵5，其中 𝐵5 也是 flatMC 的選擇，其他兩個是神經網絡的前兩個輸出。 這三個選擇的勝率非常接近，表明僅探索神經網絡的前五個輸出可能足以實現與 flatMC 選擇相當甚至更好的性能。 實際上，根據人類玩家的經驗，𝐵2 和 𝐵8 甚至被認為比 𝐵5 更好。 雖然 𝐵5 可以通過三種可能的順序（𝐵3𝐵4，𝐵4𝐵6，𝐵6𝐵7）由下一位玩家合併，但 𝐵2 只能通過兩種可能的順序（𝐵1𝐵3，𝐵3𝐵4）由下一位玩家合併，而 𝐵8 也只能通過兩種可能的順序（𝐵6𝐵7，𝐵7𝐵9）由下一位玩家合併。 這意味著，即使是由 flatMC 生成的遊戲記錄訓練的，神經網絡的前幾個選擇有可能實現比 flatMC 更好的性能。 Figure 3.5 Comparison of top ten choices’ winning counts 基於以上實驗結果，我們最終選擇在 Rowlet 中設置 𝑘 = 5，以快速選擇前五個棄牌候選，以供 flatMC 進一步探索。 這種過濾方法顯著加快了 flatMC 的過程並節省了計算資源，因為不需要對所有的棄牌候選進行模擬。 在像 TCGA 這樣的麻將比賽中，玩家在確定每個動作時被限制為三秒。 為了獲得準確的模擬結果，增加模擬次數是必要的，但由於時間限制而具有挑戰性。 通過我們的觀察，我們發現模擬階段所需的平均時間主要受到四個因素的影響。 前兩個因素是模擬設置中的參數 n 和 m。 在這裡，n 代表對每個棄牌候選進行的總模擬次數，而 m 則代表在模擬被視為失敗之前不滿足贏牌條件的最大抽牌數。 除了這兩個參數之外，棄牌候選數量和贏牌的可能性也影響著模擬時間。 在 Rowlet 中，我們使用參數 k 從神經網絡的輸出中選擇最多前 k 個有前途的候選者進行進一步的模擬，實現有效的時間縮短。 宣布贏牌的可能性受到在模擬中滿足合牌條件（吃、碰、明槓）的所有手牌所需的額外擴展和處理的影響。 然而，這種額外的處理也會增加單次模擬的時間。 此外，模擬設置中的參數 m 確定了最大抽牌數，這影響了額外擴展的數量，從而影響了模擬時間。 在 Rowlet 中，我們將 m 設置為 MTW + 1 的數量，並將 k 固定為 5，表示棄牌候選的數量。 呼叫一張牌的可能性基於當前手牌直接確定，無法調整。 因此，為了充分利用有限的時間，我們根據 MTW 和呼叫牌的可能性調整參數 n。 # Calling Tile Decision 對於呼叫牌，我們還採用了前一節描述的方法，即由神經網絡輸出修剪的 flatMC。 我們認為這種修剪技術在呼叫牌階段也能取得更好的效果。 以最複雜的呼叫牌選項之一，即吃，為例，最多有四種可能的選擇： 不呼叫牌和三種不同的順子。 每種選擇都需要在棄牌後進行後續的 flatMC 模擬。 選擇不呼叫牌提供了額外的抽牌機會，之後仍需要進行 flatMC 模擬。 因此，最大的 flatMC 模擬次數為 59，包括在不呼叫牌的選擇後的原始 17 個棄牌候選者和每個三種順子選擇的 14 個棄牌候選者。 這遠高於在不呼叫牌的情況下原始 17 個棄牌候選者所需的 flatMC 模擬次數。 通過應用提出的修剪方法，棄牌候選者的最大數量被減少到 4 × n。 在 Rowlet 中，我們將 n 設置為 4，因此有 16 個棄牌候選者。 這意味著我們的神經網絡引導的修剪方法可以將計算工作量有效地減少到原始水平的三分之一以下。 在我們的呼叫牌策略中，我們不考慮明槓。 上述方法也適用於碰牌、加槓和暗槓的情況。 對於這些情況中的每一種，神經網絡都用於識別 𝑛 個呼叫牌和不呼叫牌的棄牌候選者。 在 𝑛 為 4 的情況下，總共需要模擬 8 種情境。 # 性能評估 這一章介紹我們進行的遊戲實驗，以評估 Rowlet 的性能，並討論實驗結果。 # 實驗設計和評估方法 由於臺灣麻將具有固有的隨機性，客觀評估人工智慧代理的性能相對較為困難。 為了客觀評估 Rowlet 和所提出的方法的性能，我們使用了獲勝次數，而不是比賽中使用的得分，作為性能指標，因為在自摸的情況下，得分更容易受到運氣的影響。 具體而言，在比較兩種不同的方法或人工智慧代理時，每個代理將有兩個實例構成遊戲的四名玩家。 例如，在比較方法 A 和方法 B 時，將有兩個代理，𝐴1 和 𝐴2，都實現方法 A，還有另外兩個代理，𝐵1 和 𝐵2，都實現方法 B。 它們將按照 𝐴1 - 𝐵1 - 𝐴2 - 𝐵2 的順序坐下，其中一個代理將有一個實施相同方法的對手，而兩個相鄰的對手則實施另一種方法。 在每個實驗中，我們進行了 1000 輪遊戲，並仔細記錄了各自的勝場和放槓次數。 為了減少隨機性的影響，我們在位置旋轉期間保持了相同的起始狀態。 因此，在實驗期間，方法 A 和方法 B 都經歷了相同的牌局分佈和初始手牌。 每次實驗結束後，收集的勝場和放槍次數被用來計算代表兩種方法相對實力的指標，通過計算不同方法之間勝場和放槍次數之間的比率。 例如，要根據獲勝次數來評估方法 A 與方法 B，獲勝比率的計算方式為 (𝐴1 獲勝次數 + 𝐴2 獲勝次數)/(𝐵1 獲勝次數 + 𝐵2 獲勝次數)。 值超過 1 表示方法 A 的實力優於方法 B。 值小於 1 表示方法 B 比方法 A 更強。 值與 1 的偏離程度越大，兩種方法之間的實力差異就越大。 另一個相似的指標是放槍的比率，可以根據實驗中收集的放槍次數計算得出，公式為 (𝐴1 放槍次數 + 𝐴2 放槍次數)/(𝐵1 放槍次數 + 𝐵2 放槍次數)。 然而，與前述的獲勝比率相反，較低的放槍比率值較為理想。 當值超過 1 時，認為方法 A 在遊戲中犯錯較多，因此方法 B 可能比方法 A 更強。 當值小於 1 時，通常可用來表明方法 A 比方法 B 更強。 同樣，值與 1 的偏離程度越大，兩種方法之間的實力差距就越大。 # Experimental Results for Supervised Learning (監督式學習的實驗結果) 進行神經網絡模型訓練的電腦使用了一顆單獨的 GeForce RTX 3070。 兩個具有不同輸入格式的模型，即（8x34）和（36x34），被分別訓練。 每個模型進行了 25 個 epochs，每個 epoch 在大約 118,100 個數據樣本上進行訓練。 驗證使用約 11,810 個數據樣本進行，以計算準確性和損失。 如圖 4.1 和 4.2 所示，兩個模型在準確性方面達到了約 0.74 的收斂，損失也收斂到約 0.7。 結果與我們的期望一致，因為更複雜的模型往往收斂速度較慢。 因此，（8x34）模型比（36x34）模型更早達到了收斂。 然而，兩個模型的最終準確性值僅達到約 0.74，表明該方法存在性能瓶頸。 Figure 4.1 Accuracy evaluation of supervised learning Figure 4.2 Loss evaluation of supervised learning 除了基於準確性和損失進行模型評估之外，我們還將它們與 VeryLongCat 中使用的 Expectimax 搜索算法進行比較。 需要注意的一點是，Expectimax 搜索算法需要完全擴展才能獲得完整的輸出，因此在比賽中可能超出時間限制，這可能是一個潛在的缺點。 在以下的比較中，為了專注於輸出的質量，我們允許 Expectimax 搜索算法進行完整的擴展，而不施加任何時間限制。 表 4.1 和 4.2 顯示了 Expectimax 搜索算法和我們的兩個神經網絡模型（分別使用（8 × 34），即 N=8，和（36 × 34），即 N=36，的輸入格式）在前面描述的勝指數和放槍指數方面的比較。 這兩個指數將列中的方法與行中的方法進行比較。 因此，顯然 Expectimax 方法優於神經網絡模型。 此外，在兩個神經網絡模型之間，使用（8 × 34）輸入格式的模型表現優於使用（36 × 34）輸入格式的模型。 除了勝指數和放槍指數之外，我們還比較了這些方法所需的平均和最大計算時間，如表 4.3 所示。 對於 Expectimax 方法，我們實現了 VeryLongCat 對孤立牌的預處理，將計算時間大大減少到平均不到 0.5 秒。 然而，仍然可以觀察到在某些情況下，可能需要非常長的計算時間，例如表 4.3 中顯示的超過 228 秒。 另一方面，神經網絡模型的平均和最大計算時間之間僅存在輕微差異，表明更穩定的推理速度是一個重要的優勢。 # Experimental Results for Reinforcement Learning (強化學習的實驗結果) 本節介紹了由強化學習訓練的神經網絡模型的實驗結果。 在訓練過程中，使用了 Intel (R) Xeon (R) Gold 6230 CPU @ 2.10GHz 和 GeForce RTX 2080 Ti 進行訓練。 在每約 50 個 epochs 生成一個新模型，平均每 2 小時生成一個新模型。 圖 4.3 比較了每個生成的模型與原始模型（即使用 (36 × 34) 輸入格式進行監督式學習的模型）的強度，以贏指數為指標。 Figure 4.3 Strength comparison during the reinforcement learning process 在圖 4.3 中，我們可以觀察到深度強化學習（DRL）方法最初經歷了性能的急劇下降，然後持續改善。 在這次實驗中，DRL 方法在訓練的早期階段達到了約 1.18 的最高贏指數。 在中期，贏指數迅速下降，並在 1 和 0.8 之間波動。 接下來，我們選擇了整個強化學習過程中贏指數最高的模型進行進一步的實驗，與其他方法進行比較，包括 Expectimax 以及使用 (8 × 34) 和 (36 × 34) 輸入格式進行監督學習的兩個模型。 以下表格呈現了 1000 回合的實驗結果。 表格 4.4 和 4.5 分別比較了 DRL 模型與其他方法在贏指數和放槍指數方面的表現。 儘管神經網絡模型未能達到非常優越的性能，但它仍然通過 DRL 方法進行學習，並在某種程度上優於這兩個監督學習模型。 然而，DRL 模型與 Expectimax 方法之間仍存在顯著的性能差距。 根據以上實驗結果，深度強化學習被證明是一種有效的方法，相對於監督學習訓練的模型，它可以進一步提升神經網絡模型的性能。 然而，在臺灣麻將方面，DRL 模型仍然無法擊敗傳統方法，即 Expectimax，這是大多數當前競技程序中常用的方法。 # Experimental Results for Rowlet (Rowlet 的實驗結果) 這一節介紹了我們臺灣麻將 AI 代理 Rowlet 與近期參加競賽的程序中使用的兩種主要方法 FlatMC 和 Expectimax 的實驗比較。 我們的 Rowlet 採用了一種混合方法，進一步增強其實力，該方法利用深度強化學習訓練的神經網絡模型來引導改進的 FlatMC 過程。 FlatMC 是 SimCat 中使用的方法，但在以下的實驗中使用的 FlatMC 程序是我們自己實現的，並且包含了並行化技術。 Rowlet 和 SimCat 之間的主要區別在於第 3 章中描述的 OneSim 功能和基於神經網絡模型的修剪機制。 為了確保 Rowlet 和原始 FlatMC 之間的公平比較，我們將 FlatMC 中的參數 m 設置為相同的 MTW + 1 並以相同的方式調整 n。 表 4.6 顯示了根據獲勝指數的性能比較。 Rowlet 優於 FlatMC 和 Expectimax，這表明我們在這篇論文中提出的優化技術，即改進的 OneSim 過程和基於神經網絡模型的 FlatMC 修剪機制，是有效的。 表 4.7 比較了這三種方法的放槍指數。 我們的 Rowlet 還導致較低的放槍指數值，這也有助於 Rowlet 的整體優勢。 表 4.8 比較了原始 FlatMC 和 Rowlet 所需的平均和最大計算時間。 在相同的配置下，顯然 Rowlet 的平均和最大計算時間明顯較低，相比於原始 FlatMC。 Rowlet 在速度上的優勢也有助於提高其實力。 Rowlet 首次參加了 2023 年 TCGA 舉辦的臺灣麻將比賽，並幸運地贏得了冠軍，如圖 4.4 所示。 比賽的第二和第三名分別被 SimCat 和 MeomCaTS 獲得。 MeomCaTS 是由 SimCat 的同一作者開發的一個新的臺灣麻將 AI 代理。 比賽結果揭示了兩個重要的發現。 首先，由於 Rowlet 在 SimCat 中使用的方法，尤其是 FlatMC，競賽結果可能顯示 MCS 方法在臺灣麻將 AI 代理中的潛力，相對於其他搜索或啟發式方法，例如 Expectimax。 其次，比賽結果還展示了我們在 Rowlet 中採用的基於 FlatMC 和神經網絡模型的混合方法的有效性，該方法在本論文中有所介紹。 Figure 4.4 TCGA 2023 Final Table Settlement 與原始的 FlatMC 相比，我們的混合方法利用神經網絡模型進行有效的剪枝，可以通過減少無效的模擬和計算，更好地利用有限的計算資源。 然而，SimCat 對於爆炸性的牌組合做了特殊考慮，而 Rowlet 並未處理此問題。 對於處理爆炸性的牌組合方式的不同可能導致在牌的匹配方面取得不同的結果，這是進一步增強 Rowlet 的未來方向之一。 # 結論與未來方向 儘管在日本麻將 AI 領域進行了許多神經網絡的研究，但在臺灣麻將 AI 中利用神經網絡的研究相對有限。 本論文介紹了我們將深度神經網絡模型引入臺灣麻將 AI 代理的工作。 具體而言，基於神經網絡模型，我們探討並評估了三種不同的可能性，包括監督學習、強化學習，以及將神經網絡模型與 FlatMC 方法整合的混合方法。 由於臺灣麻將缺乏公開的遊戲記錄，我們的監督學習神經網絡模型是基於實現 VeryLongCat 中使用的 Expectimax 方法的 AI 代理生成的數據。Expectimax 方法在之前的幾場比賽中取得了冠軍。 強化學習始於由監督學習訓練的神經網絡模型，並生成一個改進的模型，用於混合方法。 我們進行了一系列的實驗來評估這三種方法。 對於基於監督學習的方法，神經網絡模型實現了約 74% 的準確度，與 Expectimax 方法選擇的動作相比。 然而，在贏指數和放槍指數方面，監督學習方法無法與 Expectimax 方法相比。 這是一個合理的結果，因為神經網絡模型無法學習 Expectimax 方法的完整行為，即 100% 的準確性。 基於強化學習的代理性能優於監督學習方法，但仍然不及 Expectimax 方法。 最後，我們的 AI 代理 Rowlet 實現的混合方法在贏指數和放槍指數方面都優於 Expectimax 和 flatMC。 除了在實驗中取得更好的表現外，Rowlet 還在 TCGA 2023 年臺灣麻將比賽中贏得了冠軍。 我們的研究工作表明，深度強化學習是開發台灣麻將 AI 代理的一個可行且有前途的方向。 然而，直接用深度神經網絡模型取代傳統的樹搜索方法（例如 Expectimax）是不適當的，因為實驗結果顯示，在贏指數和放槍指數方面，這樣的神經網絡模型仍然無法與傳統的樹搜索方法相媲美。 一個有前途的方向是將深度神經網絡模型集成到傳統的樹搜索方法中（例如 FlatMC），用於引導搜索過程，正如我們的實驗結果和 TCGA 2023 年台灣麻將比賽所展示的那樣。 基於我們在這篇論文中提出的研究工作的經驗，我們還確定了一些值得進一步探索的未來研究方向。 首先，在監督學習階段，我們使用了一個相對簡單的輸入結構，這對於基於快速贏取原則的簡單策略可能足夠。 然而，要有效地學習高級策略，尤其是在強化學習階段，可能需要更廣泛的輸入結構。 其次，基於強化學習的神經網絡模型的實際表現未達預期，這是一個需要解決的挑戰。 考慮採用在訓練日本麻將 AI 代理 Suphx 時使用的神經網絡方法，即使用 oracle 代理方法，這種方法可能也適用於台灣麻將 AI 代理。 此外，Suphx 還建議通過控制商來增加代理的探索。 此外，根據我們的經驗，獎勵設計也是一個關鍵問題，需要進一步改進。 目前，提出的混合方法僅在實際遊戲中使用，而不在強化學習過程中使用。 考慮到 AlphaZero 的經驗，將蒙特卡羅搜索（MCS）方法融入自我遊玩階段可能有望提高強化學習的效果，進而進一步提高 Rowlet 的實力。 最後，在 Rowlet 中，我們改進的 flatMC 方法僅考慮三種類型的呼叫：吃、碰和暗槓。 整合其他類型的呼叫，例如明槓和加槓，並制定一個全面的呼叫策略，可能有助於更好地評估模擬階段的手牌價值。 此外，值得進一步探討 flatMC 中使用的深度參數 𝑚。在我們的實現中，𝑚 被設置為 MTW（贏牌的最小張數）+ 1，但這種設置可能導致過於短視的模擬結果。 然而，將 𝑚 設置得太高可能導致過於長視的結果，並可能在某些情況下損失利益。 需要進一步的調查和研究工作。 # 名詞解釋 傳統策略賽局可以分成兩種: 不完美信息：對手會隱藏某些賽局的資訊，如：麻將中自己的手牌其他人不知道，只有一些桌上的訊息是公開的。 完美信息：每個玩家清楚的知道之前發生的情況，如：暗棋、五子棋、圍棋。 帶來的不確定性: 隱藏信息：有些手牌對方式不知道的。 偶然性：隨機的翻牌，如：暗棋也具又偶然性。 同時移動：玩家在同一時間做選擇。 # 其他資訊 完美信息的 AI 知名程式: 國際象棋: Deep Blue developed by IBM 圍棋: AlphaGo developed by DeepMind 不完美信息的 AI 知名程式: 德州撲克: Libratus 日本麻將: Suphx 完美信息常用的技術: 樹剪枝技術 （tree pruning techniques） MCS (Monte Carlo Simulation): 是一種統計方法，通常用於較為無法輕易解析的問題上，透過隨機抽樣的方式產出大量的隨機樣本，並透過對這些產出來的大量隨機樣本分析後解決問題。MCS 能被運用的領域相當廣，在數學、科學、經濟、工程學領域都非常常見，並且 MCS 也是長期被使用在遊戲對局的一種方法。 在臺灣麻將人工智慧的研究中國立陽明交通大學的 SimCat 與國立台北大學的 FatesGate 也都是使用 MCS 的方法。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Artificial-Intelligence","slug":"computer-science/Artificial-Intelligence","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Artificial-Intelligence/"}],"tags":[{"name":"Reinforcement Learning","slug":"Reinforcement-Learning","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Reinforcement-Learning/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Deep-Learning/"},{"name":"MCTS","slug":"MCTS","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/MCTS/"},{"name":"Supervised learning","slug":"Supervised-learning","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Supervised-learning/"}]},{"title":"1026. Maximum Difference Between Node and Ancestor","slug":"coding/leetcode/Medium/1026-Maximum-Difference-Between-Node-and-Ancestor","date":"2024-01-11T11:10:36.000Z","updated":"2024-01-11T12:04:34.580Z","comments":true,"path":"coding/leetcode/Medium/1026-Maximum-Difference-Between-Node-and-Ancestor/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1026-Maximum-Difference-Between-Node-and-Ancestor/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b . A node a is an ancestor of b if either: any child of a is equal to b or any child of a is an ancestor of b . # Example 1 Input: root = [8,3,10,1,6,null,14,null,null,4,7,13] Output: 7 Explanation: We have various ancestor-node differences, some of which are given below : |8 - 3| = 5 |3 - 7| = 4 |8 - 1| = 7 |10 - 13| = 3 Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7. # Example 2 Input: root = [1,null,2,null,0,3] Output: 3 TreeNode 的 class 內容 TreeNode// Definition for a binary tree node.public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode() &#123; &#125; TreeNode(int val) &#123; this.val = val; &#125; TreeNode(int val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125;&#125; # 解題思路 # Solution import java.util.ArrayList;import java.util.Collections;class Solution &#123; public int maxAncestorDiff(TreeNode root) &#123; int Max = 0; ArrayList&lt;TreeNode> tree = new ArrayList&lt;>(); toNode(root, tree); for (TreeNode t : tree) &#123; ArrayList&lt;Integer> arr = new ArrayList&lt;>(); int min = 0; int max = 0; getAllValue(t, arr); if ((arr.size() - 1) != 0) &#123; Collections.sort(arr); min = arr.get(0); max = arr.get(arr.size() - 1); if (Max &lt; Math.abs(t.val - min)) &#123; Max = Math.abs(t.val - min); &#125; if (Max &lt; Math.abs(t.val - max)) &#123; Max = Math.abs(t.val - max); &#125; &#125; &#125; return Max; &#125; public void toNode(TreeNode root, ArrayList&lt;TreeNode> tree) &#123; if (root != null) &#123; tree.add(root); &#125; if (root.left != null) &#123; toNode(root.left, tree); &#125; if (root.right != null) &#123; toNode(root.right, tree); &#125; &#125; public void getAllValue(TreeNode root, ArrayList&lt;Integer> arr) &#123; if (root.left != null) &#123; getAllValue(root.left, arr); &#125; if (root.right != null) &#123; getAllValue(root.right, arr); &#125; if (root != null) &#123; arr.add(root.val); &#125; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Tree","slug":"Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Tree/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Tree/"}]},{"title":"1578. Minimum Time to Make Rope Colorful","slug":"coding/leetcode/Medium/1578-Minimum-Time-to-Make-Rope-Colorful","date":"2023-12-27T04:27:35.000Z","updated":"2023-12-27T05:01:24.925Z","comments":true,"path":"coding/leetcode/Medium/1578-Minimum-Time-to-Make-Rope-Colorful/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1578-Minimum-Time-to-Make-Rope-Colorful/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Alice has n balloons arranged on a rope. You are given a 0-indexed string colors where colors[i] is the color of the ith balloon. Alice wants the rope to be colorful. She does not want two consecutive balloons to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it colorful. You are given a 0-indexed integer array neededTime where neededTime[i] is the time (in seconds) that Bob needs to remove the ith balloon from the rope. Return the minimum time Bob needs to make the rope colorful. # Example 1 Input: colors = &quot;abaac&quot;, neededTime = [1,2,3,4,5] Output: 3 Explanation: In the above image, 'a' is blue, 'b' is red, and 'c' is green. Bob can remove the blue balloon at index 2. This takes 3 seconds. There are no longer two consecutive balloons of the same color. Total time = 3. # Example 2 Input: colors = &quot;abc&quot;, neededTime = [1,2,3] Output: 0 Explanation: The rope is already colorful. Bob does not need to remove any balloons from the rope. # Example 3 Input: colors = &quot;aabaa&quot;, neededTime = [1,2,3,4,1] Output: 2 Explanation: Bob will remove the ballons at indices 0 and 4. Each ballon takes 1 second to remove. There are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2. # 解題思路 # Solution class Solution &#123; public int minCost(String colors, int[] neededTime) &#123; int totalTime = 0; int i = 0, j = 0; while (i &lt; neededTime.length &amp;&amp; j &lt; neededTime.length) &#123; int currTotal = 0, currMax = 0; while (j &lt; neededTime.length &amp;&amp; colors.charAt(i) == colors.charAt(j)) &#123; currTotal += neededTime[j]; currMax = Math.max(currMax, neededTime[j]); j++; &#125; totalTime += currTotal - currMax; i = j; &#125; return totalTime; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"1758. Minimum Changes To Make Alternating Binary String","slug":"coding/leetcode/Easy/1758-Minimum-Changes-To-Make-Alternating-Binary-String","date":"2023-12-24T06:58:51.000Z","updated":"2023-12-24T07:37:48.163Z","comments":true,"path":"coding/leetcode/Easy/1758-Minimum-Changes-To-Make-Alternating-Binary-String/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1758-Minimum-Changes-To-Make-Alternating-Binary-String/","excerpt":"","text":"⭐️ # 題目敘述 You are given a string s consisting only of the characters '0' and '1' . In one operation, you can change any '0' to '1' or vice versa. The string is called alternating if no two adjacent characters are equal. For example, the string &quot;010&quot; is alternating, while the string &quot;0100&quot; is not. Return the minimum number of operations needed to make s alternating. # Example 1 Input: s = &quot;0100&quot; Output: 1 Explanation: If you change the last character to '1', s will be &quot;0101&quot;, which is alternating. # Example 2 Input: s = &quot;10&quot; Output: 0 Explanation: s is already alternating. # Example 3 Input: s = &quot;1111&quot; Output: 2 Explanation: You need two operations to reach &quot;0101&quot; or &quot;1010&quot;.5) # 解題思路 # Solution class Solution &#123; public int minOperations(String s) &#123; int len = s.length(); int diff = 0; for (int i = 0; i &lt; len; i++) &#123; if (i % 2 == 0 &amp;&amp; s.charAt(i) != '1') &#123; diff++; &#125;else if (i % 2 == 1 &amp;&amp; s.charAt(i) != '0') &#123; diff++; &#125; &#125; return Math.min(diff, len - diff); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"2706. Buy Two Chocolates","slug":"coding/leetcode/Easy/2706-Buy-Two-Chocolates","date":"2023-12-20T05:20:00.000Z","updated":"2023-12-20T05:29:44.901Z","comments":true,"path":"coding/leetcode/Easy/2706-Buy-Two-Chocolates/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2706-Buy-Two-Chocolates/","excerpt":"","text":"⭐️ # 題目敘述 You are given an integer array prices representing the prices of various chocolates in a store. You are also given a single integer money , which represents your initial amount of money. You must buy exactly two chocolates in such a way that you still have some non-negative leftover money. You would like to minimize the sum of the prices of the two chocolates you buy. Return the amount of money you will have leftover after buying the two chocolates. If there is no way for you to buy two chocolates without ending up in debt, return money . Note that the leftover must be non-negative. # Example 1 Input: prices = [1,2,2], money = 3 Output: 0 Explanation: Purchase the chocolates priced at 1 and 2 units respectively. You will have 3 - 3 = 0 units of money afterwards. Thus, we return 0. # Example 2 Input: prices = [3,2,3], money = 3 Output: 3 Explanation: You cannot buy 2 chocolates without going in debt, so we return 3. # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public int buyChoco(int[] prices, int money) &#123; Arrays.sort(prices); if(money - prices[0] - prices[1] &lt; 0)&#123; return money; &#125; return money - prices[0] - prices[1]; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"}]},{"title":"Practise Floyd-Warshall 單機版程式 vs. 平行版程式","slug":"computer-science/HPC/MPI/Practise-Floyd-Warshall-單機版程式-vs-平行版程式","date":"2023-12-20T05:15:25.000Z","updated":"2023-12-20T05:54:11.245Z","comments":true,"path":"computer-science/HPC/MPI/Practise-Floyd-Warshall-單機版程式-vs-平行版程式/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/HPC/MPI/Practise-Floyd-Warshall-%E5%96%AE%E6%A9%9F%E7%89%88%E7%A8%8B%E5%BC%8F-vs-%E5%B9%B3%E8%A1%8C%E7%89%88%E7%A8%8B%E5%BC%8F/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 題目 Floyd-Warshall 演算法 wiki 撰寫出 Floyd-Warshall 演算法，處理點到點的最短路徑 # 單機版程式 #include &lt;bits/stdc++.h>#define N 1000using namespace std;int main() &#123; srand(36); long start = clock(); int **D; D = (int **)malloc(N * sizeof(int *)); for (int i = 0; i &lt; N; i++) &#123; D[i] = (int *)malloc(N * sizeof(int)); for (int j = 0; j &lt; N; j++) &#123; if (i == j) D[i][j] = 0; else D[i][j] = rand() % 100 + 1; &#125; &#125; for (int k = 0; k &lt; N; k++) &#123; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; if (D[i][k] + D[k][j] &lt; D[i][j]) &#123; // P[i][j] = k + 1; D[i][j] = D[i][k] + D[k][j]; &#125; &#125; &#125; // cout &lt;&lt; \"k = \" &lt;&lt; (k + 1) &lt;&lt; endl; &#125; long end = clock(); for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 5; j++) &#123; cout &lt;&lt; setw(3) &lt;&lt; D[i][j]; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; \"\\033[36mTotal: \" &lt;&lt; (end - start) / 1000.0 &lt;&lt; \" (sec)\\033[0m\" &lt;&lt; endl; free(D); return 0;&#125;# 平行版程式 #include &lt;bits/stdc++.h>#include &lt;mpi.h>#define N 1000using namespace std;int main() &#123; MPI_Init(NULL, NULL); int world_size, world_rank; MPI_Comm_size(MPI_COMM_WORLD, &amp;world_size); MPI_Comm_rank(MPI_COMM_WORLD, &amp;world_rank); srand(36); double start = MPI_Wtime(); int **D; D = (int **)malloc(N * sizeof(int *)); for (int i = 0; i &lt; N; i++) &#123; D[i] = (int *)malloc(N * sizeof(int)); &#125; if (world_rank == 0) &#123; for (int k = 0; k &lt; N; k++) &#123; for (int j = 0; j &lt; N; j++) &#123; if (k == j) D[k][j] = 0; else D[k][j] = rand() % 100 + 1; &#125; &#125; for (int k = 0; k &lt; N; k += world_size) &#123; for (int i = 1; i &lt; world_size; i++) &#123; if (k + i &lt; N) &#123; MPI_Send(D[k + i], N, MPI_INT, i, k, MPI_COMM_WORLD); &#125; &#125; &#125; &#125; else &#123; for (int k = 0; k &lt; N; k += world_size) &#123; if (k + world_rank &lt; N) &#123; MPI_Recv(D[k + world_rank], N, MPI_INT, 0, k, MPI_COMM_WORLD, MPI_STATUS_IGNORE); &#125; &#125; &#125; for (int k = 0; k &lt; N; k++) &#123; MPI_Bcast(D[k], N, MPI_INT, k % world_size, MPI_COMM_WORLD); for (int i = 0; i &lt; N; i += world_size) &#123; for (int j = 0; j &lt; N; j++) &#123; if (i + world_rank &lt; N) &#123; D[i + world_rank][j] = min(D[i + world_rank][j], D[i + world_rank][k] + D[k][j]); &#125; &#125; &#125; &#125; if (world_rank == 0) &#123; for (int k = 0; k &lt; N; k += world_size) &#123; for (int i = 1; i &lt; world_size; i++) &#123; if (k + i &lt; N) &#123; MPI_Recv(D[k + i], N, MPI_INT, i, k, MPI_COMM_WORLD, MPI_STATUS_IGNORE); &#125; &#125; &#125; &#125; else &#123; for (int k = 0; k &lt; N; k += world_size) &#123; if (k + world_rank &lt; N) &#123; MPI_Send(D[k + world_rank], N, MPI_INT, 0, k, MPI_COMM_WORLD); &#125; &#125; &#125; double end = MPI_Wtime(); if (world_rank == 0) &#123; for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 5; j++) &#123; cout &lt;&lt; setw(3) &lt;&lt; D[i][j]; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; \"\\033[36mTotal: \" &lt;&lt; (end - start) &lt;&lt; \" (sec)\\033[0m\" &lt;&lt; endl; &#125; free(D); MPI_Finalize(); return 0;&#125;","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"HPC","slug":"computer-science/HPC","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/HPC/"},{"name":"MPI","slug":"computer-science/HPC/MPI","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/HPC/MPI/"}],"tags":[]},{"title":"1913. Maximum Product Difference Between Two Pairs","slug":"coding/leetcode/Easy/1913-Maximum-Product-Difference-Between-Two-Pairs","date":"2023-12-18T06:18:17.000Z","updated":"2023-12-18T06:28:19.444Z","comments":true,"path":"coding/leetcode/Easy/1913-Maximum-Product-Difference-Between-Two-Pairs/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1913-Maximum-Product-Difference-Between-Two-Pairs/","excerpt":"","text":"⭐️ # 題目敘述 The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d) . For example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16 . Given an integer array nums , choose four distinct indices w , x , y , and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized. Return the maximum such product difference. # Example 1 Input: nums = [5,6,2,7,4] Output: 34 Explanation: We can choose indices 1 and 3 for the first pair (6, 7) and indices 2 and 4 for the second pair (2, 4). The product difference is (6 * 7) - (2 * 4) = 34. # Example 2 Input: nums = [4,2,5,9,7,4,8] Output: 64 Explanation: We can choose indices 3 and 6 for the first pair (9, 8) and indices 1 and 5 for the second pair (2, 4). The product difference is (9 * 8) - (2 * 4) = 64. # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public int maxProductDifference(int[] nums) &#123; Arrays.sort(nums); return (nums[nums.length - 1] * nums[nums.length - 2]) - (nums[0] * nums[1]); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"}]},{"title":"2353. Design a Food Rating System","slug":"coding/leetcode/Medium/2353-Design-a-Food-Rating-System","date":"2023-12-17T04:35:29.000Z","updated":"2023-12-17T05:51:38.866Z","comments":true,"path":"coding/leetcode/Medium/2353-Design-a-Food-Rating-System/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2353-Design-a-Food-Rating-System/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Design a food rating system that can do the following: Modify the rating of a food item listed in the system. Return the highest-rated food item for a type of cuisine in the system. Implement the FoodRatings class: FoodRatings(String[] foods, String[] cuisines, int[] ratings) Initializes the system. The food items are described by foods , cuisines and ratings , all of which have a length of n . foods[i] is the name of the ith food, cuisines[i] is the type of cuisine of the ith food, and ratings[i] is the initial rating of the ith food. void changeRating(String food, int newRating) Changes the rating of the food item with the name food . String highestRated(String cuisine) Returns the name of the food item that has the highest rating for the given type of cuisine . If there is a tie, return the item with the lexicographically smaller name. Note that a string x is lexicographically smaller than string y if x comes before y in dictionary order, that is, either x is a prefix of y , or if i is the first position such that x[i] != y[i] , then x[i] comes before y[i] in alphabetic order. # Example 1 Input [&quot;FoodRatings&quot;, &quot;highestRated&quot;, &quot;highestRated&quot;, &quot;changeRating&quot;, &quot;highestRated&quot;, &quot;changeRating&quot;, &quot;highestRated&quot;] [[[&quot;kimchi&quot;, &quot;miso&quot;, &quot;sushi&quot;, &quot;moussaka&quot;, &quot;ramen&quot;, &quot;bulgogi&quot;], [&quot;korean&quot;, &quot;japanese&quot;, &quot;japanese&quot;, &quot;greek&quot;, &quot;japanese&quot;, &quot;korean&quot;], [9, 12, 8, 15, 14, 7]], [&quot;korean&quot;], [&quot;japanese&quot;], [&quot;sushi&quot;, 16], [&quot;japanese&quot;], [&quot;ramen&quot;, 16], [&quot;japanese&quot;]] Output [null, &quot;kimchi&quot;, &quot;ramen&quot;, null, &quot;sushi&quot;, null, &quot;ramen&quot;] Explanation FoodRatings foodRatings = new FoodRatings([&quot;kimchi&quot;, &quot;miso&quot;, &quot;sushi&quot;, &quot;moussaka&quot;, &quot;ramen&quot;, &quot;bulgogi&quot;], [&quot;korean&quot;, &quot;japanese&quot;, &quot;japanese&quot;, &quot;greek&quot;, &quot;japanese&quot;, &quot;korean&quot;], [9, 12, 8, 15, 14, 7]); foodRatings.highestRated(&quot;korean&quot;); // return &quot;kimchi&quot; // &quot;kimchi&quot; is the highest rated korean food with a rating of 9. foodRatings.highestRated(&quot;japanese&quot;); // return &quot;ramen&quot; // &quot;ramen&quot; is the highest rated japanese food with a rating of 14. foodRatings.changeRating(&quot;sushi&quot;, 16); // &quot;sushi&quot; now has a rating of 16. foodRatings.highestRated(&quot;japanese&quot;); // return &quot;sushi&quot; // &quot;sushi&quot; is the highest rated japanese food with a rating of 16. foodRatings.changeRating(&quot;ramen&quot;, 16); // &quot;ramen&quot; now has a rating of 16. foodRatings.highestRated(&quot;japanese&quot;); // return &quot;ramen&quot; // Both &quot;sushi&quot; and &quot;ramen&quot; have a rating of 16. // However, &quot;ramen&quot; is lexicographically smaller than &quot;sushi&quot;. # 解題思路 # Solution import java.util.Comparator;import java.util.HashMap;import java.util.Map;import java.util.PriorityQueue;class FoodRatings &#123; public class Data &#123; String food; String cuisine; int rating; public Data(String food, String cuisine, int rating) &#123; this.food = food; this.cuisine = cuisine; this.rating = rating; &#125; &#125; Map&lt;String, PriorityQueue&lt;Data>> cuisineMap; Map&lt;String, Data> foodMap; public FoodRatings(String[] foods, String[] cuisines, int[] ratings) &#123; cuisineMap = new HashMap&lt;>(); foodMap = new HashMap&lt;>(); for (int i = 0; i &lt; foods.length; i++) &#123; Data data = new Data(foods[i], cuisines[i], ratings[i]); foodMap.put(foods[i], data); if (cuisineMap.containsKey(cuisines[i])) &#123; cuisineMap.get(cuisines[i]).add(data); &#125; else &#123; PriorityQueue&lt;Data> pq = new PriorityQueue&lt;Data>(new Comparator&lt;Data>() &#123; @Override public int compare(Data a, Data b) &#123; int result = b.rating - a.rating; if (result == 0) &#123; return (a.food).compareTo(b.food); &#125; return result; &#125; &#125;); pq.add(data); cuisineMap.put(cuisines[i], pq); &#125; &#125; &#125; public void changeRating(String food, int newRating) &#123; Data prev = foodMap.get(food); cuisineMap.get(prev.cuisine).remove(prev); Data curr = new Data(food, prev.cuisine, newRating); foodMap.put(food, curr); cuisineMap.get(prev.cuisine).add(curr); &#125; public String highestRated(String cuisine) &#123; return cuisineMap.get(cuisine).peek().food; &#125;&#125;/** * Your FoodRatings object will be instantiated and called as such: * FoodRatings obj = new FoodRatings(foods, cuisines, ratings); * obj.changeRating(food,newRating); * String param_2 = obj.highestRated(cuisine); */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Design","slug":"Design","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Design/"},{"name":"Ordered Set","slug":"Ordered-Set","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Ordered-Set/"}]},{"title":"242. Valid Anagram","slug":"coding/leetcode/Easy/242-Valid-Anagram","date":"2023-12-16T14:45:12.000Z","updated":"2023-12-16T15:51:41.448Z","comments":true,"path":"coding/leetcode/Easy/242-Valid-Anagram/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/242-Valid-Anagram/","excerpt":"","text":"⭐️ # 題目敘述 Given two strings s and t , return true if t is an anagram of s , and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. # Example 1 Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot; Output: true # Example 2 Input: s = &quot;rat&quot;, t = &quot;car&quot; Output: false # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public boolean isAnagram(String s, String t) &#123; if(s.length() != t.length()) return false; char[] arrs = s.toCharArray(); char[] arrt = t.toCharArray(); Arrays.sort(arrs); Arrays.sort(arrt); for(int i = 0; i &lt; arrs.length; i++)&#123; if(arrs[i] != arrt[i]) return false; &#125; return true; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"What is VPN?","slug":"computer-science/Information-Security/What-is-VPN","date":"2023-12-15T17:46:11.000Z","updated":"2023-12-16T17:09:10.065Z","comments":true,"path":"computer-science/Information-Security/What-is-VPN/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Information-Security/What-is-VPN/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 Virtual Private Network (VPN) 虛擬私人網路 使用 VPN 可在電腦和 VPN 提供者的伺服器之間建立一條安全的、加密的通道。 在電腦和 VPN 提供者的伺服器之間建立數位連線，形成點對點通道，可加密個人資料，同時遮罩 IP 位址，在網際網路上能夠跨越網站封鎖和防火牆的限制，使用 VPN 確保連線體驗更為私人、受保護且更安全。 VPN 提供了一種安全、私密且匿名的連線方式，特別適合需要在不受信任的網路環境中保護敏感資料的情況。 Virtual: 連線過程未涉及實體纜線 Private: 透過此連線，其他人無法資料或瀏覽活動 Network: 有多個裝置一起運作，才能維持建立的連結 # 為何使用 VPN 保護資料 在家工作 隨時隨地存取或串流區域內容 繞過審查和監視 防止 ISP 和第三方追蹤 # VPN 連線類型 遠端存取 VPN (也稱為用戶端對站台 VPN) 站對站 VPN VPN 應用程式","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Information-Security","slug":"computer-science/Information-Security","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Information-Security/"}],"tags":[]},{"title":"1436. Destination City","slug":"coding/leetcode/Easy/1436-Destination-City","date":"2023-12-15T06:32:19.000Z","updated":"2023-12-15T19:04:35.041Z","comments":true,"path":"coding/leetcode/Easy/1436-Destination-City/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1436-Destination-City/","excerpt":"","text":"⭐️ # 題目敘述 You are given the array paths , where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi . Return the destination city, that is, the city without any path outgoing to another city. It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city. # Example 1 Input: paths = [[&quot;London&quot;,&quot;New York&quot;],[&quot;New York&quot;,&quot;Lima&quot;],[&quot;Lima&quot;,&quot;Sao Paulo&quot;]] Output: &quot;Sao Paulo&quot; Explanation: Starting at &quot;London&quot; city you will reach &quot;Sao Paulo&quot; city which is the destination city. Your trip consist of: &quot;London&quot; -&gt; &quot;New York&quot; -&gt; &quot;Lima&quot; -&gt; &quot;Sao Paulo&quot;. # Example 2 Input: paths = [[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;,&quot;B&quot;],[&quot;C&quot;,&quot;A&quot;]] Output: &quot;A&quot; Explanation: All possible trips are: &quot;D&quot; -&gt; &quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;. &quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;. &quot;C&quot; -&gt; &quot;A&quot;. &quot;A&quot;. Clearly the destination city is &quot;A&quot;. # Example 3 Input: paths = [[&quot;A&quot;,&quot;Z&quot;]] Output: &quot;Z&quot; # 解題思路 # Solution import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;class Solution &#123; public String destCity(List&lt;List&lt;String>> paths) &#123; Map&lt;String, Integer> map = new HashMap&lt;>(); ArrayList&lt;String> tmp = new ArrayList&lt;>(); for(List&lt;String> p : paths)&#123; String start = p.get(0); String end = p.get(1); map.put(start, map.getOrDefault(start, 0) + 1); map.put(end, map.getOrDefault(end, 0) - 1); if(map.get(start) == 0 &amp;&amp; tmp.contains(start)) tmp.remove(start); if(map.get(end) == -1) tmp.add(end); &#125; return tmp.get(0); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"熟悉 Linux","slug":"computer-science/HPC/Linux/熟悉-Linux","date":"2023-12-14T08:16:10.000Z","updated":"2023-12-15T18:26:16.701Z","comments":true,"path":"computer-science/HPC/Linux/熟悉-Linux/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/HPC/Linux/%E7%86%9F%E6%82%89-Linux/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 簡介 Linux Linux 是一種作業系統的核心，有時候的 Linux 也被稱為基於 Linux 的完整作業系統，如: Ubuntu、CentOS、Debian、Gentoo，作業系統除了 Linux 核心外，其中也包含了許多使用者圖形介面和其他實用工具。 # Linux 開機流程 # BIOS / UEFI # GPT / MBR # GRUB # vmlinuz # initramfs / initrd # systemd # Linux 工具 # 文字編輯器 # Shell Scripts # Tmux # NFS # Make # Slurm (任務調度工具) # 其他相關資訊 # CPU vs. GPU # HPL &amp; BLAS # CUDA","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"HPC","slug":"computer-science/HPC","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/HPC/"},{"name":"Linux","slug":"computer-science/HPC/Linux","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/HPC/Linux/"}],"tags":[]},{"title":"10055 - Hashmat the Brave Warrior","slug":"coding/cpe/One Star/10055-Hashmat-the-Brave-Warrior","date":"2023-12-14T07:22:41.000Z","updated":"2023-12-14T07:56:55.443Z","comments":true,"path":"coding/cpe/One Star/10055-Hashmat-the-Brave-Warrior/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/10055-Hashmat-the-Brave-Warrior/","excerpt":"","text":"🌗🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Hashmat is a brave warrior who with his group of young soldiers moves from one place to another to fight against his opponents. Before Fighting he just calculates one thing, the difference between his soldier number and the opponent’s soldier number. From this difference he decides whether to fight or not. Hashmat’s soldier number is never greater than his opponent. # Input The input contains two numbers in every line. These two numbers in each line denotes the number soldiers in Hashmat’s army and his opponent’s army or vice versa. The input numbers are not greater than 232. Input is terminated by ‘End of File’. # Output For each line of input, print the difference of number of soldiers between Hashmat’s army and his opponent’s army. Each output should be in seperate line. # Sample Input 10 12 10 14 100 200 # Sample Output 2 4 100 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); while (sc.hasNextLong()) &#123; long a = sc.nextLong(); long b = sc.nextLong(); System.out.println(Math.abs(b - a)); &#125; &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"10050 - Hartals","slug":"coding/cpe/One Star/10050-Hartals","date":"2023-12-14T06:57:05.000Z","updated":"2023-12-14T07:56:51.626Z","comments":true,"path":"coding/cpe/One Star/10050-Hartals/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/10050-Hartals/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 A social research organization has determined a simple set of parameters to simulate the behavior of the political parties of our country. One of the parameters is a positive integer h (called the hartal parameter) that denotes the average number of days between two successive hartals (strikes) called by the corresponding party. Though the parameter is far too simple to be flawless, it can still be used to forecast the damages caused by hartals. The following example will give you a clear idea: Consider three political parties. Assume h1 = 3, h2 = 4 and h3 = 8 where hi is the hartal parameter for party i (i = 1, 2, 3). Now, we will simulate the behavior of these three parties for N = 14 days. One must always start the simulation on a Sunday and assume that there will be no hartals on weekly holidays (on Fridays and Saturdays). The simulation above shows that there will be exactly 5 hartals (on days 3, 4, 8, 9 and 12) in 14 days. There will be no hartal on day 6 since it is a Friday. Hence we lose 5 working days in 2 weeks. In this problem, given the hartal parameters for several political parties and the value of N, your job is to determine the number of working days we lose in those N days. # Input The first line of the input consists of a single integer T giving the number of test cases to follow. The first line of each test case contains an integer N (7 ≤ N ≤ 3650) giving the number of days over which the simulation must be run. The next line contains another integer P (1 ≤ P ≤ 100) representing the number of political parties in this case. The ith of the next P lines contains a positive integer hi (which will never be a multiple of 7) giving the hartal parameter for party i (1 ≤ i ≤ P). # Output For each test case in the input output the number of working days we lose. Each output must be on a separate line. # Sample Input 2 14 3 3 4 8 100 4 12 15 25 40 # Sample Output 5 15 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for(int i = 0; i &lt; T; i++)&#123; int N = sc.nextInt(); int P = sc.nextInt(); int[] arr = new int[N + 1]; for(int j = 6; j &lt;= N; j = j + 7)&#123; arr[j] = -1; if(j + 1 &lt;= N)&#123; arr[j + 1] = -1; &#125; &#125; for(int j = 0; j &lt; P; j++)&#123; int num = sc.nextInt(); int tmp = num; while (tmp &lt;= N) &#123; if(arr[tmp] != -1)&#123; arr[tmp]++; &#125; tmp += num; &#125; &#125; int ans = 0; for(int j = 1; j &lt;= N; j++)&#123; if(arr[j] > 0)&#123; ans++; &#125; &#125; System.out.println(ans); &#125; &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"2482. Difference Between Ones and Zeros in Row and Column","slug":"coding/leetcode/Medium/2482-Difference-Between-Ones-and-Zeros-in-Row-and-Column","date":"2023-12-14T06:41:28.000Z","updated":"2023-12-15T19:09:39.898Z","comments":true,"path":"coding/leetcode/Medium/2482-Difference-Between-Ones-and-Zeros-in-Row-and-Column/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2482-Difference-Between-Ones-and-Zeros-in-Row-and-Column/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given a 0-indexed m x n binary matrix grid . A 0-indexed m x n difference matrix diff is created with the following procedure: Let the number of ones in the ith row be onesRowi . Let the number of ones in the jth column be onesColj . Let the number of zeros in the ith row be zerosRowi . Let the number of zeros in the jth column be zerosColj . diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj Return the difference matrix diff . # Example 1 Input: grid = [[0,1,1],[1,0,1],[0,0,1]] Output: [[0,0,4],[0,0,4],[-2,-2,2]] Explanation: diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 2 + 1 - 1 - 2 = 0 diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 2 + 1 - 1 - 2 = 0 diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 2 + 3 - 1 - 0 = 4 diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 2 + 1 - 1 - 2 = 0 diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 2 + 1 - 1 - 2 = 0 diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 2 + 3 - 1 - 0 = 4 diff[2][0] = onesRow2 + onesCol0 - zerosRow2 - zerosCol0 = 1 + 1 - 2 - 2 = -2 diff[2][1] = onesRow2 + onesCol1 - zerosRow2 - zerosCol1 = 1 + 1 - 2 - 2 = -2 diff[2][2] = onesRow2 + onesCol2 - zerosRow2 - zerosCol2 = 1 + 3 - 2 - 0 = 2 # Example 2 Input: grid = [[1,1,1],[1,1,1]] Output: [[5,5,5],[5,5,5]] Explanation: diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 3 + 2 - 0 - 0 = 5 diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 3 + 2 - 0 - 0 = 5 diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 3 + 2 - 0 - 0 = 5 diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 3 + 2 - 0 - 0 = 5 diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 3 + 2 - 0 - 0 = 5 diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 3 + 2 - 0 - 0 = 5 # 解題思路 # Solution class Solution &#123; public int[][] onesMinusZeros(int[][] grid) &#123; int lenRow = grid.length; int lenCol = grid[0].length; int[] onesRow = new int[lenRow]; int[] onesCol = new int[lenCol]; int[] zeroRow = new int[lenRow]; int[] zeroCol = new int[lenCol]; for(int i = 0; i &lt; lenRow; i++)&#123; for(int j = 0; j &lt; lenCol; j++)&#123; int num = grid[i][j]; if(num == 0)&#123; zeroRow[i]++; zeroCol[j]++; &#125;else&#123; onesRow[i]++; onesCol[j]++; &#125; &#125; &#125; int[][] ans = new int[lenRow][lenCol]; for(int i = 0; i &lt; lenRow; i++)&#123; for(int j = 0; j &lt; lenCol; j++)&#123; ans[i][j] = onesRow[i] + onesCol[j] - zeroRow[i] - zeroCol[j]; &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"}]},{"title":"Practise 找質數 - 單機版程式 vs. 平行版程式","slug":"computer-science/HPC/MPI/Practise-找質數-單機版程式-vs-平行版程式","date":"2023-12-13T15:57:58.000Z","updated":"2023-12-27T03:38:50.946Z","comments":true,"path":"computer-science/HPC/MPI/Practise-找質數-單機版程式-vs-平行版程式/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/HPC/MPI/Practise-%E6%89%BE%E8%B3%AA%E6%95%B8-%E5%96%AE%E6%A9%9F%E7%89%88%E7%A8%8B%E5%BC%8F-vs-%E5%B9%B3%E8%A1%8C%E7%89%88%E7%A8%8B%E5%BC%8F/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 題目 利用 The Sieve of Eratosthenes 演算法找出質數 # 單機版程式 #include &lt;bits/stdc++.h>#define ALLNUM 100000000using namespace std;long long arr[ALLNUM + 1] = &#123;0&#125;;int main() &#123; int k = 2; long start = clock(); for (int i = 2; i &lt;= ALLNUM;) &#123; k = i; if (k * k > ALLNUM) &#123; break; &#125; int mark = k + k; while (mark &lt;= ALLNUM) &#123; arr[mark] = 1; mark += k; &#125; i++; while (arr[i] != 0) &#123; i++; &#125; &#125; long end = clock(); int ans = 0; for (int i = 2; i &lt;= ALLNUM; i++) &#123; if (arr[i] == 0) &#123; ans++; &#125; &#125; printf(\"%d\\n\", ans); cout &lt;&lt; \"\\033[36mTotal: \" &lt;&lt; (end - start) / 1000.0 &lt;&lt; \" (sec)\\033[0m\" &lt;&lt; endl; return 0;&#125;# 平行版程式 #include &lt;bits/stdc++.h>#include &lt;mpi.h>#define ALLNUM 100000000using namespace std;long long arr[ALLNUM + 1] = &#123;0&#125;;long long ans = 0;int main() &#123; MPI_Init(NULL, NULL); int world_size, world_rank; MPI_Comm_size(MPI_COMM_WORLD, &amp;world_size); MPI_Comm_rank(MPI_COMM_WORLD, &amp;world_rank); int size = ALLNUM / world_size; int from = world_rank * size; int to = (world_rank != world_size - 1 ? (world_rank + 1) * size - 1 : ALLNUM); int k = 2; arr[0] = 1; arr[1] = 1; double start = MPI_Wtime(); for (int i = from; i &lt;= to;) &#123; MPI_Bcast(&amp;k, 1, MPI_INT, 0, MPI_COMM_WORLD); if (k * k > ALLNUM) &#123; break; &#125; if (k &lt; to) &#123; int mark = from; while (mark % k != 0 || mark == 0) &#123; mark += 1; &#125; if (mark == k) &#123; mark += k; &#125; while (mark &lt;= to) &#123; arr[mark] = 1; mark += k; &#125; // marking i++; while (arr[i] != 0) &#123; i++; &#125; // find K &#125; int newK = i; MPI_Reduce(&amp;newK, &amp;k, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD); &#125; int count = 0; for (int i = from; i &lt;= to; i++) &#123; if (arr[i] == 0 &amp;&amp; i != 0 &amp;&amp; i != 1) &#123; count++; &#125; &#125; MPI_Reduce(&amp;count, &amp;ans, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD); double end = MPI_Wtime(); MPI_Finalize(); if (world_rank == 0) &#123; cout &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; \"\\033[36mTotal: \" &lt;&lt; (end - start) &lt;&lt; \" (sec)\\033[0m\" &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"HPC","slug":"computer-science/HPC","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/HPC/"},{"name":"MPI","slug":"computer-science/HPC/MPI","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/HPC/MPI/"}],"tags":[]},{"title":"Practise 電路圖 - 單機版程式 vs. 平行版程式","slug":"computer-science/HPC/MPI/Practise-電路圖-單機版程式-vs-平行版程式","date":"2023-12-13T15:51:59.000Z","updated":"2023-12-15T18:26:01.363Z","comments":true,"path":"computer-science/HPC/MPI/Practise-電路圖-單機版程式-vs-平行版程式/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/HPC/MPI/Practise-%E9%9B%BB%E8%B7%AF%E5%9C%96-%E5%96%AE%E6%A9%9F%E7%89%88%E7%A8%8B%E5%BC%8F-vs-%E5%B9%B3%E8%A1%8C%E7%89%88%E7%A8%8B%E5%BC%8F/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 題目 # 單機版程式 #include &lt;bits/stdc++.h>using namespace std;int circuit(int *in)&#123; int res = (in[0] | in[1]) &amp; (~in[1] | ~in[3]) &amp; (in[2] | in[3]) &amp; (~in[3] | ~in[4]) &amp; (in[4] | ~in[5]) &amp; (in[5] | in[6]) &amp; (in[5] | ~in[6]) &amp; (in[7] | ~in[8]) &amp; (in[8] | in[9]) &amp; (in[8] | ~in[9]) &amp; (~in[9] | ~in[10]) &amp; (in[10] | in[11]) &amp; (in[11] | in[9]) &amp; (in[12] | in[13]) &amp; (in[14] | in[15]) &amp; (~in[15] | in[6]) &amp; (in[13] | ~in[14]) &amp; (~in[7] | ~in[13]); return res;&#125;int main()&#123; int count = 0; long start = clock(); for (int i = 0; i &lt; 65536; i++) &#123; int in[16] = &#123;0&#125;; for (int j = 0; j &lt; 16; j++) &#123; in[j] = (i >> (15 - j)) &amp; 1; &#125; if (circuit(in) == 1) &#123; cout &lt;&lt; \"Without Parallel Ans: \"; for(int j = 0; j &lt; 16; j++)&#123; cout &lt;&lt; in[j]; &#125; cout &lt;&lt; endl; count += 1; &#125; &#125; long end = clock(); cout &lt;&lt; count &lt;&lt; endl; cout &lt;&lt; \"\\033[36mTotal: \" &lt;&lt; (end - start) / 1000.0 &lt;&lt; \" (sec)\\033[0m\\n\" &lt;&lt; endl;&#125;# 平行版程式 #include &lt;bits/stdc++.h>#include &lt;mpi.h>using namespace std;int circuit(int *in)&#123; int res = (in[0] | in[1]) &amp; (~in[1] | ~in[3]) &amp; (in[2] | in[3]) &amp; (~in[3] | ~in[4]) &amp; (in[4] | ~in[5]) &amp; (in[5] | in[6]) &amp; (in[5] | ~in[6]) &amp; (in[7] | ~in[8]) &amp; (in[8] | in[9]) &amp; (in[8] | ~in[9]) &amp; (~in[9] | ~in[10]) &amp; (in[10] | in[11]) &amp; (in[11] | in[9]) &amp; (in[12] | in[13]) &amp; (in[14] | in[15]) &amp; (~in[15] | in[6]) &amp; (in[13] | ~in[14]) &amp; (~in[7] | ~in[13]); return res;&#125;int main()&#123; MPI_Init(NULL, NULL); int world_size, world_rank; MPI_Comm_size(MPI_COMM_WORLD, &amp;world_size); MPI_Comm_rank(MPI_COMM_WORLD, &amp;world_rank); int count = 0; int size = 65536 / world_size; int from = world_rank * size; int to = (world_rank + 1) * size; double start = MPI_Wtime(); for (int i = from; i &lt; to; i++) &#123; int in[16] = &#123;0&#125;; for (int j = 0; j &lt; 16; j++) &#123; in[j] = (i >> (15 - j)) &amp; 1; &#125; if (circuit(in) == 1) &#123; cout &lt;&lt; \"From rank \" &lt;&lt; world_rank &lt;&lt; \" out of \" &lt;&lt; world_size &lt;&lt; \" processors: \"; for(int j = 0; j &lt; 16; j++)&#123; cout &lt;&lt; in[j]; &#125; cout &lt;&lt; endl; count += 1; &#125; &#125; if (world_rank == 0) &#123; int tmp; for (int i = 1; i &lt; world_size; i++) &#123; MPI_Recv(&amp;tmp, 1, MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE); count += tmp; &#125; &#125; else &#123; MPI_Send(&amp;count, 1, MPI_INT, 0, 0, MPI_COMM_WORLD); &#125; double end = MPI_Wtime(); MPI_Finalize(); if (world_rank == 0) &#123; cout &lt;&lt; count &lt;&lt; endl; cout &lt;&lt; \"\\033[36mTotal: \" &lt;&lt; (end - start) &lt;&lt; \" (sec)\\033[0m\" &lt;&lt; endl; &#125;&#125;","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"HPC","slug":"computer-science/HPC","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/HPC/"},{"name":"MPI","slug":"computer-science/HPC/MPI","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/HPC/MPI/"}],"tags":[]},{"title":"安裝 Microsoft MPI with vscode in Windows","slug":"computer-science/HPC/MPI/安裝-Microsoft-MPI-with-vscode-in-Windows","date":"2023-12-13T13:49:08.000Z","updated":"2023-12-27T05:54:36.963Z","comments":true,"path":"computer-science/HPC/MPI/安裝-Microsoft-MPI-with-vscode-in-Windows/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/HPC/MPI/%E5%AE%89%E8%A3%9D-Microsoft-MPI-with-vscode-in-Windows/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 安裝 Microsoft MPI Microsoft MPI 官方網站 下載 Microsoft MPI 官方參考文件 # With vscode in Windows 點擊官網連結，並點擊 MS-MPI 下載，點擊 MS-MPI v10.1.3，導至下載畫面，點擊 Download，選取兩個 File，兩個都要下載喔～～ 將下載的兩個檔案點開執行 打開 cmd 輸入指令 set MSMPI ，會看到 MPI 設定的環境變數，表示安裝有成功set MSMPIMSMPI_BENCHMARKS=C:\\Program Files\\Microsoft MPI\\Benchmarks\\MSMPI_BIN=C:\\Program Files\\Microsoft MPI\\Bin\\MSMPI_INC=C:\\Program Files (x86)\\Microsoft SDKs\\MPI\\Include\\MSMPI_LIB32=C:\\Program Files (x86)\\Microsoft SDKs\\MPI\\Lib\\x86\\MSMPI_LIB64=C:\\Program Files (x86)\\Microsoft SDKs\\MPI\\Lib\\x64\\ 接下來打開 vscode 寫下測試程式，這時 #include &lt;mpi.h&gt; 可能會有紅底線表示他找不到此 header 檔hello.c#include &lt;mpi.h>#include &lt;stdio.h>int main(int argc, char** argv) &#123; // Initialize the MPI environment MPI_Init(&amp;argc, &amp;argv); // Get the number of processes int world_size; MPI_Comm_size(MPI_COMM_WORLD, &amp;world_size); // Get the rank of the process int world_rank; MPI_Comm_rank(MPI_COMM_WORLD, &amp;world_rank); // Get the name of the processor char processor_name[MPI_MAX_PROCESSOR_NAME]; int name_len; MPI_Get_processor_name(processor_name, &amp;name_len); // Print off a hello world message printf(\"Hello world from processor %s, rank %d out of %d processors\\n\", processor_name, world_rank, world_size); // Finalize the MPI environment. MPI_Finalize(); return 0;&#125; 在 .vscode 底下的 c_cpp_properties.json 把 MPI 的 Include 加入裡面，也就是 MSMPI_INC 此環境變數後面的路徑，大概會長底下這樣，可以注意有高亮的那幾行 (7, 14)，這兩行會根據大家路徑放置不相同，而有所不同，這樣紅底線應該就沒有了 c_cpp_properties.json&#123; \"configurations\": [ &#123; \"name\": \"Win32\", \"includePath\": [ \"$&#123;workspaceFolder&#125;/**\", \"C:\\\\Program Files (x86)\\\\Microsoft SDKs\\\\MPI\\\\Include\" ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"_UNICODE\" ], \"compilerPath\": \"C:\\\\mingw64\\\\bin\\\\gcc.exe\", \"cStandard\": \"c11\", \"cppStandard\": \"gnu++14\", \"intelliSenseMode\": \"windows-gcc-x86\" &#125; ], \"version\": 4&#125; 接下來就可以來編譯執行程式了 編譯指令gcc hello.c -o hello -I $MSMPI_INC -L $MSMPI_LIB64 -l msmpi $MSMPI_INC 環境變數如果找不到，可以寫絕對路徑，可以參考第三步所印出的東西 $MSMPI_LIB64 環境變數如果找不到，可以寫絕對路徑，可以參考第三步所印出的東西 我在編譯的時候還有一件很特別的事，我雖然找的到 library 的路徑，但是沒有讀到 msmpi.lib ，目前方法是把 msmpi.lib 直接放在我的檔案底下，然後在引入 library 的時候用相對路徑指定當前位置，如: -L &quot;.&quot; ，然後就有找到了 執行指令mpiexec -n 3 hello.exe 指令裡面的 3 表示有三個 processes 處理來這個程式 # Debug 檢查 gcc 版本，建議下載底下提供網址的版本 可以利用 gcc --version 檢查 gcc 版本，不要太舊，可能會有 library 或 include 不相容 WinLibs standalone build of GCC and MinGW-w64 for Windows 我是下載這個版本供參考 下載後解開壓縮檔，在系統環境變數上設定路徑，路徑要到資料夾內的 bin Terminal 重新開啟後，再次測試 gcc --version 查看版本gcc --versiongcc.exe (MinGW-W64 x86_64-ucrt-posix-seh, built by Brecht Sanders) 12.3.0Copyright (C) 2022 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Note: 如果有留之前的 gcc 且環境變數路徑設定在新版的 gcc 之前， gcc --version 可能還是會抓到舊的，可以調整一下順序 # Test MPI code hello.c#include &lt;mpi.h>#include &lt;stdio.h>int main(int argc, char** argv) &#123; // Initialize the MPI environment MPI_Init(&amp;argc, &amp;argv); // Get the number of processes int world_size; MPI_Comm_size(MPI_COMM_WORLD, &amp;world_size); // Get the rank of the process int world_rank; MPI_Comm_rank(MPI_COMM_WORLD, &amp;world_rank); // Get the name of the processor char processor_name[MPI_MAX_PROCESSOR_NAME]; int name_len; MPI_Get_processor_name(processor_name, &amp;name_len); // Print off a hello world message printf(\"Hello world from processor %s, rank %d out of %d processors\\n\", processor_name, world_rank, world_size); // Finalize the MPI environment. MPI_Finalize(); return 0;&#125;","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"HPC","slug":"computer-science/HPC","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/HPC/"},{"name":"MPI","slug":"computer-science/HPC/MPI","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/HPC/MPI/"}],"tags":[]},{"title":"What is Proxy Server?","slug":"computer-science/Information-Security/Website/What-is-Proxy-Server","date":"2023-12-13T07:10:44.000Z","updated":"2023-12-15T18:27:06.212Z","comments":true,"path":"computer-science/Information-Security/Website/What-is-Proxy-Server/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Information-Security/Website/What-is-Proxy-Server/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 介紹 Proxy Server Proxy Server (代理伺服器)","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Information-Security","slug":"computer-science/Information-Security","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Information-Security/"},{"name":"Website","slug":"computer-science/Information-Security/Website","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Information-Security/Website/"}],"tags":[]},{"title":"What is MPI?","slug":"computer-science/HPC/MPI/What-is-MPI","date":"2023-12-13T07:02:33.000Z","updated":"2024-01-03T02:50:05.220Z","comments":true,"path":"computer-science/HPC/MPI/What-is-MPI/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/HPC/MPI/What-is-MPI/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 訊息傳遞介面（英語：Message Passing Interface，縮寫 MPI）是一個平行計算的應用程式接口（API），常在超級電腦、電腦叢集等非共享記憶體環境程序設計。 # MPI vs. MP MP: 多執行續的平行，用 1 顆 CPU 多核心進行平行。 MPI: 多程序的平行，做到跨節點、跨 CPU 的平行 # MPI 語法 MPI_Init() : Initialize the MPI enviroment MPI_Comm_size(MPI_COMM_WORLD, &amp;world_size) : Get the number of processes MPI_Comm_rank(MPI_COMM_WORLD, &amp;process_rank) : Get the rank of process MPI_Finalize() : Finalize the MPI enviroment MPI_Wtime() : process time， return type is double MPI_Reduce(&amp;send, &amp;recv, count, dataType, MPI_Op, root, MPI_COMM_WORLD) : 把 send 的值經過 MPI_Op 的運算處理過後丟到 recv 中，變成 recv 的新值 MPI_Bcast(&amp;bcast, count, dataType, root, MPI_COMM_WORLD) : 把 root 的 bcast 廣播給大家 MPI_Recv(&amp;value, count, dataType, source, tag, MPI_COMM_WORLD, MPI_STATUS_IGNORE) : 將 source 的直接收 MPI_Send(&amp;value, count, dataType, dest, tag, MPI_COMM_WORLD) : 將值發送給 dest MPI_ALLreduce : 包括 MPI_Reduce 和 MPI_Bcast MPI_Scatter : 與 MPI_Bcast 很像，但區別於他是用於接收一個陣列，幫他分隔成不同區塊，然後同區塊傳給不同人 MPI_Gather : 與 MPI_Scatter 剛好相反，將不同的東西收到一起，集中到其中一個 MPI_Barrier() : 保證在通訊域內，所有的進程都已經執行完了呼叫之前的所有操作 可以用於要確保其他 processor 前面計算正確，到後面使用 在計算時間時可以確保計算大家都跑完的時間 # MPI_Op MPI_MIN : 找最小值 MPI_SUM : 計算總值 # MPI Hello World Code hello.c#include &lt;mpi.h>#include &lt;stdio.h>int main(int argc, char** argv) &#123; // Initialize the MPI environment MPI_Init(&amp;argc, &amp;argv); // Get the number of processes int world_size; MPI_Comm_size(MPI_COMM_WORLD, &amp;world_size); // Get the rank of the process int world_rank; MPI_Comm_rank(MPI_COMM_WORLD, &amp;world_rank); // Get the name of the processor char processor_name[MPI_MAX_PROCESSOR_NAME]; int name_len; MPI_Get_processor_name(processor_name, &amp;name_len); // Print off a hello world message printf(\"Hello world from processor %s, rank %d out of %d processors\\n\", processor_name, world_rank, world_size); // Finalize the MPI environment. MPI_Finalize(); return 0;&#125;","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"HPC","slug":"computer-science/HPC","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/HPC/"},{"name":"MPI","slug":"computer-science/HPC/MPI","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/HPC/MPI/"}],"tags":[]},{"title":"Nonogram Puzzles Solving","slug":"computer-science/HPC/Nonogram-Puzzles-Solving","date":"2023-12-13T06:17:27.000Z","updated":"2023-12-15T18:25:25.190Z","comments":true,"path":"computer-science/HPC/Nonogram-Puzzles-Solving/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/HPC/Nonogram-Puzzles-Solving/","excerpt":"","text":"# Nonogram Puzzle 規則 Input 1000 nonogram puzzles with size 25 * 25 symbol &quot;$&quot; before the puzzles number 50 lines of clues (puzzles description) The former 25 are clues at the top end from up to down The former 25 are clues at thr left end from left to right &quot;0&quot; 表示填空白，&quot;1&quot; 表示填黑色 All the numbers of clues and solutions are separated by TAB Each program solves these puzzles in order (cannot skip) For the puzzles with multiple solutions, the program only needs to generate 1 solution All of the programs will run on the same machine, use single CPU core. # Solving 一個 NP 完全問題 (NP - complete problems) # A Three-Stage Nonogram Solving Framework # Propagation Contionuously applies line solving to all rows and colums until no more pixels can be painted. 解一行或一列，看填 0 或填 1 有沒有解，如果有解再將相關的行和列再次丟入。 確認是否有解 Fix() : 看 paint 有沒有結束，且有沒有解 Fix0() : 看 paint 填 0 可不可以 Fix1() : 看 paint 填 1 可不可以 將有解確定盤面有解的盤面試著填點 Paint() : 看是否 paint 結束 Paint'() : 需要畫哪個盤面， paint0, paint1, merge Paint0() : 填入 0 Paint1() : 填入 1 Merge() : 看填入 0 或填入 1 有沒有相同的 # Fully Probing # Backtracking","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"HPC","slug":"computer-science/HPC","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/HPC/"}],"tags":[{"name":"stand-alone","slug":"stand-alone","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/stand-alone/"}]},{"title":"10041 - Vito's Family","slug":"coding/cpe/One Star/10041-Vito-s-Family","date":"2023-12-11T10:25:15.000Z","updated":"2023-12-11T10:51:13.847Z","comments":true,"path":"coding/cpe/One Star/10041-Vito-s-Family/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/10041-Vito-s-Family/","excerpt":"","text":"🌕🌗🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The world-known gangster Vito Deadstone is moving to New York. He has a very big family there, all of them living in Lamafia Avenue. Since he will visit all his relatives very often, he is trying to find a house close to them. Vito wants to minimize the total distance to all of them and has blackmailed you to write a program that solves his problem. # Input The input consists of several test cases. The first line contains the number of test cases. For each test case you will be given the integer number of relatives r (0 &lt; r &lt; 500) and the street numbers (also integers) s1, s2, . . . , si , . . . , sr where they live (0 &lt; si &lt; 30000 ) . Note that several relatives could live in the same street number. # Output For each test case your program must write the minimal sum of distances from the optimal Vito’s house to each one of his relatives. The distance between two street numbers si and sj is dij = | si − sj | . # Sample Input 2 2 2 4 3 2 4 6 # Sample Output 2 4 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int line = sc.nextInt(); for (int i = 0; i &lt; line; i++) &#123; int family = sc.nextInt(); int[] arr = new int[family]; for (int j = 0; j &lt; family; j++) &#123; arr[j] = sc.nextInt(); &#125; Arrays.sort(arr); int num = arr[family / 2]; int ans = 0; for (int j = 0; j &lt; family; j++) &#123; ans += Math.abs(arr[j] - num); &#125; System.out.println(ans); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"10038 - Jolly Jumpers","slug":"coding/cpe/One Star/10038-Jolly-Jumpers","date":"2023-12-11T10:07:36.000Z","updated":"2023-12-11T10:24:37.105Z","comments":true,"path":"coding/cpe/One Star/10038-Jolly-Jumpers/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/10038-Jolly-Jumpers/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 A sequence of n &gt; 0 integers is called a jolly jumper if the absolute values of the difference between successive elements take on all the values 1 through n − 1. For instance, 1 4 2 3 is a jolly jumper, because the absolutes differences are 3, 2, and 1 respectively. The definition implies that any sequence of a single integer is a jolly jumper. You are to write a program to determine whether or not each of a number of sequences is a jolly jumper. # Input Each line of input contains an integer n ≤ 3000 followed by n integers representing the sequence. # Output For each line of input, generate a line of output saying ‘Jolly’ or ‘Not jolly’. # Sample Input 4 1 4 2 3 5 1 4 2 -1 6 # Sample Output Jolly Not jolly # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNextInt()) &#123; int num = sc.nextInt(); int[] arr = new int[num]; int[] table = new int[num]; boolean iSJolly = true; for(int i = 0; i &lt; num; i++)&#123; arr[i] = sc.nextInt(); &#125; for(int i = 0; i &lt; num - 1; i++)&#123; int tmp = Math.abs(arr[i] - arr[i + 1]); if(tmp >= num || tmp == 0)&#123; iSJolly = false; break; &#125;else&#123; table[tmp]++; if(table[tmp] > 1)&#123; iSJolly = false; break; &#125; &#125; &#125; System.out.println((iSJolly ? \"Jolly\" : \"Not jolly\")); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"10035 - Primary Arithmetic","slug":"coding/cpe/One Star/10035-Primary-Arithmetic","date":"2023-12-11T05:12:08.000Z","updated":"2023-12-11T05:37:52.671Z","comments":true,"path":"coding/cpe/One Star/10035-Primary-Arithmetic/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/10035-Primary-Arithmetic/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Children are taught to add multi-digit numbers from right-to-left one digit at a time. Many find the “carry” operation - in which a 1 is carried from one digit position to be added to the next - to be a significant challenge. Your job is to count the number of carry operations for each of a set of addition problems so that educators may assess their difficulty. # Input Each line of input contains two unsigned integers less than 10 digits. The last line of input contains ‘0 0’. # Output For each line of input except the last you should compute and print the number of carry operations that would result from adding the two numbers, in the format shown below. # Sample Input 123 456 555 555 123 594 0 0 # Sample Output No carry operation. 3 carry operations. 1 carry operation. # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String num1 = sc.next(); String num2 = sc.next(); while (num1.charAt(0) != '0' || num2.charAt(0) != '0') &#123; int carry = 0; int count = 0; int max = Math.max(num1.length(), num2.length()); while (num1.length() &lt; max) &#123; num1 = \"0\" + num1; &#125; while (num2.length() &lt; max) &#123; num2 = \"0\" + num2; &#125; for (int i = max - 1; i >= 0; i--) &#123; int n1 = (int) (num1.charAt(i) - '0'); int n2 = (int) (num2.charAt(i) - '0'); int sum = n1 + n2 + carry; carry = sum / 10; if (carry == 1) &#123; count++; &#125; &#125; if (count == 0) &#123; System.out.println(\"No carry operation.\"); &#125; else &#123; System.out.println(count + \" carry \" + (count > 1 ? \"operations.\" : \"operation.\")); &#125; num1 = sc.next(); num2 = sc.next(); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"10019 - Funny Encryption Method","slug":"coding/cpe/One Star/10019-Funny-Encryption-Method","date":"2023-12-10T14:24:53.000Z","updated":"2023-12-11T05:10:57.616Z","comments":true,"path":"coding/cpe/One Star/10019-Funny-Encryption-Method/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/10019-Funny-Encryption-Method/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 A student from ITESM Campus Monterrey plays with a new encryption method for numbers. These method consist of the following steps: Steps : Example Read the number N to encrypt : M = 265 Interpret N as a decimal number : X1 = 265 (decimal) Convert the decimal interpretation of N to its binary representation : X1 = 100001001 (binary) Let b1 be equal to the number of 1’s in this binary representation : b1 = 3 Interpret N as a Hexadecimal number : X2 = 265 (hexadecimal) Convert the hexadecimal interpretation of N to its binary representation : X2 = 1001100101 Let b2 be equal to the number of 1’s in the last binary representation : b2 = 5 The encryption is the result of M xor (b1 ∗ b2) : 265 xor (3*5) = 262 This student failed Computational Organization, thats why this student asked the judges of ITESM Campus Monterrey internal ACM programming Contest to ask for the numbers of 1’s bits of this two representations so that he can continue playing. You have to write a program that read a Number and give as output the number b1 and b2 # Input The first line will contain a number N which is the number of cases that you have to process. Each of the following N Lines (0 &lt; N ≤ 1000) will contain the number M (0 &lt; M ≤ 9999, in decimal representation) which is the number the student wants to encrypt. # Output You will have to output N lines, each containing the number b1 and b2 in that order, separated by one space corresponding to that lines number to crypt # Sample Input 3 265 111 1234 # Sample Output 3 5 6 3 5 5 # 解題技巧 BigInteger n1 = new BigInteger(&quot;1234567890&quot;); 加減乘除運算 n1.add(n2); n1.subtract(n2); n1.multiply(n2); n1.divide(n2); 比較 n1.compareTo(n2); 變回字串 n1.toString(radix: ); # Solution Main.javaimport java.math.BigInteger;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); for(int i = 0; i &lt; N; i++)&#123; String M = sc.next(); String X1 = (new BigInteger(M, 10)).toString(2); String X2 = (new BigInteger(M, 16)).toString(2); int b1 = 0; int b2 = 0; for(int j = 0; j &lt; X1.length(); j++)&#123; if(X1.charAt(j) == '1') b1++; &#125; for(int j = 0; j &lt; X2.length(); j++)&#123; if(X2.charAt(j) == '1') b2++; &#125; System.out.println(b1 + \" \" + b2); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"10018 - Reverse and Add","slug":"coding/cpe/One Star/10018-Reverse-and-Add","date":"2023-12-10T10:16:07.000Z","updated":"2023-12-10T14:24:15.568Z","comments":true,"path":"coding/cpe/One Star/10018-Reverse-and-Add/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/10018-Reverse-and-Add/","excerpt":"","text":"🌕🌗🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The “reverse and add” method is simple: choose a number, reverse its digits and add it to the original. If the sum is not a palindrome (which means, it is not the same number from left to right and right to left), repeat this procedure. In this particular case the palindrome ‘9339’ appeared after the 4th addition. This method leads to palindromes in a few step for almost all of the integers. But there are interesting exceptions. 196 is the first number for which no palindrome has been found. It is not proven though, that there is no such a palindrome. You must write a program that give the resulting palindrome and the number of iterations (additions) to compute the palindrome. You might assume that all tests data on this problem: will have an answer , will be computable with less than 1000 iterations (additions), will yield a palindrome that is not greater than 4,294,967,295. # Input The first line will have a number N (0 &lt; N ≤ 100) with the number of test cases, the next N lines will have a number P to compute its palindrome. # Output For each of the N tests you will have to write a line with the following data : minimum number of iterations (a and the resulting palindrome itself separated by one space. # Sample Input 3 195 265 750 # Sample Output 4 9339 5 45254 3 6666 # 解題技巧 計算時 int 會不夠用 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String args[]) &#123; Scanner sc = new Scanner(System.in); int line = sc.nextInt(); for (int i = 0; i &lt; line; i++) &#123; String str = sc.next();; int count = 0; while (true) &#123; StringBuffer sb = new StringBuffer(str); String restr = sb.reverse().toString(); long tmp = Math.abs(Long.parseLong(str) + Long.parseLong(restr)); str = Long.toString(tmp); boolean isPalindrome = true; for(int j = 0; j &lt; str.length() / 2; j++)&#123; if(str.charAt(j) != str.charAt(str.length() - 1 -j))&#123; isPalindrome = false; &#125; &#125; count++; if(isPalindrome)&#123; break; &#125; &#125; System.out.println(count + \" \" + str); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"10008 - What's Cryptanalysis?","slug":"coding/cpe/One Star/10008-What-s-Cryptanalysis","date":"2023-12-10T09:43:55.000Z","updated":"2023-12-10T10:40:53.912Z","comments":true,"path":"coding/cpe/One Star/10008-What-s-Cryptanalysis/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/10008-What-s-Cryptanalysis/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Cryptanalysis is the process of breaking someone else’s cryptographic writing. This sometimes involves some kind of statistical analysis of a passage of (encrypted) text. Your task is to write a program which performs a simple analysis of a given text. # Input The first line of input contains a single positive decimal integer n. This is the number of lines which follow in the input. The next n lines will contain zero or more characters (possibly including whitespace). This is the text which must be analyzed. # Output Each line of output contains a single uppercase letter, followed by a single space, then followed by a positive decimal integer. The integer indicates how many times the corresponding letter appears in the input text. Upper and lower case letters in the input are to be considered the same. No other characters must be counted. The output must be sorted in descending count order; that is, the most frequent letter is on the first output line, and the last line of output indicates the least frequent letter. If two letters have the same frequency, then the letter which comes first in the alphabet must appear first in the output. If a letter does not appear in the text, then that letter must not appear in the output. # Sample Input 3 This is a test. Count me 1 2 3 4 5. Wow!!!! Is this question easy? # Sample Output S 7 T 6 I 5 E 4 O 3 A 2 H 2 N 2 U 2 W 2 C 1 M 1 Q 1 Y 1 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int[] arr = new int[26]; int max = 0; int line = sc.nextInt(); sc.nextLine(); for (int i = 0; i &lt; line; i++) &#123; String str = sc.nextLine(); for (char c : str.toCharArray()) &#123; if (c >= 'a' &amp;&amp; c &lt;= 'z') &#123; arr[c - 'a']++; if (arr[c - 'a'] > max) &#123; max = arr[c - 'a']; &#125; &#125; if (c >= 'A' &amp;&amp; c &lt;= 'Z') &#123; arr[c - 'A']++; if (arr[c - 'A'] > max) &#123; max = arr[c - 'A']; &#125; &#125; &#125; &#125; for (int i = max; i > 0; i--) &#123; for (int j = 0; j &lt; 26; j++) &#123; if (arr[j] == i) &#123; System.out.println((char) (j + 'A') + \" \" + i); &#125; &#125; &#125; &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"維護系網日誌","slug":"computer-science/Information-Security/Website/維護系網日誌","date":"2023-12-04T03:03:24.000Z","updated":"2024-01-12T06:31:58.663Z","comments":true,"path":"computer-science/Information-Security/Website/維護系網日誌/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Information-Security/Website/%E7%B6%AD%E8%AD%B7%E7%B3%BB%E7%B6%B2%E6%97%A5%E8%AA%8C/","excerpt":"","text":"本篇文章比較特別，比較像是日誌、紀錄，大家如果有相同問題可以參考，但不保證相同，單純想記錄酷酷的事。 # 前情提要 我在大二開始接觸學校系上網站，幫忙處理網頁開發以及學習網頁管理的部分，因為帶領我們開發的學長畢業了，所以我大三開始正式接管系網，很可惜我在這方面知識雖然有在學習，但是還是很需要歷練，也希望盡快可以不要當廢物哈哈哈。 # 2023.10.23 # 事件背景 系辦通知系網有部分頁面要修改，我們修改後將 docker image 推上 docker hub，然後在要部屬的伺服器 docker pull 下來，進行部屬。 我們 docker image 這些部分是利用 CI/CD 自動部屬的，而伺服器端是利用 docker watchtower 去檢查 docker hub 是否有更新，來確定是否需要重新 docker pull 下來，然後更新上去。 我們是利用 docker compose 將多個 images 一起跑起來的，包函了 frontend、backend、nginx、watchertower # 事件問題 在跑 CI/CD 流程時確定沒有問題，log 也顯示 success，但是系上網站卻沒有更新。 # 問題解決 經過詢問確定了是 docker watchtower 沒檢查到更新，因此我們將 docker watchtower 重啟。 # 處理步驟 進去虛擬機 先進到 docker-compose.yml 檔案的路徑 可以利用幾個方法，更具需求選擇指令 docker compose restart : Restart service containers docker compose stop : Stop services docker compose start : Start services docker compose down : Stop and remove conatiners, networks docker compose up : Create ans start containers docker compose rm : Removes stopped service comtainers docker compose create : Creates containers for a service docker compose ps : List containers docker compose ls : List running compose projects docker compose images : List images used by the created container docker compose exec : Excute a command in a running containers 最後重啟就可以了。 # 待釐清 利用 docker restart 重新啟動時，機器直接卡住。 # 2023.11.03 # 事件背景 我們後端利用 Strapi 來撰寫的，部屬的 port 原為預設值。 # 事件問題 因為 11 月中有教育部資安檢測，雖然本身這個可能不是甚麼漏洞，但我們希望可以更安全。 # 問題處理 我們將對外連接的 port 做了更改，對內在連回先前的，讓其他人不容易直接修改到真實的 port，修改有成功，不過由於這個要更改的東西眾多，我們目前只測試系統上使用，近期會再找時間進行正式版修正。 # 處理步驟 # 待釐清 port 傳接安全性提升多少。 # 2023.12.04 # 事情背景 學校在前天高電壓檢修有斷電，但是沒有特別通知到我，不過實驗室這邊的伺服器我們確定有關，但他是被用機器，小小說一下啊啊啊啊檢修完了沒有幫我開機，我還不知道他有關機，要用的時候發現關機了，差點嚇死，還好有先問學長，然後摸摸鼻子去開機，有點題外話了，但覺得這個也要記錄一下。 # 事件問題 今天真的是一大早，我還在早八的時候，系辦通知我說後端的資料傳不上去，我就上去後端看了一下發現是不論什麼資料都傳不上去。 然後就有了以下幾個猜測，我第一個想到的是可能是後端那邊的 server 有一些問題，想說把 docker compose restart 看看，結果不用沒事，一用直接出大事，我們發現他根本不能 start， 現在只能 stop，並顯示錯誤訊息，container 有存在，要 remove 或 rename，但是 docker compose rm 或 docker compose dowm 都不行，然後我就整個大清醒，真的我前天睡了一個小時，原本很想睡，直接清醒到我感覺我可以在醒個 48 小時，哈哈哈偏了偏了。 反正下來我就猜可能是 docker 要 restart，systemctl restart docker 之類的，但因為我們機器部屬在計網中心，所以我沒有 root 權限，沒辦法重啟，然後為了重啟我們通知了計網中心，沒想到計網中心一位同事要直接通報教育部資安問題，我真的更精神了，差一點嚇死，我要求他們重啟機器，但是他們說伺服器沒問題，所以沒有處理，當時我超無助啊！！！ 一下課我就狂奔我們系辦，然後系辦姊姊跟我教授幫我攔下了，讓我一個小時恢復，但因為我實在沒有權限，所以學長給我了一個建議，先把系網網址先轉到備用機，至少有東西可以看，我真的很謝謝學長給的建議，我看到了一絲希望，因為要我一個小時我想到的也只由重新部一個，但我完全忘記備用機這件事，真的很慌那時候，而且出事真得太早了，根本沒有人可以討論，不過就在我準備轉到備用機時，我們接到了一通電話...。 計網中心那為想通報的同事重啟了伺服器，然後把硬碟重組，我這裡的 docker 就好了，雖然我們猜測是因為斷電，但伺服器沒有提前關機才會如此，不過這只是猜測，我想我考完試想要找學長復盤，釐清處到底為什麼。 雖然我有一點覺得那個要通報的同事壞，不過想想他確實也是按照規定啦，但我們明明就有找到大致問題，只是沒權限處理，最後問題還出在別人那裡，當時候我真的很緊張。 # 問題處理 開啟靜態畫面，一頁式畫面 盡快處理問題","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Information-Security","slug":"computer-science/Information-Security","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Information-Security/"},{"name":"Website","slug":"computer-science/Information-Security/Website","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Information-Security/Website/"}],"tags":[{"name":"website","slug":"website","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/website/"}]},{"title":"Create Svelte Project","slug":"computer-science/program-language/Framework/Svelte/Create-Svelte-Project","date":"2023-11-15T05:44:22.000Z","updated":"2023-12-15T18:45:58.142Z","comments":true,"path":"computer-science/program-language/Framework/Svelte/Create-Svelte-Project/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/program-language/Framework/Svelte/Create-Svelte-Project/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # Create Project npm create svelte@latest &lt;project_name># Example: # 安裝套件管理工具 npm install# 把 dev 中的專案 run 起來 npm run dev剛 create 的 project run 起來會長這樣 # Project 結構介紹 .│ .gitignore│ .npmrc│ package-lock.json│ package.json│ README.md│ svelte.config.js│ tsconfig.json│ vite.config.ts │├─src│ │ app.d.ts│ │ app.html│ ││ ├─lib│ │ └─images│ │ github.svg│ │ svelte-logo.svg│ │ svelte-welcome.png│ │ svelte-welcome.webp│ ││ └─routes│ │ +layout.svelte│ │ +page.svelte│ │ +page.ts│ │ Counter.svelte│ │ Header.svelte│ │ styles.css│ ││ ├─about│ │ +page.svelte│ │ +page.ts│ ││ └─sverdle│ │ +page.server.ts│ │ +page.svelte│ │ game.ts│ │ reduced-motion.ts│ │ words.server.ts│ ││ └─how-to-play│ +page.svelte│ +page.ts│└─static favicon.png robots.txt# 參考網站 SvelteKit","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Programming Language","slug":"computer-science/program-language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/"},{"name":"Framework","slug":"computer-science/program-language/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/Framework/"},{"name":"Svelte","slug":"computer-science/program-language/Framework/Svelte","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/Framework/Svelte/"}],"tags":[]},{"title":"342. Power of Four","slug":"coding/leetcode/Easy/342-Power-of-Four","date":"2023-10-23T00:21:01.000Z","updated":"2023-12-15T19:03:58.531Z","comments":true,"path":"coding/leetcode/Easy/342-Power-of-Four/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/342-Power-of-Four/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer n , return true if it is a power of four. Otherwise, return false . An integer n is a power of four, if there exists an integer x such that n == 4^x . # Example 1 Input: n = 16 Output: true # Example 2 Input: n = 5 Output: false # Example 3 Input: n = 1 Output: true # 解題思路 # Solution class Solution &#123; public boolean isPowerOfFour(int n) &#123; while (n % 4 == 0 &amp;&amp; n > 0) &#123; n /= 4; &#125; return n == 1; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bit-Manipulation/"},{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"},{"name":"Recursion","slug":"Recursion","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Recursion/"}]},{"title":"介紹 Svelte","slug":"computer-science/program-language/Framework/Svelte/介紹-Svelte","date":"2023-10-22T08:44:33.000Z","updated":"2024-01-13T07:14:34.490Z","comments":true,"path":"computer-science/program-language/Framework/Svelte/介紹-Svelte/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/program-language/Framework/Svelte/%E4%BB%8B%E7%B4%B9-Svelte/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 簡介 這是一個在 2019 年，衝進大家視眼裡的一個前端框架。 在介紹此框架前，大家可能比較熟悉的三大前端框架是: React、Vue 或 Angular。 而這個前端框架有別於這三種，留一些懸念看下去吧！ # 特色 當應用程式運行時，像 React 和 Vue 等框架會在使用者的瀏覽器直接做它們想要做的事情，而 Svelte 則是將做的這些事移到編譯階段處理，因此那些做的事情只會發生在你建置應用程式的時候，進而能產生高度優化的原生 JavaScript 程式碼。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Programming Language","slug":"computer-science/program-language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/"},{"name":"Framework","slug":"computer-science/program-language/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/Framework/"},{"name":"Svelte","slug":"computer-science/program-language/Framework/Svelte","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/Framework/Svelte/"}],"tags":[]},{"title":"1425. Constrained Subsequence Sum","slug":"coding/leetcode/Hard/1425-Constrained-Subsequence-Sum","date":"2023-10-21T08:30:01.000Z","updated":"2023-12-15T19:05:59.798Z","comments":true,"path":"coding/leetcode/Hard/1425-Constrained-Subsequence-Sum/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/1425-Constrained-Subsequence-Sum/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 Given an integer array nums and an integer k , return the maximum sum of a non-empty subsequence of that array such that for every two consecutive integers in the subsequence, nums[i] and nums[j] , where i &lt; j , the condition j - i &lt;= k is satisfied. A subsequence of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order. # Example 1 Input: nums = [10,2,-10,5,20], k = 2 Output: 37 Explanation: The subsequence is [10, 2, 5, 20]. # Example 2 Input: nums = [-1,-2,-3], k = 1 Output: -1 Explanation: The subsequence must be non-empty, so we choose the largest number. # Example 3 Input: nums = [10,-2,-10,-5,20], k = 2 Output: 23 Explanation: The subsequence is [10, -2, -5, 20]. # 解題思路 # Solution import java.util.Arrays;import java.util.Deque;import java.util.LinkedList;public class Solution &#123; public int constrainedSubsetSum(int[] nums, int k) &#123; Deque&lt;Integer> dq = new LinkedList&lt;>(); for (int i = 0; i &lt; nums.length; i++) &#123; nums[i] += !dq.isEmpty() ? nums[dq.peekFirst()] : 0; while (!dq.isEmpty() &amp;&amp; (i - dq.peekFirst() >= k || nums[i] >= nums[dq.peekLast()])) &#123; if (nums[i] >= nums[dq.peekLast()]) dq.pollLast(); else dq.pollFirst(); &#125; if (nums[i] > 0) &#123; dq.offerLast(i); &#125; &#125; return Arrays.stream(nums).max().getAsInt(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Queue","slug":"Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Queue/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Monotonic Queue","slug":"Monotonic-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Monotonic-Queue/"}]},{"title":"1587 - Box","slug":"coding/cpe/One Star/1587-Box","date":"2023-10-20T19:27:55.000Z","updated":"2023-10-20T20:25:02.087Z","comments":true,"path":"coding/cpe/One Star/1587-Box/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/1587-Box/","excerpt":"","text":"🌕🌗🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Ivan works at a factory that produces heavy machinery. He has a simple job — he knocks up wooden boxes of different sizes to pack machinery for delivery to the customers. Each box is a rectangular parallelepiped. Ivan uses six rectangular wooden pallets to make a box. Each pallet is used for one side of the box. Joe delivers pallets for Ivan. Joe is not very smart and often makes mistakes — he brings Ivan pallets that do not fit together to make a box. But Joe does not trust Ivan. It always takes a lot of time to explain Joe that he has made a mistake. Fortunately, Joe adores everything related to computers and sincerely believes that computers never make mistakes. Ivan has decided to use this for his own advantage. Ivan asks you to write a program that given sizes of six rectangular pallets tells whether it is possible to make a box out of them. # Input Input file contains several test cases. Each of them consists of six lines. Each line describes one pallet and contains two integer numbers w and h (1 ≤ w, h ≤ 10 000) — width and height of the pallet in millimeters respectively. # Output For each test case, print one output line. Write a single word ‘POSSIBLE’ to the output file if it is possible to make a box using six given pallets for its sides. Write a single word ‘IMPOSSIBLE’ if it is not possible to do so. # Sample Input 1345 2584 2584 683 2584 1345 683 1345 683 1345 2584 683 1234 4567 1234 4567 4567 4321 4322 4567 4321 1234 4321 1234 # Sample Output POSSIBLE IMPOSSIBLE # 解題技巧 # Solution Main.javaimport java.util.*;class Box &#123; public int x, y; public Box(int x, int y) &#123; this.x = x; this.y = y; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNextInt()) &#123; Box[] box = new Box[6]; for (int i = 0; i &lt; 6; i++) &#123; int L = sc.nextInt(); int W = sc.nextInt(); box[i] = new Box(Math.max(L, W), Math.min(L, W)); &#125; Arrays.sort(box, new Comparator&lt;Box>() &#123; @Override public int compare(Box a, Box b) &#123; if (a.x == b.x) return a.y - b.y; return a.x - b.x; &#125; &#125;); boolean isBox = false; if (box[0].y == box[1].y &amp;&amp; box[1].y == box[2].y &amp;&amp; box[2].y == box[3].y &amp;&amp; box[2].x == box[3].x &amp;&amp; box[3].x == box[4].x &amp;&amp; box[4].x == box[5].x &amp;&amp; box[0].x == box[1].x &amp;&amp; box[1].x == box[4].y &amp;&amp; box[4].y == box[5].y) &#123; isBox = true; &#125; System.out.println(isBox ? \"POSSIBLE\" : \"IMPOSSIBLE\"); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"1585 - Score","slug":"coding/cpe/One Star/1585-Score","date":"2023-10-20T19:16:59.000Z","updated":"2023-10-20T19:27:18.307Z","comments":true,"path":"coding/cpe/One Star/1585-Score/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/1585-Score/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 There is an objective test result such as “OOXXOXXOOO” . An ‘O’ means a correct answer of a problem and an ‘X’ means a wrong answer. The score of each problem of this test is calculated by itself and its just previous consecutive ‘O’s only when the answer is correct. For example, the score of the 10th problem is 3 that is obtained by itself and its two previous consecutive ‘O’s . Therefore, the score of “OOXXOXXOOO” is 10 which is calculated by “1+2+0+0+1+0+0+1+2+3” . You are to write a program calculating the scores of test results. # Input Your program is to read from standard input. The input consists of T test cases. The number of test cases T is given in the first line of the input. Each test case starts with a line containing a string composed by ‘O’ and ‘X’ and the length of the string is more than 0 and less than 80. There is no spaces between ‘O’ and ‘X’ . # Output Your program is to write to standard output. Print exactly one line for each test case. The line is to contain the score of the test case. # Sample Input 5 OOXXOXXOOO OOXXOOXXOO OXOXOXOXOXOXOX OOOOOOOOOO OOOOXOOOOXOOOOX # Sample Output 10 9 7 55 30 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for(int i = 0; i &lt; T; i++)&#123; String input = sc.next(); int sum = 0; int value = 0; for(int j = 0; j &lt; input.length(); j++)&#123; if(input.charAt(j) == 'O')&#123; sum += (++value); &#125;else&#123; value = 0; &#125; &#125; System.out.println(sum); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"341. Flatten Nested List Iterator","slug":"coding/leetcode/Medium/341-Flatten-Nested-List-Iterator","date":"2023-10-20T09:15:37.000Z","updated":"2023-12-15T19:07:32.252Z","comments":true,"path":"coding/leetcode/Medium/341-Flatten-Nested-List-Iterator/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/341-Flatten-Nested-List-Iterator/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given a nested list of integers nestedList . Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it. Implement the NestedIterator class: NestedIterator(List&lt;NestedInteger&gt; nestedList) Initializes the iterator with the nested list nestedList . int next() Returns the next integer in the nested list. boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise. Your code will be tested with the following pseudocode: initialize iterator with nestedList res = [] while iterator.hasNext() append iterator.next() to the end of res return res If res matches the expected flattened list, then your code will be judged as correct. # Example 1 Input: nestedList = [[1,1],2,[1,1]] Output: [1,1,2,1,1] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1]. # Example 2 Input: nestedList = [1,[4,[6]]] Output: [1,4,6] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6]. # 解題思路 # Solution /** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * public interface NestedInteger &#123; * * // @return true if this NestedInteger holds a single integer, rather than a nested list. * public boolean isInteger(); * * // @return the single integer that this NestedInteger holds, if it holds a single integer * // Return null if this NestedInteger holds a nested list * public Integer getInteger(); * * // @return the nested list that this NestedInteger holds, if it holds a nested list * // Return empty list if this NestedInteger holds a single integer * public List&lt;NestedInteger> getList(); * &#125; */public class NestedIterator implements Iterator&lt;Integer> &#123; private List&lt;Integer> flattened; private int index; public NestedIterator(List&lt;NestedInteger> nestedList) &#123; flattened = new ArrayList&lt;>(); index = 0; flattened = flatten(nestedList); &#125; private List&lt;Integer> flatten(List&lt;NestedInteger> nested) &#123; List&lt;Integer> result = new ArrayList&lt;>(); for (NestedInteger ni : nested) &#123; if (ni.isInteger()) &#123; result.add(ni.getInteger()); &#125; else &#123; result.addAll(flatten(ni.getList())); &#125; &#125; return result; &#125; @Override public Integer next() &#123; return flattened.get(index++); &#125; @Override public boolean hasNext() &#123; return index &lt; flattened.size(); &#125;&#125;/** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i = new NestedIterator(nestedList); * while (i.hasNext()) v[f()] = i.next(); */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Queue","slug":"Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Queue/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Tree","slug":"Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Tree/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"Design","slug":"Design","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Design/"},{"name":"Iterator","slug":"Iterator","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Iterator/"}]},{"title":"What is watchtower?","slug":"computer-science/DevOps/Docker/What-is-watchtower","date":"2023-10-20T07:24:42.000Z","updated":"2023-12-15T18:59:45.403Z","comments":true,"path":"computer-science/DevOps/Docker/What-is-watchtower/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/What-is-watchtower/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 一個可以全自動幫你升級到最新 image 的工具 WatchTower 官方文件 https://containrrr.github.io/watchtower/ # 介紹 WatchTower 啓動後，會開始幫你監控機器上所有正在執行的 container，每隔一段時間發現有新的 image 後，它就會幫你下載最新 image 並且使用你當初建立該 container 時的相同環境設定去幫你重新啓動容器。 # 開啟 WatchTower 接下來會介紹兩個方式開啟 WatchTower: # docker 開啟 WatchTower docker run -d \\ --name watchtower \\ -v /var/run/docker.sock:/var/run/docker.sock \\ containrrr/watchtower# docker compose 開啟 WatchTower 基礎版 (單純開啟 watchtower) docker-compose.ymlversion: '1.0'services: nginx: image: nginx container_name: nginx ports: - 80:80 watchtower: image: containrrr/watchtower container_name: watchtower volumes: - /var/run/docker.sock:/var/run/docker.socknetworks: site: 參考詳細版 (包含建立 docker container website_frontend 和 website_backend) docker-compose.ymlversion: '1.0'services: nginx: build: . container_name: nginx restart: always environment: - TZ=Asia/Taipei volumes: - ./site:/var/www/html - ./nginx:/etc/nginx/conf.d - ./nginx/ssl/:/etc/nginx/ssl/:ro - ./nginx/log:/var/log/nginx ports: - 80:80 - 443:443 - 1337:1337 networks: - site website_frontend: image: [The-image-on-the-docker-hub-need-to-use:$&#123;MODE&#125;] container_name: website_frontend restart: always expose: - 3000 networks: - site website_backend: image: [The-image-on-the-docker-hub-need-to-use:$&#123;MODE&#125;] container_name: website_backend restart: always environment: - PUBLIC_URL=[] expose: - 1337 volumes: - ./website_backend/.backend_env:/opt/app/.env - ./website_backend/database/:/opt/app/.tmp/ - ./website_backend/media/:/opt/app/public/uploads networks: - site # 設置日誌 logging: driver: \"json-file\" options: max-size: \"10m\" max-file: \"3\" watchtower: image: containrrr/watchtower container_name: watchtower restart: always volumes: - /var/run/docker.sock:/var/run/docker.sock command: --interval 30 website_frontend website_backendnetworks: site:# 進階設置指令","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[]},{"title":"1368 - DNA Consensus String","slug":"coding/cpe/One Star/1368-DNA-Consensus-String","date":"2023-10-19T03:18:19.000Z","updated":"2023-10-20T19:16:43.495Z","comments":true,"path":"coding/cpe/One Star/1368-DNA-Consensus-String/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/1368-DNA-Consensus-String/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 DNA (Deoxyribonucleic Acid) is the molecule which contains the genetic instructions. It consists of four different nucleotides, namely Adenine, Thymine, Guanine, and Cytosine as shown in Figure 1. If we represent a nucleotide by its initial character, a DNA strand can be regarded as a long string (sequence of characters) consisting of the four characters A, T, G, and C. For example, assume we are given some part of a DNA strand which is composed of the following sequence of nucleotides: “Thymine-Adenine-Adenine-Cytosine-Thymine-Guanine-CytosineCytosine-Guanine-Adenine-Thymine” Then we can represent the above DNA strand with the string “TAACTGCCGAT.” The biologist Prof. Ahn found that a gene X commonly exists in the DNA strands of five different kinds of animals, namely dogs, cats, horses, cows, and monkeys. He also discovered that the DNA sequences of the gene X from each animal were very alike. See Figure 2. Prof. Ahn thought that humans might also have the gene X and decided to search for the DNA sequence of X in human DNA. However, before searching, he should define a representative DNA sequence of gene X because its sequences are not exactly the same in the DNA of the five animals. He decided to use the Hamming distance to define the representative sequence. The Hamming distance is the number of different characters at each position from two strings of equal length. For example, assume we are given the two strings “AGCAT” and “GGAAT.” The Hamming distance of these two strings is 2 because the 1st and the 3rd characters of the two strings are different. Using the Hamming distance, we can define a representative string for a set of multiple strings of equal length. Given a set of strings S = {s1, . . . , sm} of length n, the consensus error between a string y of length n and the set S is the sum of the Hamming distances between y and each si in S. If the consensus error between y and S is the minimum among all possible strings y of length n, y is called a consensus string of S. For example, given the three strings “AGCAT” “AGACT” and “GGAAT” the consensus string of the given strings is “AGAAT” because the sum of the Hamming distances between “AGAAT” and the three strings is 3 which is minimal. (In this case, the consensus string is unique, but in general, there can be more than one consensus string.) We use the consensus string as a representative of the DNA sequence. For the example of Figure 2 above, a consensus string of gene X is “GCAAATGGCTGTGCA” and the consensus error is 7. # Input Your program is to read from standard input. The input consists of T test cases. The number of test cases T is given in the first line of the input. Each test case starts with a line containing two integers m and n which are separated by a single space. The integer m (4 ≤ m ≤ 50) represents the number of DNA sequences and n (4 ≤ n ≤ 1000) represents the length of the DNA sequences, respectively. In each of the next m lines, each DNA sequence is given. # Output Your program is to write to standard output. Print the consensus string in the first line of each case and the consensus error in the second line of each case. If there exists more than one consensus string, print the lexicographically smallest consensus string. # Sample Input 3 5 8 TATGATAC TAAGCTAC AAAGATCC TGAGATAC TAAGATGT 4 10 ACGTACGTAC CCGTACGTAG GCGTACGTAT TCGTACGTAA 6 10 ATGTTACCAT AAGTTACGAT AACAAAGCAA AAGTTACCTT AAGTTACCAA TACTTACCAA # Sample Output TAAGATAC 7 ACGTACGTAA 6 AAGTTACCAA 12 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); Map&lt;Character, Integer> toInt = new HashMap&lt;>(); Map&lt;Integer, Character> toChar = new HashMap&lt;>(); toInt.put('A', 0); toInt.put('C', 1); toInt.put('G', 2); toInt.put('T', 3); toChar.put(0, 'A'); toChar.put(1, 'C'); toChar.put(2, 'G'); toChar.put(3, 'T'); int T = sc.nextInt(); for(int i = 0; i &lt; T; i++)&#123; int m = sc.nextInt(); int n = sc.nextInt(); char[][] arr = new char[m][n]; int[][] count = new int[n][4]; for(int j = 0; j &lt; m; j++)&#123; arr[j] = sc.next().toCharArray(); &#125; int total = 0; for(int j = 0; j &lt; n; j++)&#123; int max = -1; for(int k = 0; k &lt; m; k++)&#123; int temp = toInt.get(arr[k][j]); count[j][temp]++; max = Math.max(max, count[j][temp]); &#125; char output = ' '; for(int k = 3; k >= 0; k--)&#123; if(max == count[j][k])&#123; output = toChar.get(k); &#125; &#125; System.out.print(output); total += m - max; &#125; System.out.println(); System.out.println(total); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"844. Backspace String Compare","slug":"coding/leetcode/Easy/844-Backspace-String-Compare","date":"2023-10-19T01:24:51.000Z","updated":"2023-12-15T19:04:14.088Z","comments":true,"path":"coding/leetcode/Easy/844-Backspace-String-Compare/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/844-Backspace-String-Compare/","excerpt":"","text":"⭐️ # 題目敘述 Given two strings s and t , return true if they are equal when both are typed into empty text editors. '#' means a backspace character. Note that after backspacing an empty text, the text will continue empty. # Example 1 Input: s = &quot;ab#c&quot;, t = &quot;ad#c&quot; Output: true Explanation: Both s and t become &quot;ac&quot;. # Example 2 Input: s = &quot;ab##&quot;, t = &quot;c#d#&quot; Output: true Explanation: Both s and t become &quot;&quot;. # Example 3 Input: s = &quot;a#c&quot;, t = &quot;b&quot; Output: false Explanation: s becomes &quot;c&quot; while t becomes &quot;b&quot;. # 解題思路 # Solution import java.util.Stack;class Solution &#123; public boolean backspaceCompare(String s, String t) &#123; Stack&lt;Character> stackS = new Stack&lt;>(); Stack&lt;Character> stackT = new Stack&lt;>(); for(int i = 0; i &lt; s.length(); i++)&#123; if(s.charAt(i) == '#')&#123; if(stackS.size() != 0) stackS.pop(); &#125;else&#123; stackS.push(s.charAt(i)); &#125; &#125; for(int i = 0; i &lt; t.length(); i++)&#123; if(t.charAt(i) == '#')&#123; if(stackT.size() != 0) stackT.pop(); &#125;else&#123; stackT.push(t.charAt(i)); &#125; &#125; if(stackS.size() != stackT.size())&#123; return false; &#125; String compareS = stackS.toString(); String compareT = stackT.toString(); return compareS.equals(compareT); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"}]},{"title":"1237 - Expert Enough?","slug":"coding/cpe/One Star/1237-Expert-Enough","date":"2023-10-13T09:24:45.000Z","updated":"2023-10-13T11:46:25.279Z","comments":true,"path":"coding/cpe/One Star/1237-Expert-Enough/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/1237-Expert-Enough/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Auto-mobile Charting &amp; Manufacturing (ACM) is a company that specializes in manufacturing automobile spare parts. Being one of the leading automotive companies in the world, ACM are sure to keep up the latest information in that world. In the 100-year anniversary of the company, ACM compiled a huge list of range of prices of any automobiles ever recorded in the history. ACM then wants to develop a program that they called Automobile Expert System or AES for short. The program receives a price P as an input, and searches through the database for a car maker in which P falls in their range of lowest price L and highest price H of car they ever made. The program then output the car maker name. If the database contains no or more than one car maker that satisfies the query, the program produce output ‘UNDETERMINED’ (without quotes). Not so expert, huh? You are about to develop that program for ACM. # Input The input begins with a line containing an integer T (T ≤ 10) , the number of test cases follow. Each case begins with the size of the database D (D &lt; 10000) . The next each of D lines contains M , L and H (0 &lt; L &lt; H &lt; 1000000) which are the name of the maker (contains no whitespace and will never exceeds 20 characters), the car’s lowest price the maker ever made, and the car’s highest price the maker ever made respectively. Then there is the number of query Q (Q &lt; 1000) follows. Each of the next Q lines contains an integer P (0 &lt; P &lt; 1000000) , the query price. # Output Output for each query should be one line containing the name of the maker, or the string ‘UNDETERMINED’ (without quotes) if there is no maker or more than one maker that satisfies the query. You should separate output for different case by one empty line. # Sample Input 1 4 HONDA 10000 45000 PEUGEOT 12000 44000 BMW 30000 75900 CHEVROLET 7000 37000 4 60000 7500 5000 10000 # Sample Output BMW CHEVROLET UNDETERMINED UNDETERMINED # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int i = 0; i &lt; T; i++) &#123; if (i != 0) &#123; System.out.println(); &#125; int D = sc.nextInt(); Map&lt;String, int[]> map = new HashMap&lt;>(); for (int j = 0; j &lt; D; j++) &#123; String M = sc.next(); int[] LH = new int[2]; LH[0] = sc.nextInt(); LH[1] = sc.nextInt(); map.put(M, LH); &#125; int Q = sc.nextInt(); for (int j = 0; j &lt; Q; j++) &#123; int P = sc.nextInt(); boolean isOutput = false; String output = \" \"; for (String M : map.keySet()) &#123; int[] LH = map.get(M); if (P >= LH[0] &amp;&amp; P &lt;= LH[1]) &#123; if(isOutput)&#123; isOutput = false; break; &#125; isOutput = true; output = M; &#125; &#125; System.out.println((isOutput ? output : \"UNDETERMINED\")); &#125; &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"1225 - Digit Counting","slug":"coding/cpe/One Star/1225-Digit-Counting","date":"2023-10-13T08:23:49.000Z","updated":"2023-10-13T09:23:43.408Z","comments":true,"path":"coding/cpe/One Star/1225-Digit-Counting/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/1225-Digit-Counting/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Trung is bored with his mathematics homeworks. He takes a piece of chalk and starts writing a sequence of consecutive integers starting with 1 to N (1 &lt; N &lt; 10000) . After that, he counts the number of times each digit ( 0 to 9 ) appears in the sequence. For example, with N = 13 , the sequence is: 1234567891011121312345678910111213 12345678910111213 In this sequence, 0 appears once, 1 appears 6 times, 2 appears 2 times, 3 appears 3 times, and each digit from 4 to 9 appears once. After playing for a while, Trung gets bored again. He now wants to write a program to do this for him. Your task is to help him with writing this program. # Input The input file consists of several data sets. The first line of the input file contains the number of data sets which is a positive integer and is not bigger than 20 . The following lines describe the data sets. For each test case, there is one single line containing the number N . # Output For each test case, write sequentially in one line the number of digit 0, 1, . . . 9 separated by a space. # Sample Input 2 3 13 # Sample Output 0 1 1 1 0 0 0 0 0 0 1 6 2 2 1 1 1 1 1 1 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); int line = sc.nextInt(); int[][] arr = new int[10001][10]; for(int i = 1; i &lt;= 10000; i++)&#123; String num = Integer.toString(i); for(int j = 0; j &lt; 10; j++)&#123; arr[i][j] = arr[i - 1][j]; &#125; for(int j = 0; j &lt; num.length(); j++)&#123; arr[i][(int) (num.charAt(j) - '0')]++; &#125; &#125; for(int i = 0; i &lt; line; i++)&#123; int N = sc.nextInt(); int[] ans = arr[N]; for(int j = 0; j &lt; 10; j++)&#123; System.out.print((j != 0 ? \" \" : \"\") + ans[j]); &#125; System.out.println(\"\"); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"948 - Fibonaccimal Base","slug":"coding/cpe/One Star/948-Fibonaccimal-Base","date":"2023-10-13T07:19:03.000Z","updated":"2023-10-13T08:22:55.309Z","comments":true,"path":"coding/cpe/One Star/948-Fibonaccimal-Base/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/948-Fibonaccimal-Base/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The well known Fibonacci sequence is obtained by starting with 0 and 1 and then adding the two last numbers to get the next one. For example the third number in the sequence is 1 (1=1+0) , the forth is 2 (2=1+1) , the fifth is 3 (3=2+1) and so on. The sequence appears on many things in our life, in nature, and has a great significance. Among other things, do you know that all positive integer numbers can be represented as a sum of numbers in the Fibonacci sequence? More than that, all positive integers can be represented as a sum of a set of Fibonacci numbers, that is, numbers from the sequence, without repetition. For example: 13 can be the sum of the sets &#123;13&#125; , &#123;5,8&#125; or &#123;2,3,8&#125; and 17 is represented by &#123;1,3,13&#125; or &#123;1,3,5,8&#125; . Since all numbers have this property (do you want to try to prove this for yourself?) this set could be a nice way to use as a &quot;base&quot; to represent the number. But, as we have seen, some numbers have more than one set whose sum is the number. How can we solve that? Simple! If we add the constraint that the sets cannot have two consecutive Fibonacci numbers, than we have a unique representation for each number! This restriction is because the sum of any two consecutive Fibonacci numbers is just the following Fibonacci number. Now that we know all this we can prepare a nice way to represent any positive integer. We will use a binary sequence (just zeros and ones) to do that. For example, 17 = 1 + 3 + 13 (remember that no two consecutive Fibonacci numbers can be used). Let’s write a zero for each Fibonacci number that is not used and one for each one that is used, starting at the right. Then, 17 = 100101 . See figure 2 for a detailed explanation. In this representation we should not have zeros at the left, this is, we should only write starting with the first one. In order for you to understand better, note that in this scheme, not using two consecutive Fibonacci numbers means that the binary sequence will not have two consecutive ones. When we use this representation for a number we say that we are using the Fibonaccimal base, and we write it like 17 = 100101 (fib) . Given a set of numbers in decimal base, your task is to write them in the Fibonaccimal base. # Input The first line of input contains a single number N , representing the quantity of numbers that follow (1 ≤ N ≤ 500) . Than follow exactly N lines, each one containing a single positive integer smaller than 100 000 000 . These numbers can come in any order. # Output You should output a single line for each of the N integers in the input, with the format ‘DEC BASE = F IB BASE (fib)’ . DEC BASE is the original number in decimal base and FIB BASE is its representation in Fibonaccimal base. See the sample output for an example. # Sample Input 10 1 2 3 4 5 6 7 8 9 10 # Sample Output 1 = 1 (fib) 2 = 10 (fib) 3 = 100 (fib) 4 = 101 (fib) 5 = 1000 (fib) 6 = 1001 (fib) 7 = 1010 (fib) 8 = 10000 (fib) 9 = 10001 (fib) 10 = 10010 (fib) # 解題技巧 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); long[] fib = new long[50]; fib[0] = 1; fib[1] = 1; for(int i = 2; i &lt; 50; i++)&#123; fib[i] = fib[i - 1] + fib[i - 2]; &#125; for(int i = 0; i &lt; N; i++)&#123; long num = sc.nextLong(); System.out.print(num + \" = \"); String ans = \"\"; for(int j = (50 - 1); j >= 1; j--)&#123; if(num >= fib[j])&#123; ans += \"1\"; num -= fib[j]; &#125;else if(ans.length() != 0)&#123; ans += \"0\"; &#125; &#125; System.out.println(ans + \" (fib)\"); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"746. Min Cost Climbing Stairs","slug":"coding/leetcode/Easy/746-Min-Cost-Climbing-Stairs","date":"2023-10-13T04:32:48.000Z","updated":"2023-12-15T19:04:11.348Z","comments":true,"path":"coding/leetcode/Easy/746-Min-Cost-Climbing-Stairs/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/746-Min-Cost-Climbing-Stairs/","excerpt":"","text":"⭐️ # 題目敘述 You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps. You can either start from the step with index 0 , or the step with index 1 . Return the minimum cost to reach the top of the floor. # Example 1 Input: cost = [10,15,20] Output: 15 Explanation: You will start at index 1. Pay 15 and climb two steps to reach the top. The total cost is 15. # Example 2 Input: cost = [1,100,1,1,1,100,1,1,100,1] Output: 6 Explanation: You will start at index 0. Pay 1 and climb two steps to reach index 2. Pay 1 and climb two steps to reach index 4. Pay 1 and climb two steps to reach index 6. Pay 1 and climb one step to reach index 7. Pay 1 and climb two steps to reach index 9. Pay 1 and climb one step to reach the top. The total cost is 6. # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public int minCostClimbingStairs(int[] cost) &#123; int len = cost.length; int[] dp = new int[len]; Arrays.fill(dp, Integer.MAX_VALUE); dp[0] = cost[0]; dp[1] = cost[1]; for (int i = 1; i &lt; len; i++) &#123; dp[i] = Math.min(cost[i] + dp[i - 1], dp[i]); if (i + 1 != len) &#123; dp[i + 1] = Math.min(cost[i + 1] + dp[i - 1], dp[i + 1]); &#125; &#125; return Math.min(dp[len - 2], dp[len - 1]); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"913 - Joana and the Odd Numbers","slug":"coding/cpe/One Star/913-Joana-and-the-Odd-Numbers","date":"2023-10-12T12:42:18.000Z","updated":"2023-10-13T07:11:00.763Z","comments":true,"path":"coding/cpe/One Star/913-Joana-and-the-Odd-Numbers/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/913-Joana-and-the-Odd-Numbers/","excerpt":"","text":"🌕🌗🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Joana loves playing with odd numbers. In the other day, she started writing, in each line, an odd number of odd numbers. It looked as follows: 135791113151719212325272931...\\begin {matrix} &amp;1 &amp; &amp; &amp; &amp; &amp; &amp; \\\\ &amp;3 &amp;5 &amp;7 &amp; &amp; &amp; &amp;\\\\ &amp;9 &amp;11 &amp;13 &amp;15 &amp;17 &amp; &amp;\\\\ &amp;19 &amp;21 &amp;23 &amp;25 &amp;27 &amp;29 &amp;31\\\\ &amp;... &amp; &amp; &amp; &amp; &amp; &amp; \\end {matrix} ​13919...​51121​71323​1525​1727​29​31​ On a certain line Joana wrote 55 odd numbers. Can you discover the sum of the last three numbers written in that line? Can you do this more generally for a given quantity of odd numbers? Given the number N of odd numbers in a certain line, your task is to determine the sum of the last three numbers of that line. # Input The input is a sequence of lines, one odd number N (1 &lt; N &lt; 1000000000) per line # Output For each input line write the sum of the last three odd numbers written by Joana in that line with N numbers. This sum is guaranteed to be less than 263. # Sample Input 3 5 7 # Sample Output 15 45 87 # 解題技巧 這題雖然不難，但是要想得到運算的方法: line : 計算出 N 是第幾行 totalNum : 再利用行數計算出，到該行總共有幾個數字 lastNum : 最後利用總數字個數計算出該行最後一個奇數 ans : 藉由最後一個數字算出答案 提示: 因為 1 &lt; N &lt; 1000000000 ，所以要利用 long 。 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNextLong()) &#123; long N = sc.nextLong(); long line = (N + 1) / 2; long totalNum = line * line; long lastNum = 2 * (totalNum) - 1; long ans = (lastNum - 2) * 3; System.out.println(ans); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"}]},{"title":"1095. Find in Mountain Array","slug":"coding/leetcode/Hard/1095-Find-in-Mountain-Array","date":"2023-10-12T03:17:50.000Z","updated":"2023-12-15T19:05:56.850Z","comments":true,"path":"coding/leetcode/Hard/1095-Find-in-Mountain-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/1095-Find-in-Mountain-Array/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 (This problem is an interactive problem.) You may recall that an array arr is a mountain array if and only if: arr.length &gt;= 3 There exists some i with 0 &lt; i &lt; arr.length - 1 such that: arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i] arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1] Given a mountain array mountainArr , return the minimum index such that mountainArr.get(index) == target . If such an index does not exist, return -1 . You cannot access the mountain array directly. You may only access the array using a MountainArray interface: MountainArray.get(k) returns the element of the array at index k (0-indexed). MountainArray.length() returns the length of the array. Submissions making more than 100 calls to MountainArray.get will be judged Wrong Answer. Also, any solutions that attempt to circumvent the judge will result in disqualification. # Example 1 Input: array = [1,2,3,4,5,3,1], target = 3 Output: 2 Explanation: 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2. # Example 2 Input: array = [0,1,2,4,2,1], target = 3 Output: -1 Explanation: 3 does not exist in the array, so we return -1. # 解題思路 使用 Binary Search First: 找出 mountain value 的 index 用於將 array 拆成兩段再進行第二段的 binary search，一個由小到大、一個由大到小 Second: 找出前半段 (由小到大) 的 array 是否有與 target 相同的值， return 其 index Third: 找出後半段 (由大到小) 的 array 是否有與 target 相同的值， return 其 index 最後都沒有找到 return -1 # Solution /** * // This is MountainArray's API interface. * // You should not implement it, or speculate about its implementation * interface MountainArray &#123; * public int get(int index) &#123;&#125; * public int length() &#123;&#125; * &#125; */class Solution &#123; public int findInMountainArray(int target, MountainArray mountainArr) &#123; int len = mountainArr.length(); int left = 0; int right = len - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; int valueMid = mountainArr.get(mid); int valueLeft = mountainArr.get(mid - 1); int valueRight = mountainArr.get(mid + 1); if(valueLeft &lt; valueMid &amp;&amp; valueRight &lt; valueMid)&#123; left = mid; break; &#125; else if(valueLeft > valueMid &amp;&amp; valueRight &lt; valueMid)&#123; right = mid; &#125; else if(valueLeft &lt; valueMid &amp;&amp; valueRight > valueMid)&#123; left = mid; &#125; &#125; int leftLeft = 0; int leftRight = left; while(leftLeft &lt; leftRight)&#123; int mid = leftLeft + (leftRight - leftLeft) / 2; int valueMid = mountainArr.get(mid); if(target == valueMid)&#123; leftLeft = mid; break; &#125; if(target > valueMid)&#123; leftLeft = mid + 1; &#125;else if(target &lt; valueMid)&#123; leftRight = mid - 1; &#125; &#125; if(mountainArr.get(leftLeft) == target)&#123; return leftLeft; &#125; int rightLeft = left; int rightRight = len - 1; while(rightLeft &lt; rightRight)&#123; int mid = rightLeft + (rightRight - rightLeft) / 2; int valueMid = mountainArr.get(mid); if(target == valueMid)&#123; rightLeft = mid; break; &#125; else if(target > valueMid)&#123; rightRight = mid - 1; &#125;else if(target &lt; valueMid)&#123; rightLeft = mid + 1; &#125; &#125; if(mountainArr.get(rightLeft) == target)&#123; return rightLeft; &#125; return -1; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Interactive","slug":"Interactive","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Interactive/"}]},{"title":"865 - Substitution Cypher","slug":"coding/cpe/One Star/865-Substitution-Cypher","date":"2023-10-09T14:10:03.000Z","updated":"2023-10-12T12:43:26.442Z","comments":true,"path":"coding/cpe/One Star/865-Substitution-Cypher/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/865-Substitution-Cypher/","excerpt":"","text":"🌕🌗🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Substitution cyphers are the simplest of cyphers where the letters of one alphabet are substituted for the letters of another alphabet. In one form or another, they’ve been in use for over 2000 years. # Input The input begins with a single positive integer on a line by itself indicating the number of the cases following, each of them as described below. This line is followed by a blank line, and there is also a blank line between two consecutive inputs. a line containing the plaintext alphabet a line containing the substitution alphabet several lines of text # Output For each test case, the output must follow the description below. The outputs of two consecutive cases will be separated by a blank line. a line containing the substitution alphabet a line containing the plaintext alphabet the converted lines of text Please note: All lines will be at most 64 characters, plus a trailing end-of-line character. Pass through all characters not found in the plaintext alphabet. # Sample Input 1 abcdefghijklmnopqrstuvwxyz zyxwvutsrqponmlkjihgfedcba Shar’s Birthday: The birthday is October 6th, but the party will be Saturday, October 5. It’s my 24th birthday and the first one in some years for which I’ve been employed. Plus, I have new clothes. So I have cause to celebrate. More importantly, though, we’ve cleaned the house! The address is 506-D Albert Street. Extra enticement for CS geeks: there are several systems in the house, and the party is conveniently scheduled for 3 hours after the second CSC programming contest ends (not to mention, within easy walking distance)! # Sample Output zyxwvutsrqponmlkjihgfedcba abcdefghijklmnopqrstuvwxyz Sszi’h Brigswzb: Tsv yrigswzb rh Oxglyvi 6gs, yfg gsv kzigb droo yv Szgfiwzb, Oxglyvi 5. Ig’h nb 24gs yrigswzb zmw gsv urihg lmv rm hlnv bvzih uli dsrxs I’ev yvvm vnkolbvw. Pofh, I szev mvd xolgsvh. Sl I szev xzfhv gl xvovyizgv. Mliv rnkligzmgob, gslfts, dv’ev xovzmvw gsv slfhv! Tsv zwwivhh rh 506-D Aoyvig Sgivvg. Ecgiz vmgrxvnvmg uli CS tvvph: gsviv ziv hvevizo hbhgvnh rm gsv slfhv, zmw gsv kzigb rh xlmevmrvmgob hxsvwfovw uli 3 slfih zugvi gsv hvxlmw CSC kiltiznnrmt xlmgvhg vmwh (mlg gl nvmgrlm, drgsrm vzhb dzoprmt wrhgzmxv)! # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int line = sc.nextInt(); sc.nextLine(); sc.nextLine(); for (int i = 0; i &lt; line; i++) &#123; if(i != 0)&#123; System.out.println(\"\"); &#125; String a = sc.nextLine(); String b = sc.nextLine(); Map&lt;Character, Character> map = new HashMap&lt;>(); for (int j = 0; j &lt; a.length(); j++) &#123; map.put(a.charAt(j), b.charAt(j)); &#125; System.out.println(b); System.out.println(a); String str = sc.nextLine(); while (str.length() != 0) &#123; for(int j = 0; j &lt; str.length(); j++)&#123; char c = str.charAt(j); if (map.containsKey(c)) &#123; System.out.print(map.get(c)); &#125; else &#123; System.out.print(c); &#125; &#125; System.out.println(\"\"); if(sc.hasNextLine())&#123; str = sc.nextLine(); &#125;else&#123; break; &#125; &#125; &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"763 - Fibinary Numbers","slug":"coding/cpe/One Star/763-Fibinary-Numbers","date":"2023-10-09T10:32:55.000Z","updated":"2023-10-12T12:43:31.929Z","comments":true,"path":"coding/cpe/One Star/763-Fibinary-Numbers/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/763-Fibinary-Numbers/","excerpt":"","text":"🌕🌗🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The standard interpretation of the binary number 1010 is 8 + 2 = 10 . An alternate way to view the sequence “1010” is to use Fibonacci numbers as bases instead of powers of two. For this problem, the terms of the Fibonacci sequence are: 1,2,3,5,8,13,21,...1, 2, 3, 5, 8, 13, 21, . . . 1,2,3,5,8,13,21,... Where each term is the sum of the two preceding terms (note that there is only one 1 in the sequence as defined here). Using this scheme, the sequence “1010” could be interpreted as 1·5+0·3+1·2+0·1 = 7 . This representation is called a Fibinary number. Note that there is not always a unique Fibinary representation of every number. For example the number 10 could be represented as either 8 + 2 (10010) or as 5 + 3 + 2 (1110) . To make the Fibinary representations unique, larger Fibonacci terms must always be used whenever possible (i.e. disallow 2 adjacent 1 ’s). Applying this rule to the number 10 , means that 10 would be represented as 8+2 (10010) . Write a program that takes two valid Fibinary numbers and prints the sum in Fibinary form. # Input The input file contains several test cases with a blank line between two consecutive. Each test case consists in two lines with Fibinary numbers. These numbers will have at most 100 digits. # Output For each test case, print the sum of the two input numbers in Fibinary form. It must be a blank line between two consecutive outputs. # Sample Input 10010 1 10000 1000 10000 10000 # Sample Output 10100 100000 100100 # 解題技巧 BigInteger : 可以善用此方法，用於大數運算。 # Solution Main.javaimport java.math.BigInteger;import java.util.*;public class Main&#123; public static void main(String[] args)&#123; ArrayList&lt;BigInteger> fib = new ArrayList&lt;>(); fib.add(new BigInteger(\"1\")); fib.add(new BigInteger(\"2\")); for(int i = 2; i &lt; 101; i++)&#123; fib.add(fib.get(i - 1).add(fib.get(i - 2))); &#125; Scanner sc = new Scanner(System.in); while(sc.hasNext())&#123; String a = sc.next(); String b = sc.next(); BigInteger num = new BigInteger(\"0\"); for(int i = a.length() - 1, idx = 0; i >= 0; i--, idx++)&#123; num = num.add(fib.get(idx).multiply(new BigInteger(a.substring(i, i + 1)))); &#125; for(int i = b.length() - 1, idx = 0; i >= 0; i--, idx++)&#123; num = num.add(fib.get(idx).multiply(new BigInteger(b.substring(i, i + 1)))); &#125; String ans = \"\"; for(int i = 100; i >= 0; i--)&#123; if(!ans.equals(\"\") &amp;&amp; fib.get(i).compareTo(num) == 1)&#123; ans += \"0\"; &#125;else if(fib.get(i).compareTo(num) != 1)&#123; ans += \"1\"; num = num.subtract(fib.get(i)); &#125; &#125; System.out.println(ans.length() == 0 ? 0 : ans); if(sc.hasNext())&#123; System.out.println(\"\"); &#125; &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"737 - Gleaming the Cubes","slug":"coding/cpe/One Star/737-Gleaming-the-Cubes","date":"2023-10-09T06:58:16.000Z","updated":"2023-10-12T12:43:39.800Z","comments":true,"path":"coding/cpe/One Star/737-Gleaming-the-Cubes/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/737-Gleaming-the-Cubes/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 As chief engineer of the Starship Interprize, the task of repairing the hyperstellar, cubic, transwarpedout software has fallen on your shoulders. Simply put, you must compute the volume of the intersection of anywhere from 2 to 1000 cubes. # Input and Output The input data file consists of several sets of cubes for which the volume of their intersections must be computed. The first line of the data file contains a number (from 2 to 1000 ) which indicates the number of cubes which follow, one cube per line. Each line which describes a cube contains four integers. The first three integers are the x , y and z coordinates of the corner of a cube, and the fourth integer is the positive distance which the cube extends in each of the three directions (parallel to the x , y , and z axes) from that corner. Following the data for the first set of cubes will be a number which indicates how many cubes are in a second set, followed by the cube descriptions for the second set, again one per line. Following this will be a third set, and so on. Your program should continue to process sets of cubes, outputting the volume of their intersections to the output file, one set per line, until a zero is read for the number of cubes. Note that the data file will always contain at least one set of cubes, and every set will contain at least 2 and at most 1000 cubes. For any given set of cubes, the volume of their intersections will not exceed 1,000,000 units. # Sample Input 2 0 0 0 10 9 1 1 5 3 0 0 0 10 9 1 1 5 8 2 2 3 0 # Sample Output 25 9 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int cube = sc.nextInt(); while(cube != 0)&#123; int[][] arr = &lt;!--swig￼0-->; for(int i = 0; i &lt; cube; i++)&#123; int x = sc.nextInt(); int y = sc.nextInt(); int z = sc.nextInt(); int len = sc.nextInt(); arr[0][0] = Math.max(arr[0][0], x); arr[0][1] = Math.min(arr[0][1], x + len); arr[1][0] = Math.max(arr[1][0], y); arr[1][1] = Math.min(arr[1][1], y + len); arr[2][0] = Math.max(arr[2][0], z); arr[2][1] = Math.min(arr[2][1], z + len); &#125; int ans = (arr[0][1] - arr[0][0]) * (arr[1][1] - arr[1][0]) * (arr[2][1] - arr[2][0]); System.out.println(ans &lt; 0 ? 0 : ans); cube = sc.nextInt(); &#125; &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"725 - Division","slug":"coding/cpe/One Star/725-Division","date":"2023-10-09T05:17:42.000Z","updated":"2023-10-12T12:43:45.546Z","comments":true,"path":"coding/cpe/One Star/725-Division/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/725-Division/","excerpt":"","text":"🌕🌗🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Write a program that finds and displays all pairs of 5-digit numbers that between them use the digits 0 through 9 once each, such that the first number divided by the second is equal to an integer N, where 2 ≤ N ≤ 79 . That is, abcdefghij=N\\frac{abcde}{fghij} = N fghijabcde​=N where each letter represents a different digit. The first digit of one of the numerals is allowed to be zero. # Input Each line of the input file consists of a valid integer N . An input of zero is to terminate the program. # Output Your program have to display ALL qualifying pairs of numerals, sorted by increasing numerator (and, of course, denominator). Your output should be in the following general form: xxxxx / xxxxx = N xxxxx / xxxxx = N . . In case there are no pairs of numerals satisfying the condition, you must write ‘There are no solutions for N .’. Separate the output for two different values of N by a blank line. # Sample Input 61 62 0 # Sample Output There are no solutions for 61. 79546 / 01283 = 62 94736 / 01528 = 62 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); String sortNum = \" /0123456789\"; while(N != 0)&#123; ArrayList&lt;String> ans = new ArrayList&lt;>(); for(int i = 98765; i >= 1234; )&#123; if(i % N == 0)&#123; int num = i / N; String str = i + \" / \" + (num &lt; 10000 ? \"0\" + num : num); char[] c = str.toCharArray(); Arrays.sort(c); String temp = new String(c); if(temp.equals(sortNum))&#123; ans.add(str); &#125; i = i - N; &#125;else&#123; i--; &#125; &#125; if(ans.size() == 0)&#123; System.out.println(\"There are no solutions for \" + N + \".\"); &#125;else&#123; for(int i = ans.size() - 1; i >= 0; i--)&#123; System.out.println(ans.get(i) + \" = \" + N); &#125; &#125; N = sc.nextInt(); if(N != 0)&#123; System.out.println(\"\"); &#125; &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"34. Find First and Last Position of Element in Sorted Array","slug":"coding/leetcode/Medium/34-Find-First-and-Last-Position-of-Element-in-Sorted-Array","date":"2023-10-09T04:54:28.000Z","updated":"2023-12-15T19:06:55.539Z","comments":true,"path":"coding/leetcode/Medium/34-Find-First-and-Last-Position-of-Element-in-Sorted-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/34-Find-First-and-Last-Position-of-Element-in-Sorted-Array/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1] . You must write an algorithm with O(log n) runtime complexity. # Example 1 Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] # Example 2 Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] # Example 3 Input: nums = [], target = 0 Output: [-1,-1] # 解題思路 # Solution class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int[] ans = &#123;-1, -1&#125;; for(int i = 0; i &lt; nums.length; i++)&#123; if(target == nums[i] &amp;&amp; ans[0] == -1)&#123; ans[0] = i; &#125; if(target == nums[i])&#123; ans[1] = Math.max(ans[1], i); &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"}]},{"title":"706 - LC-Display","slug":"coding/cpe/One Star/706-LC-Display","date":"2023-10-06T16:25:05.000Z","updated":"2023-10-12T12:43:50.491Z","comments":true,"path":"coding/cpe/One Star/706-LC-Display/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/706-LC-Display/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 A friend of you has just bought a new computer. Until now, the most powerful computer he ever used has been a pocket calculator. Now, looking at his new computer, he is a bit disappointed, because he liked the LC-display of his calculator so much. So you decide to write a program that displays numbers in an LC-display-like style on his computer. # Input The input file contains several lines, one for each number to be displayed. Each line contains two integers s , n (1 ≤ s ≤ 10, 0 ≤ n ≤ 99 999 999) , where n is the number to be displayed and s is the size in which it shall be displayed. The input file will be terminated by a line containing two zeros. This line should not be processed. # Output Output the numbers given in the input file in an LC-display-style using s ‘-’ signs for the horizontal segments and s ‘|’ signs for the vertical ones. Each digit occupies exactly s + 2 columns and 2s + 3 rows. (Be sure to fill all the white space occupied by the digits with blanks, also for the last digit.) There has to be exactly one column of blanks between two digits. Output a blank line after each number. (You will find a sample of each digit in the sample output.) # Sample Input 2 12345 3 67890 0 0 # Sample Output # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int s = sc.nextInt(); String n = sc.next(); int[] row1 = &#123; 1, 0, 1, 1, 0, 1, 1, 1, 1, 1 &#125;; int[] col1 = &#123; 1, 0, 0, 0, 1, 1, 1, 0, 1, 1 &#125;; int[] col2 = &#123; 1, 1, 1, 1, 1, 0, 0, 1, 1, 1 &#125;; int[] row2 = &#123; 0, 0, 1, 1, 1, 1, 1, 0, 1, 1 &#125;; int[] col3 = &#123; 1, 0, 1, 0, 0, 0, 1, 0, 1, 0 &#125;; int[] col4 = &#123; 1, 1, 0, 1, 1, 1, 1, 1, 1, 1 &#125;; int[] row3 = &#123; 1, 0, 1, 1, 0, 1, 1, 0, 1, 1 &#125;; while (s != 0) &#123; char[] c = n.toCharArray(); for (int k = 0; k &lt; c.length; k++) &#123; if (k != 0) &#123; System.out.print(\" \"); &#125; int num = (int) (c[k] - '0'); System.out.print(\" \"); for (int i = 0; i &lt; s; i++) &#123; System.out.print((row1[num] == 1 ? \"-\" : \" \")); &#125; System.out.print(\" \"); &#125; System.out.println(\"\"); String temp = \"\"; for (int k = 0; k &lt; c.length; k++) &#123; if (k != 0) &#123; temp += \" \"; &#125; int num = (int) (c[k] - '0'); temp += col1[num] == 1 ? \"|\" : \" \"; for (int j = 0; j &lt; s; j++) &#123; temp += \" \"; &#125; temp += col2[num] == 1 ? \"|\" : \" \"; &#125; for (int i = 0; i &lt; s; i++) &#123; System.out.println(temp); &#125; for (int k = 0; k &lt; c.length; k++) &#123; if (k != 0) &#123; System.out.print(\" \"); &#125; int num = (int) (c[k] - '0'); System.out.print(\" \"); for (int i = 0; i &lt; s; i++) &#123; System.out.print((row2[num] == 1 ? \"-\" : \" \")); &#125; System.out.print(\" \"); &#125; System.out.println(\"\"); temp = \"\"; for (int k = 0; k &lt; c.length; k++) &#123; if (k != 0) &#123; temp += \" \"; &#125; int num = (int) (c[k] - '0'); temp += col3[num] == 1 ? \"|\" : \" \"; for (int j = 0; j &lt; s; j++) &#123; temp += \" \"; &#125; temp += col4[num] == 1 ? \"|\" : \" \"; &#125; for (int i = 0; i &lt; s; i++) &#123; System.out.println(temp); &#125; for (int k = 0; k &lt; c.length; k++) &#123; if (k != 0) &#123; System.out.print(\" \"); &#125; int num = (int) (c[k] - '0'); System.out.print(\" \"); for (int i = 0; i &lt; s; i++) &#123; System.out.print((row3[num] == 1 ? \"-\" : \" \")); &#125; System.out.print(\" \"); &#125; System.out.println(\"\"); System.out.println(\"\"); s = sc.nextInt(); n = sc.next(); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"630 - Anagrams (II)","slug":"coding/cpe/One Star/630-Anagrams-II","date":"2023-10-06T15:30:15.000Z","updated":"2023-10-12T12:43:54.508Z","comments":true,"path":"coding/cpe/One Star/630-Anagrams-II/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/630-Anagrams-II/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 One of the preferred kinds of entertainment of people living in final stages of XX century is filling in the crosswords. Almost every newspaper and magazine has a column dedicated to entertainment but only amateurs have enough after solving one crossword. Real professionals require more than one crossword for a week. And it is so dull — just crosswords and crosswords — while so many other riddles are waiting out there. For those are special, dedicated magazines. There are also quite a few competitions to take part in, even reaching the level of World Championships. Anyway — a lot. You were taken on by such a professional for whom riddle solving competing is just a job. He had a brilliant idea to use a computer in work not just to play games. Somehow anagrams found themselves first in the line. You are to write a program which searches for anagrams of given words, using a given vocabulary, tediously filled with new words by yours employer. # Input The first line contains T the number of test cases. There is a blank line after this. Then, T test cases follow — each separated by a blank line. Each test case has the following structure: &lt; number of words in vocabulary &gt; &lt; word 1 &gt; .............. &lt; word N &gt; &lt; test word 1 &gt; ................ &lt; test word k &gt; END &lt; number of words in vocabulary &gt; is an integer number N &lt; 1000 . &lt; word 1 &gt; up to &lt; word N &gt; are words from the vocabulary. &lt; test word 1 &gt; up to &lt; test word k &gt; are the words to find anagrams for. All words are lowercase (word ‘END’ means end of data — it is NOT a test word). You can assume all words are not longer than 20 characters. # Output For each &lt; test word &gt; — in the order in which it appeared — list the found anagrams in the following way: Anagrams for: &lt; test word &gt; &lt; No &gt;) &lt; anagram &gt; ............... &lt; No &gt; should be printed on 3 chars. In case of failing to find any anagrams your output should look like this: Anagrams for: &lt; test word &gt; No anagrams for: &lt;test word&gt; Print a blank line between datasets. # Sample Input 1 8 atol lato microphotographics rata rola tara tola pies tola kola aatr photomicrographics END # Sample Output Anagrams for: tola 1) atol 2) lato 3) tola Anagrams for: kola No anagrams for: kola Anagrams for: aatr 1) rata 2) tara Anagrams for: photomicrographics 1) microphotographics # 解題技巧 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for(int i = 0; i &lt; T; i++)&#123; if(i != 0)&#123; System.out.println(\"\"); &#125; int N = sc.nextInt(); String[] arr = new String[N]; for(int j = 0; j &lt; N; j++)&#123; arr[j] = sc.next(); &#125; String word = sc.next(); while(!word.equals(\"END\"))&#123; int test = 0; String remember = word; System.out.println(\"Anagrams for: \" + remember); boolean hasWord = false; char[] c = word.toCharArray(); Arrays.sort(c); word = new String(c); for(String a : arr)&#123; c = a.toCharArray(); Arrays.sort(c); if(word.equals(new String(c)))&#123; System.out.println(\" \" + (++test) + \") \" + a); hasWord = true; &#125; &#125; if(!hasWord)&#123; System.out.println(\"No anagrams for: \" + remember); &#125; word = sc.next(); &#125; &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"591 - Box of Bricks","slug":"coding/cpe/One Star/591-Box-of-Bricks","date":"2023-10-06T14:40:56.000Z","updated":"2023-10-12T12:43:59.779Z","comments":true,"path":"coding/cpe/One Star/591-Box-of-Bricks/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/591-Box-of-Bricks/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Little Bob likes playing with his box of bricks. He puts the bricks one upon another and builds stacks of different height. “Look, I’ve built a wall!”, he tells his older sister Alice. “Nah, you should make all stacks the same height. Then you would have a real wall.”, she retorts. After a little con- sideration, Bob sees that she is right. So he sets out to rearrange the bricks, one by one, such that all stacks are the same height afterwards. But since Bob is lazy he wants to do this with the minimum number of bricks moved. Can you help? # Input The input consists of several data sets. Each set begins with a line containing the number n of stacks Bob has built. The next line contains n numbers, the heights hi of the n stacks. You may assume 1 ≤ n ≤ 50 and 1 ≤ hi ≤ 100 . The total number of bricks will be divisible by the number of stacks. Thus, it is always possible to rearrange the bricks such that all stacks have the same height. The input is terminated by a set starting with n = 0 . This set should not be processed. # Output For each set, first print the number of the set, as shown in the sample output. Then print the line ‘The minimum number of moves is k .’, where k is the minimum number of bricks that have to be moved in order to make all the stacks the same height. Output a blank line after each set. # Sample Input 6 5 2 4 1 7 5 0 # Sample Output Set #1 The minimum number of moves is 5. # 解題技巧 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int k = sc.nextInt(); int idx = 0; while(k != 0)&#123; int[] arr = new int[k]; int sum = 0; int move = 0; for(int i = 0; i &lt; k; i++)&#123; arr[i] = sc.nextInt(); sum += arr[i]; &#125; int high = sum / k; for(int i = 0; i &lt; k; i++)&#123; if(arr[i] > high)&#123; move += (arr[i] - high); &#125; &#125; System.out.println(\"Set #\" + (++idx)); System.out.println(\"The minimum number of moves is \" + move + \".\"); System.out.println(\"\"); k = sc.nextInt(); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"579 - Clock Hands","slug":"coding/cpe/One Star/579-Clock-Hands","date":"2023-10-06T07:42:17.000Z","updated":"2023-10-12T12:44:06.171Z","comments":true,"path":"coding/cpe/One Star/579-Clock-Hands/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/579-Clock-Hands/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The medieval interest in mechanical contrivances is well illustrated by the development of the mechanical clock, the oldest of which is driven by weights and controlled by a verge, an oscillating arm engaging with a gear wheel. It dates back to 1386. Clocks driven by springs had appeared by the mid-15th century, making it possible to con- struct more compact mechanisms and preparing the way for the portable clock. English spring-driven pendulum clocks were first commonly kept on a small wall bracket and later on a shelf. Many bracket clocks contained a drawer to hold the winding key. The earliest bracket clocks, made for a period after 1660, were of architectural design, with pillars at the sides and a pediment on top. In 17th- and 18th-century France, the table clock became an object of monumental design, the best examples of which are minor works of sculpture. The longcase clocks (also called grandfather clocks) are tall pendulum clock enclosed in a wooden case that stands upon the floor and is typically from 6 to 7.5 feet (1.8 to 2.3 m) in height. Later, the name “grandfather clock” became popular after the popular song “My Grandfather’s Clock,” written in 1876 by Henry Clay Work. One of the first atomic clocks was an ammonia-controlled clock. It was built in 1949 at the National Bureau of Standards, Washington, D.C.; in this clock the frequency did not vary by more than one part in 108. Nuclear clocks are built using two clocks. The aggregate of atoms that emit the gamma radiation of precise frequency may be called the emitter clock; the group of atoms that absorb this radiation is the absorber clock. One pair of these nuclear clocks can detect energy changes of one part in 1014, being about 1,000 times more sensitive than the best atomic clock. The cesium clock is the most accurate type of clock yet developed. This device makes use of transitions between the spin states of the cesium nucleus and produces a frequency which is so regular that it has been adopted for establishing the time standard. The history of clocks is fascinating, but unrelated to this problem. In this problem, you are asked to find the angle between the minute hand and the hour hand on a regular analog clock. Assume that the second hand, if there were one, would be pointing straight up at the 12. Give all angles as the smallest positive angles. For example 9:00 is 90 degrees; not -90 or 270 degrees. # Input The input is a list of times in the form ‘H:M’ , each on their own line, with 1 ≤ H ≤ 12 and 00 ≤ M ≤ 59 . The input is terminated with the time ‘0:00’ . Note that H may be represented with 1 or 2 digits (for 1–9 or 10–12 , respectively); M is always represented with 2 digits (the input times are what you typically see on a digital clock). # Output The output displays the smallest positive angle in degrees between the hands for each time. The answer should between 0 degrees and 180 degrees for all input times. Display each angle on a line by itself in the same order as the input. The output should be rounded to the nearest 1/1000 , i.e., three places after the decimal point should be printed. # Sample Input 12:00 9:00 8:10 0:00 # Sample Output 0.000 90.000 175.000 # 解題技巧 注意: 時針在分針不為 0 時，也會偏移原本的數值，記得要計算！ # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String input = sc.next(); while (!input.equals(\"0:00\")) &#123; int hr = Integer.parseInt(input.split(\":\")[0]); int min = Integer.parseInt(input.split(\":\")[1]); double degreeH = hr * 360 / 12.0 + min * 360 / (12.0 * 60.0); double degreeM = min * 360 / 60.0; double ans = 0; ans = (degreeH > degreeM ? degreeH - degreeM : degreeM - degreeH); if (ans > 180) &#123; ans = 360 - ans; &#125; System.out.printf(\"%.3f\", ans); System.out.println(\"\"); input = sc.next(); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"}]},{"title":"499 - What's The Frequency, Kenneth?","slug":"coding/cpe/One Star/499-What-s-The-Frequency-Kenneth","date":"2023-10-06T06:26:26.000Z","updated":"2023-10-12T12:44:10.921Z","comments":true,"path":"coding/cpe/One Star/499-What-s-The-Frequency-Kenneth/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/499-What-s-The-Frequency-Kenneth/","excerpt":"","text":"🌕🌗🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 #include &lt;stdio.h>main()&#123; int i; char *suffix[] = &#123;\"st\", \"nd\", \"rd\"&#125;; char *item[] = &#123;\"Unix\", \"cat\", \"sed\", \"awk\", \"grep\", \"ed\", \"vi\"&#125;; printf(\"In the beginning, there was nothing.\\n\"); for (i = 0; i &lt; 7; i++) printf(\"And on the %d%s day, God created %s. And it was good.\\n\", i + 1, (i &lt; 3) ? suffix[i] : \"th\", item[i]);&#125;But then God saw that vi led people into temptation. Instead of choosing the righteous ways of make, dbx, and RCS, people used long command lines, printf(), and tape backups. So God decreed, “I see that Engineers have thus defiled my vi. And so, I shall create emacs, an editor more powerful than words. Further, for each instantiation vi hitherto, the Engineer responsible shalt perform Penance. And lo, the Penance wilt be painful; there will be much wailing and gnushingof teeth. The Engineer will read many lines of text. For each line of text, the Engineer must tell me which letters occur the most frequently.” “I charge you all with My Golden Rule: ’Friends shalt not let friends use vi’.” # Input The input file consists of a lot of lines of text. # Output A line of output should contain a list of letters that all occured with the highest frequency in the corresponding input line, followed by the frequency. The list of letters should be an alphabetical list of upper case letters followed by an alphabetical list of lower case letters. # Sample Input When riding your bicycle backwards down a one-way street, if the wheel falls of a canoe, how many ball bearings does it take to fill up a water buffalo? Hello Howard. # Sample Output e 6 al 7 a 3 Hlo 2 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) &#123; String input = sc.nextLine(); char[] arr = new char[26 + 26]; int max = 0; String ans = \"\"; for(char c : input.toCharArray())&#123; if(c >= 'A' &amp;&amp; c &lt;= 'Z')&#123; arr[c - 'A']++; &#125;else if(c >= 'a' &amp;&amp; c &lt;= 'z')&#123; arr[c - 'a' + 26]++; &#125; &#125; for(int i = 0; i &lt; 52; i++)&#123; if(arr[i] > max)&#123; max = arr[i]; ans = \"\"; &#125; if(arr[i] == max)&#123; if(i >= 26)&#123; ans += Character.toString((char) (i + 'a' - 26)); &#125;else&#123; ans += Character.toString((char) (i + 'A')); &#125; &#125; &#125; System.out.println(ans + \" \" + max); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"343. Integer Break","slug":"coding/leetcode/Medium/343-Integer-Break","date":"2023-10-06T05:59:24.000Z","updated":"2023-12-15T19:07:35.305Z","comments":true,"path":"coding/leetcode/Medium/343-Integer-Break/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/343-Integer-Break/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given an integer n , break it into the sum of k positive integers, where k &gt;= 2 , and maximize the product of those integers. Return the maximum product you can get. # Example 1 Input: n = 2 Output: 1 Explanation: 2 = 1 + 1, 1 × 1 = 1. # Example 2 Input: n = 10 Output: 36 Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36. # 解題思路 # Solution class Solution &#123; public int integerBreak(int n) &#123; if (n &lt;= 3) return n - 1; int quotient = n / 3, remainder = n % 3; if(remainder == 0)&#123; return (int) Math.pow(3, quotient); &#125;else if(remainder == 1)&#123; return (int) Math.pow(3, quotient - 1) * 4; &#125;else&#123; return (int) Math.pow(3, quotient) * 2; &#125; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"}]},{"title":"496 - Simply Subsets","slug":"coding/cpe/One Star/496-Simply-Subsets","date":"2023-10-05T17:23:58.000Z","updated":"2023-10-12T12:44:22.347Z","comments":true,"path":"coding/cpe/One Star/496-Simply-Subsets/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/496-Simply-Subsets/","excerpt":"","text":"🌕🌗🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 After graduating from the University of Notre Dame, you obtained a job at Top Shelf Software, Inc., as an entry-level computer engineer. On the first day, your manager sits down with you and tasks you with the following job: “We want to see how well you understand computer programming and the abstract science behind it. As an evaluation for all of our new hires, we require them to write a program to determine the relationship between pairs of sets. I’m quite sure that you’ll do well; my confidence is high. Here’s a list of requirements for what the program should do. Good luck.” # Input Your program should accept an even number of lines of text. Each pair of lines will represent two sets; the first line represents set A, the second line represents set B. Each line of text (set) will be a list of distinct integers. # Output After each pair of lines has been read in, the sets should be compared and one of the following responses should be output: A is a proper subset of B B is a proper subset of A A equals B A and B are disjoint I'm confused! # Sample Input 55 27 55 27 9 24 1995 9 24 1 2 3 1 2 3 4 1 2 3 4 5 6 1 2 2 3 # Sample Output A equals B B is a proper subset of A A is a proper subset of B A and B are disjoint I'm confused! # 解題技巧 利用 set 此資料結構，先將 setA 、 setB 利用另一個 set 將兩者存取在一起，進行判斷某個集合是否 equal 、 subset 、 disjoin 、 confused 。 equal : setA.size() == set.size() &amp;&amp; setB.size() == set.size() subset : setA.size() == set.size() or setB.size() == set.size() disjoin : setA.size() + setB.size() == set.size() confused : 以上都不是 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while(sc.hasNextLine())&#123; String inputA = sc.nextLine(); String inputB = sc.nextLine(); Set&lt;String> set = new HashSet&lt;>(); Set&lt;String> setA = new HashSet&lt;>(); Set&lt;String> setB = new HashSet&lt;>(); for(String temp : inputA.split(\" \"))&#123; set.add(temp); setA.add(temp); &#125; for(String temp : inputB.split(\" \"))&#123; set.add(temp); setB.add(temp); &#125; boolean isA = set.size() == setA.size(); boolean isB = set.size() == setB.size(); boolean isdisjoin = set.size() == setA.size() + setB.size(); if(isA &amp;&amp; isB)&#123; System.out.println(\"A equals B\"); &#125;else if(isA)&#123; System.out.println(\"B is a proper subset of A\"); &#125;else if(isB)&#123; System.out.println(\"A is a proper subset of B\"); &#125;else if(isdisjoin)&#123; System.out.println(\"A and B are disjoint\"); &#125;else&#123; System.out.println(\"I'm confused!\"); &#125; &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"494 - Kindergarten Counting Game","slug":"coding/cpe/One Star/494-Kindergarten-Counting-Game","date":"2023-10-05T17:12:08.000Z","updated":"2023-10-12T12:44:28.000Z","comments":true,"path":"coding/cpe/One Star/494-Kindergarten-Counting-Game/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/494-Kindergarten-Counting-Game/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Everybody sit down in a circle. Ok. Listen to me carefully. “Woooooo, you scwewy wabbit!” Now, could someone tell me how many words I just said? # Input Input to your program will consist of a series of lines, each line containing multiple words (at least one). A “word” is defined as a consecutive sequence of letters (upper and/or lower case). # Output Your program should output a word count for each line of input. Each word count should be printed on a separate line. # Sample Input Meep Meep! I tot I taw a putty tat. I did! I did! I did taw a putty tat. Shsssssssssh ... I am hunting wabbits. Heh Heh Heh Heh ... # Sample Output 2 7 10 9 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while(sc.hasNextLine())&#123; String input = sc.nextLine(); String[] arr = input.split(\"[^A-Za-z]\"); int count = 0; for(String a : arr)&#123; if(a.length() != 0)&#123; count++; &#125; &#125; System.out.println(count); &#125; &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"490 - Rotating Sentences","slug":"coding/cpe/One Star/490-Rotating-Sentences","date":"2023-10-05T16:26:25.000Z","updated":"2023-10-12T12:44:32.575Z","comments":true,"path":"coding/cpe/One Star/490-Rotating-Sentences/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/490-Rotating-Sentences/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 In “Rotating Sentences,” you are asked to rotate a series of input sentences 90 degrees clockwise. So instead of displaying the input sentences from left to right and top to bottom, your program will display them from top to bottom and right to left. # Input As input to your program, you will be given a maximum of 100 sentences, each not exceeding 100 characters long. Legal characters include: newline, space, any punctuation characters, digits, and lower case or upper case English letters. (NOTE: Tabs are not legal characters.) # Output The output of the program should have the last sentence printed out vertically in the leftmost column; the first sentence of the input would subsequently end up at the rightmost column. # Sample Input Rene Decartes once said, &quot;I think, therefore I am.&quot; # Sample Output &quot;R Ie n te h iD ne kc ,a r tt he es r eo fn oc re e s Ia i ad m, . &quot; # 解題技巧 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); ArrayList&lt;String> list = new ArrayList&lt;>(); int max = 0; while(sc.hasNextLine())&#123; String input = sc.nextLine(); list.add(input); max = Math.max(max, input.length()); &#125; for(int i = 0; i &lt; max; i++)&#123; for(int j = list.size() - 1; j >= 0; j--)&#123; String temp = list.get(j); if(temp.length() > i)&#123; System.out.print(temp.charAt(i)); &#125;else&#123; System.out.print(\" \"); &#125; &#125; System.out.println(\"\"); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"229. Majority Element II","slug":"coding/leetcode/Medium/229-Majority-Element-II","date":"2023-10-05T08:12:24.000Z","updated":"2023-12-15T19:07:21.002Z","comments":true,"path":"coding/leetcode/Medium/229-Majority-Element-II/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/229-Majority-Element-II/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given an integer array of size n , find all elements that appear more than ⌊ n/3 ⌋ times. # Example 1 Input: nums = [3,2,3] Output: [3] # Example 2 Input: nums = [1] Output: [1] # Example 3 Input: nums = [1,2] Output: [1,2] # 解題思路 # Solution import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;class Solution &#123; public List&lt;Integer> majorityElement(int[] nums) &#123; List&lt;Integer> ans = new ArrayList&lt;>(); Map&lt;Integer, Integer> map = new HashMap&lt;>(); int up = nums.length / 3; for(int num : nums)&#123; map.put(num, map.getOrDefault(num, 0) + 1); &#125; for(int key : map.keySet())&#123; if(map.get(key) > up)&#123; ans.add(key); &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Counting","slug":"Counting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Counting/"}]},{"title":"482 - Permutation Arrays","slug":"coding/cpe/One Star/482-Permutation-Arrays","date":"2023-10-04T08:14:35.000Z","updated":"2023-10-12T12:44:38.766Z","comments":true,"path":"coding/cpe/One Star/482-Permutation-Arrays/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/482-Permutation-Arrays/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 In many computer problems, it is necessary to permute data arrays. That is, the data in an array must be re-arranged in some specified order. One way to permute arbitrary data arrays is to specify the permutations with an index array to point out the position of the elements in the new array. Let x be an array that is to be permuted and let x′ be the permuted array. Then, we have the relationship between x and x′ that x′pi = xi . # Input The input begins with a single positive integer on a line by itself indicating the number of the cases following, each of them as described below. This line is followed by a blank line, and there is also a blank line between two consecutive inputs. Each input set will contain two lines of numbers. The first line will be an index array p containing the integers 1 . . . n , where n is the number of integers in the list. The numbers in the first line will have been permuted in some fashion. The second line will contain a list numbers in floating point format. # Output For each test case, the output must follow the description below. The outputs of two consecutive cases will be separated by a blank line. The output for this program will be the list of floating point numbers from the input set, ordered according to the permutation array from the input file. The output numbers must be printed one per line in the same format in which they each appeared in the input file. # Sample Input 1 3 1 2 32.0 54.7 -2 # Sample Output 54.7 -2 32.0 # 解題技巧 此問題在於如何解其中一排告知輸出順序，另一排為輸出內容，而要兩排將進行結合得知輸出為何。 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int cases = sc.nextInt(); for(int i = 0; i &lt; cases; i++)&#123; if(i != 0)&#123; System.out.println(\"\"); &#125; String temp = sc.nextLine(); while(temp.length() == 0)&#123; temp = sc.nextLine(); &#125; String[] index = temp.split(\" \"); String[] input = sc.nextLine().split(\" \"); String[] ans = new String[index.length]; for(int j = 0; j &lt; index.length; j++)&#123; ans[Integer.parseInt(index[j]) - 1] = input[j]; &#125; for(String a : ans)&#123; System.out.println(a); &#125; &#125; &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"706. Design HashMap","slug":"coding/leetcode/Easy/706-Design-HashMap","date":"2023-10-04T07:50:47.000Z","updated":"2023-12-15T19:04:07.183Z","comments":true,"path":"coding/leetcode/Easy/706-Design-HashMap/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/706-Design-HashMap/","excerpt":"","text":"⭐️ # 題目敘述 Design a HashMap without using any built-in hash table libraries. Implement the MyHashMap class: MyHashMap() initializes the object with an empty map. void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value . int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key . void remove(key) removes the key and its corresponding value if the map contains the mapping for the key . # Example 1 Input [&quot;MyHashMap&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;remove&quot;, &quot;get&quot;] [[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]] Output [null, null, null, 1, -1, null, 1, null, -1] Explanation MyHashMap myHashMap = new MyHashMap(); myHashMap.put(1, 1); // The map is now [[1,1]] myHashMap.put(2, 2); // The map is now [[1,1], [2,2]] myHashMap.get(1); // return 1, The map is now [[1,1], [2,2]] myHashMap.get(3); // return -1 (i.e., not found), The map is now [[1,1], [2,2]] myHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value) myHashMap.get(2); // return 1, The map is now [[1,1], [2,1]] myHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]] myHashMap.get(2); // return -1 (i.e., not found), The map is now [[1,1]] # 解題思路 # Solution import java.util.HashMap;import java.util.Map;class MyHashMap &#123; Map&lt;Integer, Integer> map; public MyHashMap() &#123; map = new HashMap&lt;>(); &#125; public void put(int key, int value) &#123; map.put(key, value); &#125; public int get(int key) &#123; return map.getOrDefault(key, -1); &#125; public void remove(int key) &#123; map.remove(key); &#125;&#125;/** * Your MyHashMap object will be instantiated and called as such: * MyHashMap obj = new MyHashMap(); * obj.put(key,value); * int param_2 = obj.get(key); * obj.remove(key); */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Linked-List/"},{"name":"Design","slug":"Design","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Design/"},{"name":"Hash Function","slug":"Hash-Function","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Function/"}]},{"title":"476 - Points in Figures: Rectangles","slug":"coding/cpe/One Star/476-Points-in-Figures-Rectangles","date":"2023-10-03T05:49:56.000Z","updated":"2023-10-12T12:44:46.736Z","comments":true,"path":"coding/cpe/One Star/476-Points-in-Figures-Rectangles/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/476-Points-in-Figures-Rectangles/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Given a list of rectangles and a list of points in the x-y plane, determine for each point which figures (if any) contain the point. # Input There will be n(≤ 10) rectangles descriptions, one per line. The first character will designate the type of figure (“r” for rectangle). This character will be followed by four real values designating the x-y coordinates of the upper left and lower right corners. The end of the list will be signalled by a line containing an asterisk in column one. The remaining lines will contain the x-y coordinates, one per line, of the points to be tested. The end of this list will be indicated by a point with coordinates 9999.9 9999.9; these values should not be included in the output. Points coinciding with a figure border are not considered inside. # Output For each point to be tested, write a message of the form: Point i is contained in figure j for each figure that contains that point. If the point is not contained in any figure, write a message of the form: Point i is not contained in any figure Points and figures should be numbered in the order in which they appear in the input. Note: See the picture on the right for a diagram of these figures and data points. # Sample Input r 8.5 17.0 25.5 -8.5 r 0.0 10.3 5.5 0.0 r 2.5 12.5 12.5 2.5 * 2.0 2.0 4.7 5.3 6.9 11.2 20.0 20.0 17.6 3.2 -5.2 -7.8 9999.9 9999.9 # Sample Output Point 1 is contained in figure 2 Point 2 is contained in figure 2 Point 2 is contained in figure 3 Point 3 is contained in figure 3 Point 4 is not contained in any figure Point 5 is contained in figure 1 Point 6 is not contained in any figure # 解題技巧 這題難點是要怎麼處理跟儲存資料，至於判斷 (x, y) 是否在某個 figure 中，可以利用 (x, y) 是否介於該 figure 中。 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String c = sc.next(); Map&lt;Integer, double[][]> figure = new HashMap&lt;>(); int figureCount = 0; while (!c.equals(\"*\")) &#123; double[][] f = new double[2][2]; figureCount++; f[0][0] = sc.nextDouble(); f[1][1] = sc.nextDouble(); f[0][1] = sc.nextDouble(); f[1][0] = sc.nextDouble(); figure.put(figureCount, f); c = sc.next(); &#125; int pointCount = 0; double x = sc.nextDouble(); double y = sc.nextDouble(); while (x != 9999.9 &amp;&amp; y != 9999.9) &#123; boolean check = false; pointCount++; for (int key : figure.keySet()) &#123; double[][] f = figure.get(key); if (f[0][0] &lt; x &amp;&amp; f[0][1] > x &amp;&amp; f[1][0] &lt; y &amp;&amp; f[1][1] > y) &#123; System.out.println(\"Point \" + pointCount + \" is contained in figure \" + key); check = true; &#125; &#125; if (!check) &#123; System.out.println(\"Point \" + pointCount + \" is not contained in any figure\"); &#125; x = sc.nextDouble(); y = sc.nextDouble(); &#125; &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"1512. Number of Good Pairs","slug":"coding/leetcode/Easy/1512-Number-of-Good-Pairs","date":"2023-10-03T03:46:46.000Z","updated":"2023-12-15T19:04:40.468Z","comments":true,"path":"coding/leetcode/Easy/1512-Number-of-Good-Pairs/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1512-Number-of-Good-Pairs/","excerpt":"","text":"⭐️ # 題目敘述 Given an array of integers nums , return the number of good pairs. A pair (i, j) is called good if nums[i] == nums[j] and i &lt; j . # Example 1 Input: nums = [1,2,3,1,1,3] Output: 4 Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed. # Example 2 Input: nums = [1,1,1,1] Output: 6 Explanation: Each pair in the array are good. # Example 3 Input: nums = [1,2,3] Output: 0 # 解題思路 # Solution import java.util.HashMap;import java.util.Map;class Solution &#123; public int numIdenticalPairs(int[] nums) &#123; Map&lt;Integer, Integer> map = new HashMap&lt;>(); for(int num : nums)&#123; map.put(num, map.getOrDefault(num, 0) + 1); &#125; int ans = 0; for(int key : map.keySet())&#123; for(int i = map.get(key) - 1; i > 0; i--)&#123; ans += i; &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"},{"name":"Counting","slug":"Counting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Counting/"}]},{"title":"2038. Remove Colored Pieces if Both Neighbors are the Same Color","slug":"coding/leetcode/Medium/2038-Remove-Colored-Pieces-if-Both-Neighbors-are-the-Same-Color","date":"2023-10-02T00:11:44.000Z","updated":"2023-12-15T19:09:05.596Z","comments":true,"path":"coding/leetcode/Medium/2038-Remove-Colored-Pieces-if-Both-Neighbors-are-the-Same-Color/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2038-Remove-Colored-Pieces-if-Both-Neighbors-are-the-Same-Color/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B' . You are given a string colors of length n where colors[i] is the color of the ith piece. Alice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first. Alice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A' . She is not allowed to remove pieces that are colored 'B' . Bob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B' . He is not allowed to remove pieces that are colored 'A'. Alice and Bob cannot remove pieces from the edge of the line. If a player cannot make a move on their turn, that player loses and the other player wins. Assuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins. # Example 1 Input: colors = &quot;AAABABB&quot; Output: true Explanation: AAABABB -&gt; AABABB Alice moves first. She removes the second 'A' from the left since that is the only 'A' whose neighbors are both 'A'. Now it's Bob's turn. Bob cannot make a move on his turn since there are no 'B's whose neighbors are both 'B'. Thus, Alice wins, so return true. # Example 2 Input: colors = &quot;AA&quot; Output: false Explanation: Alice has her turn first. There are only two 'A's and both are on the edge of the line, so she cannot move on her turn. Thus, Bob wins, so return false. # Example 3 Input: colors = &quot;ABBBBBBBAAA&quot; Output: false Explanation: ABBBBBBBAAA -&gt; ABBBBBBBAA Alice moves first. Her only option is to remove the second to last 'A' from the right. ABBBBBBBAA -&gt; ABBBBBBAA Next is Bob's turn. He has many options for which 'B' piece to remove. He can pick any. On Alice's second turn, she has no more pieces that she can remove. Thus, Bob wins, so return false. # 解題思路 # Solution import java.util.HashMap;import java.util.Map;public class Solution &#123; public boolean winnerOfGame(String colors) &#123; Map&lt;Character, Integer> map = new HashMap&lt;>(); map.put('A', 0); map.put('B', 0); for (int i = 0; i &lt; colors.length(); ) &#123; char x = colors.charAt(i); int count = 0; while (i &lt; colors.length() &amp;&amp; colors.charAt(i) == x) &#123; i++; count++; &#125; map.put(x, map.get(x) + Math.max(count - 2, 0)); &#125; return map.get('A') > map.get('B'); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"},{"name":"Game Theory","slug":"Game-Theory","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Game-Theory/"}]},{"title":"557. Reverse Words in a String III","slug":"coding/leetcode/Easy/557-Reverse-Words-in-a-String-III","date":"2023-10-01T12:49:17.000Z","updated":"2023-12-15T19:04:03.739Z","comments":true,"path":"coding/leetcode/Easy/557-Reverse-Words-in-a-String-III/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/557-Reverse-Words-in-a-String-III/","excerpt":"","text":"⭐️ # 題目敘述 Given a string s , reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. # Example 1 Input: s = &quot;Let's take LeetCode contest&quot; Output: &quot;s'teL ekat edoCteeL tsetnoc&quot; # Example 2 Input: s = &quot;God Ding&quot; Output: &quot;doG gniD&quot; # 解題思路 # Solution class Solution &#123; public String reverseWords(String s) &#123; String[] str = s.split(\" \"); StringBuilder ans = new StringBuilder(); for(String st : str)&#123; StringBuilder sb = new StringBuilder(st); ans.append(sb.reverse()); ans.append(\" \"); &#125; ans.deleteCharAt(ans.length() - 1); return ans.toString(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"}]},{"title":"905. Sort Array By Parity","slug":"coding/leetcode/Easy/905-Sort-Array-By-Parity","date":"2023-09-28T04:44:20.000Z","updated":"2023-12-15T19:04:19.805Z","comments":true,"path":"coding/leetcode/Easy/905-Sort-Array-By-Parity/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/905-Sort-Array-By-Parity/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer array nums , move all the even integers at the beginning of the array followed by all the odd integers. Return any array that satisfies this condition. # Example 1 Input: nums = [3,1,2,4] Output: [2,4,3,1] Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. # Example 2 Input: nums = [0] Output: [0] # 解題思路 用 for 迴圈遍歷 int[] nums 利用 deque 資料結構 若遇到數值為偶數的，利用 addFirst() 至於 deque 前面 若遇到數值為奇數的，利用 addLast() 至於 deque 後面 最後將 deque 轉成 int[] 輸出 註記: 將 LinkedList&lt;&gt; 轉成 int[] 陣列輸出為答案 list.stream().mapToInt(Integer::intValue).toArray(); queue.stream().mapToInt(Integer::intValue).toArray(); deque.stream().mapToInt(Integer::intValue).toArray(); # Solution import java.util.Deque;import java.util.LinkedList;class Solution &#123; public int[] sortArrayByParity(int[] nums) &#123; Deque&lt;Integer> dq = new LinkedList&lt;>(); for(int num : nums)&#123; if(num % 2 == 0)&#123; dq.addFirst(num); &#125;else&#123; dq.addLast(num); &#125; &#125; return dq.stream().mapToInt(Integer::intValue).toArray(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"}]},{"title":"458 - The Decoder","slug":"coding/cpe/One Star/458-The-Decoder","date":"2023-09-27T13:59:39.000Z","updated":"2023-10-12T12:44:51.639Z","comments":true,"path":"coding/cpe/One Star/458-The-Decoder/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/458-The-Decoder/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Write a complete program that will correctly decode a set of characters into a valid message. Your program should read a given file of a simple coded set of characters and print the exact message that the characters contain. The code key for this simple coding is a one for one character substitution based upon a single arithmetic manipulation of the printable portion of the ASCII character set. # Input &amp; Output For example: with the input file that contains: 1JKJ'pz'{ol'{yhklthyr'vm'{ol'Jvu{yvs'Kh{h'Jvywvyh{pvu5 1PIT'pz'h'{yhklthyr'vm'{ol'Pu{lyuh{pvuhs'I|zpulzz'Thjopul'Jvywvyh{pvu5 1KLJ'pz'{ol'{yhklthyr'vm'{ol'Kpnp{hs'Lx|pwtlu{'Jvywvyh{pvu5 your program should print the message: *CDC is the trademark of the Control Data Corporation. *IBM is a trademark of the International Business Machine Corporation. *DEC is the trademark of the Digital Equipment Corporation. Your program should accept all sets of characters that use the same encoding scheme and should print the actual message of each set of characters. # Sample Input 1JKJ'pz'{ol'{yhklthyr'vm'{ol'Jvu{yvs'Kh{h'Jvywvyh{pvu5 1PIT'pz'h'{yhklthyr'vm'{ol'Pu{lyuh{pvuhs'I|zpulzz'Thjopul'Jvywvyh{pvu5 1KLJ'pz'{ol'{yhklthyr'vm'{ol'Kpnp{hs'Lx|pwtlu{'Jvywvyh{pvu5 # Sample Output *CDC is the trademark of the Control Data Corporation. *IBM is a trademark of the International Business Machine Corporation. *DEC is the trademark of the Digital Equipment Corporation. # 解題技巧 這題也挺簡單的，相信直覺。 # Solution Main.c#include &lt;stdio.h>int main()&#123; char ch; while (scanf(\"%c\", &amp;ch) == 1)&#123; if (ch != '\\n') printf(\"%c\", ch - ('J' - 'C')); else printf(\"\\n\"); &#125; return 0;&#125; Main.cpp#include &lt;bits/stdc++.h>using namespace std;int main()&#123; string str; while(getline(cin, str))&#123; for(int i = 0; i &lt; str.length(); i++)&#123; cout &lt;&lt; (char)(str[i] - ('J' - 'C')); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; Main.javaimport java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;public class Main &#123; public static void main(String[] args) throws IOException &#123; DataInputStream in = new DataInputStream(System.in); DataOutputStream output = new DataOutputStream(System.out); int c; while ((c = in.read()) != -1) &#123; if (c == 10) &#123; output.write('\\n'); &#125; else &#123; output.write(c - 7); &#125; &#125; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"880. Decoded String at Index","slug":"coding/leetcode/Medium/880-Decoded-String-at-Index","date":"2023-09-27T13:00:06.000Z","updated":"2023-12-15T19:08:00.901Z","comments":true,"path":"coding/leetcode/Medium/880-Decoded-String-at-Index/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/880-Decoded-String-at-Index/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an encoded string s . To decode the string to a tape, the encoded string is read one character at a time and the following steps are taken: If the character read is a letter, that letter is written onto the tape. If the character read is a digit d , the entire current tape is repeatedly written d - 1 more times in total. Given an integer k , return the kth letter (1-indexed) in the decoded string. # Example 1 Input: s = &quot;leet2code3&quot;, k = 10 Output: &quot;o&quot; Explanation: The decoded string is &quot;leetleetcodeleetleetcodeleetleetcode&quot;. The 10th letter in the string is &quot;o&quot;. # Example 2 Input: s = &quot;ha22&quot;, k = 5 Output: &quot;h&quot; Explanation: The decoded string is &quot;hahahaha&quot;. The 5th letter is &quot;h&quot;. # Example 3 Input: s = &quot;a2345678999999999999999&quot;, k = 1 Output: &quot;a&quot; Explanation: The decoded string is &quot;a&quot; repeated 8301530446056247680 times. The 1st letter is &quot;a&quot;. # 解題思路 # Solution class Solution &#123; public String decodeAtIndex(String s, int k) &#123; long decodedLength = 0; for (char c : s.toCharArray()) &#123; if (Character.isDigit(c)) &#123; decodedLength *= (c - '0'); &#125; else &#123; decodedLength++; &#125; &#125; for (int i = s.length() - 1; i >= 0; i--) &#123; char currChar = s.charAt(i); if (Character.isDigit(currChar)) &#123; decodedLength /= (currChar - '0'); k %= decodedLength; &#125; else &#123; if (k == 0 || decodedLength == k) &#123; return String.valueOf(currChar); &#125; decodedLength--; &#125; &#125; return \"\"; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"}]},{"title":"455 - Periodic Strings","slug":"coding/cpe/One Star/455-Periodic-Strings","date":"2023-09-26T05:36:23.000Z","updated":"2023-10-12T12:44:58.707Z","comments":true,"path":"coding/cpe/One Star/455-Periodic-Strings/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/455-Periodic-Strings/","excerpt":"","text":"🌕🌗🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 A character string is said to have period k if it can be formed by concatenating one or more repetitions of another string of length k . For example, the string ”abcabcabcabc” has period 3 , since it is formed by 4 repetitions of the string ”abc” . It also has periods 6 (two repetitions of ”abcabc” ) and 12 (one repetition of ”abcabcabcabc” ). Write a program to read a character string and determine its smallest period. # Input The first line oif the input file will contain a single integer N indicating how many test case that your program will test followed by a blank line. Each test case will contain a single character string of up to 80 non-blank characters. Two consecutive input will separated by a blank line. # Output An integer denoting the smallest period of the input string for each input. Two consecutive output are separated by a blank line. # Sample Input 1 HoHoHo # Sample Output 2 # 解題技巧 暴力解，利用擷取 substring 然後再重新組裝 time = inputstring.length() / substring.length() 次，當 inputstring 與重新組裝的字串相同就表示 substring 為 inputstring 重複的字串，而 substring.length() 及為答案。 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); for (int i = 0; i &lt; N; i++) &#123; String str = sc.next(); if (i != 0) System.out.println(); int len = str.length(); for (int j = 0; j &lt; len; j++) &#123; int subLen = j + 1; if(len % subLen != 0) continue; String subStr = str.substring(0, subLen); int time = len / subLen; String compare = \"\"; for(int k = 0; k &lt; time; k++)&#123; compare += subStr; &#125; if(compare.equals(str))&#123; System.out.println(subLen); break; &#125; &#125; &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"316. Remove Duplicate Letters","slug":"coding/leetcode/Medium/316-Remove-Duplicate-Letters","date":"2023-09-26T03:48:36.000Z","updated":"2023-12-15T19:07:26.958Z","comments":true,"path":"coding/leetcode/Medium/316-Remove-Duplicate-Letters/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/316-Remove-Duplicate-Letters/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a string s , remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Lexicographically Smaller A string a is lexicographically smaller than a string b if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. If the first min(a.length, b.length) characters do not differ, then the shorter string is the lexicographically smaller one. # Example 1 Input: s = &quot;bcabc&quot; Output: &quot;abc&quot; # Example 2 Input: s = &quot;cbacdcbc&quot; Output: &quot;acdb&quot; # 解題思路 # Solution import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Set;import java.util.Stack;public class Solution &#123; public String removeDuplicateLetters(String s) &#123; Stack&lt;Character> stack = new Stack&lt;>(); Set&lt;Character> inStack = new HashSet&lt;>(); Map&lt;Character, Integer> lastCharIdx = new HashMap&lt;>(); for (int i = 0; i &lt; s.length(); i++) &#123; lastCharIdx.put(s.charAt(i), i); &#125; // get and save the last index with the char for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); if (!inStack.contains(c)) &#123; while (!stack.isEmpty() &amp;&amp; c &lt; stack.peek() &amp;&amp; i &lt; lastCharIdx.get(stack.peek())) &#123; inStack.remove(stack.pop()); &#125; // i &lt; lastCharIdx.get(stack.peek()) mean if stack.pop() value has next at behind we can remove that value. inStack.add(c); stack.push(c); &#125; &#125; StringBuilder ans = new StringBuilder(); for (char c : stack) &#123; ans.append(c); &#125; return ans.toString(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"Monotonic Stack","slug":"Monotonic-Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Monotonic-Stack/"}]},{"title":"389. Find the Difference","slug":"coding/leetcode/Easy/389-Find-the-Difference","date":"2023-09-25T15:09:56.000Z","updated":"2023-12-15T19:04:01.070Z","comments":true,"path":"coding/leetcode/Easy/389-Find-the-Difference/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/389-Find-the-Difference/","excerpt":"","text":"⭐️ # 題目敘述 You are given two strings s and t . String t is generated by random shuffling string s and then add one more letter at a random position. Return the letter that was added to t . # Example 1 Input: s = &quot;abcd&quot;, t = &quot;abcde&quot; Output: &quot;e&quot; Explanation: 'e' is the letter that was added. # Example 2 Input: s = &quot;&quot;, t = &quot;y&quot; Output: &quot;y&quot; # 解題思路 # Solution class Solution &#123; public char findTheDifference(String s, String t) &#123; char ans = 0; for(char c : s.toCharArray()) ans ^= c; for(char c : t.toCharArray()) ans ^= c; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bit-Manipulation/"}]},{"title":"409 - Excuses, Excuses!","slug":"coding/cpe/One Star/409-Excuses-Excuses","date":"2023-09-24T11:52:55.000Z","updated":"2023-10-12T12:45:04.117Z","comments":true,"path":"coding/cpe/One Star/409-Excuses-Excuses/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/409-Excuses-Excuses/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Judge Ito is having a problem with people subpoenaed for jury duty giving rather lame excuses in order to avoid serving. In order to reduce the amount of time required listening to goofy excuses, Judge Ito has asked that you write a program that will search for a list of keywords in a list of excuses identifying lame excuses. Keywords can be matched in an excuse regardless of case. # Input Input to your program will consist of multiple sets of data. Line 1 of each set will contain exactly two integers. The first number (1 ≤ K ≤ 20) defines the number of keywords to be used in the search. The second number (1 ≤ E ≤ 20) defines the number of excuses in the set to be searched. Lines 2 through K + 1 each contain exactly one keyword. Lines K + 2 through K + 1 + E each contain exactly one excuse. All keywords in the keyword list will contain only contiguous lower case alphabetic characters of length L(1 ≤ L ≤ 20) and will occupy columns 1 through L in the input line. All excuses can contain any upper or lower case alphanumeric character, a space, or any of the following punctuation marks [&quot;.,!?] not including the square brackets and will not exceed 70 characters in length. Excuses will contain at least 1 non-space character. # Output For each input set, you are to print the worst excuse(s) from the list. The worst excuse(s) is/are defined as the excuse(s) which contains the largest number of incidences of keywords. If a keyword occurs more than once in an excuse, each occurrance is considered a separate incidence. A keyword “occurs” in an excuse if and only if it exists in the string in contiguous form and is delimited by the beginning or end of the line or any non-alphabetic character or a space. For each set of input, you are to print a single line with the number of the set immediately after the string ‘Excuse Set #’ . (See the Sample Output). The following line(s) is/are to contain the worst excuse(s) one per line exactly as read in. If there is more than one worst excuse, you may print them in any order. After each set of output, you should print a blank line. # Sample Input 5 3 dog ate homework canary died My dog ate my homework. Can you believe my dog died after eating my canary... AND MY HOMEWORK? This excuse is so good that it contain 0 keywords. 6 5 superhighway crazy thermonuclear bedroom war building I am having a superhighway built in my bedroom. I am actually crazy. 1234567890.....,,,,,0987654321?????!!!!!! There was a thermonuclear war! I ate my dog, my canary, and my homework ... note outdated keywords? # Sample Output Excuse Set #1 Can you believe my dog died after eating my canary... AND MY HOMEWORK? Excuse Set #2 I am having a superhighway built in my bedroom. There was a thermonuclear war! # 解題技巧 map.put(count, map.getOrDefault(count, &quot;&quot;) + sentence + &quot;\\n&quot;); # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); int set = 0; while(sc.hasNextInt())&#123; int K = sc.nextInt(); int E = sc.nextInt(); ArrayList&lt;String> search = new ArrayList&lt;>(); Map&lt;Integer, String> map = new HashMap&lt;>(); int max = 0; for(int i = 0; i &lt; K; i++)&#123; String word = sc.next(); search.add(word.toLowerCase()); &#125; sc.nextLine(); for(int i = 0; i &lt; E; i++)&#123; String sentence = sc.nextLine(); String[] words = sentence.split(\"[^A-Za-z]\"); int count = 0; for(String word : words)&#123; if(search.contains(word.toLowerCase()))&#123; count++; &#125; &#125; map.put(count, map.getOrDefault(count, \"\") + sentence + \"\\n\"); // Online Judge Enter => \"\\n\" CPE Enter => \"\\r\\n\" max = Math.max(max, count); &#125; System.out.println(\"Excuse Set #\" + (++set)); System.out.println(map.get(max)); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"}]},{"title":"401 - Palindromes","slug":"coding/cpe/One Star/401-Palindromes","date":"2023-09-23T09:11:29.000Z","updated":"2023-10-12T12:45:10.165Z","comments":true,"path":"coding/cpe/One Star/401-Palindromes/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/401-Palindromes/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 A regular palindrome is a string of numbers or letters that is the same forward as backward. For example, the string “ABCDEDCBA” is a palindrome because it is the same when the string is read from left to right as when the string is read from right to left. A mirrored string is a string for which when each of the elements of the string is changed to its reverse (if it has a reverse) and the string is read backwards the result is the same as the original string. For example, the string “3AIAE” is a mirrored string because ‘A’ and ‘I’ are their own reverses, and ‘3’ and ‘E’ are each others’ reverses. A mirrored palindrome is a string that meets the criteria of a regular palindrome and the criteria of a mirrored string. The string “ATOYOTA” is a mirrored palindrome because if the string is read backwards, the string is the same as the original and because if each of the characters is replaced by its reverse and the result is read backwards, the result is the same as the original string. Of course, ‘A’ , ‘T’ , ‘O’ , and ‘Y’ are all their own reverses. A list of all valid characters and their reverses is as follows. Character Reverse Character Reverse Character Reverse A A M M Y Y B N Z 5 C O O 1 1 D P 2 S E 3 Q 3 E F R 4 G S 2 5 Z H H T T 6 I I U U 7 J L V V 8 8 K W W 9 L J X X Note that ‘0’ (zero) and ‘O’ (the letter) are considered the same character and therefore ONLY the letter ‘O’ is a valid character. # Input Input consists of strings (one per line) each of which will consist of one to twenty valid characters. There will be no invalid characters in any of the strings. Your program should read to the end of file. # Output For each input string, you should print the string starting in column 1 immediately followed by exactly one of the following strings. STRING CRITERIA ‘ -- is not a palindrome.’ if the string is not a palindrome and is not a mirrored string ‘ -- is a regular palindrome.’ if the string is a palindrome and is not a mirrored string ‘ -- is a mirrored string.’ if the string is not a palindrome and is a mirrored string ‘ -- is a mirrored palindrome.’ if the string is a palindrome and is a mirrored string Note that the output line is to include the ‘-’ s and spacing exactly as shown in the table above and demonstrated in the Sample Output below. In addition, after each output line, you must print an empty line. # Sample Input NOTAPALINDROME ISAPALINILAPASI 2A3MEAS ATOYOTA # Sample Output NOTAPALINDROME -- is not a palindrome. ISAPALINILAPASI -- is a regular palindrome. 2A3MEAS -- is a mirrored string. ATOYOTA -- is a mirrored palindrome. # 解題技巧 分別判斷是否為 palindrome 或 mirrored。 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); Map&lt;Character, Character> map = new HashMap&lt;>(); map.put('A', 'A'); map.put('E', '3'); map.put('H', 'H'); map.put('I', 'I'); map.put('J', 'L'); map.put('L', 'J'); map.put('M', 'M'); map.put('O', 'O'); map.put('S', '2'); map.put('T', 'T'); map.put('U', 'U'); map.put('V', 'V'); map.put('W', 'W'); map.put('X', 'X'); map.put('Y', 'Y'); map.put('Z', '5'); map.put('1', '1'); map.put('2', 'S'); map.put('3', 'E'); map.put('5', 'Z'); map.put('8', '8'); while (sc.hasNext()) &#123; String input = sc.next(); boolean isPalindrome = false; boolean isMirrored = true; StringBuilder sb = new StringBuilder(input); String reverseInput = sb.reverse().toString(); if (input.equals(reverseInput)) &#123; isPalindrome = true; &#125; for (int i = 0; i &lt;= input.length() / 2; i++) &#123; if (map.containsKey(input.charAt(i))) &#123; if (map.get(input.charAt(i)) != input.charAt(input.length() - i - 1)) &#123; isMirrored = false; break; &#125; &#125; else &#123; isMirrored = false; break; &#125; &#125; if (isPalindrome) &#123; if (isMirrored) &#123; System.out.println(input + \" -- is a mirrored palindrome.\"); &#125; else &#123; System.out.println(input + \" -- is a regular palindrome.\"); &#125; &#125; else &#123; if (isMirrored) &#123; System.out.println(input + \" -- is a mirrored string.\"); &#125; else &#123; System.out.println(input + \" -- is not a palindrome.\"); &#125; &#125; System.out.println(\"\"); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"}]},{"title":"389 - Basically Speaking","slug":"coding/cpe/One Star/389-Basically-Speaking","date":"2023-09-23T08:38:43.000Z","updated":"2023-10-12T12:45:16.897Z","comments":true,"path":"coding/cpe/One Star/389-Basically-Speaking/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/389-Basically-Speaking/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The Really Neato Calculator Company, Inc. has recently hired your team to help design their Super Neato Model I calculator. As a computer scientist you suggested to the company that it would be neato if this new calculator could convert among number bases. The company thought this was a stupendous idea and has asked your team to come up with the prototype program for doing base conversion. The project manager of the Super Neato Model I calculator has informed you that the calculator will have the following neato features: It will have a 7-digit display. Its buttons will include the capital letters A through F in addition to the digits 0 through 9 . It will support bases 2 through 16 . # Input The input for your prototype program will consist of one base conversion per line. There will be three numbers per line. The first number will be the number in the base you are converting from. It may have leading ‘0’ s. The second number is the base you are converting from. The third number is the base you are converting to. There will be one or more blanks surrounding (on either side of) the numbers. There are several lines of input and your program should continue to read until the end of file is reached. # Output The output will only be the converted number as it would appear on the display of the calculator. The number should be right justified in the 7-digit display. If the number is to large to appear on the display, then print ‘ERROR’ (without the quotes) right justified in the display. # Sample Input 1111000 2 10 1111000 2 16 2102101 3 10 2102101 3 15 12312 4 2 1A 15 2 ABCD 16 15 03 13 10 # Sample Output 120 78 1765 7CA ERROR 11001 D071 3 # 解題技巧 Java 可以利用 Integer 與 String 轉換來解決進位轉換的過程，可以說是超級的方便解這題，短短幾行解決。 String -&gt; Integer =&gt; Integer.parseInt(value, radix); Integer -&gt; String =&gt; Integer.toString(value, radix); # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); while(sc.hasNext())&#123; String input = sc.next(); int from = sc.nextInt(); int to = sc.nextInt(); String ans = (Integer.toString(Integer.parseInt(input, from), to)); System.out.printf(\"%7s\", (ans.length() > 7 ? \"ERROR\" : ans.toUpperCase())); System.out.println(); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"1048. Longest String Chain","slug":"coding/leetcode/Medium/1048-Longest-String-Chain","date":"2023-09-23T03:14:36.000Z","updated":"2023-12-15T19:08:23.539Z","comments":true,"path":"coding/leetcode/Medium/1048-Longest-String-Chain/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1048-Longest-String-Chain/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an array of words where each word consists of lowercase English letters. wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB . For example, &quot;abc&quot; is a predecessor of &quot;abac&quot; , while &quot;cba&quot; is not a predecessor of &quot;bcad&quot; . A word chain is a sequence of words [word1, word2, ..., wordk] with k &gt;= 1 , where word1 is a predecessor of word2 , word2 is a predecessor of word3 , and so on. A single word is trivially a word chain with k == 1 . Return the length of the longest possible word chain with words chosen from the given list of words . # Example 1 Input: words = [&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;] Output: 4 Explanation: One of the longest word chains is [&quot;a&quot;,&quot;ba&quot;,&quot;bda&quot;,&quot;bdca&quot;]. # Example 2 Input: words = [&quot;xbc&quot;,&quot;pcxbcf&quot;,&quot;xb&quot;,&quot;cxbc&quot;,&quot;pcxbc&quot;] Output: 5 Explanation: All the words can be put in a word chain [&quot;xb&quot;, &quot;xbc&quot;, &quot;cxbc&quot;, &quot;pcxbc&quot;, &quot;pcxbcf&quot;]. # Example 3 Input: words = [&quot;abcd&quot;,&quot;dbqca&quot;] Output: 1 Explanation: The trivial word chain [&quot;abcd&quot;] is one of the longest word chains. [&quot;abcd&quot;,&quot;dbqca&quot;] is not a valid word chain because the ordering of the letters is changed. # 解題思路 # Solution import java.util.Arrays;import java.util.HashMap;import java.util.Map;class Solution &#123; public int longestStrChain(String[] words) &#123; int ans = 0; Arrays.sort(words, (a, b) -> a.length() - b.length()); Map&lt;String, Integer> map = new HashMap&lt;>(); for(String word : words)&#123; map.put(word, 1); for(int i = 0; i &lt; word.length(); i++)&#123; String prev = word.substring(0, i) + word.substring(i + 1); if(map.containsKey(prev))&#123; map.put(word, Math.max(map.get(word), map.get(prev) + 1)); &#125; &#125; ans = Math.max(ans, map.get(word)); &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"}]},{"title":"386 - Perfect Cubes","slug":"coding/cpe/One Star/386-Perfect-Cubes","date":"2023-09-21T09:11:26.000Z","updated":"2023-10-12T12:45:20.950Z","comments":true,"path":"coding/cpe/One Star/386-Perfect-Cubes/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/386-Perfect-Cubes/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 For hundreds of years Fermat’s Last Theorem, which stated simply that for n &gt; 2 there exist no integers a, b, c &gt; 1 such that an=bn+cna^n = b^n + c^nan=bn+cn , has remained elusively unproven. (A recent proof is believed to be correct, though it is still undergoing scrutiny.) It is possible, however, to find integers greater than 1 that satisfy the “perfect cube” equation a3=b3+c3+d3a^3 = b^3 + c^3 + d^3a3=b3+c3+d3 (e.g. a quick calculation will show that the equation 123=63+83+10312^3 = 6^3 + 8^3 + 10^3123=63+83+103 is indeed true). This problem requires that you write a program to find all sets of numbers &#123;a, b, c, d&#125; which satisfy this equation for a ≤ 200 . # Output The output should be listed as shown below, one perfect cube per line, in non-decreasing order of a (i.e. the lines should be sorted by their a values). The values of b, c, and d should also be listed in non-decreasing order on the line itself. There do exist several values of a which can be produced from multiple distinct sets of b, c, and d triples. In these cases, the triples with the smaller b values should be listed first. The first part of the output is shown here: Cube = 6, Triple = (3,4,5) Cube = 12, Triple = (6,8,10) Cube = 18, Triple = (2,12,16) Cube = 18, Triple = (9,12,15) Cube = 19, Triple = (3,10,18) Cube = 20, Triple = (7,14,17) Cube = 24, Triple = (12,16,20) # 解題技巧 要避免掉 TLE，可以嘗試以 3 個 for 迴圈解題， cubeD = cubeA - cubeB - cubeC 來求出原本要跑第 4 次 for 迴圈的 cubeD ，來減少 time complexity。 # Solution Main.javapublic class Main &#123; public static void main(String[] args) &#123; for (int a = 2; a &lt;= 200; a++) &#123; int cubeA = (int) Math.pow(a, 3); for (int b = 2; b &lt; a; b++) &#123; int cubeB = (int) Math.pow(b, 3); for (int c = b + 1; c &lt; a; c++) &#123; int cubeC = (int) Math.pow(c, 3); int cubeD = cubeA - cubeB - cubeC; if(cubeC > cubeD)&#123; continue; &#125; int d = (int)Math.round(Math.pow(cubeD, 1.0/3)); if ((int)Math.pow(d, 3) == cubeD) &#123; System.out.println(\"Cube = \" + a + \", Triple = (\" + b + \",\" + c + \",\" + d + \")\"); &#125; &#125; &#125; &#125; &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"382 - Perfection","slug":"coding/cpe/One Star/382-Perfection","date":"2023-09-21T08:27:53.000Z","updated":"2023-10-12T12:45:28.540Z","comments":true,"path":"coding/cpe/One Star/382-Perfection/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/382-Perfection/","excerpt":"","text":"🌕🌗🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 From the article Number Theory in the 1994 Microsoft Encarta: “If a, b, c are integers such that a = bc, a is called a multiple of b or of c, and b or c is called a divisor or factor of a. If c is not ±1, b is called a proper divisor of a. Even integers, which include 0, are multiples of 2, for example, -4, 0, 2, 10; an odd integer is an integer that is not even, for example, -5, 1, 3, 9. A perfect number is a positive integer that is equal to the sum of all its positive, proper divisors; for example, 6, which equals 1 + 2 + 3, and 28, which equals 1 + 2 + 4 + 7 + 14, are perfect numbers. A positive number that is not perfect is imperfect and is deficient or abundant according to whether the sum of its positive, proper divisors is smaller or larger than the number itself. Thus, 9, with proper divisors 1, 3, is deficient; 12, with proper divisors 1, 2, 3, 4, 6, is abundant.” Your task is: Given a number, determine if it is perfect, abundant, or deficient. # Input A list of N positive integers (none greater than 60,000 ), with 1 &lt; N &lt; 100 . A ‘0’ will mark the end of the list. # Output The first line of output should read ‘PERFECTION OUTPUT’ . The next N lines of output should list for each input integer whether it is perfect, deficient, or abundant, as shown in the example below. Format counts: the echoed integers should be right justified within the first 5 spaces of the output line, followed by two blank spaces, followed by the description of the integer. The final line of output should read ‘END OF OUTPUT’ # Sample Input 15 28 6 56 60000 22 496 0 # Sample Output PERFECTION OUTPUT 15 DEFICIENT 28 PERFECT 6 PERFECT 56 ABUNDANT 60000 ABUNDANT 22 DEFICIENT 496 PERFECT END OF OUTPUT # 解題技巧 直覺解題，數論：整數分解的題目。 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); System.out.println(\"PERFECTION OUTPUT\"); while(n != 0)&#123; int sum = (n != 1 ? 1 : 0); for(int i = 2; i &lt;= Math.sqrt(n); i++)&#123; if(n % i == 0)&#123; int temp = n / i; sum += i; if(temp != i)&#123; sum += temp; &#125; &#125; &#125; if(sum > n)&#123; System.out.printf(\"%5d%s\", n, \" ABUNDANT\"); System.out.println(\"\"); &#125;else if(sum == n)&#123; System.out.printf(\"%5d%s\", n, \" PERFECT\"); System.out.println(\"\"); &#125;else&#123; System.out.printf(\"%5d%s\", n, \" DEFICIENT\"); System.out.println(\"\"); &#125; n = sc.nextInt(); &#125; System.out.println(\"END OF OUTPUT\"); sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"}]},{"title":"305 - Joseph","slug":"coding/cpe/One Star/305-Joseph","date":"2023-09-21T06:53:06.000Z","updated":"2023-10-12T12:45:35.029Z","comments":true,"path":"coding/cpe/One Star/305-Joseph/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/305-Joseph/","excerpt":"","text":"🌕🌗🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The Joseph’s problem is notoriously known. For those who are not familiar with the original problem: from among n people, numbered 1, 2, ..., n , standing in circle every m-th is going to be executed and only the life of the last remaining person will be saved. Joseph was smart enough to choose the position of the last remaining person, thus saving his life to give us the message about the incident. For example when n = 6 and m = 5 then the people will be executed in the order 5 , 4 , 6 , 2 , 3 and 1 will be saved. Suppose that there are k good guys and k bad guys. In the circle the first k are good guys and the last k bad guys. You have to determine such minimal m that all the bad guys will be executed before the first good guy. # Input The input file consists of separate lines containing k . The last line in the input file contains ‘0’ . You can suppose that 0 &lt; k &lt; 14 . # Output The output file will consist of separate lines containing m corresponding to k in the input file. # Sample Input 3 4 0 # Sample Output 5 30 # 解題技巧 理解題目，然後暴力解，小提示題目只有要求 0 &lt; k &lt; 14 可以在讀取輸入前先把答案存進陣列中，如果後面有重複輸入就不用再跑一次，避免 TLE。 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int[] arr = new int[15]; for (int k = 1; k &lt; 15; k++) &#123; int m = k + 1; while (true) &#123; int killed = -1; int group = k * 2; while (group > k) &#123; killed += m; killed %= group; if (killed &lt; k) &#123; break; &#125; killed--; group--; &#125; if(group == k)&#123; arr[k] = m; break; &#125; m++; &#125; &#125; int k = sc.nextInt(); while (k != 0) &#123; System.out.println(arr[k]); k = sc.nextInt(); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"299 - Train Swapping","slug":"coding/cpe/One Star/299-Train-Swapping","date":"2023-09-21T05:54:20.000Z","updated":"2023-10-12T12:45:39.156Z","comments":true,"path":"coding/cpe/One Star/299-Train-Swapping/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/299-Train-Swapping/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 At an old railway station, you may still encounter one of the last remaining “train swappers”. A train swapper is an employee of the railroad, whose sole job it is to rearrange the carriages of trains. Once the carriages are arranged in the optimal order, all the train driver has to do, is drop the carriages off, one by one, at the stations for which the load is meant. The title “train swapper” stems from the first person who performed this task, at a station close to a railway bridge. Instead of opening up vertically, the bridge rotated around a pillar in the center of the river. After rotating the bridge 90 degrees, boats could pass left or right. The first train swapper had discovered that the bridge could be operated with at most two carriages on it. By rotating the bridge 180 degrees, the carriages switched place, allowing him to rearrange the carriages (as a side effect, the carriages then faced the opposite direction, but train carriages can move either way, so who cares). Now that almost all train swappers have died out, the railway company would like to automate their operation. Part of the program to be developed, is a routine which decides for a given train the least number of swaps of two adjacent carriages necessary to order the train. Your assignment is to create that routine. # Input The input contains on the first line the number of test cases (N). Each test case consists of two input lines. The first line of a test case contains an integer L, determining the length of the train (0 ≤ L ≤ 50). The second line of a test case contains a permutation of the numbers 1 through L, indicating the current order of the carriages. The carriages should be ordered such that carriage 1 comes first, then 2, etc. with carriage L coming last. # Output For each test case output the sentence: ‘Optimal train swapping takes S swaps.’ where S is an integer. # Sample Input 3 3 1 3 2 4 4 3 2 1 2 2 1 # Sample Output Optimal train swapping takes 1 swaps. Optimal train swapping takes 6 swaps. Optimal train swapping takes 1 swaps. # 解題技巧 運用 sorting 演算法來解題，判斷要交換幾次可以解決。 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); for(int i = 0; i &lt; N; i++)&#123; int L = sc.nextInt(); int[] arr = new int[L]; int ans = 0; for(int j = 0; j &lt; L; j++)&#123; arr[j] = sc.nextInt(); &#125; for(int x = 0; x &lt; L; x++)&#123; for(int y = x + 1; y &lt; L; y++)&#123; if(arr[x] > arr[y])&#123; int temp = arr[x]; arr[x] = arr[y]; arr[y] = temp; ans++; &#125; &#125; &#125; System.out.println(\"Optimal train swapping takes \" + ans + \" swaps.\"); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"Sotring","slug":"Sotring","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sotring/"}]},{"title":"4. Median of Two Sorted Arrays","slug":"coding/leetcode/Hard/4-Median-of-Two-Sorted-Arrays","date":"2023-09-21T04:11:55.000Z","updated":"2023-12-15T19:05:25.079Z","comments":true,"path":"coding/leetcode/Hard/4-Median-of-Two-Sorted-Arrays/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/4-Median-of-Two-Sorted-Arrays/","excerpt":"","text":"⭐️⭐️⭐️⭐️ # 題目敘述 Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)) . # Example 1 Input: nums1 = [1,3], nums2 = [2] Output: 2.00000 Explanation: merged array = [1,2,3] and median is 2. # Example 2 Input: nums1 = [1,2], nums2 = [3,4] Output: 2.50000 Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5. # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int[] nums = new int[nums1.length + nums2.length]; int index = 0; for (int num : nums1) &#123; nums[index++] = num; &#125; for (int num : nums2) &#123; nums[index++] = num; &#125; Arrays.sort(nums); double ans = 0; int len = nums.length; if (len % 2 == 0) &#123; ans = (nums[len / 2 - 1] + nums[len / 2]) / 2.0; &#125; else &#123; ans = nums[len / 2]; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Divide-and-Conquer/"}]},{"title":"272 - TEX Quotes","slug":"coding/cpe/One Star/272-TEX-Quotes","date":"2023-09-20T14:48:20.000Z","updated":"2023-10-12T12:45:44.096Z","comments":true,"path":"coding/cpe/One Star/272-TEX-Quotes/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/272-TEX-Quotes/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 TEX is a typesetting language developed by Donald Knuth. It takes source text together with a few typesetting instructions and produces, one hopes, a beautiful document. Beautiful documents use “ and ” to delimit quotations, rather than the mundane &quot; which is what is provided by most keyboards. Keyboards typically do not have an oriented double-quote, but they do have a left-single-quote ` and a right-single-quote '. Check your keyboard now to locate the left-single-quote key ` (sometimes called the “backquote key”) and the right-single-quote key ' (sometimes called the “apostrophe” or just “quote”). Be careful not to confuse the left-single-quote ` with the “backslash” key . TEX lets the user type two left-single-quotes `` to create a left-double-quote “ and two right-single-quotes '' to create a right-double-quote ”. Most typists, however, are accustomed to delimiting their quotations with the un-oriented double-quote &quot;. If the source contained &quot;To be or not to be,&quot; quoth the bard, &quot;that is the question.&quot; then the typeset document produced by TEX would not contain the desired form: “To be or not to be,” quoth the bard, “that is the question.” In order to produce the desired form, the source file must contain the sequence: ``To be or not to be,'' quoth the bard, ``that is the question.'' You are to write a program which converts text containing double-quote (&quot;) characters into text that is identical except that double-quotes have been replaced by the two-character sequences required by TEX for delimiting quotations with oriented double-quotes. The double-quote (&quot;) characters should be replaced appropriately by either `` if the &quot; opens a quotation and by '' if the &quot; closes a quotation. Notice that the question of nested quotations does not arise: The first &quot; must be replaced by ``, the next by '', the next by ``, the next by '', the next by ``, the next by '', and so on. # Input Input will consist of several lines of text containing an even number of double-quote (&quot;) characters. Input is ended with an end-of-file character. # Output The text must be output exactly as it was input except that: the first &quot; in each pair is replaced by two ` characters: `` and the second &quot; in each pair is replaced by two ' characters: ''. # Sample Input &quot;To be or not to be,&quot; quoth the Bard, &quot;that is the question&quot;. The programming contestant replied: &quot;I must disagree. To `C' or not to `C', that is The Question!&quot; # Sample Output ``To be or not to be,' ' quoth the Bard, ``that is the question' '. The programming contestant replied: ``I must disagree. To `C' or not to `C', that is The Question!' ' # 解題技巧 運用讀取整行字串的方式解題，蠻直覺的題目。 # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int count = 0; while(sc.hasNextLine())&#123; String str = sc.nextLine(); for(int i = 0; i &lt; str.length(); i++)&#123; if(str.charAt(i) != '\\\"')&#123; System.out.print(str.charAt(i)); &#125;else if(count == 0)&#123; System.out.print(\"``\"); count = 1; &#125;else&#123; System.out.print(\"\\'\\'\"); count = 0; &#125; &#125; System.out.println(); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"264 - Count on Cantor","slug":"coding/cpe/One Star/264-Count-on-Cantor","date":"2023-09-20T06:20:25.000Z","updated":"2023-10-12T12:45:50.378Z","comments":true,"path":"coding/cpe/One Star/264-Count-on-Cantor/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/264-Count-on-Cantor/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 One of the famous proofs of modern mathematics is Georg Cantor’s demonstration that the set of rational numbers is enumerable. The proof works by using an explicit enumeration of rational numbers as shown in the diagram below. In the above diagram, the first term is 1/1 , the second term is 1/2 , the third term is 2/1 , the fourth term is 3/1 , the fifth term is 2/2 , and so on. # Input and Output You are to write a program that will read a list of numbers in the range from 1 to 107 and will print for each number the corresponding term in Cantor’s enumeration as given below. No blank line should appear after the last number. The input list contains a single number per line and will be terminated by end-of-file. # Sample Input 3 14 7 # Sample Output TERM 3 IS 2/1 TERM 14 IS 2/4 TERM 7 IS 1/4 # 解題技巧 sqrt(10^7 * 2) &lt; 4500 利用陣列計算當行最大的 num 會是多少 分子分母可以分開用兩個 int 儲存計算 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int max[] = new int[4500]; // sqrt(10^7 * 2) &lt; 4500 max[1] = 1; for(int i = 2; i &lt; 4500; i++)&#123; max[i] = max[i - 1] + i; &#125; while(sc.hasNextInt())&#123; int num = sc.nextInt(); int line = 0; int up = 0, down = 0; for(int i = 1; i &lt; 4500; i++)&#123; if(num &lt;= max[i])&#123; line = i; break; &#125; &#125; for(int i = 1; i &lt;= num - max[line - 1]; i++)&#123; if(line % 2 == 0)&#123; up = i; down = line + 1 - i; &#125;else&#123; down = i; up = line + 1 - i; &#125; &#125; System.out.println(\"TERM \" + num + \" IS \" + up + \"/\" + down); &#125; &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"}]},{"title":"1658. Minimum Operations to Reduce X to Zero","slug":"coding/leetcode/Medium/1658-Minimum-Operations-to-Reduce-X-to-Zero","date":"2023-09-20T01:23:58.000Z","updated":"2023-12-15T19:08:57.084Z","comments":true,"path":"coding/leetcode/Medium/1658-Minimum-Operations-to-Reduce-X-to-Zero/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1658-Minimum-Operations-to-Reduce-X-to-Zero/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an integer array nums and an integer x . In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x . Note that this modifies the array for future operations. Return the minimum number of operations to reduce x to exactly 0 if it is possible, otherwise, return -1 . # Example 1 Input: nums = [1,1,4,2,3], x = 5 Output: 2 Explanation: The optimal solution is to remove the last two elements to reduce x to zero. # Example 2 Input: nums = [5,6,7,8,9], x = 4 Output: -1 # Example 3 Input: nums = [3,2,20,1,1,3], x = 10 Output: 5 Explanation: The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero. # 解題思路 # Solution public class Solution &#123; public int minOperations(int[] nums, int x) &#123; int total = 0; for (int num : nums) &#123; total += num; &#125; int target = total - x; int left = 0; int n = nums.length; int maxWindow = -1; int sum = 0; for (int right = 0; right &lt; n; right++) &#123; sum += nums[right]; while (sum > target &amp;&amp; left &lt;= right) &#123; sum -= nums[left]; left++; &#125; if (sum == target) &#123; maxWindow = Math.max(maxWindow, right - left + 1); &#125; &#125; return maxWindow != -1 ? n - maxWindow : -1; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"}]},{"title":"263 - Number Chains","slug":"coding/cpe/One Star/263-Number-Chains","date":"2023-09-19T12:47:27.000Z","updated":"2023-10-12T12:45:55.503Z","comments":true,"path":"coding/cpe/One Star/263-Number-Chains/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/263-Number-Chains/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Given a number, we can form a number chain by arranging its digits in descending order arranging its digits in ascending order subtracting the number obtained in (2) from the number obtained (1) to form a new number and repeat these steps unless the new number has already appeared in the chain Note that 0 is a permitted digit. The number of distinct numbers in the chain is the length of the chain. You are to write a program that reads numbers and outputs the number chain and the length of that chain for each number read. # Input The input consists of a sequence of positive numbers, all less than 10910^9109, each on its own line, terminated by ‘0’ . The input file contains at most 5000 numbers. # Output The output consists of the number chains generated by the input numbers, followed by their lengths exactly in the format indicated below. After each number chain and chain length, including the last one, there should be a blank line. No chain will contain more than 1000 distinct numbers. # Sample Input 123456789 1234 444 0 # Sample Output Original number was 123456789 987654321 - 123456789 = 864197532 987654321 - 123456789 = 864197532 Chain length 2 Original number was 1234 4321 - 1234 = 3087 8730 - 378 = 8352 8532 - 2358 = 6174 7641 - 1467 = 6174 Chain length 4 Original number was 444 444 - 444 = 0 0 - 0 = 0 Chain length 2 # 解題技巧 利用到各種字串技巧: String 轉 char []: char[] c = str.toCharArray(); char [] 排序: Arrays.sort(c); char [] 轉 String: String str = new String(c); String 倒轉: StringBuilder sb = new StringBuilder(str); String reverseStr = sb.reverse().toString(); String 轉 int: int reverseInt = Integer.parseInt(reverseStr); # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String s = sc.next(); Set&lt;String> set = new HashSet&lt;>(); while (!s.equals(\"0\")) &#123; int count = 0; System.out.println(\"Original number was \" + s); set = new HashSet&lt;>(); while (true) &#123; char[] c = s.toCharArray(); Arrays.sort(c); String asc = new String(c); StringBuilder sb = new StringBuilder(asc); String des = sb.reverse().toString(); int desInt = Integer.parseInt(des); int ascInt = Integer.parseInt(asc); int next = desInt - ascInt; s = Integer.toString(next); System.out.println(desInt + \" - \" + ascInt + \" = \" + next); count++; if(set.contains(s))&#123; break; &#125;else&#123; set.add(s); &#125; &#125; System.out.println(\"Chain length \" + count); System.out.println(\"\"); s = sc.next(); &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"256 - Quirksome Squares","slug":"coding/cpe/One Star/256-Quirksome-Squares","date":"2023-09-19T05:20:02.000Z","updated":"2023-10-12T12:46:00.610Z","comments":true,"path":"coding/cpe/One Star/256-Quirksome-Squares/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/256-Quirksome-Squares/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The number 3025 has a remarkable quirk: if you split its decimal representation in two strings of equal length ( 30 and 25 ) and square the sum of the numbers so obtained, you obtain the original number: (30+25)2=3025(30 + 25)^2 = 3025 (30+25)2=3025 The problem is to determine all numbers with this property having a given even number of digits. For example, 4-digit numbers run from 0000 to 9999 . Note that leading zeroes should be taken into account. This means that 0001 which is equal to (00+01)2(00 + 01)^2(00+01)2 is a quirksome number of 4 digits. The number of digits may be 2 , 4 , 6 or 8 . Although maxint is only 32767 and numbers of eight digits are asked for, a well-versed programmer can keep his numbers in the range of the integers. However efficiency should be given a thought. # Input The input of your program is a textfile containing numbers of digits (taken from 2 , 4 , 6 , 8 ), each number on a line of its own. # Output The output is a textfile consisting of lines containing the quirksome numbers (ordered according to the input numbers and for each input number in increasing order). Warning: Please note that the number of digits in the output is equal to the number in the corresponding input line : leading zeroes may not be suppressed. # Sample Input 2 2 # Sample Output 00 01 81 00 01 81 # 解題技巧 利用運算解題，基本上就是直覺解。 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); Map&lt;Integer, ArrayList&lt;String>> map = new HashMap&lt;>(); for(int i = 2; i &lt;= 8; i = i + 2)&#123; int pow = (int)Math.pow(10, i / 2); ArrayList&lt;String> temp = new ArrayList&lt;>(); for(int a = 0; a &lt; pow; a++)&#123; for(int b = 0; b &lt; pow; b++)&#123; if(a * pow + b == Math.pow(a + b, 2))&#123; String t = Integer.toString(a * pow + b); while(t.length() &lt; i)&#123; t = \"0\" + t; &#125; temp.add(t); &#125; &#125; &#125; map.put(i, temp); &#125; while(sc.hasNextInt())&#123; int num = sc.nextInt(); ArrayList&lt;String> ans = map.get(num); for(String s : ans)&#123; System.out.println(s); &#125; &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"}]},{"title":"287. Find the Duplicate Number","slug":"coding/leetcode/Medium/287-Find-the-Duplicate-Number","date":"2023-09-19T04:37:41.000Z","updated":"2023-12-15T19:07:23.639Z","comments":true,"path":"coding/leetcode/Medium/287-Find-the-Duplicate-Number/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/287-Find-the-Duplicate-Number/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums , return this repeated number. You must solve the problem without modifying the array nums and uses only constant extra space. # Example 1 Input: nums = [1,3,4,2,2] Output: 2 # Example 2 Input: nums = [3,1,3,4,2] Output: 3 # 解題思路 利用 Set 資料結構來處理此題。 # Solution import java.util.HashSet;import java.util.Set;class Solution &#123; public int findDuplicate(int[] nums) &#123; Set&lt;Integer> set = new HashSet&lt;>(); for(int num : nums)&#123; if(set.contains(num))&#123; return num; &#125; set.add(num); &#125; return -1; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bit-Manipulation/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"}]},{"title":"1337. The K Weakest Rows in a Matrix","slug":"coding/leetcode/Easy/1337-The-K-Weakest-Rows-in-a-Matrix","date":"2023-09-18T04:03:18.000Z","updated":"2023-12-15T19:04:25.799Z","comments":true,"path":"coding/leetcode/Easy/1337-The-K-Weakest-Rows-in-a-Matrix/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1337-The-K-Weakest-Rows-in-a-Matrix/","excerpt":"","text":"⭐️ # 題目敘述 You are given an m x n binary matrix mat of 1 's (representing soldiers) and 0 's (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1 's will appear to the left of all the 0 's in each row. A row i is weaker than a row j if one of the following is true: The number of soldiers in row i is less than the number of soldiers in row j . Both rows have the same number of soldiers and i &lt; j . Return the indices of the k weakest rows in the matrix ordered from weakest to strongest. # Example 1 Input: mat = [[1,1,0,0,0], [1,1,1,1,0], [1,0,0,0,0], [1,1,0,0,0], [1,1,1,1,1]], k = 3 Output: [2,0,3] Explanation: The number of soldiers in each row is: Row 0: 2 Row 1: 4 Row 2: 1 Row 3: 2 Row 4: 5 The rows ordered from weakest to strongest are [2,0,3,1,4]. # Example 2 Input: mat = [[1,0,0,0], [1,1,1,1], [1,0,0,0], [1,0,0,0]], k = 2 Output: [0,2] Explanation: The number of soldiers in each row is: Row 0: 1 Row 1: 4 Row 2: 1 Row 3: 1 The rows ordered from weakest to strongest are [0,2,3,1]. # 解題思路 用 sorting 去完成。 # Solution import java.util.Arrays;class Solution &#123; public int[] kWeakestRows(int[][] mat, int k) &#123; int m = mat.length; int[][] rowAdd = new int[m][2]; for(int i = 0; i &lt; m; i++)&#123; int add = 0; for(int num : mat[i])&#123; add += num; &#125; rowAdd[i][0] = add; rowAdd[i][1] = i; &#125; Arrays.sort(rowAdd, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]); int[] ans = new int[k]; for(int i = 0; i &lt; k; i++)&#123; ans[i] = rowAdd[i][1]; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"}]},{"title":"145 - Gondwanaland Telecom","slug":"coding/cpe/One Star/145-Gondwanaland-Telecom","date":"2023-09-17T15:49:41.000Z","updated":"2023-10-12T12:46:07.224Z","comments":true,"path":"coding/cpe/One Star/145-Gondwanaland-Telecom/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/145-Gondwanaland-Telecom/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Gondwanaland Telecom makes charges for calls according to distance and time of day. The basis of the charging is contained in the following schedule, where the charging step is related to the distance: Charging Step (distance) Day Rate 8am to 6pm Evening Rate 6pm to 10pm Night Rate 10pm to 8am A 0.10 0.06 0.02 B 0.25 0.15 0.05 C 0.53 0.33 0.13 D 0.87 0.47 0.17 E 1.44 0.80 0.30 All charges are in dollars per minute of the call. Calls which straddle a rate boundary are charged according to the time spent in each section. Thus a call starting at 5:58 pm and terminating at 6:04 pm will be charged for 2 minutes at the day rate and for 4 minutes at the evening rate. Calls less than a minute are not recorded and no call may last more than 24 hours. Write a program that reads call details and calculates the corresponding charges. # Input Input lines will consist of the charging step (upper case letter ‘A’..‘E’), the number called (a string of 7 digits and a hyphen in the approved format) and the start and end times of the call, all separated by exactly one blank. Times are recorded as hours and minutes in the 24 hour clock, separated by one blank and with two digits for each number. Input will be terminated by a line consisting of a single ‘#’. # Output Output will consist of the called number, the time in minutes the call spent in each of the charge categories, the charging step and the total cost in the format shown below. Note: The first line of the Sample Output below in not a part of the output, but only to show the exact tabulation format it must follow. # Sample Input A 183-5724 17 58 18 04 # # Sample Output 10 16 22 28 31 39 183-5724 2 4 0 A 0.44 # 解題技巧 依舊可以暴力解，不過有小技巧可以讓程式更簡潔！ # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); char distance = sc.next().charAt(0); Map&lt;Character, double[]> rate = new HashMap&lt;>(); rate.put('A', new double[] &#123; 0.02, 0.1, 0.06, 0.02, 0.1, 0.06, 0.02 &#125;); rate.put('B', new double[] &#123; 0.05, 0.25, 0.15, 0.05, 0.25, 0.15, 0.05 &#125;); rate.put('C', new double[] &#123; 0.13, 0.53, 0.33, 0.13, 0.53, 0.33, 0.13 &#125;); rate.put('D', new double[] &#123; 0.17, 0.87, 0.47, 0.17, 0.87, 0.47, 0.17 &#125;); rate.put('E', new double[] &#123; 0.3, 1.44, 0.8, 0.3, 1.44, 0.8, 0.3 &#125;); int[] time = new int[] &#123; 480, 1080, 1320, 1920, 2520, 2760, 2880 &#125;; while (distance != '#') &#123; String plane = sc.next(); int startHr = sc.nextInt(); int startMin = sc.nextInt(); int endHr = sc.nextInt(); int endMin = sc.nextInt(); int start = startHr * 60 + startMin; int end = endHr * 60 + endMin; if (start >= end) &#123; end += 24 * 60; &#125; int[] ansTime = new int[7]; double cost = 0; for (int i = 0; i &lt; 7; i++) &#123; if (start &lt;= time[i]) &#123; if (end &lt;= time[i]) &#123; ansTime[i] = end - start; cost += rate.get(distance)[i] * ansTime[i]; break; &#125; else &#123; ansTime[i] = time[i] - start; start = time[i]; cost += rate.get(distance)[i] * ansTime[i]; &#125; &#125; &#125; System.out.printf(\"%10s%6d%6d%6d%3s%8.2f\\n\", plane, ansTime[1] + ansTime[4], ansTime[2] + ansTime[5], ansTime[0] + ansTime[3] + ansTime[6], distance, cost); distance = sc.next().charAt(0); &#125; &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"}]},{"title":"141 - The Spot Game","slug":"coding/cpe/One Star/141-The-Spot-Game","date":"2023-09-17T14:04:26.000Z","updated":"2023-10-12T12:46:12.514Z","comments":true,"path":"coding/cpe/One Star/141-The-Spot-Game/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/141-The-Spot-Game/","excerpt":"","text":"🌕🌗🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 The game of Spot is played on an N × N board as shown below for N = 4 . During the game, alternate players may either place a black counter (spot) in an empty square or remove one from the board, thus producing a variety of patterns. If a board pattern (or its rotation by 90 degrees or 180 degrees ) is repeated during a game, the player producing that pattern loses and the other player wins. The game terminates in a draw after 2N moves if no duplicate pattern is produced before then. Consider the following patterns: If the first pattern had been produced earlier, then any of the following three patterns (plus one other not shown) would terminate the game, whereas the last one would not. # Input Input will consist of a series of games, each consisting of the size of the board, N (2 ≤ N ≤ 50) followed, on separate lines, by 2N moves, whether they are all necessary or not. Each move will consist of the coordinates of a square (integers in the range 1..N ) followed by a blank and a character ‘+’ or ‘-’ indicating the addition or removal of a spot respectively. You may assume that all moves are legal, that is there will never be an attempt to place a spot on an occupied square, nor to remove a non-existent spot. Input will be terminated by a zero (0) . # Output Output will consist of one line for each game indicating which player won and on which move, or that the game ended in a draw. See the Sample Output below for the exact format. # Sample Input 2 1 1 + 2 2 + 2 2 - 1 2 + 2 1 1 + 2 2 + 1 2 + 2 2 - 0 # Sample Output Player 2 wins on move 3 Draw # 解題技巧 運用到 StringBuffer : StringBuffer sb = new StringBuffer() or StringBuffer sb = new StringBuffer(string) sb.append(string) sb.setCharAt(index, char) # Solution Main.javaimport java.util.*;public class Main&#123; static StringBuffer str0; static StringBuffer str90; static StringBuffer str180; static StringBuffer str270; static Set&lt;String> map; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); while(N != 0)&#123; map = new HashSet&lt;>(); str0 = new StringBuffer(); int play = 0; boolean isDraw = true; for(int i = 0; i &lt; N * N; i++)&#123; str0.append(\"-\"); &#125; str90 = new StringBuffer(str0); str180 = new StringBuffer(str0); str270 = new StringBuffer(str0); for(int i = 1; i &lt;= 2 * N; i++)&#123; int x = sc.nextInt(); int y = sc.nextInt(); char doing = sc.next().charAt(0); if(!isDraw)&#123; continue; &#125; if(isWin(N, x - 1, y - 1, doing))&#123; isDraw = false; play = i; &#125; &#125; System.out.println((isDraw ? \"Draw\" : \"Player \" + (play % 2 + 1) + \" wins on move \" + play)); N = sc.nextInt(); &#125; sc.close(); &#125; public static boolean isWin(int n, int x, int y, char doing)&#123; str0.setCharAt(toOneArray(x, y, n), doing); str90.setCharAt(toOneArray(n - x - 1, y, n), doing); str180.setCharAt(toOneArray(n - x - 1, n - y - 1, n), doing); str270.setCharAt(toOneArray(x, n - y - 1, n), doing); if(map.contains(str0.toString()))&#123; return true; &#125; map.add(str0.toString()); map.add(str90.toString()); map.add(str180.toString()); map.add(str270.toString()); return false; &#125; public static int toOneArray(int x, int y, int n)&#123; return x * n + y; &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"847. Shortest Path Visiting All Nodes","slug":"coding/leetcode/Hard/847-Shortest-Path-Visiting-All-Nodes","date":"2023-09-17T02:39:53.000Z","updated":"2023-12-15T19:05:46.672Z","comments":true,"path":"coding/leetcode/Hard/847-Shortest-Path-Visiting-All-Nodes/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/847-Shortest-Path-Visiting-All-Nodes/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 You have an undirected, connected graph of n nodes labeled from 0 to n - 1 . You are given an array graph where graph[i] is a list of all the nodes connected with node i by an edge. Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges. # Example 1 Input: graph = [[1,2,3],[0],[0],[0]] Output: 4 Explanation: One possible path is [1,0,2,0,3] # Example 2 Input: graph = [[1],[0,2,4],[1,3,4],[2],[1,2]] Output: 4 Explanation: One possible path is [0,1,4,2,3] # 解題思路 Use BitMask + BFS 運算式介紹: allVisitedMask = (1 &lt;&lt; n) - 1 : 運算結果為 15 ，以二進位來查看為 1111 ，用於表示全部節點都走過了。 currMask : 表示當前 queue 中經過了那些節點。 newMask = currMask | (1 &lt;&lt; next) : 表示經過下一個 node ( next ) 後的所有經過節點， | 運算子稱作 OR ，運算方式如: 0011 | 0101 = 0111 。 BFS 結束條件: 如果經過相同 node ( newMask )，且下一個去向也是相同 node ( next )， visited[newMask][next] == true ，可以不用再跑下去。 如果 currMask == allVisitedMask 表示所有節點都走過了，而 currLen - 1 就是答案。 # Solution import java.util.Arrays;import java.util.LinkedList;import java.util.Queue;class Solution &#123; public int shortestPathLength(int[][] graph) &#123; int n = graph.length; int allVisitedMask = (1 &lt;&lt; n) - 1; Queue&lt;int[]> queue = new LinkedList&lt;>(); boolean[][] visited = new boolean[allVisitedMask + 1][n]; for (boolean[] v : visited) &#123; Arrays.fill(v, false); &#125; for (int currNode = 0; currNode &lt; n; currNode++) &#123; int initialMask = (1 &lt;&lt; currNode); queue.add(new int[] &#123; currNode, initialMask, 1 &#125;); visited[initialMask][currNode] = true; &#125; while (!queue.isEmpty()) &#123; int[] curr = queue.poll(); int currNode = curr[0]; int currMask = curr[1]; int currLen = curr[2]; if (currMask == allVisitedMask) &#123; return currLen - 1; &#125; for (int i = 0; i &lt; graph[currNode].length; i++) &#123; int next = graph[currNode][i]; int newMask = currMask | (1 &lt;&lt; next); if (visited[newMask][next]) &#123; continue; &#125; queue.add(new int[] &#123; next, newMask, currLen + 1 &#125;); visited[newMask][next] = true; &#125; &#125; return -1; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bit-Manipulation/"},{"name":"Bitmask","slug":"Bitmask","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bitmask/"}]},{"title":"136 - Ugly Numbers","slug":"coding/cpe/One Star/136-Ugly-Numbers","date":"2023-09-15T12:52:22.000Z","updated":"2023-10-12T12:46:16.416Z","comments":true,"path":"coding/cpe/One Star/136-Ugly-Numbers/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/136-Ugly-Numbers/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Ugly numbers are numbers whose only prime factors are 2 , 3 or 5 . The sequence 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, ...1,\\ \\ 2,\\ \\ 3,\\ \\ 4,\\ \\ 5,\\ \\ 6,\\ \\ 8,\\ \\ 9,\\ \\ 10,\\ \\ 12,\\ \\ 15,\\ \\ ... 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, ... shows the first 11 ugly numbers. By convention, 1 is included. Write a program to find and print the 1500’th ugly number. # Input There is no input to this program. # Output Output should consist of a single line as shown below, with ‘&lt;number&gt;’ replaced by the number computed. # Sample Output The 1500'th ugly number is &lt;number&gt;. # 解題技巧 # Solution Main.javapublic class Main &#123; public static void main(String[] args) &#123; int[] uglyNum = new int[1505]; int index2 = 1, index3 = 1, index5 = 1; uglyNum[1] = 1; for (int i = 2; i &lt;= 1500; i++) &#123; while (uglyNum[index2] * 2 &lt;= uglyNum[i - 1]) index2++; while (uglyNum[index3] * 3 &lt;= uglyNum[i - 1]) index3++; while (uglyNum[index5] * 5 &lt;= uglyNum[i - 1]) index5++; uglyNum[i] = Math.min(uglyNum[index2] * 2, uglyNum[index3] * 3); uglyNum[i] = Math.min(uglyNum[i], uglyNum[index5] * 5); &#125; System.out.println(\"The 1500'th ugly number is \" + uglyNum[1500] + \".\"); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"118 - Mutant Flatworld Explorers","slug":"coding/cpe/One Star/118-Mutant-Flatworld-Explorers","date":"2023-09-15T10:51:27.000Z","updated":"2023-10-12T12:46:23.943Z","comments":true,"path":"coding/cpe/One Star/118-Mutant-Flatworld-Explorers/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/118-Mutant-Flatworld-Explorers/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Robotics, robot motion planning, and machine learning are areas that cross the boundaries of many of the subdisciplines that comprise Computer Science: artificial intelligence, algorithms and complexity, electrical and mechanical engineering to name a few. In addition, robots as “turtles” (inspired by work by Papert, Abelson, and diSessa) and as “beeper-pickers” (inspired by work by Pattis) have been studied and used by students as an introduction to programming for many years. This problem involves determining the position of a robot exploring a pre-Columbian flat world. Given the dimensions of a rectangular grid and a sequence of robot positions and instructions, you are to write a program that determines for each sequence of robot positions and instructions the final position of the robot. A robot position consists of a grid coordinate (a pair of integers: x-coordinate followed by y-coordinate) and an orientation ( N , S , E , W for north, south, east, and west). A robot instruction is a string of the letters ‘L’ , ‘R’ , and ‘F’ which represent, respectively, the instructions: Left: the robot turns left 90 degrees and remains on the current grid point. Right: the robot turns right 90 degrees and remains on the current grid point. Forward: the robot moves forward one grid point in the direction of the current orientation and mantains the same orientation. The direction North corresponds to the direction from grid point (x, y) to grid point (x, y + 1) . Since the grid is rectangular and bounded, a robot that moves “off” an edge of the grid is lost forever. However, lost robots leave a robot “scent” that prohibits future robots from dropping off the world at the same grid point. The scent is left at the last grid position the robot occupied before disappearing over the edge. An instruction to move “off” the world from a grid point from which a robot has been previously lost is simply ignored by the current robot. # Input The first line of input is the upper-right coordinates of the rectangular world, the lower-left coordinates are assumed to be 0,0 . The remaining input consists of a sequence of robot positions and instructions (two lines per robot). A position consists of two integers specifying the initial coordinates of the robot and an orientation (N,S,E,W) , all separated by white space on one line. A robot instruction is a string of the letters ‘L’ , ‘R’ , and ‘F’ on one line. Each robot is processed sequentially, i.e., finishes executing the robot instructions before the next robot begins execution. Input is terminated by end-of-file. You may assume that all initial robot positions are within the bounds of the specified grid. The maximum value for any coordinate is 50 . All instruction strings will be less than 100 characters in length. # Output For each robot position/instruction in the input, the output should indicate the final grid position and orientation of the robot. If a robot falls off the edge of the grid the word ‘LOST’ should be printed after the position and orientation. # Sample Input 5 3 1 1 E RFRFRFRF 3 2 N FRRFLLFFRRFLL 0 3 W LLFFFLFLFL # Sample Output 1 1 E 3 3 N LOST 2 3 S # 解題技巧 基本上也是暴力解，不過有一些小技巧可以讓程式碼簡潔！ # Solution Main.javaimport java.util.*;public class Main&#123; public static int[] dx = &#123;0, 1, 0, -1&#125;; public static int[] dy = &#123;1, 0, -1, 0&#125;; public static Map&lt;String, Integer> toInt = new HashMap&lt;>(); public static Map&lt;Integer, String> toStr = new HashMap&lt;>(); public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); toInt.put(\"N\", 0); toStr.put(0, \"N\"); toInt.put(\"E\", 1); toStr.put(1, \"E\"); toInt.put(\"S\", 2); toStr.put(2, \"S\"); toInt.put(\"W\", 3); toStr.put(3, \"W\"); int x = sc.nextInt(); int y = sc.nextInt(); ArrayList&lt;String> scent = new ArrayList&lt;>(); while(sc.hasNextInt())&#123; int nowX = sc.nextInt(); int nowY = sc.nextInt(); String now = sc.next(); String walk = sc.next(); boolean lost = false; for(int i = 0; i &lt; walk.length(); i++)&#123; if(walk.charAt(i) == 'F')&#123; String temp = Integer.toString(nowX) + \" \" + Integer.toString(nowY); int X = dx[toInt.get(now)]; int Y = dy[toInt.get(now)]; lost = (nowX + X &lt; 0 || nowX + X > x || nowY + Y &lt; 0 || nowY + Y > y); if(!scent.contains(temp) &amp;&amp; lost)&#123; scent.add(temp); break; &#125; if(!(lost))&#123; nowX += X; nowY += Y; &#125; &#125;else if(walk.charAt(i) == 'L')&#123; now = toStr.get((toInt.get(now) + 4 - 1) % 4); &#125;else&#123; now = toStr.get((toInt.get(now) + 1) % 4); &#125; &#125; System.out.println(nowX + \" \" + nowY + \" \" + now + (lost ? \" LOST\" : \"\")); &#125; sc.close(); &#125;&#125; Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int x = sc.nextInt(); int y = sc.nextInt(); List&lt;String> Lost = new ArrayList&lt;>(); while (sc.hasNextInt()) &#123; int currX = sc.nextInt(); int currY = sc.nextInt(); char direction = sc.next().charAt(0); sc.nextLine(); String step = sc.nextLine(); // N E S W int[] nextX = &#123; 0, 1, 0, -1 &#125;; int[] nextY = &#123; 1, 0, -1, 0 &#125;; boolean lost = false; for (int i = 0; i &lt; step.length(); i++) &#123; if(step.charAt(i) == 'F')&#123; int tempX = currX + nextX[toInt(direction)]; int tempY = currY + nextY[toInt(direction)]; if(tempX >= 0 &amp;&amp; tempY >= 0 &amp;&amp; tempX &lt;= x &amp;&amp; tempY &lt;= y)&#123; currX = tempX; currY = tempY; &#125;else&#123; String temp = currX + \" \" + currY; if(!Lost.contains(temp))&#123; System.out.println(currX + \" \" + currY + \" \" + direction + \" LOST\"); Lost.add(temp); lost = true; break; &#125; &#125; &#125;else&#123; direction = nextDirection(direction, step.charAt(i)); &#125; &#125; if(!lost)&#123; System.out.println(currX + \" \" + currY + \" \" + direction); &#125; &#125; &#125; public static int toInt(char direction)&#123; switch(direction)&#123; case 'N': return 0; case 'E': return 1; case 'S': return 2; case 'W': return 3; &#125; return 0; &#125; public static char nextDirection(char direction, char step) &#123; switch (step) &#123; case 'L': switch (direction) &#123; case 'N': return 'W'; case 'E': return 'N'; case 'S': return 'E'; case 'W': return 'S'; &#125; break; case 'R': switch (direction) &#123; case 'N': return 'E'; case 'E': return 'S'; case 'S': return 'W'; case 'W': return 'N'; &#125; break; &#125; return ' '; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"108 - Maximum Sum","slug":"coding/cpe/One Star/108-Maximum-Sum","date":"2023-09-15T03:05:44.000Z","updated":"2023-10-12T12:46:29.562Z","comments":true,"path":"coding/cpe/One Star/108-Maximum-Sum/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/108-Maximum-Sum/","excerpt":"","text":"🌕🌗🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 A problem that is simple to solve in one dimension is often much more difficult to solve in more than one dimension. Consider satisfying a boolean expression in conjunctive normal form in which each conjunct consists of exactly 3 disjuncts. This problem (3-SAT) is NP-complete. The problem 2-SAT is solved quite efficiently, however. In contrast, some problems belong to the same complexity class regardless of the dimensionality of the problem. Given a 2-dimensional array of positive and negative integers, find the sub-rectangle with the largest sum. The sum of a rectangle is the sum of all the elements in that rectangle. In this problem the subrectangle with the largest sum is referred to as the maximal sub-rectangle. A sub-rectangle is any contiguous sub-array of size 1 × 1 or greater located within the whole array. As an example, the maximal sub-rectangle of the array: 0−2−7092−62−41−41−180−2\\begin {matrix} 0 &amp; −2 &amp; −7 &amp; 0\\\\9 &amp; 2 &amp; −6 &amp; 2\\\\−4 &amp; 1 &amp; −4 &amp; 1\\\\−1 &amp; 8 &amp; 0 &amp; −2 \\end {matrix}09−4−1​−2218​−7−6−40​021−2​ is in the lower-left-hand corner: 92−41−18\\begin {matrix} 9 &amp; 2\\\\−4 &amp; 1\\\\−1 &amp; 8 \\end {matrix}9−4−1​218​ and has the sum of 15. # Input The input consists of an N × N array of integers. The input begins with a single positive integer N on a line by itself indicating the size of the square two dimensional array. This is followed by N^2 integers separated by white-space (newlines and spaces). These N^2 integers make up the array in row-major order (i.e., all numbers on the first row, left-to-right, then all numbers on the second row, left-to-right, etc.). N may be as large as 100 . The numbers in the array will be in the range [−127, 127] . # Output The output is the sum of the maximal sub-rectangle. # Sample Input 4 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 # Sample Output 15 # 解題技巧 利用兩次 dp (Dynamic Programming) 來完成紀錄最大的子矩陣數值總數 第一個 dp 是用來記錄矩陣從左上角的矩陣開始，並固定開始位置，一路計算子矩陣數值到右下角。 第二個 dp 是由 Time Complexity O(n^4) 完成的，利用前面計算的陣列，並以下圖的方式解決中間子陣列的數值計算。 註：為了計算方便，我們將陣列大小設為 N + 1 避免判斷 i - 1 或 j - 1 小於 0 的可能性。 在計算第二個 dp 的時候每個數值來比大小，並記錄最大值，就為答案。 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); int[][] arr = new int[N + 1][N + 1]; int max = Integer.MIN_VALUE; for(int i = 1; i &lt; N + 1; i++)&#123; for(int j = 1; j &lt; N + 1; j++)&#123; int input = sc.nextInt(); arr[i][j] = arr[i - 1][j] + arr[i][j - 1] - arr[i - 1][j - 1] + input; &#125; &#125; for(int i = 1; i &lt; N + 1; i++)&#123; for(int j = 1; j &lt; N + 1; j++)&#123; for(int x = i; x &lt; N + 1; x++)&#123; for(int y = j; y &lt; N + 1; y++)&#123; int curr = arr[x][y] - arr[i - 1][y] - arr[x][j - 1] + arr[i - 1][j - 1]; max = Math.max(max, curr); &#125; &#125; &#125; &#125; System.out.println(max); sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"1584. Min Cost to Connect All Points","slug":"coding/leetcode/Medium/1584-Min-Cost-to-Connect-All-Points","date":"2023-09-15T01:28:00.000Z","updated":"2023-12-15T19:08:53.607Z","comments":true,"path":"coding/leetcode/Medium/1584-Min-Cost-to-Connect-All-Points/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1584-Min-Cost-to-Connect-All-Points/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi] . The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj| , where |val| denotes the absolute value of val . Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points. # Example 1 Input: points = [[0,0],[2,2],[3,10],[5,2],[7,0]] Output: 20 Explanation: We can connect the points as shown above to get the minimum cost of 20. Notice that there is a unique path between every pair of points. # Example 2 Input: points = [[3,12],[-2,5],[-4,1]] Output: 18 # 解題思路 先將 points[][] 中兩兩點連線，並運算其長度 (使用 manhattan distance)，將其存於 W[][] 中。 從第一個節點出發，也就是 W[0] 開始，將其與其他節點的值存於 distance[] 中。 接著就開始使用 MST (Minimum Spanning Trees) 演算法進行尋找最佳路徑。 # Solution class Solution &#123; public int minCostConnectPoints(int[][] points) &#123; int V = points.length; int ans = 0; int[] distance = new int[V]; int[][] W = new int[V][V]; for (int i = 0; i &lt; V; i++) &#123; for (int j = 0; j &lt; V; j++) &#123; if (i == j) &#123; W[i][j] = 0; &#125; else &#123; W[i][j] = Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1]); &#125; &#125; &#125; for (int i = 0; i &lt; V; i++) &#123; distance[i] = W[0][i]; &#125; return prim(distance, W, V); &#125; private int prim(int[] distance, int[][] W, int V) &#123; int res = 0; int count = 0; while (count &lt; V - 1) &#123; int min = Integer.MAX_VALUE; int vnear = 0; for (int i = 0; i &lt; V; i++) &#123; if (distance[i] > 0 &amp;&amp; distance[i] &lt; min) &#123; min = distance[i]; vnear = i; &#125; &#125; distance[vnear] = -1; for (int i = 0; i &lt; V; i++) &#123; if (W[i][vnear] &lt; distance[i]) &#123; distance[i] = W[i][vnear]; &#125; &#125; res += min; count++; &#125; return res; &#125;&#125; 單字 coordinates 座標 n. one of a pair of numbers and/or letters that show the exact position of a point on a map or graph X and y coordinates are the horizontal and vertical addresses of a point in any 2D space and help identify the exact location of a point. 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Minimum Spanning Tree","slug":"Minimum-Spanning-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Minimum-Spanning-Tree/"}]},{"title":"105 - The Skyline Problem","slug":"coding/cpe/One Star/105-The-Skyline-Problem","date":"2023-09-14T13:32:58.000Z","updated":"2023-10-12T12:46:33.838Z","comments":true,"path":"coding/cpe/One Star/105-The-Skyline-Problem/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/105-The-Skyline-Problem/","excerpt":"","text":"🌕🌗🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 With the advent of high speed graphics workstations, CAD (computer-aided design) and other areas (CAM, VLSI design) have made increasingly effective use of computers. One of the problems with drawing images is the elimination of hidden lines — lines obscured by other parts of a drawing. You are to design a program to assist an architect in drawing the skyline of a city given the locations of the buildings in the city. To make the problem tractable, all buildings are rectangular in shape and they share a common bottom (the city they are built in is very flat). The city is also viewed as twodimensional. A building is specified by an ordered triple (Li, Hi, Ri) where Li and Ri are the left and right coordinates, respectively, of building i (0 &lt; Li &lt; Ri) and Hi is the height of the building. In the diagram below buildings are shown on the left with triples (1,11,5),(2,6,7),(3,13,9),(12,7,16),(14,3,25),(19,18,22),(23,13,29),(24,4,28)(1, 11, 5),(2, 6, 7),(3, 13, 9),(12, 7, 16),(14, 3, 25),(19, 18, 22),(23, 13, 29),(24, 4, 28) (1,11,5),(2,6,7),(3,13,9),(12,7,16),(14,3,25),(19,18,22),(23,13,29),(24,4,28) the skyline, shown on the right, is represented by the sequence: (1,11,3,13,9,0,12,7,16,3,19,18,22,3,23,13,29,0)(1, 11, 3, 13, 9, 0, 12, 7, 16, 3, 19, 18, 22, 3, 23, 13, 29, 0) (1,11,3,13,9,0,12,7,16,3,19,18,22,3,23,13,29,0) # Input The input is a sequence of building triples. All coordinates of buildings are integers less than 10,000 and there will be at least one and at most 5,000 buildings in the input file. Each building triple is on a line by itself in the input file. All integers in a triple are separated by one or more spaces. The triples will be sorted by Li , the left x-coordinate of the building, so the building with the smallest left x-coordinate is first in the input file. # Output The output should consist of the vector that describes the skyline as shown in the example above. In the skyline vector (v1, v2, v3, . . . , vn−2, vn−1, vn) , the vi such that i is an even number represent a horizontal line (height). The vi such that i is an odd number represent a vertical line (x-coordinate). The skyline vector should represent the “path” taken, for example, by a bug starting at the minimum x-coordinate and traveling horizontally and vertically over all the lines that define the skyline. Thus the last entry in all skyline vectors will be a ‘0’ . # Sample Input 1 11 5 2 6 7 3 13 9 12 7 16 14 3 25 19 18 22 23 13 29 24 4 28 # Sample Output 1 11 3 13 9 0 12 7 16 3 19 18 22 3 23 13 29 0 # 解題技巧 # Solution Main.javaimport java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int[] build = new int[10005]; int buildingStart = Integer.MAX_VALUE, buildingEnd = 0, sameHigh = 0; while(sc.hasNextInt())&#123; int start = sc.nextInt(); int high = sc.nextInt(); int end = sc.nextInt(); buildingStart = Math.min(start, buildingStart); buildingEnd = Math.max(end, buildingEnd); for(; start &lt; end; start++)&#123; build[start] = Math.max(high, build[start]); &#125; &#125; for(int curr = buildingStart; curr &lt;= buildingEnd; curr++)&#123; if(sameHigh != build[curr])&#123; System.out.print(curr + \" \" + build[curr] + (curr != buildingEnd ? \" \" : \"\\n\")); sameHigh = build[curr]; &#125; &#125; sc.close(); &#125;&#125;單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"100 - The 3n + 1 problem","slug":"coding/cpe/One Star/100-The-3n-1-problem","date":"2023-09-13T00:01:00.000Z","updated":"2023-10-12T12:46:38.182Z","comments":true,"path":"coding/cpe/One Star/100-The-3n-1-problem/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/cpe/One%20Star/100-The-3n-1-problem/","excerpt":"","text":"🌕🌑🌑🌑🌑 # 題目連結 題目連結 Online Judge uDebug # 題目說明 Time limit: 3.000 seconds # 題目 Problems in Computer Science are often classified as belonging to a certain class of problems (e.g., NP, Unsolvable, Recursive). In this problem you will be analyzing a property of an algorithm whose classification is not known for all possible inputs. Consider the following algorithm: input n print n if n = 1 then STOP if n is odd then n ← 3n + 1 else n ← n/2 GOTO 2 Given the input 22, the following sequence of numbers will be printed 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1 22\\ \\ \\ 11\\ \\ \\ 34\\ \\ \\ 17\\ \\ \\ 52\\ \\ \\ 26\\ \\ \\ 13\\ \\ \\ 40\\ \\ \\ 20\\ \\ \\ 10\\ \\ \\ 5\\ \\ \\ 16\\ \\ \\ 8\\ \\ \\ 4\\ \\ \\ 2\\ \\ \\ 1\\ \\ \\ 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1 It is conjectured that the algorithm above will terminate (when a 1 is printed) for any integral input value. Despite the simplicity of the algorithm, it is unknown whether this conjecture is true. It has been verified, however, for all integers n such that 0 &lt; n &lt; 1, 000, 000 (and, in fact, for many more numbers than this.) Given an input n , it is possible to determine the number of numbers printed before and including the 1 is printed. For a given n this is called the cycle-length of n . In the example above, the cycle length of 22 is 16. For any two numbers i and j you are to determine the maximum cycle length over all numbers between and including both i and j . # Input The input will consist of a series of pairs of integers i and j , one pair of integers per line. All integers will be less than 10,000 and greater than 0 . You should process all pairs of integers and for each pair determine the maximum cycle length over all integers between and including i and j . You can assume that no operation overflows a 32-bit integer. # Output For each pair of input integers i and j you should output i , j , and the maximum cycle length for integers between and including i and j . These three numbers should be separated by at least one space with all three numbers on one line and with one line of output for each line of input. The integers i and j must appear in the output in the same order in which they appeared in the input and should be followed by the maximum cycle length (on the same line). # Sample Input 1 10 100 200 201 210 900 1000 # Sample Output 1 10 20 100 200 125 201 210 89 900 1000 174 # 解題技巧 沒什麼特別技巧，暴力解哈哈哈！ # Solution Main.javaimport java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNextInt()) &#123; int i = sc.nextInt(); int j = sc.nextInt(); System.out.print(i + \" \" + j + \" \"); int maxCount = 0; for (int temp = Math.min(i, j); temp &lt;= Math.max(i, j); temp++) &#123; int count = 1; int curr = temp; while (curr != 1) &#123; curr = algorithm(curr); count++; &#125; maxCount = Math.max(maxCount, count); &#125; System.out.println(maxCount); &#125; &#125; public static int algorithm(int i) &#123; int res = 0; if (i % 2 == 1) &#123; res = 3 * i + 1; &#125; else &#123; res = i / 2; &#125; return res; &#125;&#125;單字 certain 肯定 adj. having no doubt or knowing exactly that something is true, or known to be true, correct, exact, or effective [ + (that) ] Are you absolutely certain (that) you gave them the right number? 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"}],"tags":[]},{"title":"1282. Group the People Given the Group Size They Belong To","slug":"coding/leetcode/Medium/1282-Group-the-People-Given-the-Group-Size-They-Belong-To","date":"2023-09-11T13:41:16.000Z","updated":"2023-12-15T19:08:31.331Z","comments":true,"path":"coding/leetcode/Medium/1282-Group-the-People-Given-the-Group-Size-They-Belong-To/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1282-Group-the-People-Given-the-Group-Size-They-Belong-To/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 There are n people that are split into some unknown number of groups. Each person is labeled with a unique ID from 0 to n - 1 . You are given an integer array groupSizes , where groupSizes[i] is the size of the group that person i is in. For example, if groupSizes[1] = 3 , then person 1 must be in a group of size 3 . Return a list of groups such that each person i is in a group of size groupSizes[i] . Each person should appear in exactly one group, and every person must be in a group. If there are multiple answers, return any of them. It is guaranteed that there will be at least one valid solution for the given input. # Example 1 Input: groupSizes = [3,3,3,3,3,1,3] Output: [[5],[0,1,2],[3,4,6]] Explanation: The first group is [5]. The size is 1, and groupSizes[5] = 1. The second group is [0,1,2]. The size is 3, and groupSizes[0] = groupSizes[1] = groupSizes[2] = 3. The third group is [3,4,6]. The size is 3, and groupSizes[3] = groupSizes[4] = groupSizes[6] = 3. Other possible solutions are [[2,1,6],[5],[0,4,3]] and [[5],[0,6,2],[4,3,1]]. # Example 2 Input: groupSizes = [2,1,3,3,3,2] Output: [[1],[0,5],[2,3,4]] # 解題思路 Map.computeIfAbsent(key, k -&gt; value) Map.values() List.subList # Solution import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;class Solution &#123; public List&lt;List&lt;Integer>> groupThePeople(int[] groupSizes) &#123; Map&lt;Integer, List&lt;Integer>> groupMap = new HashMap&lt;>(); List&lt;List&lt;Integer>> result = new ArrayList&lt;>(); for (int idx = 0; idx &lt; groupSizes.length; idx++) &#123; int size = groupSizes[idx]; // If groupMap didn't have the key of size then create new ArrayList with this size. groupMap.computeIfAbsent(size, k -> new ArrayList&lt;>()).add(idx); &#125; for (List&lt;Integer> group : groupMap.values()) &#123; int size = group.size(); for (int i = 0; i &lt; size; i += groupSizes[group.get(i)]) &#123; result.add(group.subList(i, i + groupSizes[group.get(i)])); &#125; &#125; return result; &#125;&#125; 片語 & 搭配詞 labeled with 標記為","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"}]},{"title":"403. Frog Jump","slug":"coding/leetcode/Hard/403-Frog-Jump","date":"2023-08-27T12:45:36.000Z","updated":"2023-12-15T19:05:39.645Z","comments":true,"path":"coding/leetcode/Hard/403-Frog-Jump/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/403-Frog-Jump/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water. Given a list of stones ' positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit. If the frog's last jump was k units, its next jump must be either k - 1 , k , or k + 1 units. The frog can only jump in the forward direction. # Example 1 Input: stones = [0,1,3,5,6,8,12,17] Output: true Explanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone. # Example 2 Input: stones = [0,1,2,3,4,8,9,11] Output: false Explanation: There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large. # 解題思路 # Solution import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Set;class Solution &#123; public boolean canCross(int[] stones) &#123; int n = stones.length; Map&lt;Integer, Set&lt;Integer>> dp = new HashMap&lt;>(); for (int stone : stones) &#123; dp.put(stone, new HashSet&lt;>()); &#125; dp.get(0).add(0); for (int i = 0; i &lt; n; i++) &#123; for (int k : dp.get(stones[i])) &#123; for (int step = k - 1; step &lt;= k + 1; step++) &#123; if (step != 0 &amp;&amp; dp.containsKey(stones[i] + step)) &#123; dp.get(stones[i] + step).add(step); &#125; &#125; &#125; &#125; return !dp.get(stones[n - 1]).isEmpty(); &#125;&#125; 單字 river 河 a natural wide flow of fresh water across the land into the sea, a lake, or another river We sailed slowly down the river. 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"542. 01 Matrix","slug":"coding/leetcode/Medium/542-01-Matrix","date":"2023-08-17T13:27:38.000Z","updated":"2023-12-15T19:07:42.976Z","comments":true,"path":"coding/leetcode/Medium/542-01-Matrix/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/542-01-Matrix/","excerpt":"","text":"⭐️⭐️⭐️⭐️ # 題目敘述 Given an m x n binary matrix mat , return the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1 . # Example 1 Input: mat = [[0,0,0],[0,1,0],[0,0,0]] Output: [[0,0,0],[0,1,0],[0,0,0]] # Example 2 Input: mat = [[0,0,0],[0,1,0],[1,1,1]] Output: [[0,0,0],[0,1,0],[1,2,1]] # 解題思路 # Solution import java.util.LinkedList;import java.util.Queue;class Solution &#123; public int[][] updateMatrix(int[][] mat) &#123; Queue&lt;int[]> q = new LinkedList&lt;>(); int rows = mat.length; int cols = mat[0].length; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; if (mat[i][j] == 0) &#123; q.offer(new int[]&#123;i, j&#125;); &#125; else &#123; mat[i][j] = -1; &#125; &#125; &#125; int[] dirX = &#123;1, -1, 0, 0&#125;; int[] dirY = &#123;0, 0, 1, -1&#125;; int length = 0; while (!q.isEmpty()) &#123; int size = q.size(); length++; while (size-- > 0) &#123; int[] front = q.poll(); int r = front[0]; int c = front[1]; for (int i = 0; i &lt; 4; i++) &#123; int newRow = r + dirX[i]; int newCol = c + dirY[i]; if (newRow &lt; 0 || newCol &lt; 0 || newRow >= rows || newCol >= cols || mat[newRow][newCol] >= 0) &#123; continue; &#125; mat[newRow][newCol] = length; q.offer(new int[]&#123;newRow, newCol&#125;); &#125; &#125; &#125; return mat; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"}]},{"title":"239. Sliding Window Maximum","slug":"coding/leetcode/Hard/239-Sliding-Window-Maximum","date":"2023-08-16T07:29:08.000Z","updated":"2023-12-15T19:05:36.863Z","comments":true,"path":"coding/leetcode/Hard/239-Sliding-Window-Maximum/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/239-Sliding-Window-Maximum/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 You are given an array of integers nums , there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. # Example 1 Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 # Example 2 Input: nums = [1], k = 1 Output: [1] # 解題思路 Use Deque name dq . Map k integer in the nums , and keep the high number in the dq first value. Adding dp first value in List name res which will become the answer. Making List&lt;Integer&gt; into int[] and return. # Solution import java.util.ArrayDeque;import java.util.ArrayList;import java.util.Deque;import java.util.List;class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; Deque&lt;Integer> dq = new ArrayDeque&lt;>(); List&lt;Integer> res = new ArrayList&lt;>(); for (int i = 0; i &lt; k; i++) &#123; while (!dq.isEmpty() &amp;&amp; nums[i] >= nums[dq.peekLast()]) &#123; dq.pollLast(); &#125; dq.offerLast(i); &#125; res.add(nums[dq.peekFirst()]); for (int i = k; i &lt; nums.length; i++) &#123; if (dq.peekFirst() == i - k) &#123; dq.pollFirst(); &#125; while (!dq.isEmpty() &amp;&amp; nums[i] >= nums[dq.peekLast()]) &#123; dq.pollLast(); &#125; dq.offerLast(i); res.add(nums[dq.peekFirst()]); &#125; return res.stream().mapToInt(Integer::intValue).toArray(); &#125;&#125; 單字 slide 滑動 v. to (cause to) move easily and without interruption over a surface sliding doors 片語 & 搭配詞 make sth into sth 把… 變成 make + 受詞 (物) + into + 受詞 (物) They’ve made the spare room into an office. 他們已把空置的房間改成辦公室。","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Queue","slug":"Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Queue/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Monotonic Queue","slug":"Monotonic-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Monotonic-Queue/"}]},{"title":"動詞的現在簡單式","slug":"language/english/文法/動詞的現在簡單式","date":"2023-08-15T17:09:11.000Z","updated":"2023-08-16T07:27:58.326Z","comments":true,"path":"language/english/文法/動詞的現在簡單式/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/language/english/%E6%96%87%E6%B3%95/%E5%8B%95%E8%A9%9E%E7%9A%84%E7%8F%BE%E5%9C%A8%E7%B0%A1%E5%96%AE%E5%BC%8F/","excerpt":"","text":"⭐️⭐️ # 文法摘要 主詞是第三人稱單數 (he, she, it) 且為現在式，使用的動詞字尾上必須加 &quot;-s&quot; 或 &quot;-es&quot;，規則如下: 動詞規則改法 範例 動詞字尾加上 s hit - hits 動詞結尾是 e，加上 s hide - hides 動詞字尾是 s/o/x/z/ch/sh，加上 es catch - catches 動詞字尾為 「母音 + y」，只要加 s stay - stays 動詞字尾為 「子音 + y」，要去 y 加上 ies study - studies 表示現在或事實的動作與狀態：注意第三人稱單數的字尾 s/es/ies 變化: 例一: Mr. Smith lives in Taichung, but he works in Taipei. 史密斯先生住在台中，但他在台北工作。 例二: You look tired. Stop working and take a break. 你看起來很累，別工作了，休息一下吧。 表示不變的格言、真理和事實: 例一: The sun rises in the east and sets in the west. 太陽從東邊升起，西邊落下。 例二: There is no royal road to learning. 學習無坦途。 表示現在的習慣或反覆的動作，常與以下頻率副詞連用: always (總是) /frequently (頻繁地) /often (常常) /usually (通常) /sometime (有時) /seldom (不常) /never (絕不) every + 時間 次數 + a/an + 單數時間 例一: On Halloween, houses and yards in the U.S.A. are often lit up by jack-o'-lanterns. 萬聖節時，美國的房子和庭院常點著南瓜燈。 例二: Cindy studies math and English every day. 辛蒂每天讀數學和英文。 例三: He writes to his parents once a week. 他每週寫一次信給父母。 表示時間或條件的副詞子句，用現在式代替未來式 例一: If she comes here tomorrow, please give her this letter. 若她明天來到這，請給她這封信。 例二: Even when you are very old, your fingerprints will still look very much the way they do now. 即便當你非常老，你的指紋仍會看起來和現在非常像。 註：在副詞子句和名詞子句中，仍用未來式表示未來式 例一: Tell me where she will go next month. 告訴我她下個月會去那裡。 例二: I don't know the exact time when he will hand in the report. 我不知道他會繳交報告的確切時間。 單字 royal 皇家的 adj. belonging or connected to a king or queen or a member of their family the royal family # 精選試題 Bill never carries a bag or a wallet when shopping. Every time he has to pay, he takes out money from his pocket. Bill 買東西時從來不帶包包或皮夾。每次要付錢的時候，他就會從口袋裡拿出錢來。 Although Annie know fast food is not good for her health, she still eats it. 雖然 Annie 知道速食對健康不好，她還是繼續吃。 Somewhere along the road, there is a shop which sells things from foreign countries. 這條路上的某處，有家賣異國商品的店。","categories":[{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"文法","slug":"language/english/文法","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E6%96%87%E6%B3%95/"}],"tags":[{"name":"英文文法","slug":"英文文法","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95/"}]},{"title":"86. Partition List","slug":"coding/leetcode/Medium/86-Partition-List","date":"2023-08-15T15:59:54.000Z","updated":"2023-12-15T19:07:09.072Z","comments":true,"path":"coding/leetcode/Medium/86-Partition-List/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/86-Partition-List/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given the head of a linked list and a value x , partition it such that all nodes less than x come before nodes greater than or equal to x . You should preserve the original relative order of the nodes in each of the two partitions. # Example 1 Input: head = [1,4,3,2,5,2], x = 3 Output: [1,2,2,4,3,5] # Example 2 Input: head = [2,1], x = 2 Output: [1,2] # 解題思路 Use two ListNode , less and greater , to hold nodes with values less than x and which node greater than or equal to x . Linking two ListNode togother, attach the greater to the end of the less . # Solution // Definition for singly-linked list.public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125;class Solution &#123; public ListNode partition(ListNode head, int x) &#123; ListNode less = new ListNode(0); ListNode lessTail = less; ListNode greater = new ListNode(0); ListNode greaterTail = greater; while (head != null) &#123; if (head.val &lt; x) &#123; lessTail.next = new ListNode(head.val); lessTail = lessTail.next; &#125; else &#123; greaterTail.next = new ListNode(head.val); greaterTail = greaterTail.next; &#125; head = head.next; &#125; lessTail.next = greater.next; return less.next; &#125;&#125; 單字 preserve 保存 v. to keep something as it is, especially in order to prevent it from decaying or being damaged or destroyed to preserve the environment We want to preserve the character of the town while improving the facilities.","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Linked List","slug":"Linked-List","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Linked-List/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"}]},{"title":"215. Kth Largest Element in an Array","slug":"coding/leetcode/Medium/215-Kth-Largest-Element-in-an-Array","date":"2023-08-14T13:56:51.000Z","updated":"2023-12-15T19:07:18.324Z","comments":true,"path":"coding/leetcode/Medium/215-Kth-Largest-Element-in-an-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/215-Kth-Largest-Element-in-an-Array/","excerpt":"","text":"⭐️⭐️ # 題目敘述 Given an integer array nums and an integer k , return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Can you solve it without sorting? # Example 1 Input: nums = [3,2,1,5,6,4], k = 2 Output: 5 # Example 2 Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 # 解題思路 Use the PriorityQueue which is a data structure. # Solution import java.util.Comparator;import java.util.PriorityQueue;class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; PriorityQueue&lt;Integer> PQ = new PriorityQueue&lt;>(new PQComparator()); for (int num : nums) &#123; PQ.add(num); &#125; int ans = 0; for (int i = 0; i &lt; k; i++) &#123; ans = PQ.poll(); &#125; return ans; &#125;&#125;class PQComparator implements Comparator&lt;Integer> &#123; @Override public int compare(Integer number1, Integer number2) &#123; int value = number1.compareTo(number2); // elements are sorted in reverse order if (value > 0) &#123; return -1; &#125; else if (value &lt; 0) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;&#125; 單字 distinct 清楚的 adj. There's a distinct smell of cigarettes in here. clearly noticeable; that certainly exists 片語 & 搭配詞 smell of + sth ... 的香味","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Divide-and-Conquer/"},{"name":"Quickselect","slug":"Quickselect","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Quickselect/"}]},{"title":"2369. Check if There is a Valid Partition For The Array","slug":"coding/leetcode/Medium/2369-Check-if-There-is-a-Valid-Partition-For-The-Array","date":"2023-08-13T11:59:37.000Z","updated":"2023-12-15T19:09:25.167Z","comments":true,"path":"coding/leetcode/Medium/2369-Check-if-There-is-a-Valid-Partition-For-The-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2369-Check-if-There-is-a-Valid-Partition-For-The-Array/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given a 0-indexed integer array nums . You have to partition the array into one or more contiguous subarrays. We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions: The subarray consists of exactly 2 equal elements. For example, the subarray [2,2] is good. The subarray consists of exactly 3 equal elements. For example, the subarray [4,4,4] is good. The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1 . For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not. Return true if the array has at least one valid partition. Otherwise, return false. # Example 1 Input: nums = [4,4,4,5,6] Output: true Explanation: The array can be partitioned into the subarrays [4,4] and [4,5,6]. This partition is valid, so we return true. # Example 2 Input: nums = [1,1,1,2] Output: false Explanation: There is no valid partition for this array. # 解題思路 # Solution import java.util.HashMap;import java.util.Map;class Solution &#123; Map&lt;Integer, Boolean> map = new HashMap&lt;>(); public boolean prefixIsValid(int[] nums, int i) &#123; if (map.containsKey(i)) &#123; return map.get(i); &#125; boolean ans = false; if (i > 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; ans |= prefixIsValid(nums, i - 2); &#125; if (i > 1 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; nums[i - 1] == nums[i - 2]) &#123; ans |= prefixIsValid(nums, i - 3); &#125; if (i > 1 &amp;&amp; nums[i] == nums[i - 1] + 1 &amp;&amp; nums[i - 1] == nums[i - 2] + 1) &#123; ans |= prefixIsValid(nums, i - 3); &#125; map.put(i, ans); return ans; &#125; public boolean validPartition(int[] nums) &#123; int n = nums.length; map.put(-1, true); return prefixIsValid(nums, n - 1); &#125;&#125; 單字 partition 分割、隔開 v. to divide one part of a room from another with a thin wall Why don't you partition that large room into a lounge and a dining-room? contiguous 連續的 adj. next to or touching another, usually similar, thing The two states are contiguous with/to each other, but the laws are quite different. valid 有效的 adj. based on truth or reason; able to be accepted My way of thinking might be different from yours, but it's equally valid. obtain 獲得 v. to get something, especially by asking for it, buying it, working for it, or producing it from something else First editions of these books are now almost impossible to obtain. satisfy 滿足 v. to please someone by giving them what they want or need Come on, satisfy my curiosity (= tell me what I want to know) - what happened last night? exactly 確切地 adv. used when you are giving or asking for information that is completely correct It tastes exactly the same as the real thing, but has half the fat. consecutive 連續的 adj. Consecutive events, numbers, etc. follow one after another without an interruption This is the fifth consecutive weekend that I've spent working. adjacent 鄰近的 adj. very near, next to, or touching They lived in a house adjacent to the railway. 片語 & 搭配詞 to obtain permission 獲得許可 satisfy conditions/needs/requirements 滿足條件 / 需求 / 要求 consists of 由... 組成","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"UML 實務手冊","slug":"computer-science/Note/UML-實務手冊","date":"2023-08-13T09:46:23.000Z","updated":"2023-08-13T09:49:44.898Z","comments":true,"path":"computer-science/Note/UML-實務手冊/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Note/UML-%E5%AF%A6%E5%8B%99%E6%89%8B%E5%86%8A/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 認識 UML # 統一建模語言 UML (Unified Modeling Language) 是建構模式 (model) 的專用語言。 在編寫程式碼前，開發人員會先經過分析設計的思考，並繪製一些圖形，再搭配一些文字，作為分析設計的產出，這份產出可稱之為軟體模式模型。 # UML 圖 UML 推出了十多款圖，不過並非每款圖都實用，在開發商用資訊系統時，最常用到的 UML 圖，包含有：類別圖、循序圖、使用案例圖、狀態圖 (state machine diagram) 和活動圖 (activity diagram)。 # 簡易的開發程序 實務上， 使用案例圖及敘述 、 類別圖 與 循序圖 三者之搭配，幾乎是 UML 專案的基本型，所以在分工或外包的設計文檔中，通常少不了這三款 UML 圖。 最常見的開發程序是，並行建構使用案例圖文與類別圖，接著才建構循序圖以及按圖編碼。 一個系統只有一個內部結構，而且系統對外提供的所有服務，都僅依賴這個系統穩定的內部結構所支撐。 然而，每一項服務的運作方式皆不同，所以雖然系統僅有一個靜態結構，卻可以有很多個動態行為。 因此，透過 UML 圖來呈現系統的狀況時，一個系統僅有一張呈現系統內部結構的類別圖，而且無論使用案例圖中有多少個使用案例。 但是，每一個使用案例至少對應一張循序圖，呈現出系統執行使用案例期間，其內部的一群物件互動的運作情況。 再者，類別圖通常不是一次就能夠設計完全，而是透過一個又一個的使用案例，以及一張又一張的循序圖，三者經過多次循環更新的歷程後，類別圖才能逐步形成且穩定下來。 # 類別圖 類別圖 (class diagram) 是最重要的 UML 圖。 主要功能: 用來呈現系統內部的靜態結構，而這樣的靜態結構通常可以用直接對應程式碼，因此，從程式設計師的角度來看，類別圖是最被關注的 UML 圖。 類別圖描述了系統的類別集合，類別的屬性和類別之間的關係。 矩形代表類別 (class)、類別內部記載屬性 (attribute) 與操作 (operation)。 類別之間有代表結合關係 (association relationship) 的實線、組合關係 (composition relationship) 的實心菱形實線、一般化關係 (generalization relationship) 的三角形實線。 類別圖符號分成兩種: 物件本身 物件與物件的關係 物件本身 + : public - : private # : protected 物件間的關係 association relationship 結合關係 # 使一個類別知道另一個類別屬性和方法。 // 通常含有「知道」、「了解」的含義。 (A knows B) dependency relationship 依賴關係 # 指在參數或回傳時有用到 (A uses B) Implementation relationship 實作關係 # 指的是一個 class 類別實現 interface 介面 (A implements B) generalization relationship 一般化關係 # 指的是父類別擁有子類別的共用功能，子類別可以視作父類別的特例。 # 描述 is-a 關係。 (A is a type of B) aggregation relationship 聚合關係 # 整體與部分的「弱」包含關係，部分類別可以單獨存在，也可以屬於多個整體物件。 # 描述 has-a 關係。 (A owns B) composition relationship 組合關係 # 整體與部分的「強」包含關係，部分類別無法單獨存在，其生命週期與整體相同。 # 描述 contains-a 關係。 (B is part of A) 多重性 (Multiplicity) | 指示符 | 意思 | | ------ | ------- | | 0...1 | 0 or 1 | | 1 | 1 | | 0...* | 0 or 多 | | 1...* | 1 or 多 | | * | 多 | # 循序圖 循序圖 (sequence diagram) 將類別圖部分更細節。 主要功能: 呈現類別圖操作之實作方法。 在類別圖中，未能提出操作之實作方法，這部分的細節設計，可藉由循序圖來呈現。雖然，我們可以從類別圖對應到程式中的類別、屬性、關係及操作之宣告，但也僅止於此，對於操作的實作方法，還要搭配循序圖才能獲得。 除了表達實作方法外，更重要的是，循序圖還能夠表達執行期間的一群物件，為了合力完成某一個目的，呼叫操作之互動情況。 ![image sequence diagram][reference link] # 使用案例圖 使用案例圖 (use case diagram) 是最與眾不同的 UML 圖。 主要功能: 獨特之處在於它適合用來表達系統的「外部」行為，其餘的 UML 圖都適用於呈現系統內部結構或行為。其餘的 UML 圖都是用於呈現系統的「內部」結構或行為。 橢圓形的使用案例圖示位於系統內部，代表系統將提供且支援這些使用案例，而參與者位於系統外部，代表使用案例的啟動者或支援者。 ![image use case diagram][reference link] # 狀態圖 狀態圖 (state machine diagram) 主要功能: 狀態圖可以讓我們聚焦在單一種類的物件本身，表達物件一生中可以出現的狀態 (state) 變化。 相較之下，狀態圖的觀點與循序圖的觀點全然不同，循序圖表達某一種物件與其他種物件之間的互動情況。 簡而言之，循序圖用以表達物件外部互動行為，而狀態圖表達物件內部的狀態變化。 ![image use case diagram][reference link] # 活動圖 活動圖 (activity diagram) 主要功能: 活動圖非常適合用來表達一連串的行動。 活動圖相當容易理解與使用，它跟我們隨手繪製的流程圖沒什麼不同，唯一需要講究的只有它特定的圖示。 在企業組織領域裡，我們經常用它來表達工作流程、企業流程或聯合服務等的活動流程。 至於資訊系統的應用上，遇到較為複雜的系統流程、整合流程及操作時，我們也會配合使用活動圖協助思考及設計。 其他時候，為了節省開發成本與縮短開發時程，可能僅採用循序圖來表達系統內部物件的互動情況。 ![image use case diagram][reference link] # UML 工具 StarUML IBM RSA Case Complete","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Note","slug":"computer-science/Note","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Note/"}],"tags":[]},{"title":"C Program 進階","slug":"computer-science/program-language/C Programming Language/C-Program-進階","date":"2023-08-13T09:15:16.000Z","updated":"2023-12-15T18:33:57.441Z","comments":true,"path":"computer-science/program-language/C Programming Language/C-Program-進階/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/program-language/C%20Programming%20Language/C-Program-%E9%80%B2%E9%9A%8E/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # Array 變數可以幫我們存取一筆資料，但要存取多筆資料時就會顯得很麻煩。 比如我們要記錄三個學生的成績: # Declare Data type 變數名稱[陣列大小] = &#123;資料&#125;; # Array Input/Output # Two-dimensional Arrays 二維陣列 陣列裡面存放陣列 # Declare Data type 變數名稱[column][row] = &lt;!--swig￼1-->; # Two-dimensional Arrays Input/Output # String 字串 在 C programming language 中，沒有 string 的變數型態， 因此我們這邊提到的字串是以字元陣列的型態表示， 另一種是用 pointer 的型態來表示。 # Declare char 變數名稱[陣列大小] = &#123;‘資’, ‘料’&#125;; char 變數名稱[陣列大小] = “資料”; # Gets/Fgets/Puts 字串輸入 / 輸出 因為 gets 函式無法知道字元陣列的大小，而是依賴換行符號或 EOF 才會結束輸入，因此有可能引發緩衝區溢位的安全問題 。 # Scanf # String of function There are many important string functions defined in &quot;string.h&quot; library. # Strlen The strlen() function returns the length of the given string. It doesn't count null character '\\0' . # Strcpy The strcpy(destination, source) function copies the source string in destination. # Strcat The strcat(first_string, second_string) function concatenates two strings and result is returned to first_string. # Strcmp The strcmp(first_string, second_string) function compares two string and returns 0 if both strings are equal. # Strrev The strrev(string) function returns reverse of the given string. # Strlwr The strlwr(string) function returns string characters in lowercase. # Strupr The strupr(string) function returns string characters in uppercase. # Strstr strstr () 函數返回指向給定字符串中第一次出現的匹配字符串的指針。 它用於返回從第一個匹配到最後一個字符的子字符串。 # Function 函式 A function is a block of code which only runs when it is called. Functions are used to perform certain actions, and they are important for reusing code: Define the code once and use it many times. 我們可以簡單的將程式的函數分成兩種: 有回傳值的 無回傳值的 # Advantage 函式 (function) 是程序抽象化 (procedure abstraction) 的實踐方法: Reusability 重複利用性 Readability 易讀性 Reduce Coupling 降低耦合性 (耦合，指的是和其它程式碼「有」相關) Modularity of the program 模組化 # Syntax _ return value # Syntax _ without parameter # Syntax _ without return value # Function Function 可以把他想成某個功能的實現，用於簡化 main 中的程式，並妥善的將程式清楚區分功能，達到重用、降低耦合性，也讓寫思考程式功能更能分塊撰寫。 在這邊我們可以先不管 Function 內的程式是如何寫的，但是我們知道他可以實現他的功能；區分好後再開始分段思考，要如何撰寫 Function 內的程式可以達到我們所希望的樣子。 # Pointer # Recall Data type 變數名稱 = 資料; # Value # Pointer # Declare T* ptr ptr is pointed a T type object/value &amp;value get address of value *ptr Access data by an address # Pointer # Pointer in Pointer # Pointer and Array # Thinking 請問右邊程式執行後會輸出什麼呢？ # Struct 結構 (structure) 是一種複合型別 (derived data type)，用來表達由多個屬性組成的型別，而這些屬性可以是基本型別或是另一個複合型別所組成。 # 宣告結構 # 存取結構內屬性 # 內嵌在結構內的結構 # 儲存結構的陣列 # 存取結構指標的屬性 # Scope 主要是指我們的變數都有可以使用的範圍，通常一個可以用的範圍是其 “{} ” 內。 EX: 自訂 function 和 main function，其實是兩個不同括號 (“ {} ” ) 的兩段程式碼，所以它裡面的變數命名一樣是不會導致錯誤的，因為對程式來說它是兩塊不同的東西。 EX: main function 中 while/for 中所定義的變數，在 while/for 的 “{} ” 是無法被使用的。 # Argument Passing # Call by Value 利用 call by value 的方法去傳值時，因為 a, b 的記憶體和 swap function 內 a, b 的記憶體是分開的，所以不會互相干擾，但需要使用另外的兩個記憶體去儲存他們！ # Call by Address 使用了一個 swap function，它的功能是將 a 和 b 傳入的 address 進行交換，之後在 main 裡面利用 &amp; 符號傳入 address ，然後執行一遍就可以發現，交換前 a 的值為 1，b 的值為 0，交換後 a 的記憶體空間和 b 交換，所以各自代表的值也變成了 0 和 1。 # Algorithm 由有限步驟所構成的集合，可以用於解決某一個特定的問題。 其實演算法就是一種解決問題的邏輯思維！ Ex: 假設我們今天要解決的那一個特定問題是「把蘋果做成一杯蘋果汁」 可以透過以下幾個步驟來實現： 清洗蘋果 將蘋果削皮、去籽 將經過步驟 (2) 處理的蘋果放入果汁機 在果汁機中加入一定比例的水 按下果汁機啟動按鈕 將果汁機裡面的蘋果汁倒入玻璃杯中","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Programming Language","slug":"computer-science/program-language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/"},{"name":"C Programming Language","slug":"computer-science/program-language/C-Programming-Language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/C-Programming-Language/"}],"tags":[]},{"title":"C Program 基礎","slug":"computer-science/program-language/C Programming Language/C-Program-基礎","date":"2023-08-13T08:44:47.000Z","updated":"2023-12-15T18:33:52.488Z","comments":true,"path":"computer-science/program-language/C Programming Language/C-Program-基礎/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/program-language/C%20Programming%20Language/C-Program-%E5%9F%BA%E7%A4%8E/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # Get Start 前情提要 Program language C C++ Java JavaScript Python Source-code Editor VS code dev c++ Code::Block notepad++ Compiler # Introduction 介紹 雖然他是一個很古老的語言，也相較底層，但到如今還是一個相當熱門的語言。 他是很多語言的基礎，學習 C 語言後，在學習其他語言，會更加容易上手。 C 語言 與 UNIX 密切相關，因為它是為編寫 UNIX 作業系統而開發的。 C 語言 相較於其他語言來說，較為快速。 # Base 基本概念 Rule Left to Right, Up to Down ; at the end of each line of instructions return 0 ; end of program Use TAB &#123;&#125; content in structure Comment // … single line /* … */ multi-line # Syntax 語法 get start #include &lt;stdio.h>int main()&#123; ... return 0;&#125; 引入函式庫 Standard Library Header File 標準函式庫標頭檔 #include &lt;stdio.h&gt; : 內容大略為處理輸入和輸出對象 scanf / printf 給電腦字典 (標頭檔) 查詢程式內容意思 主函式 程式執行的主要內容，任何程式的切入點 備註：學到 function 後會更加清楚 # Variable 變數 簡單來說，就是它的數值會改變的數 Type 型態 Label 標籤 Data 資料 # Declare Data type 變數名稱 = 資料; # Data Type Primitive Data Types : int, float, char, bool, void Derived Data Types : function, array, pointer, reference Abstract or User-Defined Data Types : Class, Structure, Union, Enumeration, Typedef defined Datatype # Primitive Data Type These data types are built-in or predefined data types and can be used directly by the user to declare variables. Data Type byte Remark Int 整數 4 byte range from ≈ 10^9 Float 單精度浮點數 4 byte Double 雙經度浮點數 8 byte range from -128 to 127 or 0 to 255 Char 字元 1 byte True(1) or False(0) Bool 布林 1byte used for function which does not return a value Void 無 / 空 1byte == 8bits # Identifiers Can contain letters, digits and underscores Must begin with a letter or an underscore (_) case sensitive (myVar and myvar are different variables) Cannot contain whitespaces or special characters ( ! # % ……) Reserved words cannot be used (like C keywords, such as int) 名稱要有描述性且合理 少用縮寫，對於沒有參與這個專案、但在相關領域的人熟悉的縮寫字，可以使用 變數（包括函式的參數）的名稱一律小寫，單字之間用底線連接 命名規則 # Constants 常數 無法被更改的數值 cconst Data type 變數名稱 = 資料; # I/O # Printf 輸出 將資料輸出，顯示在螢幕上 輸出變數 將變數輸出，顯示在螢幕上 輸出變數於特定格式 將變數輸出成特定格式，顯示在螢幕上 # Escape \\ 跳脫字元 \\0 空字元 (NULL) \\t TAB \\n 換行 \\a 響鈴 (BEL) \\” 雙引號 \\’ 單引號 # Scanf 輸入 輸入資料，需要利用變數來放入輸入的資料 # Getchar/Putchar 字元輸入 / 輸出 如果輸入了兩個以上的字元，則 getchar 會取得第一個字元，並將第二個字元留在緩衝區中，直到再使用 getchar 或 scanf 取得輸入。 # Operator Arithmetic Operator Assignment Operator Relational Operator / Comparison Operator Logical Operator Unary Operator # Arithmetic Operators + 加法 - 減法 * 乘法 / 商數除法 % 餘數除法 # Assignment Operators = 指派 += 複合指派 # Relational Operators &gt; 大於 &gt;= 大於等於 &lt; 小於 &lt;= 小於等於 == 等於 != 不等於 = VS. == = 指派: a = b 將 b 的值存入 a 變數中 == 等於: a == b a 與 b 是否相等？True/False # Logical Operators &amp;&amp; AND 且 || OR 或 ! NOT 相反 # Unary Operators ++ / -- postfix-expression ++ ++ unary-expression # Challenge (B) (A) (A) (B) # Encoding Encoding is the process of converting information from one format to another. # ASCII American Standard Code for Information Interchange 字元編碼（Character encoding）total 128 Control character 33 Printable characters 95 ASCII 維基百科 大寫轉小寫 英文大寫 A 十進位表示方式: 65 英文小寫 a 十進位表示方式: 97 # 97–65=3297 – 65 = 3297–65=32 # 英文大小寫 十進位表示方式差 32 # Control flow Selection Statements 選擇語句 Iteration Statements 反覆語句 Jump Statements 跳轉語句 # Selection Statements 經由判斷條件是 TRUE 或是 FALSE，來選擇要執行哪段程式 If … else Switch case # Iteration Statements 重複執行單個或多個運算式，在每次執行前會先判斷條件式，若為 FALSE 或是 break，才會中斷。 While Do while For loop # Jump Statements Break 中斷 中斷並結束迴圈。 Continue 繼續 中斷當次迴圈循環，到開頭在執行一次。 # Selection Statements # If … else If _ Flow chart If _ Syntax If … else _ Flow chart If … else _ Syntax Shorthand if … else _ Syntax If … else if … else _ Flow chart If … else if … else _ Syntax Nested if _ Flow chart Nested if _ Syntax # Switch Switch _ Flow chart Switch _ Syntax # Thinking 請問右邊程式執行後會輸出什麼呢？ 中止條件: 一直執行到沒有 case 為止 當遇到 break 時，強制跳離 # Iteration Statements # While While _ Flow chart While _ Syntax # Do while Do while _ Flow chart Do while _ Syntax # For loop For loop _ Flow chart For loop_ Syntax statement 1 : initialization statement 2 : conditional statement 3 : update # Nested loop 巢狀是指東西如同鳥巢一樣，一層一層的包下去，而程式中的巢狀迴圈是， while/for 迴圈內包著 while/for 迴圈。 # Midway Challenge","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Programming Language","slug":"computer-science/program-language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/"},{"name":"C Programming Language","slug":"computer-science/program-language/C-Programming-Language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/C-Programming-Language/"}],"tags":[]},{"title":"PHP 串接資料庫","slug":"computer-science/program-language/PHP/PHP-串接資料庫","date":"2023-08-13T08:10:47.000Z","updated":"2023-12-15T18:33:16.876Z","comments":true,"path":"computer-science/program-language/PHP/PHP-串接資料庫/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/program-language/PHP/PHP-%E4%B8%B2%E6%8E%A5%E8%B3%87%E6%96%99%E5%BA%AB/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 與資料庫的結合運用 在 PHP 中連結資料庫 all.php&lt;?php require '../header.php'; ?>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', '帳號', '密碼');?>&lt;?php require '../footer.php'; ?>網頁沒有顯示錯誤訊息就表示連接成功。 # 利用 PDO 連接資料庫 在 PHP 中要連結資料庫，通常使用提供了 PHP 與資料庫間的連線機制的 PDO。 在 PHP 中，可以使用 類別 (Class) 來統整定義相關的變數與函式。 PDO 即是一種類別，裡面包含了操作資料庫時會使用到的變數與函式。 類別中的變數稱為 屬性 (property)，類別內的函式稱為 方法 (Method)。 要使用類別之前，一定要產生 instance。 # 產生 PDO 的 instance $pdo=new PDO(...); 用來識別資料庫的參數 (DSN) 'mysql:host=localhost;dbname=shop;charset=utf8' mysql 表示要連線到 MySQL。在冒號 (:) 之後列出連線資料庫所需的資料，並以分號 ( ; ) 分隔每項資料。 host=localhost 是指 MySQL 存在於 localhost。在此所用的 MySQL，是與 XAMPP 一起安裝在您手邊的電腦上，因此指定位置為 localhost。 dbname=shop 表示 shop 資料庫。 charset=utf8 則表示資料庫所用的文字編碼為 UTF-8。 登入的使用者名稱 'staff'第 2 個參數用來設定登入資料庫的使用者名稱。 這裡指定為建立 shop 資料庫時建立的使用者 staff。必須以單引號 (') 框住。 登入密碼 'password'第 3 個參數用來設定登入密碼。 這裡指定為建立使用者所設定的密碼 password。必須以單引號 (') 框住。 用 PHP 顯示 table 中資料 all2.php&lt;?php require '../header.php'; ?>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');foreach ($pdo->query('select * from product') as $row) &#123; echo '&lt;p>'; echo $row['id'], ':'; echo $row['name'], ':'; echo $row['price']; echo '&lt;/p>';&#125;?>&lt;?php require '../footer.php'; ?>all3.php&lt;?php require '../header.php'; ?>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');foreach ($pdo->query('select * from product') as $row) &#123; echo \"&lt;p>$row[id]:$row[name]:$row[price]&lt;/p>\";&#125;?>&lt;?php require '../footer.php'; ?>以雙引號框住的字串，具有可在字串之中插入變數值的功能。 # 執行 SQL 指令 PDO的變數->query('SQL指令')變數 PDO 名字是 $pdo $pdo->query('SQL指令')呼叫方法的程式寫法為 (變數 -&gt; 方法 ) # 取得資料欄內的資料 陣列名稱['資料欄名稱']利用 foreach 迴圈，就可將資料逐筆處理。 用 PHP 顯示 Table 中資料 all4.php&lt;?php require '../header.php'; ?>&lt;table>&lt;tr>&lt;th>商品編號&lt;/th>&lt;th>商品名稱&lt;/th>&lt;th>商品價格&lt;/th>&lt;/tr>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=pratice;charset=utf8', '帳號', '密碼');foreach ($pdo->query('select * from person') as $row) &#123; echo \"&lt;tr>&lt;td>$row[person_id]&lt;/td>&lt;td>$row[person_name]&lt;/td>&lt;td>$row[person_birth]&lt;/td>&lt;/tr>\"; echo \"\\n\";&#125;?>&lt;/table>&lt;?php require '../footer.php'; ?>以雙引號框住的字串，具有可在字串之中插入變數值的功能。 all5.php&lt;?php require '../header.php'; ?>&lt;table>&lt;tr>&lt;th>商品編號&lt;/th>&lt;th>商品名稱&lt;/th>&lt;th>商品價格&lt;/th>&lt;/tr>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');foreach ($pdo->query('select * from product') as $row) &#123; echo '&lt;tr>'; echo '&lt;td>', htmlspecialchars($row['id']), '&lt;/td>'; echo '&lt;td>', htmlspecialchars($row['name']), '&lt;/td>'; echo '&lt;td>', htmlspecialchars($row['price']), '&lt;/td>'; echo '&lt;/tr>'; echo \"\\n\";&#125;?>&lt;/table>&lt;?php require '../footer.php'; ?>資料中若有可能包含在 HTML 中有特殊意義的字，顯示前應先經 htmlspecialchars 函式處理。 # 函式的定義 PHP 不僅提供了許多現成的函式，程式設計師也可自行撰寫需要的函式。 function 函式名稱(傳入參數, ...)&#123; 執行的處理; ... return 回傳值;&#125;# 資料的搜尋 用欄位中的名稱搜尋資料 search-input.php&lt;?php require '../header.php'; ?>請輸入商品名稱：&lt;form action=\"search-output.php\" method=\"post\">&lt;input type=\"text\" name=\"keyword\">&lt;input type=\"submit\" value=\"搜尋\">&lt;/form>&lt;?php require '../footer.php'; ?>search-output.php&lt;?php require '../header.php'; ?>&lt;table>&lt;tr>&lt;th>商品編號&lt;/th>&lt;th>商品名稱&lt;/th>&lt;th>商品價格&lt;/th>&lt;/tr>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');$sql=$pdo->prepare('select * from product where name=?');$sql->execute([$_REQUEST['keyword']]);foreach ($sql->fetchAll() as $row) &#123; echo '&lt;tr>'; echo '&lt;td>', $row['id'], '&lt;/td>'; echo '&lt;td>', $row['name'], '&lt;/td>'; echo '&lt;td>', $row['price'], '&lt;/td>'; echo '&lt;/tr>'; echo \"\\n\";&#125;?>&lt;/table>&lt;?php require '../footer.php'; ?> # where 在 SQL 的 select 敘述中，用來指定搜尋條件，在他之後直接寫出條件式。 where 資料欄名稱 ='搜尋的鍵值'可以用？來代替之後才要代入的值。 select * from product where 資料欄名稱 =?# prepare 是用來進行 SQL 指令執行前的準備。 PDO的變數->prepare('SQL指令')prepare 方法在執行後，會回傳已設定好 SQL 指令的 PDOStatement 實例。 這個實例在之後執行 SQL 指令時還是會用到，因此要先將它指定給變數。 $sql=$pdo->prepare('select * from product where name=?'); # execute 要執行以傳入參數傳入 prepare 方法的 SQL 指令，必須利用 PHP 內建的 PDOStatement 類別的 execute 方法。 變數->execute(值)若指令中有多個 (?) 時，可以用 ( , ) 分隔多值。 [$_REQUEST['first_keyword'], $_REQUEST['second_keywork']]利用 prepare 方法預處理好 SQL 指令，要利用 execute 方法執行。 # fetchAll 利用 execute 方法執行 SQL 指令後，可再利用 PDOStatement 類別的 fetchAll 方法取的執行結果。 foreach(PDO的變數->fetchAll() as 要將取的結果代入的變數)foreach ($sql->fetchAll() as $row) &#123;# like 搜尋部分符合的商品 select * from product where name like ?;? =&gt; %word% 指就算 word 前後有其他字也符合條件 $sql=$pdo->prepare('select * from product where name like ?');$sql->execute(['%'.$_REQUEST['keyword'].'%']);# not like 找出不含搜尋關鍵字的資訊 select * from product where name not like ?;# like and not like select * from product where name like ? and name not like ?;# 在資料表內新增資料 insert-input.php&lt;?php require '../header.php'; ?>&lt;p>資料新增：&lt;/p>&lt;form action=\"insert-output.php\" method=\"post\">商品名稱&lt;input type=\"text\" name=\"name\">價格&lt;input type=\"text\" name=\"price\">&lt;input type=\"submit\" value=\"確定新增\">&lt;/form>&lt;?php require '../footer.php'; ?>insert-output.php&lt;?php require '../header.php'; ?>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');$sql=$pdo->prepare('insert into product values(null, ?, ?)');if ($sql->execute([$_REQUEST['name'], $_REQUEST['price']])) &#123; echo '新增成功。';&#125; else &#123; echo '新增失敗。';&#125;?>&lt;?php require '../footer.php'; ?>insert-output2.php&lt;?php require '../header.php'; ?>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');$sql=$pdo->prepare('insert into product values(null, ?, ?)');if (empty($_REQUEST['name'])) &#123; echo '請輸入商品名稱。';&#125; else if (!preg_match('/[0-9]+/', $_REQUEST['price'])) &#123; echo '請以整數輸入商品價格。';&#125; else if ($sql->execute( [htmlspecialchars($_REQUEST['name']), $_REQUEST['price']] )) &#123; echo '新增成功。'; &#125; else &#123; echo '新增失敗。'; &#125;?>&lt;?php require '../footer.php'; ?> # empty 在值為空時，回傳 TRUE。 empty(值)# 資料隱碼攻擊 (SQL injection) 說到要預防資料庫存入有問題的資料，就必須提到 資料隱碼攻擊 (SQL injection)。 資料隱碼攻擊 是指系統執行了非開發者撰寫的 SQL 指令，導致資料庫被非法存取的問題。 # 修改資料庫資料 update-input.php&lt;?php require '../header.php'; ?>&lt;table>&lt;tr>&lt;th>商品編號&lt;/th>&lt;th>商品名稱&lt;/th>&lt;th>商品價格&lt;/th>&lt;/tr>&lt;?php$pdo=new PDO( 'mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');foreach ($pdo->query('select * from product') as $row) &#123; echo '&lt;tr>&lt;form action=\"update-output.php\" method=\"post\">'; echo '&lt;input type=\"hidden\" name=\"id\" value=\"', $row['id'], '\">'; echo '&lt;td>', $row['id'], '&lt;/td>'; echo '&lt;td>'; echo '&lt;input type=\"text\" name=\"name\" value=\"', $row['name'], '\">'; echo '&lt;/td>'; echo '&lt;td>'; echo '&lt;input type=\"text\" name=\"price\" value=\"', $row['price'], '\">'; echo '&lt;/td>'; echo '&lt;td>&lt;input type=\"submit\" value=\"確定修改\">&lt;/td>'; echo '&lt;/form>&lt;/tr>'; echo \"\\n\";&#125;?>&lt;/table>&lt;?php require '../footer.php'; ?>update-output.php&lt;?php require '../header.php'; ?>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');$sql=$pdo->prepare('update product set name=?, price=? where id=?');if (empty($_REQUEST['name'])) &#123; echo '請輸入商品名稱。';&#125; elseif (!preg_match('/[0-9]+/', $_REQUEST['price'])) &#123; echo '請以整數輸入商品價格。';&#125; elseif ($sql->execute( [htmlspecialchars($_REQUEST['name']), $_REQUEST['price'], $_REQUEST['id']])) &#123; echo '修改成功。';&#125; else &#123; echo '修改失敗。';&#125;?>&lt;?php require '../footer.php'; ?> # 刪除資料庫資料 delete-input.php&lt;?php require '../header.php'; ?>&lt;table>&lt;tr>&lt;th>商品編號&lt;/th>&lt;th>商品名稱&lt;/th>&lt;th>商品價格&lt;/th>&lt;/tr>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');foreach ($pdo->query('select * from product') as $row) &#123; echo '&lt;tr>'; echo '&lt;td>', $row['id'], '&lt;/td>'; echo '&lt;td>', $row['name'], '&lt;/td>'; echo '&lt;td>', $row['price'], '&lt;/td>'; echo '&lt;td>'; echo '&lt;a href=\"delete-output.php?id=', $row['id'], '\">確定刪除&lt;/a>'; echo '&lt;/td>'; echo '&lt;/tr>'; echo \"\\n\";&#125;?>&lt;/table>&lt;?php require '../footer.php'; ?>delete-output.php&lt;?php require '../header.php'; ?>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');$sql=$pdo->prepare('delete from product where id=?');if ($sql->execute([$_REQUEST['id']])) &#123; echo '刪除成功。';&#125; else &#123; echo '刪除失敗。';&#125;?>&lt;?php require '../footer.php'; ?> # 含有 REQUEST 參數的連結 要開啟的檔案名稱?REQUEST參數名=值要開啟的檔案名稱?REQUEST參數名=值 &amp; REQUEST參數名=值 &amp;...echo '&lt;a href=\"delete-output.php?id=', $row['id'], '\">確定刪除&lt;/a>';# 整合新增、修改、刪除 edit3.php&lt;?php require '../header.php'; ?>&lt;table>&lt;tr>&lt;th>商品編號&lt;/th>&lt;th>商品名稱&lt;/th>&lt;th>價格&lt;/th>&lt;/tr>&lt;?php$pdo=new PDO('mysql:host=localhost;dbname=shop;charset=utf8', 'staff', 'password');if (isset($_REQUEST['command'])) &#123; switch ($_REQUEST['command']) &#123; case 'insert': if (empty($_REQUEST['name']) || !preg_match('/[0-9]+/', $_REQUEST['price'])) break; $sql=$pdo->prepare('insert into product values(null,?,?)'); $sql->execute( [htmlspecialchars($_REQUEST['name']), $_REQUEST['price']]); break; case 'update': if (empty($_REQUEST['name']) || !preg_match('/[0-9]+/', $_REQUEST['price'])) break; $sql=$pdo->prepare( 'update product set name=?, price=? where id=?'); $sql->execute( [htmlspecialchars($_REQUEST['name']), $_REQUEST['price'], $_REQUEST['id']]); break; case 'delete': $sql=$pdo->prepare('delete from product where id=?'); $sql->execute([$_REQUEST['id']]); break; &#125;&#125;foreach ($pdo->query('select * from product') as $row) &#123; echo '&lt;tr>'; echo '&lt;form action=\"edit3.php\" method=\"post\">'; echo '&lt;input type=\"hidden\" name=\"command\" value=\"update\">'; echo '&lt;input type=\"hidden\" name=\"id\" value=\"', $row['id'], '\">'; echo '&lt;td>', $row['id'], '&lt;/td>'; echo '&lt;td>'; echo '&lt;input type=\"text\" name=\"name\" value=\"', $row['name'], '\">'; echo '&lt;/td>'; echo '&lt;td>'; echo '&lt;input type=\"text\" name=\"price\" value=\"', $row['price'], '\">'; echo '&lt;/td>'; echo '&lt;td>&lt;input type=\"submit\" value=\"確定修改\">&lt;/td>'; echo '&lt;/form>'; echo '&lt;form action=\"edit3.php\" method=\"post\">'; echo '&lt;input type=\"hidden\" name=\"command\" value=\"delete\">'; echo '&lt;input type=\"hidden\" name=\"id\" value=\"', $row['id'], '\">'; echo '&lt;td>&lt;input type=\"submit\" value=\"確定刪除\">&lt;/td>'; echo '&lt;/form>'; echo '&lt;/tr>'; echo \"\\n\";&#125;?>&lt;tr>&lt;form action=\"edit3.php\" method=\"post\">&lt;input type=\"hidden\" name=\"command\" value=\"insert\">&lt;td>&lt;/td>&lt;td>&lt;input type=\"text\" name=\"name\">&lt;/td>&lt;td>&lt;input type=\"text\" name=\"price\">&lt;/td>&lt;td>&lt;input type=\"submit\" value=\"確定新增\">&lt;/td>&lt;/form>&lt;/tr>&lt;/table>&lt;?php require '../footer.php'; ?> # 實用的 PHP 程式 - 以購物網站為例 # Session 是在網頁應用程式中用來放置各使用者資料的機制。 利用 Session 機制，就能管理每個使用者的個別資料。 在 PHP 中，可透過 $_SESSION 陣列存取 Session 資料。 # 網站上線的實務知識 # 限制錯誤訊息的顯示 error_reporting(級別);級別 常數 意義 0 隱藏所有錯誤訊息 E_ERROR 出現重大的執行錯誤時，中斷程式的執行 E_WARNING 執行時出現的警告不會中斷程式的執行 E_PARSE 解釋程式時出現錯誤。會在語法錯誤時發生 E_NOTICE 執行時出現注意。會在懷疑程式可能有誤發生時 E_ALL 顯示所有錯誤訊息 # 利用框架 (Framework) 框架 (Framework) 與函式庫一樣，都是用來支援應用程式開發的軟體。 但是框架提供的不是好用的函式與類別，而且用來規範應用程式的技術方式。 框架並不是用來提供應用程式會用到的部分功能，而是用來提供建構應用程式的整體框架。 因此和函式庫一樣，若能善用框架，就能在短時間開發出功能更好的應用程式。 此外，在多人同時開發應用程式時，利用框架就能統一應用程式的技術方式。 可以讓開發團隊更容易共享資訊，提高開發效率。 Laravel https://laravel.com/","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Programming Language","slug":"computer-science/program-language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/"},{"name":"PHP","slug":"computer-science/program-language/PHP","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/PHP/"}],"tags":[]},{"title":"PHP 基本語法","slug":"computer-science/program-language/PHP/PHP-基本語法","date":"2023-08-13T06:49:13.000Z","updated":"2023-12-15T18:33:21.635Z","comments":true,"path":"computer-science/program-language/PHP/PHP-基本語法/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/program-language/PHP/PHP-%E5%9F%BA%E6%9C%AC%E8%AA%9E%E6%B3%95/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # PHP 標籤與程式碼 &lt;?phpPHP 程式內容?> PHP 只會執行 &lt;?php 與 ?&gt; 所框住的內容。 # echo 用來顯示文字訊息 echo '文字訊息'; 以 ' 或 &quot; 框住的內容會被當作是字串。 請留意每行程式的最後，都會有一個分號 (😉。 有多個敘述並列時，將由上至下依序執行。 &lt;?phpecho Welcome;?> 未定義常數 Welcome，錯誤發生於 C:\\xampp\\htdocs\\php\\chapter3\\welcome-error.php 第 2 行 # print 用來顯示文字訊息 print '文字訊息'; echo 和 print 都可用來顯示文字訊息。 通常認為 echo 的處理速度較快 (執行到顯示出訊息所需的時間較短)。 echo 具有將多個字串、數值連接起來顯示的功能。 HTML 區塊: 用於顯示固定不變的內容。 PHP 區塊: 用於顯示會因情況而變動的內容。 &lt;?php echo '歡迎光臨'; ?>可以化簡為 &lt;?= '歡迎光臨'; ?> # require 在 PHP 中，要載入並執行放在其他檔案中的程式，必須使用 require 敘述。 require '檔案名稱'; 可將程式中重複使用的內容存為獨立檔案，再用 require 載入他。 節省反覆輸入重複內容的時間，讓程式看起來更簡潔。 要修改共通使用的部分時，不需在多支程式裡分別修改，只要修改單一檔案的內容即可。 user-input.php&lt;?php require '../header.php'; ?>&lt;p>請輸入姓名：&lt;/p>&lt;form action=\"user-output.php\" method=\"post\"> &lt;!-- post v.s. get --> &lt;input type=\"text\" name=\"user\"> &lt;!-- user 是用在 PHP 中接收的 REQUEST 參數名 --> &lt;input type=\"submit\" value=\"確定\">&lt;/form>&lt;?php require '../footer.php'; ?># request 取得表單回傳的參數 (字串) $_REQUEST['REQUEST參數名']user-output.php&lt;?php require '../header.php'; ?>&lt;?phpecho '午安，', $_REQUEST['user'], '您好。';?>&lt;?php require '../footer.php'; ?># 優化程式 避免出現 REQUEST 參數名 未被定義 (Undefined) 的情形，可以用以下寫法。 &lt;?php require '../header.php'; ?>&lt;?phpif (isset($_REQUEST['user'])) &#123; echo '午安，', $_REQUEST['user'], '您好。';&#125;?>&lt;?php require '../footer.php'; ?> 避免出現 輸入內容含有 HTML，並被執行 的情形，可以用以下寫法。 &lt;?php require '../header.php'; ?>&lt;?phpif (isset($_REQUEST['user'])) &#123; echo '午安，', htmlspecialchars($_REQUEST['user']), '您好。';&#125;?>&lt;?php require '../footer.php'; ?> # 算符 (或稱運算子 Operator) 進行計算的處理即稱為「運算」 算符 作用 ** 平方 ++ -- 加 1、減 1 ! 邏輯 (反值) * / % 乘法、除法、餘數 + - . 加法、減法、字串相連 &lt; &lt;= &gt; &gt;= 比較 (小於、小於等於、大於、大於等於) == != 比較 (等於、不等於) &amp;&amp; 邏輯 (AND) || 邏輯 (OR) = 指派 算符有優先順序之分 # 變數 是用來存放資料的機制 變數名稱的前面必須加上錢字號 ($)。 開頭第 1 個字必須為英文字母或底線 (_)。 除了第 1 個字之外，其他可用英文字母、數字、底線隨意組成。 英文字母的大小寫視為不同文字。 預先定義好的變數 自行定義的變數名稱不可與這些 PHP 預先定義的變數名稱相同 變數名稱 功能 $_REQUEST HTTP 的所有 REQUEST 參數 (無論是以 GET 或 POST 方式傳送) $_GET HTTP 以 GET 方式傳送的 REQUEST 參數 $_POST HTTP 以 POST 方式傳送的 REQUEST 參數 $_FILES 上傳檔案的資料 $_SESSION Session $_COOKIE Cookie # 指派 「=」被稱為指派算符，可將他右邊的值寫入左邊的變數。 變數=值# 變數之間的指派 變數A=變數B# 常數 一開始指派了常數的值之後，就不能再對值做變更。 const 常數名=值# 陣列 (Array) 陣列內區分為多個區塊，用來存放多個資料值，這些區塊稱為陣列的元素。 為了區隔個別元素，必須使用 索引 (index) 來存取。 陣列=[值A, 值B, 值C, ...];陣列=[ 值A, 值B, 值C, ...];陣列=[索引A => 值A,索引B => 值B,索引C => 值C,...];陣列=[ 索引A => 值A, 索引B => 值B, 索引C => 值C, ...];# 新增元素 陣列[]=新元素;# 流程控制 核取方塊 check-input.php&lt;?php require '../header.php'; ?>&lt;form action=\"check-output.php\" method=\"post\"> &lt;p>&lt;input type=\"checkbox\" name=\"mail\">訂閱特賣情報電子報&lt;/p> &lt;p>&lt;input type=\"submit\" value=\"確定\">&lt;/p>&lt;/form>&lt;?php require '../footer.php'; ?> check-output.php&lt;?php require '../header.php'; ?>&lt;?phpif (isset($_REQUEST['mail'])) &#123; echo '已訂閱特賣情報電子報。';&#125; else &#123; echo '未訂閱特賣情報電子報。';&#125;?>&lt;?php require '../footer.php'; ?> # if if 判斷式是 PHP 中用於條件分歧的語法之一。 if(條件)&#123; 條件成立時進行的處理;&#125;以真偽值代入 if 判斷式 if(條件)&#123; 條件為 TRUE 時執行的處理;&#125;# if-else 在條件成立時與條件不成立時，分別執行對應的處理。 if(條件)&#123; 條件成立時進行的處理;&#125; else&#123; 條件不成立時進行的處理;&#125;以真偽值代入 if-else 判斷式 if(條件)&#123; 條件為 TRUE 時執行的處理;&#125; else&#123; 條件為 FALSE 時執行的處理;&#125;# isset 檢查變數是否宣告， NULL 是用來表示變數內為空值的特殊值。 若變數中已代入值且其值不為 NULL 時，則回傳 TRUE 。 isset(變數)在 if 判斷式中使用 REQUEST 參數 if(isset(REQUEST 參數中的變數))&#123; 變數已宣告時要執行的處理;&#125;在 if-else 判斷式中使用 REQUEST 參數 if(isset(REQUEST 參數中的變數))&#123; 變數已宣告時要執行的處理;&#125; else&#123; 變數未宣告時要執行的處理;&#125;# 條件運算式 在 if 判斷式和 if-else 判斷式的條件中，也可使用運算式。 常數 + 算符 (運算子) + 常數 在 if 判斷式的條件中使用運算式 if(運算式)&#123; 當運算結果條件為 TRUE 時執行的處理;&#125;在 if-else 判斷式的條件中使用運算式 if(運算式)&#123; 當運算結果條件為 TRUE 時執行的處理;&#125; else&#123; 當運算結果條件為 FALSE 時執行的處理;&#125;省略大括號 &#123;&#125; 當 if 判斷式的 &#123;&#125; 中只有 1 行程式時，可省略 &#123;&#125; 。 但若 &#123;&#125; 有多行程式，則不可省略。 if(運算式) 當運算結果條件為 TRUE 時執行的處理;if(運算式) 當運算結果條件為 TRUE 時執行的處理; else 當運算結果條件為 FALSE 時執行的處理; 單選紐 radio-input.php&lt;?php require '../header.php'; ?>請選擇餐點：&lt;form action=\"radio-output.php\" method=\"post\"> &lt;p>&lt;input type=\"radio\" name=\"meal\" value=\"日式套餐\" checked>日式套餐&lt;/p> &lt;p>&lt;input type=\"radio\" name=\"meal\" value=\"西式套餐\">西式套餐&lt;/p> &lt;p>&lt;input type=\"radio\" name=\"meal\" value=\"中式套餐\">中式套餐&lt;/p> &lt;p>&lt;input type=\"submit\" value=\"確定\">&lt;/p>&lt;/form>&lt;?php require '../footer.php'; ?> radio-output.php&lt;?php require '../header.php'; ?>&lt;?phpswitch ($_REQUEST['meal']) &#123;case '日式套餐': echo '烤魚、燉菜、味噌湯、白飯、水果'; break;case '西式套餐': echo '果汁、水波蛋、薯餅、麵包、咖啡'; break;case '中式套餐': echo '春捲、煎餃、蛋花湯、炒飯、杏仁豆腐'; break;&#125;echo '將稍候送達';?>&lt;?php require '../footer.php'; ?> # switch 依照不同的輸入訊息顯示出不同訊息的程式，是常見將程式流程分成多段，再依使用者所選內容執行對應的流程。 switch (運算式) &#123;case 值A: 運算結果為 A 時應執行的處理; break;case 值B: 運算結果為 B 時應執行的處理; break;case 值C: 運算結果為 C 時應執行的處理; break;...&#125; 在 case 敘述的最後必須寫上 break 敘述，用來表示處理程序結果，跳出 switch 判斷式的區塊。請記得加上 break 敘述。 下拉式選單 select-input.php&lt;?php require '../header.php'; ?>&lt;p>請選擇座位類型：&lt;/p>&lt;form action=\"select-output.php\" method=\"post\"> &lt;select name=\"seat\"> &lt;option value=\"自由席\">自由席&lt;/option> &lt;option value=\"指定席\">指定席&lt;/option> &lt;option value=\"商務車廂\">商務車廂&lt;/option> &lt;/select> &lt;p>&lt;input type=\"submit\" value=\"確定\">&lt;/p>&lt;/form>&lt;?php require '../footer.php'; ?> select-output.php&lt;?php require '../header.php'; ?>&lt;?phpswitch ($_REQUEST['seat']) &#123;case '指定席': echo '需加付120元補票。'; break;case '商務車廂': echo '需加付250元補票。'; break;default: echo '不需補票。'; break;&#125;?>&lt;?php require '../footer.php'; ?> # default 以上皆非可以使用 default 敘述撰寫。 switch (條件運算式) &#123;case 值A: 運算結果為 A 時應執行的處理; break;case 值B: 運算結果為 B 時應執行的處理; break;default: 運算結果與所有 case 的值都不符合時應執行的處理; break;...&#125; 下拉式選單 select-for-input.php&lt;?php require '../header.php'; ?>&lt;p>請選擇訂購數量：&lt;/p>&lt;form action=\"select-for-output.php\" method=\"post\"> &lt;select name=\"count\"> &lt;option value=\"0\">0&lt;/option> &lt;option value=\"1\">1&lt;/option> &lt;option value=\"2\">2&lt;/option> &lt;option value=\"3\">3&lt;/option> &lt;option value=\"4\">4&lt;/option> &lt;option value=\"5\">5&lt;/option> &lt;option value=\"6\">6&lt;/option> &lt;option value=\"7\">7&lt;/option> &lt;option value=\"8\">8&lt;/option> &lt;option value=\"9\">9&lt;/option> &lt;/select> &lt;p>&lt;input type=\"submit\" value=\"確定\">&lt;/p>&lt;/form>&lt;?php require '../footer.php'; ?>select-for-input2.php&lt;?php require '../header.php'; ?>&lt;p>請選擇訂購數量：&lt;/p>&lt;form action=\"select-for-output.php\" method=\"post\"> &lt;select name=\"count\"> &lt;?php for ($i=0; $i&lt;10; $i++) &#123; echo '&lt;option value=\"', $i, '\">', $i, '&lt;/option>'; &#125; ?> &lt;/select> &lt;p>&lt;input type=\"submit\" value=\"確定\">&lt;/p>&lt;/form>&lt;?php require '../footer.php'; ?> select-for-output.php&lt;?php require '../header.php'; ?>&lt;?phpecho $_REQUEST['count'], '個商品放入購物車。';?>&lt;?php require '../footer.php'; ?> # for 用來進行重複處理的語法之一。 for(開始處理; 條件式; 更新處理)&#123; 重複執行的處理;&#125;# 比較算符 演算子 讀法 判斷結果為 TRUE 的情況 &lt; 小於 左邊值小於右邊 &gt; 大於 左邊值大於右邊 &lt;= 小於等於 左邊值小於等於右邊 (左邊值在右邊以下) &gt;= 大於等於 左邊值大於等於右邊 (左邊值在右邊以上) == 相等 左右相等 != 不相等 (! 為否定之意) 左右不相等 # while 用來進行重複處理的語法之一。 while(條件式)&#123; 重複執行的處理;&#125; for 迴圈與他最大的差異，在於 while 迴圈沒有開始處理和更新處理。 開始處理while(條件式)&#123; 重複執行的處理; 更新處理&#125;# foreach foreach(陣列 as 變數)&#123; 使用變數進行的處理;&#125;foreach($question as $item)&#123; echo '&lt;option value=\"', $item, '\">', $item, '&lt;/option>';&#125;foreach(陣列 as 索引鍵的變數 => 值的變數)&#123; 以索引鍵與值進行的處理;&#125;foreach($store as $key => $value)&#123; echo '&lt;option value=\"', $value, '\">', $key, '&lt;/option>';&#125;# 使用函式 # 呼叫函式 函式(傳入參數)函式(傳入參數1, 傳入參數2, ...)# 設定時區 date_default_timezone_set(地區)# 顯示日期時間 date 函式執行時，會先取得現在的日期時間，再依指定的格式將它當做字串回傳。 date(格式) 文字 說明 Y 年。4 位數 m 月。2 位數，無十位數時自動補 0 d 日。2 位數，無十位數時自動補 0 H 小時。2 位數，無十位數時自動補 0。24 小時制 i 分。2 位數，無十位數時自動補 0 s 秒。2 位數，無十位數時自動補 0 # rand 函式 用來隨機產生一組數值，如果未傳入任何參數，則會回傳 0 以上，亂數最大值以下的亂數回來。 rand()亂數最大值會依執行環境不同而有差異，利用 gettrandmax 函式就能取得最大值。 gettrandmax()rand(最小值, 最大值)# preg_match 函式 利用常規表達式檢查資料格式。 preg_match(模板, 輸入字串)當傳入參數中指定的模板與輸入字串的格式相符，則 preg_match 函式會回傳「1」、「TRUE」; 若格式不符，則回傳「0」、「FALSE」。 preg_match('/^[0-9]&#123;7&#125;$/', $postcode) ^ : 句首 [0-9] :0 ~ 9 的數字 1 個 &#123;7&#125; : 符合前項格式的文字 7 個 $ : 句尾 - : 連字號 (?=.*[a-z]) : 包含小寫英文字母 (a ~ z) (?=.*[A-Z]) : 包含大寫英文字母 (A ~ Z) (?=.*[0-9]) : 包含數字 (0 ~ 9) [a-zA-Z0-9] : 小寫英文字母、大寫英文字母、數字各 1 個 &#123;8,&#125; : 符合前項格式的文字 8 個以上 首先是「.」與「*」，「.」代表任意 1 字；「*」則代表它前面的文字重複 0 次以上。 兩者合一的「.*」，表示任意文字重複 0 次以上。 8 個字母 (包含) 以上，包含至少一個大寫字母、一個小寫字母、一個數字，正則表達式的含義如下： $pattern = '/^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])[a-zA-Z\\d]&#123;8,&#125;$/'; ^ 匹配字符串的開始位置 (?=.*[0-9]) 至少包含一個數字 (?=.*[a-z]) 至少包含一個小寫字母 (?=.*[A-Z]) 至少包含一個大寫字母 [a-zA-Z0-9]&#123;8,&#125; 由大小寫字母和數字組成的字符串，長度至少為 8 個字符 $ 匹配字符串的結束位置 # 將半形轉換成全形 mb_convert_kana(字串, 類型代碼)mb_convert_kana($_REQUEST['name'], 'R') // R 的代碼就表示將半形轉換成全形 類型代碼 意義 r 全形英文字母轉換成半形 R 半形英文字母轉換成全形 n 全形數字轉換成半形 N 半形數字轉換成全形 a 全形英數字轉換成半形 A 半形英數字轉換成全形 s 全形空格轉換成半形 S 半形空格轉換成全形 檔案讀寫 board-input.php&lt;?php require '../header.php'; ?>&lt;p>請輸入留言內容。&lt;/p>&lt;form action=\"board-output.php\" method=\"post\"> &lt;input type=\"text\" name=\"message\"> &lt;input type=\"submit\" value=\"送出\">&lt;/form>&lt;?php require '../footer.php'; ?> board-output.php&lt;?php require '../header.php'; ?>&lt;?php$file='board.txt';if (file_exists($file)) &#123; $board=json_decode(file_get_contents($file));&#125;$board[]=$_REQUEST['message'];file_put_contents($file, json_encode($board));foreach ($board as $message) &#123; echo '&lt;p>', $message, '&lt;/p>&lt;hr>';&#125;?>&lt;?php require '../footer.php'; ?> # 檔案存取 從檔案讀出所有留言清單 將新留言加入留言清單 將所有留言寫入檔案 顯示留言一覽 要與留言內容儲存到檔案，必須使用 JSON 格式。JSON 為 JSON JavaScript Object Notation 的縮寫。 JSON 是緣自於程式語言 JavaScript 的標記方式，除了 JavaScript，亦被運用在多種不同的程式語言。 在 PHP 中使用 JSON 的優點是可輕易地從檔案讀取、寫入字串與陣列等資料結構。 # 讀取檔案 指定的檔案 (資料夾) 存在時，會回傳 TRUE；若檔案 (資料夾) 不存在則回傳 FALSE。 file_exists(檔案名稱)讀取檔案 file_get_contents(檔案名稱)由於讀取檔案是以 JSON 格式儲存，必須先轉換成 PHP 可用的格式，此時使用可以用來進行 JSON 編碼的 json_decode 函式。 json_decode(字串)$board=json_decode(file_get_contents($file))將陣列轉換成 JSON 格式 json_encode(值)寫入檔案 file_put_contents(檔案名稱, 字串) 若要新增檔案不存在，則會新增一個檔案。 檔案上傳 upload-input.php&lt;?php require '../header.php'; ?>&lt;p>請選擇要上傳的檔案。&lt;/p>&lt;form action=\"upload-output.php\" method=\"post\" enctype=\"multipart/form-data\"> &lt;p>&lt;input type=\"file\" name=\"file\">&lt;/p> &lt;p>&lt;input type=\"submit\" value=\"開始上傳\">&lt;/p>&lt;/form>&lt;?php require '../footer.php'; ?> upload-output.php&lt;?php require '../header.php'; ?>&lt;?phpif (is_uploaded_file($_FILES['file']['tmp_name'])) &#123; if (!file_exists('upload')) &#123; mkdir('upload'); &#125; $file='upload/'.basename($_FILES['file']['name']); if (move_uploaded_file($_FILES['file']['tmp_name'], $file)) &#123; echo $file, '上傳成功。'; echo '&lt;p>&lt;img src=\"', $file, '\">&lt;/p>'; &#125; else &#123; echo '上傳失敗。'; &#125;&#125; else &#123; echo '請選擇檔案。';&#125;?>&lt;?php require '../footer.php'; ?> # 取得暫存檔的檔名 $_FILES['檔案選擇按鈕的名稱']['tmp_name'] tmp_name : 取得暫存檔檔名 name : 取得原檔名 # 檢查是否是輸入畫面所上傳的檔案 is_uploaded_file(檔案名稱)# 建立資料夾 mkdir(資料夾名稱)# 只抽取出檔案名 basename(路徑)# 儲存暫存檔 將上傳後產生的暫存檔移動到儲存上傳檔的位置。 move_uploaded_file(暫存檔的檔名, 儲存用的檔名)# 時間戳 # 時間參數 參數 說明 範例 Y 年，四位元數字 “1999″ y 年，二位元數字 “99″ m 月份，若不足二位元則在前面補零 “01″ 至 “12″ n 月份 “1″ 至 “12″ F 月份，英文全名 “January&quot; M 月份，三個英文字母 “Jan&quot; d 幾日，若不足二位元則前面補零 “01″ 至 “31″ j 幾日，二位元數字 “1″ 至 “31″ S 字尾加英文序數，二個英文字母 “th&quot;，&quot;nd&quot; w 星期幾，數字型 “0″ (星期日) 至 “6″ (星期六) l 星期幾，英文全名 “Friday&quot; D 星期幾，三個英文字母 “Fri&quot; A 上下午 “AM&quot;或是 “PM&quot; a 上下午 “am&quot;或是 “pm&quot; h 12 小時制的小時，若不足二位元則前面補零 “01″ 至 “12″ g 12 小時制的小時 “1″ 至 12″ H 24 小時制的小時，若不足二位元則前面補零 “00″ 至 “23″ G 24 小時制的小時 “0″ 至 “23″ i 分鐘 “00″ 至 “59″ s 秒 “00″ 至 “59″ v 毫秒 (PHP 7.0.0 以後) “654″ u 微秒，000000 (PHP 5.2.2 以後，DateTime::format () 才支援) “654321″ z 一年中的第幾天 “0″ 至 “365″ W 一年中的第幾週 “42″ t 該月份的天數 “28″ 至 “31″ U 總秒數 (1970-01-01 00:00:00 開始計算) 可參考 time () 函數","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Programming Language","slug":"computer-science/program-language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/"},{"name":"PHP","slug":"computer-science/program-language/PHP","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/PHP/"}],"tags":[]},{"title":"PHP infomation","slug":"computer-science/program-language/PHP/PHP-infomation","date":"2023-08-13T06:18:21.000Z","updated":"2023-12-15T18:33:11.789Z","comments":true,"path":"computer-science/program-language/PHP/PHP-infomation/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/program-language/PHP/PHP-infomation/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # PHP 的用途概要 PHP 主要用於製作網頁應用程式 (Web Application) HTML 無法做到的依 Request 內容變化處理，但是 PHP 程式可以製作。 JavaScript 程式更擅長在瀏覽器上就能解決的處理。 程式語言與程式 網頁應用程式示意圖 透過瀏覽器與網站伺服器使用網頁應用程式 Request 與 Response 網頁應用程式需進行的處理 # 建立開發環境 安裝之後你的電腦就是伺服器，具備了開發網頁應用程式時必備的網站伺服器和資料庫管理系統等軟體。 裡用 XAMPP 可一次建構好網站伺服器與資料庫 XAMPP 所包含的軟體 Apache MariaDB (MySQL) PHP 套件 Perl 套件 可以支援 Windows、Linux、Mac OS X 等作業系統。 LAMP Linux Apache MySQL PHP / Perl / Python 除 XAMPP 之外，LAMP 也是常指開發環境，LAMP 原本常用來建置網站伺服器的軟體合稱。 # 下載 XAMPP XAMPP 官方網站 https://www.apachefriends.org/zh_tw/index.html XAMPP 下載網頁 https://www.apachefriends.org/zh_tw/download.html # 安裝 XAMPP 執行安裝檔 選擇要安裝的軟體 選擇安裝路徑 開始安裝 # 啟動 XAMPP 控制面板 XAMPP Control Panel # 啟動 Apache # 確認 Apache 是否啟動 利用瀏覽器開啟下列 URL，確認 Apache 是否正常啟動。 http://localhost/ http://localhost/dashboard/ # 執行 PHP 程式 在檔案總管中開啟 C 磁碟機中 xampp 資料夾下的 htdocs 資料夾，即路徑 C:\\xampp\\htdocs。 這個 htdocs 資料夾內就是用來放置 PHP 程式和 HTML 等檔案。 請務必記住 http://localhost 與 C:\\xampp\\htdocs\\ 的對應關係。 要執行 PHP 程式時，必須輸入程式的對應 URL。 # 顯示執行結果 # 沒有正常顯示？ Apache 沒有啟動 檔案存放的位置不正確","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Programming Language","slug":"computer-science/program-language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/"},{"name":"PHP","slug":"computer-science/program-language/PHP","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/PHP/"}],"tags":[]},{"title":"What is API?","slug":"computer-science/Note/What-is-API","date":"2023-08-13T06:10:53.000Z","updated":"2023-08-14T13:26:10.377Z","comments":true,"path":"computer-science/Note/What-is-API/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Note/What-is-API/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # API 介紹: https://www.hububble.co/blog/api 引用文 https://aws.amazon.com/tw/what-is/api/ # 什麼是 API？ API 是使用一組定義和協定讓兩個軟體元件彼此通訊的機制。舉例來說，氣象局的軟體系統包含有每日的天氣資料。您手機中的天氣應用程式會透過 API 與此系統「交談」並且在您的手機顯示每日天氣的最新消息。 # API 代表什麼意思？ API 代表應用程式開發介面。在 API 的內容中，應用程式一詞指的是具有不同功能的任何軟體。可以將介面看作是兩個應用程式之間的服務合約。這份合約定義了兩者如何使用要求與回應彼此進行通訊。它們的 API 文件包含有關開發人員如何構建這些要求與回應的資訊。 # API 如何運作？ API 架構通常會藉由用戶端和伺服器來說明。傳送要求的應用程式稱為用戶端，傳送回應的應用程式則稱為伺服器。因此在天氣的例子當中，氣象局的天氣資料庫是伺服器，行動應用程式是用戶端。 API 有四種不同方式可以運作，具體取決於它們建立的時機以及原因為何。 SOAP API 這些 API 使用簡單物件存取協定 (Simple Object Access Protocol)。用戶端和伺服器使用 XML 交換訊息。這是過去較為常用，但是較不具有彈性的 API。 RPC API 這些 API 稱為遠端程序呼叫 (Remote Procedure Call)。用戶端在伺服器上完成功能 (或程序)，伺服器則將輸出傳回用戶端。 WebSocket API WebSocket API 是使用 JSON 物件傳遞資料的另一個現代 Web API 開發。WebSocket API 可支援用戶端應用程式以及伺服器之間的雙向通訊。伺服器可將回呼訊息傳送至連接的用戶端，使得它與 REST API 更有效率。 REST API 這是現今在 Web 上可以找到最常用以及最彈性的 API。用戶端傳送要求至伺服器作為資料。伺服器使用此用戶端輸入來啟動內部功能，並且將輸出資料傳回用戶端。讓我們在下面更詳細地看看 REST API。 # 什麼是 API 整合？ API 整合是會自動更新用戶端與伺服器之間資料的軟體元件。API 整合的一些例子是當自動資料從手機的圖片庫同步至雲端，或是當您前往其他時區時，時間與日期自動地在您的筆記型電腦上同步。企業可以使用它們有效地自動化許多系統功能。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Note","slug":"computer-science/Note","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Note/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Web/"}]},{"title":"Maven - create project","slug":"computer-science/Note/Maven-create-project","date":"2023-08-13T05:56:45.000Z","updated":"2023-08-13T06:54:38.054Z","comments":true,"path":"computer-science/Note/Maven-create-project/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/Note/Maven-create-project/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # Maven download https://maven.apache.org/download.cgi # 環境變數設定 ![](https://i.imgur.com/AWZuYAJ.png =400x) # 確認有安裝好 Maven mvn -v mvn -version # Create Project Cmd mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false powershell 珍惜生命，學習 Java 請少用 PowerShell 當成你主要的 Shell 環境 mvn archetype:generate '-DgroupId=com.mycompany.app' -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart '-DarchetypeVersion=1.4' -DinteractiveMode=false Git Bash mvn archetype:generate \\ -DgroupId=com.mycompany.app -DartifactId=my-app \\ -DarchetypeArtifactId=maven-archetype-quickstart \\ -DarchetypeVersion=1.4 -DinteractiveMode=false \\ 換行只有 bash 以上皆無法 mvn archetype:generate 並選取以下功能 # Add exec-maven-plugin &lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!-- 其他 plugins ... --&gt; &lt;!--===== 加入這段 =====--&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;java&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;mainClass&gt;com.mycompany.app.App&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!--===== 加入這段 =====--&gt; &lt;!-- 其他 plugins ... --&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;jar.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;name&gt;my-app&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt;&lt;!--設定Goal的執行方式--&gt; &lt;goals&gt; &lt;goal&gt;java&lt;/goal&gt; &lt;!--要設定的goal--&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;mainClass&gt;jar.App&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; # 清除 target mvn clean # 產生執行檔 Compile: 通常只下這行就可以執行了 mvn compile Building: 會完整的建構整個專案，並把專案打包成.jar 檔，供別人下載執行。但會產出較多檔案，且耗費較多時間 mvn package # 執行 Execute mvn exec:java","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Note","slug":"computer-science/Note","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Note/"}],"tags":[]},{"title":"Java spring boot 串接資料庫","slug":"computer-science/program-language/Framework/Java-Spring-boot/Java-spring-boot-串接資料庫","date":"2023-07-10T06:09:52.000Z","updated":"2023-12-15T18:45:42.999Z","comments":true,"path":"computer-science/program-language/Framework/Java-Spring-boot/Java-spring-boot-串接資料庫/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/program-language/Framework/Java-Spring-boot/Java-spring-boot-%E4%B8%B2%E6%8E%A5%E8%B3%87%E6%96%99%E5%BA%AB/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 資料庫串接檔案配置 檔案路徑: ruoyi-admin/src/main/resources/application.yml ruoyi-admin/src/main/resources/application-druid.yml # 資料庫搜尋 開始撰寫前，記得檢查資料庫配置文件是否修改正確！ # 信息操作處理 檔案路徑: ruoyi-admin/src/main/java/com.ruoyi/web/controller/system 創建檔案: ExerciseController ExerciseController.javapackage com.ruoyi.web.controller.system;import com.ruoyi.common.core.controller.BaseController;import com.ruoyi.system.domain.Exercise;import com.ruoyi.system.service.IExerciseService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;/** * 参数配置 信息操作处理 * * @author ruoyi */@RestController@RequestMapping(\"/system/exercise\")public class ExerciseController extends BaseController&#123; @Autowired private IExerciseService exerciseService; @GetMapping(\"/List\") public List&lt;Exercise> selectExerciseList()&#123; return exerciseService.selectExerciseList(); &#125;;&#125;# 參數配置表 檔案路徑: ruoyi-system/src/main/java/com.ruoyi.system/domain 創建檔案: Exercise.java Exercise.javapackage com.ruoyi.system.domain;import com.ruoyi.common.core.domain.BaseEntity;/** * 参数配置表 exercise * * @author ruoyi */public class Exercise extends BaseEntity&#123; private static final long serialVersionUID = 1L; private Integer id; private String exercise1; private String exercise2; private String exercise3; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getExercise1() &#123; return exercise1; &#125; public void setExercise1(String exercise1) &#123; this.exercise1 = exercise1; &#125; public String getExercise2() &#123; return exercise2; &#125; public void setExercise2(String exercise2) &#123; this.exercise2 = exercise2; &#125; public String getExercise3() &#123; return exercise3; &#125; public void setExercise3(String exercise3) &#123; this.exercise3 = exercise3; &#125;&#125;# 數據層 檔案路徑: ruoyi-system/src/main/java/com.ruoyi.system/mapper 創建檔案: ExerciseMapper.java ExerciseMapper.javapackage com.ruoyi.system.mapper;import com.ruoyi.system.domain.Exercise;import java.util.List;/** * 参数配置 数据层 * * @author ruoyi */public interface ExerciseMapper&#123; public List&lt;Exercise> selectExerciseList();&#125;# 服務層 檔案路徑: ruoyi-system/src/main/java/com.ruoyi.system/service/impl 創建檔案: ExerciseServiceImpl.java ExerciseServiceImpl.javapackage com.ruoyi.system.service.impl;import com.ruoyi.common.core.redis.RedisCache;import com.ruoyi.system.domain.Exercise;import com.ruoyi.system.mapper.ExerciseMapper;import com.ruoyi.system.service.IExerciseService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * 参数配置 服务层实现 * * @author ruoyi */@Servicepublic class ExerciseServiceImpl implements IExerciseService&#123; @Autowired private ExerciseMapper exerciseMapper; @Autowired private RedisCache redisCache; public List&lt;Exercise> selectExerciseList()&#123; return exerciseMapper.selectExerciseList(); &#125;;&#125; 檔案路徑: ruoyi-system/src/main/java/com.ruoyi.system/service 創建檔案: IExerciseService.java IExerciseService.javapackage com.ruoyi.system.service;import com.ruoyi.system.domain.Exercise;import java.util.List;/** * 参数配置 服务层 * * @author ruoyi */public interface IExerciseService&#123; public List&lt;Exercise> selectExerciseList();&#125;# SQL 內容 檔案路徑: ruoyi-system/src/main/resources/mapper.system 創建檔案: ExerciseMapper.xml ExerciseMapper.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">&lt;mapper namespace=\"com.ruoyi.system.mapper.ExerciseMapper\"> &lt;resultMap type=\"Exercise\" id=\"ExerciseResult\"> &lt;id property=\"id\" column=\"id\" /> &lt;result property=\"exercise1\" column=\"exercise_1\" /> &lt;result property=\"exercise2\" column=\"exercise_2\" /> &lt;result property=\"exercise3\" column=\"exercise_3\" /> &lt;/resultMap> &lt;sql id=\"selectExerciseVo\"> select * from exercise &lt;/sql> &lt;select id=\"selectExerciseList\" resultMap=\"ExerciseResult\"> &lt;include refid=\"selectExerciseVo\"/> &lt;/select>&lt;/mapper># 資料庫新增","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Programming Language","slug":"computer-science/program-language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/"},{"name":"Framework","slug":"computer-science/program-language/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/Framework/"},{"name":"Java Spring Boot","slug":"computer-science/program-language/Framework/Java-Spring-Boot","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/Framework/Java-Spring-Boot/"}],"tags":[]},{"title":"Java spring boot 框架概念","slug":"computer-science/program-language/Framework/Java-Spring-boot/Java-spring-boot-框架概念","date":"2023-07-10T06:08:58.000Z","updated":"2023-12-15T18:45:45.693Z","comments":true,"path":"computer-science/program-language/Framework/Java-Spring-boot/Java-spring-boot-框架概念/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/program-language/Framework/Java-Spring-boot/Java-spring-boot-%E6%A1%86%E6%9E%B6%E6%A6%82%E5%BF%B5/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 利用若依管理系統程式內容進行延伸撰寫，可以先 clone 若依管理系統的程式，方便跟上後面描述 (待附上連接) IDE: intellij API 測試工具: Postman (與 swagger 差異待比較) SQL Sever: MySQL/Xampp phpmyadmin # 檔案結構","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Programming Language","slug":"computer-science/program-language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/"},{"name":"Framework","slug":"computer-science/program-language/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/Framework/"},{"name":"Java Spring Boot","slug":"computer-science/program-language/Framework/Java-Spring-Boot","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/Framework/Java-Spring-Boot/"}],"tags":[]},{"title":"111. Minimum Depth of Binary Tree","slug":"coding/leetcode/Easy/111-Minimum-Depth-of-Binary-Tree","date":"2023-07-10T01:36:40.000Z","updated":"2023-12-15T19:03:51.834Z","comments":true,"path":"coding/leetcode/Easy/111-Minimum-Depth-of-Binary-Tree/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/111-Minimum-Depth-of-Binary-Tree/","excerpt":"","text":"⭐️ # 題目敘述 Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. # Example 1 Input: root = [3,9,20,null,null,15,7] Output: 2 # Example 2 Input: root = [2,null,3,null,4,null,5,null,6] Output: 5 # 解題思路 # Solution DFS// Definition for a binary tree node.public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode() &#123;&#125; TreeNode(int val) &#123; this.val = val; &#125; TreeNode(int val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125;&#125;class Solution &#123; public int minDepth(TreeNode root) &#123; return dfs(root); &#125; private int dfs(TreeNode root)&#123; if(root == null) return 0; if(root.left == null &amp;&amp; root.right == null) return 1; if(root.left == null) return 1 + dfs(root.right); if(root.right == null) return 1 + dfs(root.left); return 1 + Math.min(dfs(root.left), dfs(root.right)); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Tree","slug":"Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Tree/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Tree/"}]},{"title":"2024. Maximize the Confusion of an Exam","slug":"coding/leetcode/Medium/2024-Maximize-the-Confusion-of-an-Exam","date":"2023-07-07T01:40:57.000Z","updated":"2023-12-15T19:09:02.887Z","comments":true,"path":"coding/leetcode/Medium/2024-Maximize-the-Confusion-of-an-Exam/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2024-Maximize-the-Confusion-of-an-Exam/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 A teacher is writing a test with n true/false questions, with 'T' denoting true and 'F' denoting false. He wants to confuse the students by maximizing the number of consecutive questions with the same answer (multiple trues or multiple falses in a row). You are given a string answerKey , where answerKey[i] is the original answer to the ith question. In addition, you are given an integer k , the maximum number of times you may perform the following operation: Change the answer key for any question to 'T' or 'F' (i.e., set answerKey[i] to 'T' or 'F' ). Return the maximum number of consecutive 'T' s or 'F' s in the answer key after performing the operation at most k times. # Example 1 Input: answerKey = &quot;TTFF&quot;, k = 2 Output: 4 Explanation: We can replace both the 'F's with 'T's to make answerKey = &quot;TTTT&quot;. There are four consecutive 'T's. # Example 2 Input: answerKey = &quot;TFFT&quot;, k = 1 Output: 3 Explanation: We can replace the first 'T' with an 'F' to make answerKey = &quot;FFFT&quot;. Alternatively, we can replace the second 'T' with an 'F' to make answerKey = &quot;TFFF&quot;. In both cases, there are three consecutive 'F's. # Example 3 Input: answerKey = &quot;TTFTTFTT&quot;, k = 1 Output: 5 Explanation: We can replace the first 'F' to make answerKey = &quot;TTTTTFTT&quot; Alternatively, we can replace the second 'F' to make answerKey = &quot;TTFTTTTT&quot;. In both cases, there are five consecutive 'T's. # 解題思路 # Solution import java.util.HashMap;import java.util.Map;class Solution &#123; public int maxConsecutiveAnswers(String answerKey, int k) &#123; int n = answerKey.length(); int left = k, right = n; while (left &lt; right) &#123; int mid = (left + right + 1) / 2; if (isValid(answerKey, mid, k)) &#123; left = mid; &#125; else &#123; right = mid - 1; &#125; &#125; return left; &#125; public boolean isValid(String answerKey, int size, int k) &#123; int n = answerKey.length(); Map&lt;Character, Integer> counter = new HashMap&lt;>(); for (int i = 0; i &lt; size; i++) &#123; char c = answerKey.charAt(i); counter.put(c, counter.getOrDefault(c, 0) + 1); &#125; if (Math.min(counter.getOrDefault('T', 0), counter.getOrDefault('F', 0)) &lt;= k) &#123; return true; &#125; for (int i = size; i &lt; n; i++) &#123; char c1 = answerKey.charAt(i); counter.put(c1, counter.getOrDefault(c1, 0) + 1); char c2 = answerKey.charAt(i - size); counter.put(c2, counter.getOrDefault(c2, 0) - 1); if (Math.min(counter.getOrDefault('T', 0), counter.getOrDefault('F', 0)) &lt;= k) &#123; return true; &#125; &#125; return false; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"1493. Longest Subarray of 1's After Deleting One Element","slug":"coding/leetcode/Medium/1493-Longest-Subarray-of-1-s-After-Deleting-One-Element","date":"2023-07-05T04:09:53.000Z","updated":"2023-12-15T19:08:42.006Z","comments":true,"path":"coding/leetcode/Medium/1493-Longest-Subarray-of-1-s-After-Deleting-One-Element/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1493-Longest-Subarray-of-1-s-After-Deleting-One-Element/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a binary array nums , you should delete one element from it. Return the size of the longest non-empty subarray containing only 1 's in the resulting array. Return 0 if there is no such subarray. # Example 1 Input: nums = [1,1,0,1] Output: 3 Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's. # Example 2 Input: nums = [0,1,1,1,0,1,1,0,1] Output: 5 Explanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1]. # Example 3 Input: nums = [1,1,1] Output: 2 Explanation: You must delete one element. # 解題思路 # Solution class Solution &#123; public int longestSubarray(int[] nums) &#123; int n = nums.length; int left = 0; int zeros = 0; int ans = 0; for (int right = 0; right &lt; n; right++) &#123; if (nums[right] == 0) &#123; zeros++; &#125; while (zeros > 1) &#123; if (nums[left] == 0) &#123; zeros--; &#125; left++; &#125; ans = Math.max(ans, right - left + 1 - zeros); &#125; return (ans == n) ? ans - 1 : ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"}]},{"title":"上海實習 GoGo","slug":"上海實習-GoGo","date":"2023-07-04T04:32:49.000Z","updated":"2023-12-22T05:36:32.376Z","comments":true,"path":"上海實習-GoGo/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/%E4%B8%8A%E6%B5%B7%E5%AF%A6%E7%BF%92-GoGo/","excerpt":"","text":"# 2023.07.02 (日) 行程 8:00 ~ 10:00 立榮航空飛機 台北松山 (TSA) - 上海浦東 (PVG) 12:00 ~ 13:00 前往如家酒店.neo (上海火車站店)/ 午餐 14:00 ~ 16:00 辦理電話卡 16:00 ~ 19:00 吃晚餐 # 紀錄 日記 第一天抵達上海，沒想到天氣還蠻熱的，今天還沒開始實習，下午由上海市科協的老師帶我們去申辦電話卡，因為我們人蠻多的，所以了一些時間，不過其實整個辦理的流程很快，接下來就是吃完餐了，但因為今天一大早就搭飛機，5:00 就到松山機場，前一天基本上也沒睡，所以我吃飯到後面的時候基本都在打嗑睡，吃的差不多的時候發現外面下大雷雨，本來想說等雨小一點再去搭地鐵，但是依舊很大，我們就分別叫車回去，不過下雨天的滴滴真的不好叫，最後我坐上海市科協老師的車回酒店的，回酒店一洗完澡直接開始睡覺，本來想做一些事情，但是完全抵擋不住睡意。 # 2023.07.03 (一) 行程 7:00 ~ 8:00 起床洗漱 8:00 ~ 8:30 地鐵 1 號線 + 528 公交 → 區塊鏈生態谷 8:40 抵達公司 上海计算机软件技术开发中心 - 大数据与区块链技术研究所 9:00 ~ 9:30 介紹一下公司環境 9:30 ~ 10:00 辦理手續 / 安排工位 10:00 ~ 11:20 需求分析培訓 / 撰寫功能清單 11:20 ~ 12:00 吃飯 12:00 ~ 13:30 跟胡晨路上海銀行辦理銀行卡 (沒有成功) 13:30 ~ 17:00 撰寫功能清單 17:00 ~ 17:30 下班 跟吳小麗掃碼自行車 + 地鐵 18:30 ~ 19:30 吃晚餐 # 紀錄 學習項目 今天主要做的事為需求分析培訓，講解了基本的需求分析流程，從概念、目標、非功能性的需求、產出進行闡述，並詳細說明功能性需求與非功能性需求兩個的差異，接著了解需求分析的項目實踐，包含項目介紹、需求分析過程 (需求調研、梳理功能、需求規格說明書)。 之前有就大致了解需求分析的相關概念，也實際參與過幾次專案的需求分析，所以在這方面我相對比較熟練，不過在這邊需求分析過程中的梳理功能，是我之前沒有嘗試過的，但我覺得這個方式蠻好的，利用功能清單可以更加明確、有條理的呈現所有需求，方便在撰寫需求規格說明書時，更加快速釐清所有功能性需求；在需求調研的部分是利用原型的方式進行，我藉由查閱原型完成功能清單。 日記 今天是正式實習的第一天，由於前一天實在太早睡了，我大概 6:30 左右就很有精神，本來以為是 9:00 上班想說不要壓線到，再加上我有點怕迷路，所以早早就出門，結果是 9:00 ~ 9:30 是上班時間，在 9:30 前到就好了，最後不小心太早到，整間公司基本上是暗的，第一次進公司默默地就跟一個人進去了，之後綜合辦來看到我超驚訝，想說我怎麼這麼早到，問我叫什麼名字時，拿了張紙讓我寫起來，但我只會寫繁體字，一下就被認出是台灣人。 接下來是我的指導老師來接我，他其實也蠻早到的，大家好像都叫他戴老師或戴所，學歷感覺蠻猛的，然後他就帶著我逛了一下公司，介紹了一下超宏偉的一樓，我覺得一樓感覺很高級，此外也稍微介紹了一下這邊的情況，說了許多人的名字，大概會有那些人會帶我，但實在是說太多人了，以至於我誰都沒記住哈哈哈，我記名字超爛，我記得小胡，這個稱呼，但我感覺我實在不是適合這樣叫他們，畢竟我應該是這裡最嫩的，啥都不會。 早上是由顧老師帶著我簡單的進行了需求分析的培訓，基本上 20 分鐘內就解決了，非常的快速，但其實這是我一整天的工作安排，所以我就開始做明天的，撰寫功能清單 (項目管理系統)，不過需求分析給的原型其實列的蠻清楚的，所以功能清單的文件其實寫得算很快，今天剩下最後一個小功能沒描述完，所以我把它帶回酒店寫一寫，順便把繁體字翻譯成簡體字。 中午的時候我與另一個大二實習生一起去吃飯，我們因為年紀一樣，所以聊起來比較多是校內課程，我們比較了一下課程名稱，基本每科名稱都不太一樣，後來我跟小胡一起去上海銀行辦卡，因為其實銀行下午一點才開始，所以我們就微微的聊一下天，感覺我們公司的人都蠻好的，微微聊了一下兩邊大學的內容，聊了一些偶像、遊戲跟動漫，感覺比想像中的還更加親切。 下班的時候因為公交車稍微遠了一點，所以由小麗老師帶我騎掃碼自行車，我一直覺得我腳踏車騎的應該還不錯，但是我騎上掃碼自行車後，我覺得它絕對是我今天最累的行程，那個龍頭超鬆的，手微微抖一下，方向就轉了，從後面看我一定在蛇行，真的很難控制，感覺整台車沒有摩擦力，我手把握的超緊的，回家收超酸。 # 2023.07.04 (二) 行程 8:00 ~ 8:30 起床洗漱 8:30 ~ 8:40 地鐵 1 號線 9:00 ~ 9:30 跟小劉一起坐北市上海園區公交 9:40 ~ 10:10 匯報昨天的功能清單 10:10 ~ 10:40 修改匯報時出現的問題 10:40 ~ 11:20 開始撰寫需求規格說明書 11:20 ~ 12:00 跟高悅一起吃自助餐 12:00 ~ 13:00 中午午休 / 寫 leetcode 13:00 ~ 17:00 勤奮工作 17:20 ~ 17:50 528 公交 + 地鐵 1 號線 18:40 ~ 19:30 買 + 吃晚餐 (東北千層餅 + 酸奶) 20:00 ~ 21:00 洗澡 + 休息 # 紀錄 學習項目 今天匯報了昨天完成的功能清單，第一次寫比較不確定，其實顧老師叫我說一下自己寫的內容的時候，我有點傻住了，還好我在報告上應該算是蠻擅長的，就開是報告了起來，但是因為只有我一個人報告，沒有比較的東西，所以我也不是很確定我這樣是不是還可以，不過老師沒有提出什麼問題，感覺應該還不錯，他建議我修改一些層級，把功能再區分成子功能，更方便釐清，確實這樣改我一下就更清楚所有功能。 因為功能清單原本是今天要完成的，就感覺下午在交就可以了，不過我昨天就用好，所以我一大早就先交出去了，因此接下來做的事情是三天的安排，撰寫需求規格說明書，包括項目概述、系統分析 (系統的初步調查)、產品概述 (營運可行性、技術可行性、開發的軟件可行性)、系統功能設計 (系統功能模塊圖、系統功能模塊詳細描述)、系統性能需求 (性能需求、系統兼容性和用戶體驗要求)，我今天先把項目的一些描述寫了一下，但由於我剛了解這個項目，所以寫起來還是比較卡的，不過老師說這份文件專注在寫功能設計及性能即可，因此我的項目概述就大致寫了一下我了解的項目內容。 日記 今天是第二天上班，跟小劉約一起座上海園區公交上班，準確來說是因為我不會搭，小劉帶著我搭，人也蠻好的，感覺很開朗，在車上我們稍微聊了一下上海可以遊玩的地方，他超認真的在介紹，但是我實在記不住這麼多，不過我有記住可以去陸家嘴騎自行車，感覺蠻不錯的。 今天座在工位上的時間比較多，一大早稍微拍了一下工位的樣子，發現我坐在研發部，感覺是個會禿頭的部門哈哈哈，今天早上先匯報了昨天完成的功能清單，就開始撰寫需求規格說明書，依舊還是撰寫文件，打字打到後面還是會很想睡覺，於是我戴上耳機，幫助自己提高專注力。 我午餐跟高悅一起去吃自助餐，感覺就跟陸劇場景一樣，不過我們是自己打飯菜，沒有手抖的食堂大媽，可惜的是我忘記拍照了，高悅是個很可愛的姊姊，非常的照顧我，基本上都會問我意見，只不過我對吃的真的就不是很在乎，所以我的回答就是都可以啊！感覺好爛，我下次努力有點想法，爭取不要讓大家尷尬。 下班回家的時候，因為小麗姐姐很忙，所以我是自己坐公交車回家的，我們的下班時間其實跟公交好像對不太上，所以都要等一陣子，回到飯店就稍微比較晚了，今天晚餐的時候，因為其他同學在他們上班的地方吃了，所以我是自己出去吃的，為了避免我支付寶不能用，所以我給樓下超商的阿姨 200 元，請他把錢轉到我的支付寶錢包裡，因為他好像比較常用微信支付，所已支付寶裡只有 200 元，所以我只能先存 200 了，不過應該可以撐幾天。 當然有支付寶了我就非常方便，可以自己吃飯，不用寄生於別人，結果第一次使用支付寶好像有蠻多優惠的，我的晚餐雖然計 11 元，但是因為支付寶優惠，最後其實不用錢，好爽，然後我再去買了很想喝的酸奶，想說上次來的時候幾乎天天喝，結果這次來就基本上找不到，找到也是常溫的，我覺得酸奶就是要冰的啊！ # 2023.07.05 (三) 行程 8:10 ~ 8:40 起床洗漱 8:45 ~ 8:55 地鐵 1 號線 9:00 ~ 9:30 坐北市上海園區公交 9:40 ~ 11:20 撰寫需求規格說明書 11:20 ~ 12:00 跟 4 位同事一起吃自助餐 12:00 ~ 13:00 中午午休 13:00 ~ 13:30 去上海銀行辦銀行卡 (成功) 13:30 ~ 14:30 匯報需求規格說明書 v1.0 14:30 ~ 17:00 修改匯報時遇到的問題 17:20 ~ 17:50 528 公交 + 地鐵 1 號線 18:40 ~ 20:30 叫外賣 (黃燜雞飯) + 吃 21:00 ~ 23:00 討論周末行程 23:00 ~ 23:30 洗澡 + 休息 # 紀錄 學習項目 今天早上把昨天的需求規格說明書整理一下後，畫了一些模組圖、流程圖，下午進行了匯報，雖然依舊無法進行比較，但顧老師提出了一些問題，包括詳細程度與文字排版的問題。 排版上因為我其實有一點找不到我 Word 的目錄修改在哪邊，所以這個我也當場問了一下，後來發現其實蠻好找的，老師也說了不用全部一個功能的描述全部寫一起，還是可以分段的，確實分段後更好閱讀，更容易專注於某個描述。 至於詳細程度了話，因為我之前基本就是把功能清單的說明加入到功能的說明中，當時寫得雖然已經蠻詳細的，不過確實有描述可以更清楚以及完整，我也近一步完善了這部分。 日記 今天是第三天上班，工作依舊是整理需求，撰寫需求規格說明書，但生活上還是有一些變化的，今天是我獨自搭北市園區的公交車，算是正式獨立上班了，午餐跟坐我附近的一些實習生一起吃，這次都是男生，討論了一些很有趣的事情，話題包括學校、結婚跟台灣是用什麼錢，他們還說我的位置很難摸魚，有一個男生說他原本坐我這，但因為太難摸魚了所以換了...，不考慮換回來嗎？其實我有發現，因為我的位置簡直就是交通樞紐，裝水、電梯、廁所全都要經過我，我真的會謝哈哈哈，不過我還是會聽歌來輔助我打字，不然真的好想睡。 中午回來我就跟小胡去上海銀行辦銀行卡，這次有實習證明相對就比較順利，但是還是卡了一下子，不過往好處想我至少辦成功了，在台灣的中國信託銀行都沒辦成功，在這辦成功了，而且就算因為我是台灣人比較麻煩，但是流程還是比中國信託銀行快了至少半天，我覺得中國信託銀行要檢討檢討，真的是做蠻爛的，一個上午只開了四個戶頭... 做事效率堪憂，重點我等了這麼久不給辦，好啦～～這是題外話，我就像嘴一下台灣的中國信託銀行，我只能說他是我前進的動力，我一定要搞垮中國信託銀行，之後我成功了有一半一定要感謝那些曾經看不起我的人。 然後辦完確認一下銀行卡可以用，我跟小胡回公司了，我們確認可以用的方法讓我覺得小胡真的是太好了，之前的飲料錢，我有支付寶後他也不跟我收，為了測試我的銀行可不可以轉錢，他直接轉了錢給我，我跟他說我在還給他，結果他不要，真的是讓我很手足無措啊！因為支付寶一定要對方同意顯示支付條碼才可以，不可以像台灣一樣阿嬤式塞錢法，還有前一天小麗姐姐用支付寶幫我用掃碼自行車，他也說不用沒關係，天啊！我真的是有被驚訝到。 晚餐因為有了銀行卡，所以我就試試看點了外賣，第一次用也太爽了，超多優惠，不過不確定是不是因為第一次用啦！有很多現金折抵的優惠，我的晚餐一下子變得很多有不太貴，甚至我吃不完。 # 2023.07.06 (四) 行程 8:20 ~ 8:40 起床洗漱 8:45 ~ 8:55 地鐵 1 號線 9:00 ~ 9:30 坐北市上海園區公交 9:40 ~ 11:20 撰寫需求規格說明書 11:20 ~ 12:00 跟 5 位同事一起吃自助餐 12:00 ~ 13:00 中午午休 / 打羽球、乒乓球 13:30 ~ 14:00 撰寫需求規格說明書 14:00 ~ 15:00 戴老師帶著我們了解公司的項目 16:30 ~ 17:15 最終匯報需求階段文件 17:20 ~ 18:00 走路 + 地鐵 1 號線 18:40 ~ 21:30 叫 + 吃外賣 (小龍蝦 + 喜茶) 21:30 ~ 00:00 休息 00:00 ~ 00:50 洗澡 # 紀錄 學習項目 今天繼續把昨天的需求規格說明書完善，從 14 頁直接暴增到 31 頁啊！兩倍啊啊啊啊！好多，總共 1 萬 4 千多字，還好我是用繁體打字，不然我大概要打一個禮拜吧，完全不會拼音的人，我直接用爛翻譯，繁體轉簡體，還被關注了一下我在做什麼，我快笑死。 因為我有一點超前進度了，所以我在今天向我的實習指導老師匯報了這週的工作內容，也是蠻突然的，完全沒有準備啊！不過整理狀況還是蠻好的，老師說整體做的還是蠻細緻的，指導我坐需求規格說明書的老師說，整體效率很快，交代的事情一下子就解決了，還不錯，不過到今天為止都還在我很熟練的部分，所以暫時都沒甚麼問題，只不過有一些方式我們用的不太一樣，但都很不錯值得使用。 日記 今天就是一個忙碌的一天，由於我前幾天就將需求規格說明書寫得差不多了，今天剩下排版、字型和繁體字轉簡體字等，簡單來說就是過了一下整份文件，然後就突然超多事，我的實習導師帶我去了解公司，之後他去見了一下客戶，我就開啟了匯報工作，真的是挺突然的。 晚上叫了我們小龍蝦，體驗了一下電視劇上面看起來很好吃的東西，確實真的蠻不錯的，不過感覺可以再吃辣一點，我們點十三香，下次可以試試其他口味，我們還叫了喜茶喝，真的不錯喝哈哈哈，什麼廢話，我是點芝芝玫影，下次想喝鴨喜香檸打茶。 # 2023.07.07 (五) 行程 8:20 ~ 8:40 起床洗漱 8:45 ~ 8:55 地鐵 1 號線 9:00 ~ 9:30 坐北市上海園區公交 9:40 ~ 11:20 上班？ 11:20 ~ 12:45 叫 + 吃外送酸菜魚 13:30 ~ 14:00 上班？ 15:30 ~ 16:00 聽了一下 spring boot 框架 16:00 ~ 17:00 上班？ 17:20 ~ 18:00 公交車 + 地鐵 1 號線 18:00 ~ 19:00 吃澆油麵 20:30 ~ 01:00 酒吧喝酒 01:20 ~ 01:25 參觀夜店... 哈哈哈 02:00 ~ 03:00 洗澡 # 紀錄 學習項目 今天簡單的了解了一下 java spring boot 框架，但由於大家今天有很多會議，上科院的領導也來了，好像還有客戶，所以大家其實今天沒什麼時間管我，所以我今天確實沒有很忙。 日記 今天撇除掉工作，我們下班還是很瘋的，一群人大概 10 個左右去了酒吧喝酒，因為坐卡座，低消 3000，貴到爛，但我們大概 8 點多，一路喝到 1 點左右，裡面有個小姐姐唱歌唱很多台灣歌手的歌，結果小萬 (我們這群的其中一位) 超級嗨，我快笑死，他還一直說我都不嗨，沒有喝很多，但其實我也喝了 6 ~ 7 杯左右了，第一次喝這麼多威士忌，聞起來真的很苦，我的小祕訣是喝酒前喝酸奶，感覺完全沒有醉的感覺，如果不想喝醉可以學學，但是隔天肚子超痛哈哈哈。 然後我們上廁所的時候認識了一個貴州的小姊姊，來上海讀大學跟實習，帶著一個約他一起出來玩的高學歷帥哥，結果我們最後拼在一起玩，我個人表示好扯，喝酒喝到拐走別人的小姐姐，最後連帥哥都一起了，後來我們還有去夜店玩，但是我真的是受不了煙味，那裏簡直煙霧瀰漫，所以我就進去了一下就出來了，感覺差點窒息在夜店裡，好可怕，聽說夜店這樣很正常，再也不去了嗚嗚嗚，出來手還好養。","categories":[],"tags":[]},{"title":"137. Single Number II","slug":"coding/leetcode/Medium/137-Single-Number-II","date":"2023-07-04T02:26:24.000Z","updated":"2023-12-15T19:07:14.923Z","comments":true,"path":"coding/leetcode/Medium/137-Single-Number-II/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/137-Single-Number-II/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it. You must implement a solution with a linear runtime complexity and use only constant extra space. # Example 1 Input: nums = [2,2,3,2] Output: 3 # Example 2 Input: nums = [0,1,0,1,0,1,99] Output: 99 # 解題思路 # Solution class Solution &#123; public int singleNumber(int[] nums) &#123; int once = 0, twice = 0; for(int num : nums)&#123; once = (num ^ once) &amp; (~twice); twice = (num ^ twice) &amp; (~once); &#125; return once; &#125;&#125; import java.util.HashMap;import java.util.Map;class Solution &#123; public int singleNumber(int[] nums) &#123; Map&lt;Integer, Integer> mp = new HashMap&lt;>(); for(int i = 0; i &lt; nums.length; i++)&#123; mp.put(nums[i], mp.getOrDefault(nums[i], 0) + 1); if(mp.get(nums[i]) == 3)&#123; mp.remove(nums[i]); &#125; &#125; int ans = 0; for(int m : mp.keySet())&#123; ans = m; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bit-Manipulation/"}]},{"title":"859. Buddy Strings","slug":"coding/leetcode/Easy/859-Buddy-Strings","date":"2023-07-03T14:43:19.000Z","updated":"2023-12-15T19:04:17.289Z","comments":true,"path":"coding/leetcode/Easy/859-Buddy-Strings/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/859-Buddy-Strings/","excerpt":"","text":"⭐️ # 題目敘述 Given two strings s and goal , return true if you can swap two letters in s so the result is equal to goal , otherwise, return false . Swapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j] . For example, swapping at indices 0 and 2 in &quot;abcd&quot; results in &quot;cbad&quot; . # Example 1 Input: s = &quot;ab&quot;, goal = &quot;ba&quot; Output: true Explanation: You can swap s[0] = 'a' and s[1] = 'b' to get &quot;ba&quot;, which is equal to goal. # Example 2 Input: s = &quot;ab&quot;, goal = &quot;ab&quot; Output: false Explanation: The only letters you can swap are s[0] = 'a' and s[1] = 'b', which results in &quot;ba&quot; != goal. # Example 3 Input: s = &quot;aa&quot;, goal = &quot;aa&quot; Output: true Explanation: You can swap s[0] = 'a' and s[1] = 'a' to get &quot;aa&quot;, which is equal to goal. # 解題思路 # Solution import java.util.HashSet;import java.util.Set;class Solution &#123; public boolean buddyStrings(String s, String goal) &#123; int n = s.length(); if (s.equals(goal)) &#123; Set&lt;Character> temp = new HashSet&lt;>(); for (char c : s.toCharArray()) &#123; temp.add(c); &#125; return temp.size() &lt; goal.length(); // Swapping same characters &#125; // two string equal int i = 0; int j = n - 1; while (i &lt; j &amp;&amp; s.charAt(i) == goal.charAt(i)) &#123; i++; &#125; while (j >= 0 &amp;&amp; s.charAt(j) == goal.charAt(j)) &#123; j--; &#125; if (i &lt; j) &#123; char[] clone = s.toCharArray(); char temp = clone[i]; clone[i] = clone[j]; clone[j] = temp; s = new String(clone); &#125; // Find two letter to swap, when two letter on deference string in same index isn't equal return s.equals(goal); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"Vue 指令","slug":"computer-science/program-language/Framework/Vue/Vue-指令","date":"2023-06-29T17:45:03.000Z","updated":"2023-12-15T18:47:34.755Z","comments":true,"path":"computer-science/program-language/Framework/Vue/Vue-指令/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/program-language/Framework/Vue/Vue-%E6%8C%87%E4%BB%A4/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # Text Interpolation Using the &quot;Mustache&quot; syntax (double curly braces 兩個大括號 &#123;&#123; &#125;&#125; ) &lt;p> &#123;&#123; value &#125;&#125; &lt;/p>But Mustaches cannot be used inside HTML attributes. # v-bind 用法 &lt;div v-bind:[attribute]=\"[Vue data]\">&lt;/div># v-if 、 v-else-if 、 v-else 用法 &lt;p v-if=\"score >= 80\">Perfect&lt;/p>&lt;p v-else-if=\"scroe > 60\">Good&lt;/p>&lt;p v-else>Poor&lt;/p> A condition, or &quot;if-statement&quot;, is something that is either true or false . A condition is often a comparison check between two values like in the example above to see if one value is greater than the other. We use comparison operators like &lt; , &gt;= or !== to do such checks. Comparison checks can also be combined with logical operators such as &amp;&amp; or || . &lt;script>export default &#123; data() &#123; return &#123; text: 'I like taco, pizza, Thai beef salad, pho soup and tagine.' &#125; &#125;&#125;&lt;/script>&lt;template> &lt;p v-if=\"text.includes('pizza')\">The text includes the word 'pizza'&lt;/p> &lt;p v-else>The word 'pizza' is not found in the text&lt;/p>&lt;/template># v-show 當條件為 false 時，該指令通過將 CSS display 屬性值設置為 none 來隱藏元素。 &lt;script>export default &#123; data() &#123; return &#123; showDiv: true &#125; &#125;&#125;&lt;/script>&lt;template> &lt;div v-show=\"showDiv\">This div tag can be hidden&lt;/div>&lt;/template># 參考 / 學習文章 官方文件 w3school 維基百科 MDN web docs Vue.js 30 天隨身包系列","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Programming Language","slug":"computer-science/program-language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/"},{"name":"Framework","slug":"computer-science/program-language/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/Framework/"},{"name":"Vue","slug":"computer-science/program-language/Framework/Vue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/Framework/Vue/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}]},{"title":"Vue 基本介紹","slug":"computer-science/program-language/Framework/Vue/Vue-基本介紹","date":"2023-06-29T12:51:20.000Z","updated":"2023-12-15T18:47:39.353Z","comments":true,"path":"computer-science/program-language/Framework/Vue/Vue-基本介紹/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/program-language/Framework/Vue/Vue-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 專案結構 tree /f > structure.txt有整理過的 structure.txtvue-project│ .gitignore│ env.d.ts│ index.html│ output.txt│ package-lock.json│ package.json│ README.md│ tsconfig.app.json│ tsconfig.json│ tsconfig.node.json│ vite.config.ts│ ├─.vscode│ extensions.json│ ├─public│ favicon.ico│ └─src │ App.vue │ main.ts │ ├─assets │ base.css │ logo.svg │ main.css │ └─components │ HelloWorld.vue │ └─icons IconCommunity.vue public ：這個資料夾包含了所有發布的靜態檔案，這些檔案在建置過程不會經過 Webpack 加工。（但是有一個例外： index.html 會有一些處理）。 favicon.ico ：這是應用程式的 favicon。目前是 Vue 的標誌。 index.html ：這是應用程式的模板。你的 Vue 應用程式會透過這個 HTML 頁面來運行，你也可以使用 lodash 樣板語言在這個頁面穿插一些值。 src ：這個資料夾是 Vue 專案的核心。 main.js ：這是應用程式的進入點。目前，這個檔案會初始化你的 Vue 應用程式並定義要將應用掛載到 index.html 檔案中的哪個 HTML 元素。通常還會在這個檔案註冊全域性元件或載入其他 Vue 函式庫。 App.vue ：這是 Vue 應用程式的根節點元件。往下看可以了解更多關於 Vue 元件的說明。 components ：你可以把你的元件放在這個資料夾。目前它只有放一個範例元件。 assets ：這個資料夾是用來放一些靜態檔案像是 CSS 和圖片。因為這些檔案在來源目錄下，它們可以透過 Webpack 加工處理。這表示你可以使用一些預處理器，像是 Sass / SCSS 或是 Stylus 。 # Web 元件化系統 Vue.js 嚮往的就是先建立好根實體 (Vue Instance)，再開發好底下每個小元件 (Components)，慢慢往上組合成一個完整頁面，最後全部搭建起來成為一個完整專案。 通常一個元件包含 html、css、js，而 Vue 會將其全部寫在一個 .vue 為副檔名的檔案當中，vue-loader 會編譯這個 .vue 的檔案，將結果顯示出來。 # Vue Instance 根實體 (Vue Instance) 是樹狀結構中最上面的那個點。 每個 Vue App 都是從創建一個 vue instance 開始，Vue Instance 是透過 Vue Constructor (建構式) 所產生。 在實體化時，可傳入一個選項物件 (Options)，此物件包含這個 vue instance 需要用到的屬性，像是掛載點 (el)、資料 (data)、方法 (methods)、模板 (template)、** 生命週期鉤子 (hooks)** 等等。 var vm = new Vue (&#123; // options&#125;) # .vue 檔案（單一檔案元件） Vue 讓你把模板、相關指令碼和 CSS 整合在一起放在以 .vue 結尾的檔案裡。這些檔案會被 JS 的打包工具（像是 Webpack ）加以處理，這也代表你可以在你的專案裡使用一些建置工具，像是 Babel 、 TypeScript 、 SCSS 等工具來創造更複雜的元件。 # App.vue 在創建專案時，你可以在 src 資料夾中，看到第一個 .vue 檔案。 由三個部分組成： &lt;template&gt; 、 &lt;script&gt; 以及 &lt;style&gt; ，分別包含了元件的模板、指令碼和樣式資訊。 所有的單一檔案元件都是使用這種基本架構。 App.vue&lt;script setup lang=\"ts\"> &#123;/* javascript */&#125;import HelloWorld from './components/HelloWorld.vue'import TheWelcome from './components/TheWelcome.vue'&lt;/script>&lt;template> &#123;/* html */&#125; &lt;header> &lt;img alt=\"Vue logo\" class=\"logo\" src=\"./assets/logo.svg\" width=\"125\" height=\"125\" /> &lt;div class=\"wrapper\"> &lt;HelloWorld msg=\"You did it!\" /> &lt;/div> &lt;/header> &lt;main> &lt;TheWelcome /> &lt;/main>&lt;/template>&lt;style scoped> &#123;/* css */&#125;header &#123; line-height: 1.5;&#125;.logo &#123; display: block; margin: 0 auto 2rem;&#125;&lt;/style> &lt;template&gt; 元件的模板: 包含所有的標記結構以及元件的呈現邏輯。 模板可以包含任何有效的 HTML，以及一些 Vue 特定的語法。 在 &lt;template&gt; 標籤上設定 lang 屬性。例如設置 &lt;template lang=&quot;pug&quot;&gt; ，你就可以使用 Pug 樣板語法來取代標準的 HTML 。在本教學中我們會使用標準 HTML ，但還是值得知道有這個方法。 &lt;script&gt; 指令碼: 包含元件中所有非顯示的邏輯。最重要的是， &lt;script&gt; 標籤必須輸出一個 JS 物件。 這個物件是在本地端註冊的元件，包含定義屬性、處理本地狀態、定義方法等等。 如果想要使用 TypeScript 語法，必須把 &lt;script&gt; 標籤的 lang 屬性設定成 &lt;script lang=&quot;ts&quot;&gt; 來告訴編譯器你要使用 TypeScript 。 &lt;style&gt; 樣式: 是撰寫元件的 CSS 的地方。 如果加上 scoped 屬性，例如 &lt;style scoped&gt; ， Vue 會把樣式的範圍限制在這個單一檔案元件裡。這類似 CSS-in-JS 的解決方案，但是它允許你寫單純的 CSS 。 如果在使用 CLI 創建專案時有選擇 CSS 預處理器，就可以在 &lt;style&gt; 標籤上添加 lang 屬性，這些內容在建置的時候將會被 Webpack 處理。舉例來說， &lt;style lang=&quot;scss&quot;&gt; 允許在樣式資訊中使用 SCSS 語法。 # Lifecycle Hooks 這 8 個 hook 的資料型態皆為 function: beforeCreate 在初始化 vue instance 並開啟整個 Lifecycle 後，資料綁定與事件配置之前。 目前階段還無法調用 $data 。 應用場景：loading 進頁面的事件 created vue instance 創建完成 $data 已可以取得，屬性與事件也已綁定好。 目前階段尚未掛載 el ，DOM 也尚未生成。 beforeMount 在掛載 el 開始之前。 目前階段是相關 render 函式首次被調用，尚未被 DOM 給綁定。 mounted el 被剛創建好的 vm.$el 替換取代，並且掛載到 vm 上。 目前階段已被 DOM 綁定。 應用場景：對後端發出請求或讀取新資料 beforeUpdate 在資料更新時調用，Virtual DOM 重新 render 與 patch 之前，可以在這個階段變更資料狀態。 目前階段還不會繪製 view。 updated 資料更新後會使 Virtual DOM 重新 render 頁面。 目前階段會繪製出正確的 view。 beforeDestroy 在 vue instance 被銷毀前調用。 目前階段還可以完全使用這個 vue instance。 destroyed vue instance 銷毀後可以調用 調用後這個 vue instance 底下的資料與樣板會解除綁定，事件會取消監聽，所有子元件也會被銷毀。 # Example var vm = new Vue(&#123; data: &#123; name: 'Eva', &#125;, beforeCreate: function() &#123; //vue instance 尚未創建完成，還不能讀取到資料 console.log('beforeCreate: My name is ' + this.name); &#125;, created: function() &#123; //vue instance 創建完成，資料已綁定 console.log('created: My name is ' + this.name); &#125;, beforeMount: function() &#123; // 尚未掛載 el 與綁定 DOM console.log('beforeMount: My name is ' + this.name); &#125;, mounted: function() &#123; // 綁定 DOM 之後 console.log('mounted: My name is ' + this.name); &#125;, beforeUpdate: function() &#123; // 資料更新時調用，尚未更新 DOM console.log('beforeUpdate: My name is ' + this.name); &#125;, updated: function() &#123; // 因為資料更新而更新 DOM console.log('updated: My name is ' + this.name); &#125;, beforeDestroy: function() &#123; // 銷毀整個 vue instance 之前 console.log('beforeDestroy'); &#125;, destroyed: function() &#123; // 銷毀整個 vue instance 之後 console.log('destroyed'); &#125;,&#125;);# 第一階段：beforeCreate /created 在綁定 el 之前，beforeCreate 階段還不能讀取資料 # 第二階段：beforeMount /mounted 加入 el 屬性在物件裡 # 第三階段：beforeUpdate /updated 因為要變更資料才會觸發這兩個 function，這邊我們使用強制變更資料 # 第四階段：beforeDestroy /destroyed 因為上面第三階段強制變更資料的方法會導致一直執行更新資料，所以先將剛剛新增的 vm.$beforeUpdate(); 刪掉，加入 destroy 的方法 # 參考 / 學習文章 官方文件 w3school 維基百科 MDN web docs Vue.js 30 天隨身包系列","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Programming Language","slug":"computer-science/program-language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/"},{"name":"Framework","slug":"computer-science/program-language/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/Framework/"},{"name":"Vue","slug":"computer-science/program-language/Framework/Vue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/Framework/Vue/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}]},{"title":"創建 Vue.js Project","slug":"computer-science/program-language/Framework/Vue/創建-Vue-js-Project","date":"2023-06-28T18:06:32.000Z","updated":"2023-12-15T18:47:21.491Z","comments":true,"path":"computer-science/program-language/Framework/Vue/創建-Vue-js-Project/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/program-language/Framework/Vue/%E5%89%B5%E5%BB%BA-Vue-js-Project/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 創建的項目將使用基於 Vite 的構建設置，並允許我們使用 Vue 的單文件組件 (SFC)。 請先確認是否安裝 Node.js，可運用以下指令測試 node -v 。 # 創建 Vue Project npm vue 版本 npm init vue@latest# 設定 Vue Project # 運行 Vue Project 在第一次創建或是更新 package 內容時，記得要輸入 npm install ，安裝內容所需。 npm run dev終端機會出現類似以下的訊息: > vue-project@0.0.0 dev> vite VITE v4.3.9 ready in 801 ms ➜ Local: http://localhost:5173/ ➜ Network: use --host to expose ➜ press h to show help 可以在瀏覽器輸入 http://localhost:5173/ 來查看專案樣式 # 建構 Vue Project npm run build 此命令會在 ./dist 文件夾中為你的應用創建一個生產環境的構建版本。 # 參考 / 學習文章 官方文件 w3school 維基百科 MDN web docs Vue.js 30 天隨身包系列","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Programming Language","slug":"computer-science/program-language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/"},{"name":"Framework","slug":"computer-science/program-language/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/Framework/"},{"name":"Vue","slug":"computer-science/program-language/Framework/Vue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/Framework/Vue/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}]},{"title":"什麼是Vue?","slug":"computer-science/program-language/Framework/Vue/什麼是Vue","date":"2023-06-28T06:57:21.000Z","updated":"2023-12-15T18:47:25.859Z","comments":true,"path":"computer-science/program-language/Framework/Vue/什麼是Vue/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/program-language/Framework/Vue/%E4%BB%80%E9%BA%BC%E6%98%AFVue/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 先備知識 HTML CSS JavaScript # What is Vue? Evan You 是一名使用 AngularJS 的 Google 員工，於 2013 年開始開發 Vue。 Vue 1.0 版本於 2015 年發布。 Vue（發音為 /vjuː/，如 view）是一個用於構建用戶界面的 JavaScript 框架。 與 Vue 類似的框架有 React 和 Angular，但 Vue 更輕量級，更容易上手。 構建在標準 HTML、CSS 和 JavaScript 之上，提供聲明性和基於組件的程式模型，幫助您高效地開發用戶界面，無論是簡單的還是複雜的。 它提供了很多有用的功能來達到漸進增強（ progressive enhancement ）的策略。 與其他的框架不同的是，你可以把 Vue 和既有的 HTML 做整合，這讓你可以像使用插入性替換的函式庫一樣來使用 Vue。 # 優勢 簡單易用。 能夠處理簡單和復雜的項目。 其日益普及和開源社區的支持。 在普通 JavaScript 中，我們需要編寫 HTML 和 JavaScript 如何連接，但在 Vue 中，我們只需要確保存在連接，然後讓 Vue 處理其餘的事情。 通過基於模板的語法、雙向數據綁定和集中狀態管理實現更高效的開發過程。 Vue 所關注的核心是 MVC 模式中的視圖層，同時，它也能方便地取得資料更新，並通過組件內部特定的方法實現視圖與模型的互動。 # 特性 組件 (Components) 為了更好地管理一個大型的應用程式，往往需要將應用切割為小而獨立、具有復用性的組件。 在 Vue 中，組件是基礎 HTML 元素的拓展，可方便地自訂其資料與行為。 模板 (Templates) 回應式設計 (Reactivity) 回應式是指 MVC 模型中的視圖隨著模型變化而變化。 在 Vue 中，開發者只需將視圖與對應的模型進行繫結，Vue 便能自動觀測模型的變動，並重繪視圖。 這一特性使得 Vue 的狀態管理變得相當簡單直觀。 過渡效果 (Transitions) 單檔案組件 (SFC) 為了更好地適應複雜的專案，Vue 支援以 .vue 為副檔名的檔案來定義一個完整組件，用以替代使用 Vue.component 註冊組件的方式。 # Chose which API? 在 Vue 中編寫代碼有兩種不同的方式：The Options API 和 The Composition API。 基本概念是相同的，因此在學習其中一個 API 後，可以輕鬆切換到另一個。 建議可以先學習 The Options API，相對比較好上手。 # 選項式 API (Options API) 使用選項式 API，我們可以用包含多個選項的對象來描述組件的邏輯，例如 data 、 methods 和 mounted 。選項所定義的屬性都會暴露在函數內部的 this 上，它會指向當前的組件實例。 Vue (Options API)&lt;script>export default &#123; //data () 返回的属性将会成为响应式的状态 // 并且暴露在 `this` 上 data() &#123; return &#123; count: 0 &#125; &#125;, //methods 是一些用来更改状态与触发更新的函数 // 它们可以在模板中作为事件处理器绑定 methods: &#123; increment() &#123; this.count++ &#125; &#125;, // 生命周期钩子会在组件生命周期的各个不同阶段被调用 // 例如这个函数就会在组件挂载完成后被调用 mounted() &#123; console.log(`The initial count is $&#123;this.count&#125;.`) &#125;&#125;&lt;/script>&lt;template> &lt;button @click=\"increment\">Count is: &lt;!--swig￼1-->&lt;/button>&lt;/template># 組合式 API (Composition API) 通過組合式 API，我們可以使用導入的 API 函數來描述組件邏輯。在單文件組件中，組合式 API 通常會與 &lt;script setup&gt; 搭配使用。這個 setup attribute 是一個標識，告訴 Vue 需要在編譯時進行一些處理，讓我們可以更簡潔地使用組合式 API。比如， &lt;script setup&gt; 中的導入和頂層變量 / 函數都能夠在模板中直接使用。 下面是使用了組合式 API 與 &lt;script setup&gt; 改造後和上面的模板完全一樣的組件： Vue (Composition API)&lt;script setup>import &#123; ref, onMounted &#125; from 'vue'// 响应式状态const count = ref(0)// 用来修改状态、触发更新的函数function increment() &#123; count.value++&#125;// 生命周期钩子onMounted(() => &#123; console.log(`The initial count is $&#123;count.value&#125;.`)&#125;)&lt;/script>&lt;template> &lt;button @click=\"increment\">Count is: &lt;!--swig￼2-->&lt;/button>&lt;/template># 參考 / 學習文章 官方文件 w3school 維基百科 MDN web docs Vue.js 30 天隨身包系列","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Programming Language","slug":"computer-science/program-language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/"},{"name":"Framework","slug":"computer-science/program-language/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/Framework/"},{"name":"Vue","slug":"computer-science/program-language/Framework/Vue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/Framework/Vue/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}]},{"title":"1514. Path with Maximum Probability","slug":"coding/leetcode/Medium/1514-Path-with-Maximum-Probability","date":"2023-06-28T05:02:53.000Z","updated":"2023-12-15T19:08:48.019Z","comments":true,"path":"coding/leetcode/Medium/1514-Path-with-Maximum-Probability/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1514-Path-with-Maximum-Probability/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an undirected weighted graph of n nodes (0-indexed), represented by an edge list where edges[i] = [a, b] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb[i] . Given two nodes start and end , find the path with the maximum probability of success to go from start to end and return its success probability. If there is no path from start to end , return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5. # Example 1 Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2 Output: 0.25000 Explanation: There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25. # Example 2 Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2 Output: 0.30000 # Example 3 Input: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2 Output: 0.00000 Explanation: There is no path between 0 and 2. # 解題思路 # Solution class Solution &#123; public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) &#123; double[] maxProb = new double[n]; maxProb[start] = 1.0; for (int i = 0; i &lt; n - 1; i++) &#123; boolean hasUpdate = false; for (int j = 0; j &lt; edges.length; j++) &#123; int u = edges[j][0]; int v = edges[j][1]; double pathProb = succProb[j]; if (maxProb[u] * pathProb > maxProb[v]) &#123; maxProb[v] = maxProb[u] * pathProb; hasUpdate = true; &#125; if (maxProb[v] * pathProb > maxProb[u]) &#123; maxProb[u] = maxProb[v] * pathProb; hasUpdate = true; &#125; &#125; if (!hasUpdate) &#123; break; &#125; &#125; return maxProb[end]; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Shortest Path","slug":"Shortest-Path","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Shortest-Path/"}]},{"title":"373. Find K Pairs with Smallest Sums","slug":"coding/leetcode/Medium/373-Find-K-Pairs-with-Smallest-Sums","date":"2023-06-27T15:01:24.000Z","updated":"2023-12-15T19:07:38.070Z","comments":true,"path":"coding/leetcode/Medium/373-Find-K-Pairs-with-Smallest-Sums/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/373-Find-K-Pairs-with-Smallest-Sums/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k . Define a pair (u, v) which consists of one element from the first array and one element from the second array. Return the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums. # Example 1 Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 Output: [[1,2],[1,4],[1,6]] Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] # Example 2 Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2 Output: [[1,1],[1,1]] Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] # Example 3 Input: nums1 = [1,2], nums2 = [3], k = 3 Output: [[1,3],[2,3]] Explanation: All possible pairs are returned from the sequence: [1,3],[2,3] # 解題思路 # Solution import java.util.ArrayList;import java.util.HashSet;import java.util.List;import java.util.PriorityQueue;import java.util.Set;class Solution &#123; public List&lt;List&lt;Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) &#123; int m = nums1.length; int n = nums2.length; List&lt;List&lt;Integer>> ans = new ArrayList&lt;>(); Set&lt;Pair&lt;Integer, Integer>> visited = new HashSet&lt;>(); PriorityQueue&lt;int[]> minHeap = new PriorityQueue&lt;>((a, b)->(a[0] - b[0])); minHeap.offer(new int[]&#123;nums1[0] + nums2[0], 0, 0&#125;); visited.add(new Pair&lt;Integer, Integer>(0, 0)); while (k-- > 0 &amp;&amp; !minHeap.isEmpty()) &#123; int[] top = minHeap.poll(); int i = top[1]; int j = top[2]; ans.add(List.of(nums1[i], nums2[j])); if (i + 1 &lt; m &amp;&amp; !visited.contains(new Pair&lt;Integer, Integer>(i + 1, j))) &#123; minHeap.offer(new int[]&#123;nums1[i + 1] + nums2[j], i + 1, j&#125;); visited.add(new Pair&lt;Integer, Integer>(i + 1, j)); &#125; if (j + 1 &lt; n &amp;&amp; !visited.contains(new Pair&lt;Integer, Integer>(i, j + 1))) &#123; minHeap.offer(new int[]&#123;nums1[i] + nums2[j + 1], i, j + 1&#125;); visited.add(new Pair&lt;Integer, Integer>(i, j + 1)); &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"}]},{"title":"2462. Total Cost to Hire K Workers","slug":"coding/leetcode/Medium/2462-Total-Cost-to-Hire-K-Workers","date":"2023-06-26T05:17:30.000Z","updated":"2023-12-15T19:09:36.287Z","comments":true,"path":"coding/leetcode/Medium/2462-Total-Cost-to-Hire-K-Workers/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2462-Total-Cost-to-Hire-K-Workers/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the ith worker. You are also given two integers k and candidates . We want to hire exactly k workers according to the following rules: You will run k sessions and hire exactly one worker in each session. In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers. Break the tie by the smallest index. For example, if costs = [3,2,7,7,1,2] and candidates = 2 , then in the first hiring session, we will choose the 4th worker because they have the lowest cost [3,2,7,7,1,2] . In the second hiring session, we will choose 1st worker because they have the same lowest cost as 4th worker but they have the smallest index [3,2,7,7,2] . Please note that the indexing may be changed in the process. If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index. A worker can only be chosen once. Return the total cost to hire exactly k workers. # Example 1 Input: costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4 Output: 11 Explanation: We hire 3 workers in total. The total cost is initially 0. In the first hiring round we choose the worker from [17,12,10,2,7,2,11,20,8]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2. In the second hiring round we choose the worker from [17,12,10,7,2,11,20,8]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4. In the third hiring round we choose the worker from [17,12,10,7,11,20,8]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers. The total hiring cost is 11. # Example 2 Input: costs = [1,2,4,1], k = 3, candidates = 3 Output: 4 Explanation: We hire 3 workers in total. The total cost is initially 0. In the first hiring round we choose the worker from [1,2,4,1]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers. In the second hiring round we choose the worker from [2,4,1]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2. In the third hiring round there are less than three candidates. We choose the worker from the remaining workers [2,4]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4. The total hiring cost is 4. # 解題思路 # Solution import java.util.PriorityQueue;class Solution &#123; public long totalCost(int[] costs, int k, int candidates) &#123; PriorityQueue&lt;int[]> pq = new PriorityQueue&lt;>((a, b) -> &#123; if (a[0] == b[0]) &#123; return a[1] - b[1]; &#125; return a[0] - b[0]; &#125;); for (int i = 0; i &lt; candidates; i++) &#123; pq.offer(new int[] &#123; costs[i], 0 &#125;); &#125; for (int i = Math.max(candidates, costs.length - candidates); i &lt; costs.length; i++) &#123; pq.offer(new int[] &#123; costs[i], 1 &#125;); &#125; long answer = 0; int nextHead = candidates; int nextTail = costs.length - candidates - 1; for (int i = 0; i &lt; k; i++) &#123; int[] currWorker = pq.poll(); int currCost = currWorker[0], currSectionId = currWorker[1]; answer += currCost; if (nextHead &lt;= nextTail) &#123; if (currSectionId == 0) &#123; pq.offer(new int[] &#123; costs[nextHead], 0 &#125;); nextHead++; &#125; else &#123; pq.offer(new int[] &#123; costs[nextTail], 1 &#125;); nextTail--; &#125; &#125; &#125; return answer; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"}]},{"title":"956. Tallest Billboard","slug":"coding/leetcode/Hard/956-Tallest-Billboard","date":"2023-06-24T03:43:15.000Z","updated":"2023-12-15T19:05:54.014Z","comments":true,"path":"coding/leetcode/Hard/956-Tallest-Billboard/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/956-Tallest-Billboard/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height. You are given a collection of rods that can be welded together. For example, if you have rods of lengths 1 , 2 , and 3 , you can weld them together to make a support of length 6 . Return the largest possible height of your billboard installation. If you cannot support the billboard, return 0 . # Example 1 Input: rods = [1,2,3,6] Output: 6 Explanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6. # Example 2 Input: rods = [1,2,3,4,5,6] Output: 10 Explanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10. # Example 3 Input: rods = [1,2] Output: 0 Explanation: The billboard cannot be supported, so we return 0. # 解題思路 # Solution import java.util.Arrays;public class Solution &#123; public int tallestBillboard(int[] rods) &#123; int maxSize = 0; for(int rod : rods)&#123; maxSize += rod; &#125; int[] dp = new int[maxSize + 1]; Arrays.fill(dp, -1); dp[0] = 0; for(int rod : rods)&#123; int[] dpCopy = dp.clone(); for (int i = 0; i &lt;= maxSize - rod; i++) &#123; if (dpCopy[i] &lt; 0) continue; dp[i + rod] = Math.max(dp[i + rod], dpCopy[i]); dp[Math.abs(i - rod)] = Math.max(dp[Math.abs(i - rod)], dpCopy[i] + Math.min(i, rod)); &#125; &#125; return dp[0]; &#125;&#125; 單字 installing 安裝 v. (READY TO USE) to put furniture, a machine, or a piece of equipment into position and make it ready to use to put a computer program onto a computer so that the computer can use it billboard 廣告牌 n. a very large board on which advertisements are shown, especially at the side of a road steel 鋼 n. a strong metal that is a mixture of iron and carbon, used for making things that need a strong structure, especially vehicles and buildings support 支持 v. to agree with and give encouragement to someone or something because you want him, her, or it to succeedn 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"1027. Longest Arithmetic Subsequence","slug":"coding/leetcode/Medium/1027-Longest-Arithmetic-Subsequence","date":"2023-06-23T08:25:06.000Z","updated":"2023-12-15T19:08:16.677Z","comments":true,"path":"coding/leetcode/Medium/1027-Longest-Arithmetic-Subsequence/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1027-Longest-Arithmetic-Subsequence/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given an array nums of integers, return the length of the longest arithmetic subsequence in nums . Note that: A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. A sequence seq is arithmetic if seq[i + 1] - seq[i] are all the same value (for 0 &lt;= i &lt; seq.length - 1 ). # Example 1 Input: nums = [3,6,9,12] Output: 4 Explanation: The whole array is an arithmetic sequence with steps of length = 3. # Example 2 Input: nums = [9,4,7,2,10] Output: 3 Explanation: The longest arithmetic subsequence is [4,7,10]. # Example 3 Input: nums = [20,1,15,3,10,5,8] Output: 4 Explanation: The longest arithmetic subsequence is [20,15,10,5]. # 解題思路 # Solution import java.util.HashMap;import java.util.Map;class Solution &#123; public int longestArithSeqLength(int[] nums) &#123; Map&lt;Integer, Integer>[] dp = new HashMap[nums.length]; int longest = 2; for(int i = 0; i &lt; nums.length; i++)&#123; dp[i] = new HashMap&lt;>(); for(int j = 0; j &lt; i; j++)&#123; int diff = nums[i] - nums[j]; dp[j].put(diff, dp[i].getOrDefault(diff, 1) + 1); longest = Math.max(longest, dp[j].get(diff)); &#125; &#125; return longest; &#125;&#125; 單字 arithmetic 算數 n. the part of mathematics that involves the adding and multiplying, etc. of numbers subsequence 子序列 n. something that follows something else 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"}]},{"title":"714. Best Time to Buy and Sell Stock with Transaction Fee","slug":"coding/leetcode/Medium/714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee","date":"2023-06-22T07:22:26.000Z","updated":"2023-12-15T19:07:52.372Z","comments":true,"path":"coding/leetcode/Medium/714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee. Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). # Example 1 Input: prices = [1,3,2,8,4,9], fee = 2 Output: 8 Explanation: The maximum profit can be achieved by: Buying at prices[0] = 1 Selling at prices[3] = 8 Buying at prices[4] = 4 Selling at prices[5] = 9 The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8. # Example 2 Input: prices = [1,3,7,5,10,3], fee = 3 Output: 6 # 解題思路 # Solution class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; int ans = 0; int buy = -prices[0]; for (int price : prices) &#123; int temp = buy; buy = Math.max(buy, ans - price); ans = Math.max(ans, temp + price - fee); &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"}]},{"title":"2448. Minimum Cost to Make Array Equal","slug":"coding/leetcode/Hard/2448-Minimum-Cost-to-Make-Array-Equal","date":"2023-06-21T17:05:34.000Z","updated":"2023-12-15T19:06:20.825Z","comments":true,"path":"coding/leetcode/Hard/2448-Minimum-Cost-to-Make-Array-Equal/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/2448-Minimum-Cost-to-Make-Array-Equal/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 You are given two 0-indexed arrays nums and cost consisting each of n positive integers. You can do the following operation any number of times: Increase or decrease any element of the array nums by 1 . The cost of doing one operation on the ith element is cost[i] . Return the minimum total cost such that all the elements of the array nums become equal. # Example 1 Input: nums = [1,3,5,2], cost = [2,3,1,14] Output: 8 Explanation: We can make all the elements equal to 2 in the following way: Increase the 0th element one time. The cost is 2. Decrease the 1st element one time. The cost is 3. Decrease the 2nd element three times. The cost is 1 + 1 + 1 = 3. The total cost is 2 + 3 + 3 = 8. It can be shown that we cannot make the array equal with a smaller cost. # Example 2 Input: nums = [2,2,2,2,2], cost = [4,2,8,1,3] Output: 0 Explanation: All the elements are already equal, so no operations are needed. # 解題思路 # Solution class Solution &#123; public long minCost(int[] nums, int[] cost) &#123; int left = nums[0]; int right = nums[0]; for (int num : nums) &#123; left = Math.min(left, num); right = Math.max(right, num); &#125; // Find the min and max in nums[] array long ans = 0; while (left &lt; right) &#123; int mid = (left + right) / 2; long cost1 = helper(nums, cost, mid); long cost2 = helper(nums, cost, mid + 1); if (cost1 > cost2) &#123; left = mid + 1; ans = cost2; &#125; else &#123; right = mid; ans = cost1; &#125; &#125; return ans; &#125; public long helper(int[] nums, int[] cost, int all) &#123; long totalCost = 0L; for (int i = 0; i &lt; nums.length; i++) &#123; totalCost += 1L * Math.abs(nums[i] - all) * cost[i]; &#125; return totalCost; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"}]},{"title":"What is CI/CD?","slug":"computer-science/DevOps/What-is-CI-CD","date":"2023-06-20T15:23:34.000Z","updated":"2023-12-15T18:58:46.350Z","comments":true,"path":"computer-science/DevOps/What-is-CI-CD/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/What-is-CI-CD/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 從測試、建置到部署一次自動化 # What is CI/CD? CI/CD 工具也是為了 DevOps 概念而產生的自動化工具，透過持續整合、持續部署的方式，在開發階段就自動協助開發人員偵測程式碼問題，並部署至伺服器。 # CI（Continuous Integration）持續整合 當開發人員完成一個階段性的程式碼後就經由自動化工具測試、驗證，協助偵測程式碼問題，並建置出即將部署的版本（Build）。 # CD（Continuous Deployment）持續部署 可以說是 CI 的下一階段，經過 CI 測試後所構建的程式碼可以透過 CD 工具部署至伺服器，減少人工部署的時間。 # CI/CD 工具 - GitLab GitLab 主要的服務是提供 git 版本控制系統，其 CI/CD Pipeline 功能簡單又實用，使用者只需要設定於專案根目錄下的「.gitlab-ci.yml」檔，便可以開始驅動各種 Pipeline 協助您完成自動化測試及部署。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"}],"tags":[]},{"title":"What is DevOps?","slug":"computer-science/DevOps/What-is-DevOps","date":"2023-06-20T14:40:23.000Z","updated":"2023-12-15T18:58:50.832Z","comments":true,"path":"computer-science/DevOps/What-is-DevOps/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/What-is-DevOps/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # What is DevOps? DevOps 拆開來就是 Development + Operations ，也就是開發與維運。 更準確的說可以是「開發」「測試」「維運」三者的結合，是一種軟體開發和部署的方法論。 DevOps 主要促進開發和 IT 運營兩個團隊的結合與運作，提升團隊之間的協作和溝通。 DevOps 的目的是通過協調和自動化開發、測試和部署來實現更快的產品交付速度、更高的品質及提升工作效率。 生命週期的每個階段：從初始軟體規劃到程式碼、建構、測試和發佈階段，再到部署、作業與持續監控。 這種關係推動了進一步改善、開發、測試及部署的持續客戶回饋循環。可能可以更快速地持續發佈必要的功能變更或新增項目。 # DevOps 核心五個概念 - CALMS Culture 文化： DevOps 不是一個工具而是代表一個 IT 文化轉型的概念，藉由同理心與換位思考讓開發與營運人員合作更加順暢。 Automation 自動化： 自動化流程提高效率，有助於建立敏捷的團隊，產出品質優良的產品。 Lean 精實： DevOps 希望能建立敏捷開發的團隊，因此精實生產過程也非常重要，包含了減少浪費、盡快交付、延遲做決定等原則，延遲做決定是指領導者可以等接收到完整的資訊後再做決策。 Measurement 測量： 利用數據判斷決策是否正確，若數字一旦有所異常即可隨時改變策略，使團隊保持敏捷性。 Sharing 分享： 藉由團隊間共享資訊，可以提升解決問題的效率。 # 生命週期 持續開發：這項實務做法涵蓋了 DevOps 開發維運生命週期的規劃與編碼階段。其中可能涉及版本控制機制。 持續測試：這項實務做法可以在正在編寫或更新應用程式的程式碼時納入預先排定的持續自動化程式碼測試。這類測試可以加快將程式碼交付至正式作業的速度。 持續整合 (CI)：這項實務做法可以將組態管理 (CM) 工具和其他測試與開發工具結合，以追蹤正在開發的程式碼有多少已準備就緒可供正式作業使用。其中涉及在測試與開發之間快速提供意見反應，以便迅速識別並解決程式碼問題。 持續交付：這項實務做法可以在測試後，自動將程式碼變更傳送至正式作業前或接移環境。然後，員工可以決定是否要將這類程式碼變更推廣至正式作業環境。 持續部署 (CD)：與持續交付類似，這項實務做法可以自動將新程式碼或變更後的程式碼發佈至正式作業環境。執行持續部署的公司每天可以發佈數次程式碼或功能變更。使用 Docker 和 Kubernetes 等 Container 技術有助於在不同的部署平台和環境中維持程式碼的一致性，進而實現持續部署。 持續監控：這項實務做法包括持續監控運作中的程式碼以及支援該程式碼的底層基礎架構。回報錯誤或問題的回饋循環隨後又會回到開發階段。 基礎架構即程式碼：這項實務做法可在各種 DevOps 開發維運階段中使用，以自動化軟體版本所需的基礎架構資源配置。開發人員可從其現有的開發工具中新增基礎架構「程式碼」。例如，開發人員可以視需求從 Docker、Kubernetes 或 OpenShift 建立儲存 Volume。這項實務做法也可讓營運團隊監控環境組態、追蹤變更，並簡化組態的復原作業。 # 工具 規劃：此階段有助於定義商業價值與需求。範例工具包括 Jira 或 Git，可協助追蹤已知問題並執行專案管理。 程式碼：此階段涉及軟體設計及軟體程式碼的建立。範例工具包括 GitHub、GitLab、BitBucket 或 Stash。 建置：在此階段，您將管理軟體建置與版本，並使用自動化工具來協助編譯及封裝程式碼，以供將來發佈到正式作業環境。您使用的原始碼程式碼儲存庫或套件儲存庫也會「封裝」產品發佈所需的基礎架構。範例工具包括 Docker、Ansible、Puppet、Chef、Gradle、Maven 或 JFrog Artifactory。 測試：此階段包括持續測試（手動或自動），以確保最佳的程式碼品質。範例工具包括 JUnit、Codeception、Selenium、Vagrant、TestNG 或 BlazeMeter。 部署：此階段可以包含有助於管理、協調、排程和自動將產品發佈至正式作業環境的工具。範例工具包括 Puppet、Chef、Ansible、Jenkins、Kubernetes、OpenShift、OpenStack、Docker 或 Jira。 操作：此階段可在正式作業期間管理軟體。範例工具包括 Ansible、Puppet、PowerShell、Chef、Salt 或 Otter。 監督：此階段包括識別及收集有關正式作業中特定軟體版本問題的資訊。範例工具包括 New Relic、Datadog、Grafana、Wireshark、Splunk、Nagios 或 Slack。 # 優勢 更快、更好地交付產品 更快地解決問題並降低複雜度 更高的擴充性與可用度 更穩定的作業環境 更佳的資源使用率 更優異的自動化功能 更清楚地掌握系統成果 更高程度的創新","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"}],"tags":[]},{"title":"2090. K Radius Subarray Averages","slug":"coding/leetcode/Medium/2090-K-Radius-Subarray-Averages","date":"2023-06-20T04:38:59.000Z","updated":"2023-12-15T19:09:08.731Z","comments":true,"path":"coding/leetcode/Medium/2090-K-Radius-Subarray-Averages/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2090-K-Radius-Subarray-Averages/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given a 0-indexed array nums of n integers, and an integer k . The k-radius average for a subarray of nums centered at some index i with the radius k is the average of all elements in nums between the indices i - k and i + k (inclusive). If there are less than k elements before or after the index i , then the k-radius average is -1 . Build and return an array avgs of length n where avgs[i] is the k-radius average for the subarray centered at index i . The average of x elements is the sum of the x elements divided by x , using integer division. The integer division truncates toward zero, which means losing its fractional part. For example, the average of four elements 2 , 3 , 1 , and 5 is (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75 , which truncates to 2 . # Example 1 Input: nums = [7,4,3,9,1,8,5,2,6], k = 3 Output: [-1,-1,-1,5,4,4,-1,-1,-1] Explanation: avg[0], avg[1], and avg[2] are -1 because there are less than k elements before each index. The sum of the subarray centered at index 3 with radius 3 is: 7 + 4 + 3 + 9 + 1 + 8 + 5 = 37. Using integer division, avg[3] = 37 / 7 = 5. For the subarray centered at index 4, avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4. For the subarray centered at index 5, avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4. avg[6], avg[7], and avg[8] are -1 because there are less than k elements after each index. # Example 2 Input: nums = [100000], k = 0 Output: [100000] Explanation: The sum of the subarray centered at index 0 with radius 0 is: 100000. avg[0] = 100000 / 1 = 100000. # Example 3 Input: nums = [8], k = 100000 Output: [-1] Explanation: avg[0] is -1 because there are less than k elements before and after index 0. # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public int[] getAverages(int[] nums, int k) &#123; int n = nums.length; int windows = 2 * k + 1; int[] ans = new int[n]; Arrays.fill(ans, -1); if(n &lt; windows)&#123; return ans; &#125; long[] sum = new long[n + 1]; for(int i = 0; i &lt; n; i++)&#123; sum[i + 1] = sum[i] + nums[i]; &#125; for(int i = k; i &lt; n - k; i++)&#123; ans[i] = (int) ((sum[i + k + 1] - sum[i - k]) / windows); &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"}]},{"title":"1732. Find the Highest Altitude","slug":"coding/leetcode/Easy/1732-Find-the-Highest-Altitude","date":"2023-06-19T06:31:22.000Z","updated":"2023-12-15T19:04:46.760Z","comments":true,"path":"coding/leetcode/Easy/1732-Find-the-Highest-Altitude/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1732-Find-the-Highest-Altitude/","excerpt":"","text":"⭐️ # 題目敘述 There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0 . You are given an integer array gain of length n where gain[i] is the net gain in altitude between points i ​​​​​​ and i + 1 for all (0 &lt;= i &lt; n) . Return the highest altitude of a point. # Example 1 Input: gain = [-5,1,5,0,-7] Output: 1 Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1. # Example 2 Input: gain = [-4,-3,-2,-1,4,3,2] Output: 0 Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0. # 解題思路 # Solution class Solution &#123; public int largestAltitude(int[] gain) &#123; int curr = 0; int ans = curr; for(int i = 0; i &lt; gain.length; i++)&#123; curr += gain[i]; ans = Math.max(ans, curr); &#125; return ans; &#125;&#125; 單字 altitudes 海拔，海拔高度 height above sea level 片語 & 搭配詞 consist of 由... 組成 [主動] 群體 + consist of + 部分 The committee consists of doctors and nurses. 該委員會由醫生和護士組成。 →「群體」committee 當主詞，consist of + 「部分」 doctors and nurses consist 必須搭配 of，consist of 只能用主動語態。 「群體」當主詞，consist of + 「部分」。 be composed of 由... 組成 [被動] 群體 + be composed of + 部分 Water is composed of hydrogen and oxygen. 水由氫和氧組成。 →「群體」water 當主詞，is composed of + 「部分」hydrogen and oxygen compose 當組成意思時，使用被動語態，必須搭配 of，用 be composed of。 「群體」當主詞，be composed of + 「部分」。 comprise 由... 組成 [主動] 群體 + comprise + 部分 The country comprises 22 cities. 該國由 22 個城市組成。 →「群體」the country 當主詞，comprise + 「部分」22 cities [主動] 部分 + comprise + 群體 Semiconductor chips and oil comprises the imports of this country. 該國的進口物有半導體晶片和石油。 →「部分」semiconductor chips and oil 當主詞，comprise + 「整體」the imports of this country [被動] 群體 + is comprised of + 部分 The basketball school team is comprised of 12 players. 籃球校隊由 12 名球員組成。 →「群體」the basketball school team 當主詞，is comprised of + 「部分」12 players comprise 的用法比較特別，在主動語態時，可以用「群體當主詞 + comprise + 組成部分」，或「組成部分當組詞 + comprise + 群體」。 在被動語態時，用群體當「主詞 + is comprised of + 組成部分」。 make up 由... 組成 [主動] 部分 + make up + 群體 Plasma, platelets, and blood cells make up blood. 血漿、血小板和血細胞構成血液。 →「部分」plasma, platelets, and blood cells 當主詞，make up + 「整體」blood [被動] 群體 + is made up of + 部分 The model plane is made up of 200 pieces of bricks. 模型飛機由 200 塊積木組成。 →「群體」the model plane 當主詞，is made up of + 「部分」200 pieces of bricks make up 意思是「組成」，用主詞語態時，以「部分」當主詞 + make up + 「群體」。 用被動語態時，「群體」當主詞，be made up of + 「部分」。","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"}]},{"title":"介紹 Java Script Boot","slug":"computer-science/program-language/Framework/Java-Spring-boot/介紹-Java-Script-Boot","date":"2023-06-17T07:11:23.000Z","updated":"2023-12-15T18:45:50.758Z","comments":true,"path":"computer-science/program-language/Framework/Java-Spring-boot/介紹-Java-Script-Boot/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/program-language/Framework/Java-Spring-boot/%E4%BB%8B%E7%B4%B9-Java-Script-Boot/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 淺淺介紹一下 Java JAVA 彈性且方便使用者使用，是開發人員建置多種應用程式時的最愛，舉凡社交媒體、Web 和遊戲應用程式及網路與企業應用程式，無所不在。 # Spring vs. Spring Boot Spring Spring Boot Info 以 JAVA 為基礎的開放原始碼 Web 應用程式架構。 在 Spring 架構上建置的延伸模組或模組。 Feature 使用預先建置程式碼的工具和程式庫，提供彈性且完全可設定的環境，以建立自訂、鬆散結合的 Web 應用程式。 提供建立獨立 Spring 應用程式的功能，這些應用程式只要立即執行，不需要註解、XML 設定或撰寫大量其他程式碼。 # Spring Boot 是什麼？ Spring Boot 是由 Pivotal 團隊在 2013 年開始研發、2014 年 4 月發布第一個版本。 它基於 Spring4.0 設計，不僅繼承了 Spring 框架原有的優秀特性，而且還通過簡化配置來進一步簡化了 Spring 應用的整個搭建和開發過程。 JAVA Spring Boot 提供的核心功能，除了 Spring 架構之外。 Spring Boot 提供更輕鬆、更快速的路徑來設定、設定及執行應用程式。 這會消除設定大多數 Spring 型應用程式所需的大量設定。 開發人員無需學習基礎 Spring 架構，就能直接加入並使用 Spring Boot。 Spring Boot 可以說是在 Java 中開發基於 REST Web 應用程序的最快方法之一。 Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can &quot;just run&quot;. We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need minimal Spring configuration. # 主要功能 創建獨立的 Spring 應用程序 直接嵌入 Tomcat、Jetty 或 Undertow（無需部署 WAR 文件） 提供自以為是的 “入門” 依賴項以簡化您的構建配置 盡可能自動配置 Spring 和 3rd 方庫 提供生產就緒的功能，例如指標、健康檢查和外部化配置 絕對沒有代碼生成，也不需要 XML 配置 # 參考連結 Spring Boot 官方網站","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Programming Language","slug":"computer-science/program-language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/"},{"name":"Framework","slug":"computer-science/program-language/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/Framework/"},{"name":"Java Spring Boot","slug":"computer-science/program-language/Framework/Java-Spring-Boot","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/Framework/Java-Spring-Boot/"}],"tags":[]},{"title":"What is Framework?","slug":"computer-science/program-language/Framework/What-is-Framework","date":"2023-05-28T17:05:57.000Z","updated":"2023-12-15T18:46:52.798Z","comments":true,"path":"computer-science/program-language/Framework/What-is-Framework/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/program-language/Framework/What-is-Framework/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 軟體框架 (Software Framework) 為軟體開發提供了一個基礎的架構、地基，去實現更複雜的軟體或是邏輯，使開發更有效率的進行，他扮演著規範和定義的角色。 框架本身無法自行運作，開發者必須將自己的程式搭配框架才是一個完整的應用程式。 運用框架其實就像把別人已經做好的零件拿來使用，就像要製作一台機器人，總不可能從製作螺絲開始吧！螺絲通常是像他人購買，而我們專注於完成機器人的整體。 而軟體架構就是如此，他提供了別人事先寫好的函式庫（Library）或類別庫（Class Library），提供軟體開發的便利性，加速了開發過程。 # 提供的好處 圖片來源 https://docs.f5ezcode.in/cs-basic/di-ba-zhang-gong-cheng-de-gong-ju/8.2-cheng-shi-yan-de-kuang-jia # 常見程式語言框架 CSS – bootstrap PHP - Laravel JavaScript – JQuery、Vue.js、React.js、Angular.js、Svelte.js、Express.js Java – Spring MVC、Spring boot Python – Django C# – .NET framework 接下來的系列文章會介紹我學習過的框架且在使用的框架，當然這裡還是以學習筆記的方式呈現，我會盡量整理的有閱讀順序啦～～ 有的框架我不是很熟，但是我會盡量與同類型的進行比較，有時間專研後，再寫筆記。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Programming Language","slug":"computer-science/program-language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/"},{"name":"Framework","slug":"computer-science/program-language/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/Framework/"}],"tags":[]},{"title":"2627. Debounce","slug":"coding/leetcode/Medium/2627-Debounce","date":"2023-05-19T05:19:53.000Z","updated":"2023-05-28T17:14:48.054Z","comments":true,"path":"coding/leetcode/Medium/2627-Debounce/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2627-Debounce/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a function fn and a time in milliseconds t, return a debounced version of that function. A debounced function is a function whose execution is delayed by t milliseconds and whose execution is cancelled if it is called again within that window of time. The debounced function should also recieve the passed parameters. For example, let's say t = 50ms, and the function was called at 30ms, 60ms, and 100ms. The first 2 function calls would be cancelled, and the 3rd function call would be executed at 150ms. If instead t = 35ms, The 1st call would be cancelled, the 2nd would be executed at 95ms, and the 3rd would be executed at 135ms. The above diagram shows how debounce will transform events. Each rectangle represents 100ms and the debounce time is 400ms. Each color represents a different set of inputs. Please solve it without using lodash's _.debounce() function. # Example 1: Input: t = 50 calls = [ {&quot;t&quot;: 50, inputs: [1]}, {&quot;t&quot;: 75, inputs: [2]} ] Output: [{&quot;t&quot;: 125, inputs: [2]}] Explanation: let start = Date.now(); function log(...inputs) { console.log([Date.now() - start, inputs ]) } const dlog = debounce(log, 50); setTimeout(() =&gt; dlog(1), 50); setTimeout(() =&gt; dlog(2), 75); The 1st call is cancelled by the 2nd call because the 2nd call occurred before 100ms The 2nd call is delayed by 50ms and executed at 125ms. The inputs were (2). # Example 2: Input: t = 20 calls = [ {&quot;t&quot;: 50, inputs: [1]}, {&quot;t&quot;: 100, inputs: [2]} ] Output: [{&quot;t&quot;: 70, inputs: [1]}, {&quot;t&quot;: 120, inputs: [2]}] Explanation: The 1st call is delayed until 70ms. The inputs were (1). The 2nd call is delayed until 120ms. The inputs were (2). # Example 3: Input: t = 150 calls = [ {&quot;t&quot;: 50, inputs: [1, 2]}, {&quot;t&quot;: 300, inputs: [3, 4]}, {&quot;t&quot;: 300, inputs: [5, 6]} ] Output: [{&quot;t&quot;: 200, inputs: [1,2]}, {&quot;t&quot;: 450, inputs: [5, 6]}] Explanation: The 1st call is delayed by 150ms and ran at 200ms. The inputs were (1, 2). The 2nd call is cancelled by the 3rd call The 3rd call is delayed by 150ms and ran at 450ms. The inputs were (5, 6). # 解題思路 # Solution /** * @param &#123;Function&#125; fn * @param &#123;number&#125; t milliseconds * @return &#123;Function&#125; */var debounce = function(fn, t) &#123; let timeout; return function(...args) &#123; clearTimeout(timeout); timeout = setTimeout(function()&#123; fn(...args); &#125;, t); &#125;&#125;;/** * const log = debounce(console.log, 100); * log('Hello'); // cancelled * log('Hello'); // cancelled * log('Hello'); // Logged at t=100ms */ type F = (...p: any[]) => anyfunction debounce(fn: F, t: number): F &#123; let timeout: any; return function(...args) &#123; clearTimeout(timeout); timeout = setTimeout(function()&#123; fn(...args); &#125;, t); &#125;&#125;;/** * const log = debounce(console.log, 100); * log('Hello'); // cancelled * log('Hello'); // cancelled * log('Hello'); // Logged at t=100ms */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"785. Is Graph Bipartite?","slug":"coding/leetcode/Medium/785-Is-Graph-Bipartite","date":"2023-05-19T04:30:34.000Z","updated":"2023-12-15T19:07:57.463Z","comments":true,"path":"coding/leetcode/Medium/785-Is-Graph-Bipartite/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/785-Is-Graph-Bipartite/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1 . You are given a 2D array graph , where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u] , there is an undirected edge between node u and node v . The graph has the following properties: There are no self-edges ( graph[u] does not contain u ). There are no parallel edges ( graph[u] does not contain duplicate values). If v is in graph[u] , then u is in graph[v] (the graph is undirected). The graph may not be connected, meaning there may be two nodes u and v such that there is no path between them. A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B . Return true if and only if it is bipartite. # Example 1: Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]] Output: false Explanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other. # Example 2: Input: graph = [[1,3],[0,2],[1,3],[0,2]] Output: true Explanation: We can partition the nodes into two sets: {0, 2} and {1, 3}. # 解題思路 # Solution class Solution &#123; public boolean isBipartite(int[][] graph) &#123; int n = graph.length; int[] remeber = new int[n]; // remeber graph index in which group, group A = 1, group B = -1 for (int i = 0; i &lt; n; i++) &#123; if (remeber[i] == 0 &amp;&amp; !dfs(graph, remeber, i, 1)) return false; &#125; return true; &#125; public boolean dfs(int[][] graph, int[] remeber, int node, int group) &#123; if (remeber[node] != 0) return remeber[node] == group; remeber[node] = group; for (int neighbor : graph[node]) &#123; if (!dfs(graph, remeber, neighbor, -group)) return false; &#125; // if neighbor node is not in same group, mean it can divide to two group. return true; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"}]},{"title":"Git 進階指令","slug":"computer-science/DevOps/Git/Git 進階指令","date":"2023-05-18T09:36:07.000Z","updated":"2023-12-15T18:58:58.439Z","comments":true,"path":"computer-science/DevOps/Git/Git 進階指令/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Git/Git%20%E9%80%B2%E9%9A%8E%E6%8C%87%E4%BB%A4/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 版本退回 引用文: https://gitbook.tw/chapters/using-git/reset-commit git log 檢視提交的歷史記錄。 git log --oneline 目前的 Git 紀錄。 git reset [版本 id] 版本退回","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"}],"tags":[]},{"title":"Work Flow","slug":"computer-science/DevOps/Git/Work-Flow","date":"2023-05-18T07:34:08.000Z","updated":"2023-12-15T19:00:27.526Z","comments":true,"path":"computer-science/DevOps/Git/Work-Flow/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Git/Work-Flow/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 當大家一起開發專案時，專案撰寫的內容越來越多，Git Commit 內容增加，就很容易有 Git Graph 非常雜亂的問題，對某一個功能重複撰寫等等。 這個時候就非常需要工作流程 (Work Flow)，讓大家有規劃，更效率地開發。 # 常見 Work Flow Git Flow GitHub Flow GitLab Flow # 定義部署的環境 開發環境（工程師的電腦） 測試環境（讓審核人員測試使用，像是 QA 測試） 展示環境（讓早期用戶或是驗收使用） 產品環境（正式讓所有用戶使用） # Git Flow Git Flow 是上述三種 Work Flow 中最早出現的。 master 負責管理發布的狀態。當準備好發佈指定版本時，最後的提交會給予一個發布版本標籤。 develop Develop 分支是針對日常開發的分支。所有新功能開發最終都會合併到這裡。 feature 這個分支是新功能的開發或修復錯誤的時候從 develop 分支分開出來的。 release Release 分支是為了發布而準備的。通常這種分支的名稱最前面會加上 &quot;release-&quot;。 hotfit Hot fix 分支是在發布的產品需要緊急修改時，從 master 分支建立的分支。 通常會在分支名稱的最前面會加上 &quot;hotfix-&quot;。 # 開發過程 從 master 分支拉出一條分支 develop 進行日常開發。 要開發新功能 / 修復錯誤時，從 develop 分支拉取一條 feature 分支。 開發完成後，將 feature 分支合入到 develop 分支，並進行開發環境的驗證。 確認完成後，從 develop 分支拉取一條 release 分支，到測試環境進行 SIT/UAT 測試。 測試完成後，可將 release 分支合入 master 分支並將現在內容給回 develop 分支。 版本部屬時，直接將 master 分支程式碼部署到最終環境。 優點: 每個分支都有明確的定義，嚴格按照 Git Flow 管理專案程式碼的話，很難出現程式碼混亂 缺點: 如果 feature 分支過多的話很容易造成程式碼衝突，從而提高了合入的成本 由於每次提交都涉及多個分支，所以 Git Flow 也太不適合提交頻率較高的項目 # GitHub Flow &amp; GitLab Flow By 因為我還沒研究過 GitHub Flow &amp; GitLab Flow，所以這裡提供我覺得寫得很不錯的文章給大家參考 文章 medium.com/@trylovetom 讓我們來了解 GitHub Flow 吧！除了會 Git 你還需要 Work Flow medium.com/i-think-so-i-live Git上的三種工作流程","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"}],"tags":[]},{"title":"Git Branch","slug":"computer-science/DevOps/Git/Git-Branch","date":"2023-05-18T07:31:13.000Z","updated":"2023-12-15T19:00:02.580Z","comments":true,"path":"computer-science/DevOps/Git/Git-Branch/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Git/Git-Branch/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 什麼是 branch? 在開發軟體時，可能同時會有多人在開發同一功能或修復錯誤，也可能會有多個發佈版本的存在，並且需要針對每個版本進行維護，同一個數據庫可以同時進行多個修改。 現在最常用來管理 Git 分支的方法: master develop feature release hotfix # 分支常用指令 git branch# 查看分支。git branch [BRANCH_NAME]# 建立分支。git checkout [BRANCH_NAME]# 取出指定的分支。git checkout -b [BRANCH_NAME]# 建立並跳到該分支。git branch -D [BRANCH_NAME]# 強制刪除指定分支 (須先切換至其他分支再做刪除)。git branch -m [OLD_BRANCH_NAME] [NEW_BRANCH_NAME]# 修改分支名稱。git merge [要合併的分支]# 切換到合併後的分支，再合併分支 合併分支: 例：把 release-1.0 分支的修改合併到 master。 先將分支切換到 mastergit checkout master 合併 release-1.0 分支git merge release-v1.0 # 分支命名和標記 如果可能，請創建不包含特殊字符的分支和標記名稱，因為這些字符需要轉義。用於分支名稱和標記名稱的安全默認字符集為： 英文字母 （a-z 和 A-Z） 數字 (0-9) 有限的標點字符集： 句點 (.) 連字符 (-) 下劃線 (_) 正斜杠 (/) 為避免混淆，分支名稱應以字母開頭。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"}],"tags":[]},{"title":"Git commit specification","slug":"computer-science/DevOps/Git/Git-commit-specification","date":"2023-05-18T07:02:09.000Z","updated":"2023-12-15T19:00:08.170Z","comments":true,"path":"computer-science/DevOps/Git/Git-commit-specification/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Git/Git-commit-specification/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 建議提交格式 建議以這種形式填寫提交訊息 Header: &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; type: 代表 commit 的類別：feat, fix, docs, style, refactor, test, chore，必要欄位。 scope 代表 commit 影響的範圍，例如資料庫、控制層、模板層等等，視專案不同而不同，為可選欄位。 subject 代表此 commit 的簡短描述，不要超過 50 個字元，結尾不要加句號，為必要欄位。 Body: 72-character wrapped. This should answer: Body 部份是對本次 Commit 的詳細描述，可以分成多行，每一行不要超過 72 個字元。 說明程式碼變動的項目與原因，還有與先前行為的對比。 Footer: 填寫任務編號（如果有的話）. BREAKING CHANGE（可忽略），記錄不兼容的變動， 以 BREAKING CHANGE: 開頭，後面是對變動的描述、以及變動原因和遷移方法。 # git commit Header feat: 新增 / 修改功能 (feature)。 fix: 修補 bug (bug fix)。 docs: 文件 (documentation)。 style: 格式 (不影響程式碼運行的變動 white-space, formatting, missing semi colons, etc)。 refactor: 重構 (既不是新增功能，也不是修補 bug 的程式碼變動)。 perf: 改善效能 (A code change that improves performance)。 test: 增加測試 (when adding missing tests)。 chore: 建構程序或輔助工具的變動 (maintain)。 revert: 撤銷回覆先前的 commit 例如：revert: type (scope): subject (回覆版本：xxxx)。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"}],"tags":[]},{"title":"Git 基本指令與觀念","slug":"computer-science/DevOps/Git/Git-基本指令與觀念","date":"2023-05-18T06:59:43.000Z","updated":"2023-12-15T19:00:18.511Z","comments":true,"path":"computer-science/DevOps/Git/Git-基本指令與觀念/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Git/Git-%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4%E8%88%87%E8%A7%80%E5%BF%B5/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 基本指令與觀念 提交訊息是查看其他人提交的修改內容或自己檢查歷史記錄時重要的資料。 所以要用心填寫讓人容易理解的提交訊息。 Git 的標準提交 (commit) 訊息： 第 1 行：提交時修改內容的摘要 第 2 行：空行 第 3 行以後：修改的理由 建議以這種形式填寫提交訊息，詳細可以參考 Git commit specification # 基本指令 git init# 建立新的本地端儲存庫 (Repository)git clone [URL]# 複製遠端的 Repository 檔案到本地端。git status# 檢查本地端檔案異動狀態。 沒事常用 git status 檢查 git 的情況 clone v.s. download clone 可以做 git 後續的一些指令，但 download 無法。 # 常用指令 # add git add [檔案或資料夾]# 將指定的檔案 (或資料夾) 加入版本控制。用 git add . 可加入全部。# commit git commit -m \"[修改內容]\"# 提交 (commit) 目前的異動並透過 -m 參數設定摘要說明文字。git commit# 提交 (commit) 目前的異動，可以打超過一行的 commit information。# push git push# 將本地端 Repository 的 commit 發佈到遠端。git push origin [BRANCH_NAME]# 發佈至遠端指定的分支 (Branch)。# pull git pull# 檔案抓取下來到自己的本地端。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"}],"tags":[]},{"title":"Git 安裝","slug":"computer-science/DevOps/Git/Git-安裝","date":"2023-05-18T06:55:23.000Z","updated":"2023-12-15T19:00:23.610Z","comments":true,"path":"computer-science/DevOps/Git/Git-安裝/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Git/Git-%E5%AE%89%E8%A3%9D/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 安裝 git - Windows git 官網: https://git-scm.com/download/win 然後開啟 Git Bash # 設定 git 識別資料 在你安裝 Git 後首先應該做的事是設定使用者名稱及電子郵件。 這一點非常重要，因為每次 Git 的提交會使用這些資訊，而且提交後不能再被修改。 git config --global user.name \"[使用者名字]\"git config --global user.email \"[電子信箱]\"若你有傳遞 --global 參數，只需要做這工作一次，因為在此系統，不論 Git 做任何事都會採用此資訊。 # 檢查讀者的設定 git config --list# 建立全新的儲存庫 echo \"# test\" >> README.mdgit initgit add README.mdgit commit –m “first commit”git remote add origin [github_repository URL]git push –u origin main","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Windows/"}]},{"title":"Git Information","slug":"computer-science/DevOps/Git/Git-Information","date":"2023-05-18T06:15:06.000Z","updated":"2023-12-15T19:00:13.060Z","comments":true,"path":"computer-science/DevOps/Git/Git-Information/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Git/Git-Information/","excerpt":"","text":"ChienI Kao 筆記網站 JHTNT 筆記網站 # 前言 版本控制系統：對軟體開發過程中程式碼、文件、文檔等，發生的變更進行管理的系统，它可以幫助團隊更好的溝通協作，從而更好的進行交付。 常見的版本控制系統分為: 集中式版本控制系統，如: SVN 用主從式架構的作法 需要網路才可以工作，版本在中央服務器上 分布式版本控制系統 distributed version control，如: Git 它允許軟體開發者可以共同參與一個軟體開發專案，但是不必在相同的網路系統下工作 用對等網路的作法來處理版本控制 版本存在自己的 host 上，同時動到一個檔案時，互相給對方看，因此衍伸出遠端數據庫 前情提要: 這章主要在介紹 git 是什麼，以及其的用法，並介紹 github 一個遠端數據庫。也會概述一下 git 分支，可以如何使用。 # Git 是什麼？ Git 是一個軟體，可藉由它產生一個數據庫（repository），並且做到分散式版本控制。 以下幾個功能讓協同開發變得容易，例如: 多處放置同一份程式碼 歷史紀錄追蹤與回朔 版本控制系統 (Version Control System) – 管理你的程式碼版本反悔了回得去、合併了能處理、多人協作互不干擾 # GitHub 是什麼？ GitHub 是一個遠端數據庫，可用於檔案存放，並紀錄檔案版本，將本地端的數據庫存於遠端，達到共同開發的目的。 常見遠端數據庫 GitHub GitLab BitBucket # Git vs. GitHub? 一個是工具，一個是網站，GitHub 的本體是一個 Git Server。 # 沒有 Git? 當你好不容易寫完程式碼，卻被你的好同事 gank。😢","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"}],"tags":[]},{"title":"2622. Cache With Time Limit","slug":"coding/leetcode/Medium/2622-Cache-With-Time-Limit","date":"2023-05-18T02:45:47.000Z","updated":"2023-12-15T19:09:59.837Z","comments":true,"path":"coding/leetcode/Medium/2622-Cache-With-Time-Limit/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2622-Cache-With-Time-Limit/","excerpt":"","text":"⭐️⭐️⭐️⭐️ # 題目敘述 Write a class that allows getting and setting key-value pairs, however a time until expiration is associated with each key. The class has three public methods: set(key, value, duration) : accepts an integer key , an integer value , and a duration in milliseconds. Once the duration has elapsed, the key should be inaccessible. The method should return true if the same un-expired key already exists and false otherwise. Both the value and duration should be overwritten if the key already exists. get(key) : if an un-expired key exists, it should return the associated value. Otherwise it should return -1 . count() : returns the count of un-expired keys. # Example 1: Input: [&quot;TimeLimitedCache&quot;, &quot;set&quot;, &quot;get&quot;, &quot;count&quot;, &quot;get&quot;] [[], [1, 42, 100], [1], [], [1]] [0, 0, 50, 50, 150] Output: [null, false, 42, 1, -1] Explanation: At t=0, the cache is constructed. At t=0, a key-value pair (1: 42) is added with a time limit of 100ms. The value doesn't exist so false is returned. At t=50, key=1 is requested and the value of 42 is returned. At t=50, count() is called and there is one active key in the cache. At t=100, key=1 expires. At t=150, get(1) is called but -1 is returned because the cache is empty. # Example 2: Input: [&quot;TimeLimitedCache&quot;, &quot;set&quot;, &quot;set&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;, &quot;count&quot;] [[], [1, 42, 50], [1, 50, 100], [1], [1], [1], []] [0, 0, 40, 50, 120, 200, 250] Output: [null, false, true, 50, 50, -1] Explanation: At t=0, the cache is constructed. At t=0, a key-value pair (1: 42) is added with a time limit of 50ms. The value doesn't exist so false is returned. At t=40, a key-value pair (1: 50) is added with a time limit of 100ms. A non-expired value already existed so true is returned and the old value was overwritten. At t=50, get(1) is called which returned 50. At t=120, get(1) is called which returned 50. At t=140, key=1 expires. At t=200, get(1) is called but the cache is empty so -1 is returned. At t=250, count() returns 0 because the cache is empty. # 解題思路 # Solution var TimeLimitedCache = function() &#123; this.cache = new Map();&#125;;/** * @param &#123;number&#125; key * @param &#123;number&#125; value * @param &#123;number&#125; time until expiration in ms * @return &#123;boolean&#125; if un-expired key already existed */TimeLimitedCache.prototype.set = function(key, value, duration) &#123; const val = this.cache.get(key); if(val)&#123; clearTimeout(val.timeout); &#125; const timeout = setTimeout(() => this.cache.delete(key), duration); this.cache.set(key, &#123;value, timeout&#125;); return Boolean(val);&#125;;/** * @param &#123;number&#125; key * @return &#123;number&#125; value associated with key */TimeLimitedCache.prototype.get = function(key) &#123; return this.cache.has(key) ? this.cache.get(key).value : -1;&#125;;/** * @return &#123;number&#125; count of non-expired keys */TimeLimitedCache.prototype.count = function() &#123; return this.cache.size;&#125;;/** * Your TimeLimitedCache object will be instantiated and called as such: * var obj = new TimeLimitedCache() * obj.set(1, 42, 1000); // false * obj.get(1) // 42 * obj.count() // 1 */ class TimeLimitedCache &#123; cache: Map&lt;any, any>; constructor() &#123; this.cache = new Map(); &#125; set(key: number, value: number, duration: number): boolean &#123; const val: any = this.cache.get(key); if (val) &#123; clearTimeout(val.timeout); &#125; const timeout = setTimeout((): Boolean => this.cache.delete(key), duration); this.cache.set(key, &#123; value, timeout &#125;); return Boolean(val); &#125; get(key: number): number &#123; return this.cache.has(key) ? this.cache.get(key).value : -1; &#125; count(): number &#123; return this.cache.size; &#125;&#125;/** * Your TimeLimitedCache object will be instantiated and called as such: * var obj = new TimeLimitedCache() * obj.set(1, 42, 1000); // false * obj.get(1) // 42 * obj.count() // 1 */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"1557. Minimum Number of Vertices to Reach All Nodes","slug":"coding/leetcode/Medium/1557-Minimum-Number-of-Vertices-to-Reach-All-Nodes","date":"2023-05-18T01:57:45.000Z","updated":"2023-12-15T19:08:50.939Z","comments":true,"path":"coding/leetcode/Medium/1557-Minimum-Number-of-Vertices-to-Reach-All-Nodes/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1557-Minimum-Number-of-Vertices-to-Reach-All-Nodes/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a directed acyclic graph, with n vertices numbered from 0 to n - 1 , and an array edges where edges[i] = [fromi, toi] represents a directed edge from node fromi to node toi . Find the smallest set of vertices from which all nodes in the graph are reachable. It's guaranteed that a unique solution exists. Notice that you can return the vertices in any order. # Example 1: Input: n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]] Output: [0,3] Explanation: It's not possible to reach all the nodes from a single vertex. From 0 we can reach [0,1,2,5]. From 3 we can reach [3,4,2,5]. So we output [0,3]. # Example 2: Input: n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]] Output: [0,2,3] Explanation: Notice that vertices 0, 3 and 2 are not reachable from any other node, so we must include them. Also any of these vertices can reach nodes 1 and 4. # 解題思路 # Solution import java.util.ArrayList;import java.util.HashSet;import java.util.List;import java.util.Set;class Solution &#123; public List&lt;Integer> findSmallestSetOfVertices(int n, List&lt;List&lt;Integer>> edges) &#123; Set&lt;Integer> link = new HashSet&lt;>(); for (List&lt;Integer> edge : edges) &#123; link.add(edge.get(1)); &#125; List&lt;Integer> ans = new ArrayList&lt;>(); for (int i = 0; i &lt; n; i++) &#123; if (!link.contains(i)) &#123; ans.add(i); &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"}]},{"title":"2636. Promise Pool","slug":"coding/leetcode/Medium/2636-Promise-Pool","date":"2023-05-17T01:55:36.000Z","updated":"2023-05-28T17:14:50.972Z","comments":true,"path":"coding/leetcode/Medium/2636-Promise-Pool/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2636-Promise-Pool/","excerpt":"","text":"⭐️ # 題目敘述 Given an array of asyncronous functions functions and a pool limit n , return an asyncronous function promisePool . It should return a promise that resolves when all the input functions resolve. Pool limit is defined as the maximum number promises that can be pending at once. promisePool should begin execution of as many functions as possible and continue executing new functions when old promises resolve. promisePool should execute functions[i] then functions[i + 1] then functions[i + 2] , etc. When the last promise resolves, promisePool should also resolve. For example, if n = 1 , promisePool will execute one function at a time in series. However, if n = 2 , it first executes two functions. When either of the two functions resolve, a 3rd function should be executed (if available), and so on until there are no functions left to execute. You can assume all functions never reject. It is acceptable for promisePool to return a promise that resolves any value. # Example 1: Input: functions = [ () =&gt; new Promise(res =&gt; setTimeout(res, 300)), () =&gt; new Promise(res =&gt; setTimeout(res, 400)), () =&gt; new Promise(res =&gt; setTimeout(res, 200)) ] n = 2 Output: [[300,400,500],500] Explanation: Three functions are passed in. They sleep for 300ms, 400ms, and 200ms respectively. They resolve at 300ms, 400ms, and 500ms respectively. The returned promise resolves at 500ms. At t=0, the first 2 functions are executed. The pool size limit of 2 is reached. At t=300, the 1st function resolves, and the 3rd function is executed. Pool size is 2. At t=400, the 2nd function resolves. There is nothing left to execute. Pool size is 1. At t=500, the 3rd function resolves. Pool size is zero so the returned promise also resolves. # Example 2: Input: functions = [ () =&gt; new Promise(res =&gt; setTimeout(res, 300)), () =&gt; new Promise(res =&gt; setTimeout(res, 400)), () =&gt; new Promise(res =&gt; setTimeout(res, 200)) ] n = 5 Output: [[300,400,200],400] Explanation: The three input promises resolve at 300ms, 400ms, and 200ms respectively. The returned promise resolves at 400ms. At t=0, all 3 functions are executed. The pool limit of 5 is never met. At t=200, the 3rd function resolves. Pool size is 2. At t=300, the 1st function resolved. Pool size is 1. At t=400, the 2nd function resolves. Pool size is 0, so the returned promise also resolves. # Example 3: Input: functions = [ () =&gt; new Promise(res =&gt; setTimeout(res, 300)), () =&gt; new Promise(res =&gt; setTimeout(res, 400)), () =&gt; new Promise(res =&gt; setTimeout(res, 200)) ] n = 1 Output: [[300,700,900],900] Explanation: The three input promises resolve at 300ms, 700ms, and 900ms respectively. The returned promise resolves at 900ms. At t=0, the 1st function is executed. Pool size is 1. At t=300, the 1st function resolves and the 2nd function is executed. Pool size is 1. At t=700, the 2nd function resolves and the 3rd function is executed. Pool size is 1. At t=900, the 3rd function resolves. Pool size is 0 so the returned promise resolves. # 解題思路 # Solution /** * @param &#123;Function[]&#125; functions * @param &#123;number&#125; n * @return &#123;Function&#125; */var promisePool = async function (functions, n) &#123; const nextPromise = async function next() &#123; if (functions.length == 0)&#123; return ; &#125; const fn = functions.shift(); await fn(); await next(); &#125; const ans = Array(n).fill(null).map(nextPromise); return await Promise.all(ans);&#125;;/** * const sleep = (t) => new Promise(res => setTimeout(res, t)); * promisePool([() => sleep(500), () => sleep(400)], 1) * .then(console.log) // After 900ms */ type F = () => Promise&lt;any>;function promisePool(functions: F[], n: number): Promise&lt;any> &#123; const nextPromise = async function next():Promise&lt;any> &#123; if(functions.length == 0)&#123; return ; &#125; const fn: Function = functions.shift(); await fn(); await next(); &#125; const ans: Promise&lt;any>[] = Array(n).fill(null).map(nextPromise); return Promise.all(ans);&#125;;/** * const sleep = (t) => new Promise(res => setTimeout(res, t)); * promisePool([() => sleep(500), () => sleep(400)], 1) * .then(console.log) // After 900ms */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"2130. Maximum Twin Sum of a Linked List","slug":"coding/leetcode/Medium/2130-Maximum-Twin-Sum-of-a-Linked-List","date":"2023-05-17T01:29:29.000Z","updated":"2023-12-15T19:09:15.786Z","comments":true,"path":"coding/leetcode/Medium/2130-Maximum-Twin-Sum-of-a-Linked-List/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2130-Maximum-Twin-Sum-of-a-Linked-List/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 In a linked list of size n , where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 &lt;= i &lt;= (n / 2) - 1 . For example, if n = 4 , then node 0 is the twin of node 3 , and node 1 is the twin of node 2 . These are the only nodes with twins for n = 4 . The twin sum is defined as the sum of a node and its twin. Given the head of a linked list with even length, return the maximum twin sum of the linked list. # Example 1: Input: head = [5,4,2,1] Output: 6 Explanation: Nodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6. There are no other nodes with twins in the linked list. Thus, the maximum twin sum of the linked list is 6. # Example 2: Input: head = [4,2,2,3] Output: 7 Explanation: The nodes with twins present in this linked list are: Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7. Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4. Thus, the maximum twin sum of the linked list is max(7, 4) = 7. # Example 3: ![](https://assets.leetcode.com/uploads/2021/12/03/eg3drawio.png =300x) Input: head = [1,100000] Output: 100001 Explanation: There is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001. # 解題思路 # Solution // Definition for singly-linked list.import java.util.Deque;import java.util.LinkedList;public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; class Solution &#123; public int pairSum(ListNode head) &#123; Deque&lt;Integer> dq = new LinkedList&lt;>(); ListNode curr = new ListNode(); curr = head; while(curr != null)&#123; dq.add(curr.val); curr = curr.next; &#125; int max = Integer.MIN_VALUE; while(!dq.isEmpty() &amp;&amp; dq.size() >= 2)&#123; max = Math.max(max, dq.pollFirst() + dq.pollLast()); &#125; return max; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Linked List","slug":"Linked-List","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Linked-List/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"}]},{"title":"Docker Practise - 2","slug":"computer-science/DevOps/Docker/Docker-Practise-2","date":"2023-05-16T11:41:31.000Z","updated":"2023-12-15T18:59:31.438Z","comments":true,"path":"computer-science/DevOps/Docker/Docker-Practise-2/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/Docker-Practise-2/","excerpt":"","text":"# 實作說明 在前一個實作中我們先創建了一個 images ubuntu ，在裡面安裝 nginx ，但其實我們只需要使用 nginx 而已，並不需要 ubuntu 這個作業系統。 所以接下來我們要實作撰寫一個 Dockerfile，在自己的專案中，run Dockerfile 進行部屬，而且不包含 ubuntu。 # 撰寫一個 Project 當然要現在馬上生出一個 project 有點費時，所以如果手邊沒有撰寫好的 project 也沒關係，接下來分兩部分來說: 已經有可以實作的 project 這個就很簡單，先進入 project 的資料夾。 沒有可實作的 project 這個其實也不難，創建一個新資料夾，名稱隨意，如果想不到可以用: [docker-test]，在裡面撰寫一個 index.html 。 以下是個簡單的 html 可以參考: index.html&lt;h1>My Project&lt;/h1> # 撰寫 nignx.conf 這個其實沒寫也沒關係，沒有寫就是原本 nignx.conf 的預設，寫了可以更改其原本預設。 server&#123; listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; index index.html; charset utf-8; access_log /var/log/nginx/access_log; error_log /var/log/nginx/error_log; &#125; 內容細節說明可以去看 docker practise - 1，那邊有稍微說明一下內容涵意。 # 創建一個 Dockerfile 的檔案 創建一個 Dockerfile 檔，沒有副檔名，純檔案。 Dockerfile 內容如下: FROM nginxMAINTAINER HsingYu# 複製一整個在根目錄專案的檔案進去COPY / /usr/share/nginx/html# 如果只有一個檔案，如: index.html 可以寫 # COPY index.html /usr/share/nginx/html# 把 nignx.conf 加入預設 conf 裡面COPY nginx.conf /etc/nginx/conf.d/default.conf# 容器對外連接 80 portEXPOSE 80這樣就完成撰寫 Dockerfile 了。 # 利用 Dockerfile 建立 images docker bulid -t [&quot;images name&quot;] . -t : 後面接為 images 命名的名稱，注意不可以是大寫字母，要是小寫喔～～ . : 指在這個地方下的 Dockerfile 建立完成會如下圖: # 執行建立的 images docker run -p 80:80 [&quot;images name&quot;] -p : 後面寫通信的 port 80:80 : 為了方便區分冒號 (:) 前後 port 代表的不同意思，接下來會以 8080:80 來解釋，容器將在端口 8080 上的主機上可用，但它與端口 80 上的容器（和應用程序）通信，簡單來說就是在 bowser 中輸入容器運行所在的 Docker 主機的 DNS 名稱或者 IP 位址，並在後面加上 port 8080，例如: localhost:8080 執行成功會如下圖: localhost port 80 不用特別寫，localhost:80 =&gt; localhost","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"}]},{"title":"Docker Practise - 1","slug":"computer-science/DevOps/Docker/Docker-Practise-1","date":"2023-05-16T11:32:34.000Z","updated":"2023-12-15T18:59:27.206Z","comments":true,"path":"computer-science/DevOps/Docker/Docker-Practise-1/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/Docker-Practise-1/","excerpt":"","text":"# 實作說明 當一個軟體完成後要進行發布網站，我們並不會使用絕對路徑，顯示檔案位置，會使用取得主機（hosting）和網域名稱（domain name）的方式來達到。 而他人只需要訪問你的 hosting IP 或為其申請的 domain name 來 request 資料。 而常見的有兩種工具來做: Apache nginx 舉個大家比較熟悉的例子就是 xampp， 可以將檔案丟進去，訪問 localhost 進行訪問。 但是因為 xampp 是一個類似於 LAMP 的環境， 他除了 Apache 以外，還包含了 phpmyadmin、PHP、Perl 等其他東西， 如果不需要用到 php 等東西，就會比較沒有必要。 # 創建一個 docker images ubuntudocker run -it -p 80:80 ubuntu:focal bash # 更新 apt apt update # 下載 nginx apt install nginx # 開啟 nginx nginx -s reload # 可能出現錯誤資訊: nginx: [error] open() &quot;/var/run/nginx.pid&quot; failed (2: No such file or directory) 解決方法: 輸入以下指令 nginx -c /etc/nginx/nginx.conf 查看 /etc/nginx/nginx.conf 修改內容 nano /etc/nginx/nginx.conf 將其中內容修改成下方 pid /var/run/nginx.pid; #pid /run/nginx.pid; pid /var/run/nginx.pid; 再試一次 nginx -s reload # 網頁連接設定 nano /etc/nginx/sites-available/default port 連接設定 根目錄檔案位置 預先載入檔案 server_name 用於設定 DNS 域名 # 最後將 APP 檔案加入根目錄檔案位置 原本顯示完整檔案位置 經過修改剩下 locolhost = 127.0.0.1 ^D = exit : 離開 container 如果在 Terminal 無法離開 container 再開起一個 Terminal docker ps : 檢查還未關閉的 container docker stop [container ID] : 這裡 container ID 可以打前兩個字就好","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"}]},{"title":"Docker Compose","slug":"computer-science/DevOps/Docker/Docker-Compose","date":"2023-05-16T11:29:28.000Z","updated":"2023-12-15T18:59:10.018Z","comments":true,"path":"computer-science/DevOps/Docker/Docker-Compose/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/Docker-Compose/","excerpt":"","text":"# Docker Compose # 為什麼要用 Docker Compose? 之前有介紹過使用 docker run 指令就可以把 Docker Container 啟動起來，但是如果我們要啟動很多個 Docker Container 時，就需要輸入很多次 docker run 指令。 另外 container 和 container 之間要做關聯的話也要記得它們之間要如何的連結 (link) Container，這樣在要啟動多個 Container 的情況下，就會顯得比較麻煩。 # 如何運作？ Docker-Compose: 寫一個 docker-compose.yml ，把所有要使用 Docker Image 寫上去，也可以把 Container 之間的關係連結 (link) 起來。 最後只要下 docker-compose up 指令，就可以把所有的 Docker Container 執行起來，這樣就可以很快速和方便的啟動多個 container。 # Docker Compose 常用指令 指令 說明 $ docker-compose up # 啟動所有的 Docker Container $ docker-compose up -d # 啟動所有的 Docker Container，且在背景執行 $ docker-compose ps # 查看 Docker Container 的執行狀態 $ docker-compose logs # 看執行的 log $ docker-compose stop # 停止 docker-compose 執行的所有 Container $ docker-compose rm # 刪除 docker-compose 的所有 Container $ docker-compose restart # 重啟 docker-compose 的所有 Container # Docker Compose 實作 實作的部份主要就是要把 Docker-Compose 安裝起來 然後撰寫一個 docker-compose.yml 並且使用 docker-compose up ，指令把所有的 Docker Container 啟動起來 # 安裝 Docker-Compose $ cd /usr/bin$ wget https://github.com/docker/compose/releases/download/1.18.0/docker-compose-Linux-x86_64$ mv docker-compose-Linux-x86_64 docker-compose$ chmod 755 docker-compose# 撰寫 docker-compose.yml docker-compose.ymlversion: '2'services: db: image: mysql environment: MYSQL_ROOT_PASSWORD: 123456 admin: image: adminer ports: - 8080:8080 主要的功能是要啟動 2 個 Docker Container，一個是 mysql 的 Container，另外一個是 admin 管理 mysql Web UI 的 container MYSQL_ROOT_PASSWORD 的環境變數用來設定登入 mysql 的密碼 參考網站: https://hub.docker.com/_/mysql/ # 啟動所有的 Docker Container $ docker-compose up -d -d 參數代表要執行在背景的方式 # 查看 Docker Container 的執行狀態 $ docker-compose ps# admin 執行 http://localhost:8080 其他指令可以參考官方網站: https://docs.docker.com/compose/compose-file/compose-file-v2/ # 參考文章 iT邦幫忙/@yangj26952 使用 Docker-Compose 啟動多個 Docker Container","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"}]},{"title":"Dockerfile","slug":"computer-science/DevOps/Docker/Docker_file","date":"2023-05-16T11:11:57.000Z","updated":"2023-12-15T18:59:06.388Z","comments":true,"path":"computer-science/DevOps/Docker/Docker_file/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/Docker_file/","excerpt":"","text":"# Dockerfile Dockerfile 由一行行命令語句組成，並且支援以 # 開頭的註解行。 Dockerfile 分為四部分： 基底映像檔資訊 維護者資訊 映像檔操作指令 容器啟動時執行指令。 # This dockerfile uses the ubuntu image # VERSION 2 - EDITION 1 # Author: docker_user # Command format: Instruction [arguments / command] .. # 基本映像檔，必須是第一個指令 FROM ubuntu# 維護者： docker_user &lt;docker_user at email.com> (@docker_user) MAINTAINER docker_user docker_user@email.com # 更新映像檔的指令 RUN echo \"deb http://archive.ubuntu.com/ubuntu/ raring main universe\" >> /etc/apt/sources.list RUN apt-get update &amp;&amp; apt-get install -y nginx RUN echo \"\\ndaemon off;\" >> /etc/nginx/nginx.conf # 建立新容器時要執行的指令 CMD /usr/sbin/nginx# Dockerfile 基本語法 # Example FROM centos:7MAINTAINER jackRUN yum install -y wgetRUN cd /ADD jdk-8u152-linux-x64.tar.gz /RUN wget http://apache.stu.edu.tw/tomcat/tomcat-7/v7.0.82/bin/apache-tomcat-7.0.82.tar.gzRUN tar zxvf apache-tomcat-7.0.82.tar.gzENV JAVA_HOME=/jdk1.8.0_152ENV PATH=$PATH:/jdk1.8.0_152/binCMD [\"/apache-tomcat-7.0.82/bin/catalina.sh\", \"run\"] FROM： 使用到的 Docker Image 名稱，今天使用 CentOS MAINTAINER： 用來說明，撰寫和維護這個 Dockerfile 的人是誰，也可以給 E-mail 的資訊 RUN： RUN 指令後面放 Linux 指令，用來執行安裝和設定這個 Image 需要的東西 ADD： 把 Local 的檔案複製到 Image 裡，如果是 tar.gz 檔複製進去 Image 時會順便自動解壓縮。Dockerfile 另外還有一個複製檔案的指令 COPY 未來還會再介紹 ENV： 用來設定環境變數 CMD： 在指行 docker run 的指令時會直接呼叫開啟 Tomcat Service # Dockerfile 實作 已經體驗過使用 Docker 的指令，把 Docker Image Pull 到 local，並且執行 container，然後在 container 上安裝 HTTP Service，就類似是在使用 VM。 直接進入 Docker Container 裡面下一些指令安裝程式和改設定檔，不夠自動化，可能需要常常的重覆在做同一件事，這樣會很沒效率。 寫 Dockerfile，只要下 docker build 的指令就可以把 Docker Image 建構起來，未來要使用就直接 Run 此 Image。 # 實作目標: 要做到在 Dockerfile 裡面，撰寫安裝 Java 和 Tomcat 的指令，包成 Docker Image， 之後只要呼叫到 docker run 指令，就可以把 Tomcat Service 啟動起來。 主要目的用來體驗如何撰寫 Dockerfile 和 Build Image 以及執行 Docker container。 記住要使用 WSL2 此虛擬機 來實作 Docker 可參考前面 安裝 Windows，或以下訊息 Docker 並非是一个通用的容器工具，它依賴於已存在並運行的 Linux 内核環境。 在 Windows 上部署 Docker 的方法都是先安装一个虛擬機，並在安装 Linux 系統的的虛擬機中運行 Docker。 # 第一步: 建立 Dockerfile 建立寫 Dockerfile 會用到的資料夾，指令如下 $ mkdir docker-test $ cd docker-test 下載 JDK 的安裝檔放在 docker-test 資料夾裡，使用的版本是 jdk-19.0.2 下載連結 https://download.java.net/java/GA/jdk19.0.2/fdb695a9d9064ad6b064dc6df578380c/7/GPL/openjdk-19.0.2_linux-x64_bin.tar.gz sudo apt install 將檔案移至路徑 \\wsl$\\Ubuntu\\home\\[user name]\\docker-test 撰寫 Dockerfile $ vi Dockerfile Dockerfile 的內容如下 FROM centos:7MAINTAINER HsingYu# 安裝 wget，yum 是 centos 的安裝指令RUN yum install -y wgetRUN cd /# 加入 jdk-19.0.2 壓縮檔案，加入後會自動解壓縮ADD openjdk-19.0.2_linux-x64_bin.tar.gz /# 下載 apache-tomcat-10.1.7.tar.gzRUN wget --no-check-certificate https://dlcdn.apache.org/tomcat/tomcat-10/v10.1.7/bin/apache-tomcat-10.1.7.tar.gz# 解壓縮 apache-tomcat-10.1.7.tar.gzRUN tar zxvf apache-tomcat-10.1.7.tar.gz# 設置 java 的環境變數ENV JAVA_HOME=/jdk-19.0.2ENV PATH=$PATH:/jdk-19.0.2/binCMD [\"/apache-tomcat-10.1.7/bin/catalina.sh\", \"run\"] 撰寫完 Dockerfile 之後資料夾的結構如下圖 或者將下載 jdk19.0.2 也寫入 Dockerfile FROM centos:7MAINTAINER HsingYuRUN yum install -y wgetRUN cd /RUN wget https://download.java.net/java/GA/jdk19.0.2/fdb695a9d9064ad6b064dc6df578380c/7/GPL/openjdk-19.0.2_linux-x64_bin.tar.gzRUN tar zxvf openjdk-19.0.2_linux-x64_bin.tar.gzRUN wget --no-check-certificate https://dlcdn.apache.org/tomcat/tomcat-10/v10.1.7/bin/apache-tomcat-10.1.7.tar.gzRUN tar zxvf apache-tomcat-10.1.7.tar.gzENV JAVA_HOME=/jdk-19.0.2ENV PATH=$PATH:/jdk-19.0.2/binCMD [\"/apache-tomcat-10.1.7/bin/catalina.sh\", \"run\"] # 第二步: Build Docker Image 預設在和 Dockerfile 檔案同層的資料夾底下輸入， docker build 指令，如下 $ docker build -t mytomcat . --no-cache 使用 --no-cache 的主要原因，是避免在 Build Docker image 時被 cache 住，而造成沒有 build 到修改過的 Dockerfile。 Build 完的結果如下圖： Build 完 Docker Image 之後，使用 docker images 指令查看是否有 build 成功如下圖 # 第三步: 在 Build 完 Docker Image 之後就可以執行 Docker Container，這時 Tomcat 的 Service 也會跟者被執行起來，指令如下 在瀏覽器跑 $ docker run -p 8080:8080 mytomcat 在虛擬機跑 $ docker run mytomcat Tomcat Service 會被執行起來的主要原因是在 Dockerfile 裡面有寫 CMD 指令，呼叫啟動 Tomcat Service # 第四步: 打開 Browser 確認 要打開 Browser 確認 Tomcat Service 有沒有被執行起來時，發現我們不知道 Docker Container 的 IP，這時侯只能使用 docker exec 進入 docker container 查詢 IP 。 要使用 docker exec 指令之前需要先知道 Container 的 ID 所以需要先使用 docker ps 指令查詢 Container ID，如下圖： 有了 IP 之後就可以打開 Browser 輸入 http://172.17.0.2:8080 URL 的位置，確認 Tomcat Service 是否有啟動，如下圖： 直接進入 Docker Container 去看 IP 的位址其實有點麻煩，會故意這樣 Daemon 主要的原因，是讓大家了解到我們把 Docker Container 執行啟來時並不會知道它的 IP 位址在哪，這需要透過設定有關於 Docker 的 Network 來解決這個問題。 目前使用最簡單的方法，就是在 run docker container 時用 Port 的 Mapping 來解決此問題，重新再一次 run docker container，指令如下： $ docker run -p 8080:8080 mytomcat Container 的 8080 port mapping 到 localhost 的 8080 port ，這樣只要輸入 http://localhost:8080 就可以看到 tomcat service 的 WebUI 畫面了。 # 參考文章 iT邦幫忙/@yangj26952 實作撰寫第一個 Dockerfile","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"}]},{"title":"基礎指令","slug":"computer-science/DevOps/Docker/基礎指令","date":"2023-05-16T10:57:42.000Z","updated":"2023-12-15T18:59:50.895Z","comments":true,"path":"computer-science/DevOps/Docker/基礎指令/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/%E5%9F%BA%E7%A4%8E%E6%8C%87%E4%BB%A4/","excerpt":"","text":"# 基礎指令 # Image 映像檔 常用指令 指令 說明 範例 search 搜尋 docker search [image_name] pull 下載 docker pull [image_name] images 查看目前 images (列表) docker images run 執行 docker run [-ti] [centos] [/bin/bash] rmi [image ID] 刪除 docker rmi [615cb40d5d19] build 建立 docker build [-t project .] login 登入 docker login [docker.okborn.com] push 上傳 docker push # Container 容器 常用指令 # Registry 倉庫 常用指令 # 基礎指令實作 # 實作目標： 先從 Docker Hub 上把 Ubuntu OS 的 image pull 到 local， 有了 image 之後就可以把 Docker container 執行起來， 然後進入到 container 裡面安裝和啟動 Apache 的 HTTP Service， 並且寫一個有 HelloWorld 字串的 HTML 檔案。 最後使用 Browser 連到 Docker Container 裡面的 HTTP Service， 確認 HelloWorld 的字串能正常的顯示出來。 # 實作的流程如下： 從 Docker Hub 下載 Docker Image 到 local 使用 Docker Image 啟動 Docker Container 並進入 Docker Container 的 terminal 在 Docker Container 裡面安裝 Apache 的 HTTP Service，並且寫一個 helloworld 的 html 檔 使用 Browser 連到 helloworld.html 確認 Docker Container 有成功的被啟動起來 # 第一步: 從 Docker Hub 下載 Docker Image 到 local 要下載 Docker Image 之前需要先搜尋一下，Docker Image 的 Name 是什麼，指令如下： $ docker search ubuntu -f is-official=true is-official=true 表示要搜尋是官方的 Docker image 就選擇星星數最多的 Name 為 ubuntu 找到了 ubuntu 的 Docker Image Name 之後，就可以把此 image pull 下來，指令如下： $ docker pull ubuntu 執行結果如下圖 要再一次確認 ubuntu 的 docker image 有沒有下載下來，可以使用以下的指令 $ docker images 執行結果如下圖 # 第二步: 有了 Docker Image 之後就可以把 container 執行起來了，並且進入 Docker Container 的 terminal 裡面 指令如下 $ docker run -it -p 8000:80 ubuntu /bin/bash 使用以上的指令就可以進入了 docker container 裡面的 terminal 可以再打開另外一個 terminal 視窗，輸入以下指令 $ docker ps -a 確認 docker container 有正常的執行，如下圖： 在要離開 docker container 的 terminal 時有一個坑。就是如果輸入 exit 指令時，container 會被關閉，如下圖： 如果不要停止 container 而要退出 docker container 的 terminal 需要輸入 ctrl + p 之後再輸入 ctrl + q 的按鍵，就不會把 container 關閉。 # 第三步: 在 docker container 裡面安裝和啟動 apache 的 http service，指令如下: root@a03f4fc98ea2:/# apt-get update root@a03f4fc98ea2:/# apt-get install -y apache2 root@a03f4fc98ea2:/# service apache2 start if it is success will show 簡單寫一個 hellowolrd.html 檔案放在 /var/www/html 的路徑下，指令如下: root@a03f4fc98ea2:/# echo &quot;HelloWorld&quot; &gt; /var/www/html/helloworld.html 使用 cat /etc/hosts 指令查看 docker container 的 IP 如下圖： 如果想要使用 ifconfig 指令，需要安裝 net-tools 工具指令如下: root@a03f4fc98ea2:/# apt-get install -y net-tools # 第四步: 使用 Linux 虛擬機 GUI browser 輸入 http://172.17.0.2/helloworld.html 的 URL 查看 helloworld.html 的檔案是否能正常的顯示。 使用 Window 本機的 browser 輸入 http://localhost:8000/helloworld.html 的 URL 查看 helloworld.html 的檔案是否能正常的顯示，畫面如下： # 參考文章 iT邦幫忙/@yangj26952 用簡單的例子來說明如何使用 Docker 指令","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"}]},{"title":"Docker-安裝","slug":"computer-science/DevOps/Docker/Docker-安裝","date":"2023-05-16T10:33:53.000Z","updated":"2023-12-15T18:59:40.349Z","comments":true,"path":"computer-science/DevOps/Docker/Docker-安裝/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/Docker-%E5%AE%89%E8%A3%9D/","excerpt":"","text":"# Windows Docker 並非是一个通用的容器工具，它依賴於已存在並運行的 Linux 内核環境。 在 Windows 上部署 Docker 的方法都是先安装一个虛擬機，並在安装 Linux 系統的的虛擬機中運行 Docker。 # 使用 WSL 在 Windows 上安裝 Linux 開發人員可以在 Windows 電腦上同時存取 Windows 和 Linux 的功能。 Windows 子系統 Linux 版 (WSL) 可讓開發人員直接在 Windows 上安裝 Linux 散發套件， (例如 Ubuntu、OpenSUSE、Type、Debian、Arch Linux 等) 並使用 Linux 應用程式、公用程式和 Bash 命令列工具，不需要傳統虛擬機器或雙佈設定的額外負荷。 # 必要條件 您必須 Windows 10 版本 2004 和更新版本執行， (組建 19041 和更新版本) 或 Windows 11。 檢查更新。 # 安裝 WSL 命令 開啟 PowerShell 或 Windows 命令提示字元 (cmd)，輸入命令，然後重新開機電腦。 wsl --install 啟用選用的 WSL 和虛擬機器平台元件 下載並安裝最新的 Linux 核心 將 WSL 2 設定為預設值 可能需要下載並安裝 Ubuntu Linux 發行版本 (重新開機) 您必須在此安裝程式期間重新開機電腦 若已有其他版本，可以以此指令來下載 Ubuntu wsl --install -d Ubuntu # 檢查 WSL 狀態 wsl --status 使用 wsl --install 命令安裝的新 Linux 安裝預設會設定為 WSL 2。 # 開啟 WSL wsl.exe # 設定 Linux 使用者名稱和密碼 系統會要求您為 Linux 發行版本建立使用者名稱和密碼。 此使用者名稱和密碼是每個各自 Linux 發行版本專屬，不會影響您的 Windows 使用者名稱。 請注意，在輸入 密碼時，畫面上不會顯示任何專案。 這稱為盲目輸入。 您不會看到您輸入的內容，這完全正常。 一旦您建立使用者名稱和密碼，帳戶就會是您散發套件的預設使用者，而且會在啟動時自動登入。 此帳戶將會被視為 Linux 系統管理員，並且能夠執行 sudo (超級使用者執行) 系統管理命令。 在 WSL 上執行的每個 Linux 發行版本都有自己的 Linux 使用者帳戶和密碼。 每當您新增散發套件、重新安裝或重設時，都必須設定 Linux 使用者帳戶。 若要變更或重設密碼，請開啟 Linux 發行版本，然後輸入命令： passwd 。 系統會要求您輸入目前的密碼，然後要求您輸入新密碼，然後確認您的新密碼。 # 使用 Docker 設定遠端開發容器 使用 WSL 2 (Windows 子系統 Linux 版 版本 2) 設定適用于 Windows 的 Docker Desktop。 # 必要條件 安裝 WSL，並為在 WSL 2 中執行的 Linux 發行版本設定使用者名稱和密碼。 安裝 Visual Studio Code (選擇性)。 這會提供最佳體驗，包括能夠在遠端 Docker 容器內撰寫程式碼和偵錯，並聯機到您的 Linux 散發套件。 安裝 Windows 終端機 (選擇性)。 這可提供最佳體驗，包括在同一個介面中自訂和開啟多個終端機的能力， (包括 Ubuntu、Debian、PowerShell、Azure CLI，或任何您想要使用)。 在 Docker Hub 註冊 Docker 識別碼， (選擇性)。 # 安裝 Docker Desktop 請先到 Docker 官網 https://www.docker.com/docker-windows 在 cmd 上輸入以下指令可以確認是否下載成功 開啟 Docker Desktop 確定已核取 [設定&gt; 一般] 中的 [使用 WSL 2 型引擎]。 移至 [設定&gt; 資源 &gt; WSL 整合]，從您想要啟用 Docker 整合的已安裝 WSL 2 散發套件中選取。 若要確認已安裝 Docker，請開啟 WSL 散發套件 (例如 Ubuntu) ，並輸入下列命令來顯示版本和組建編號： docker --version # 使用下列方式執行簡單的內建 Docker 映射，以測試您的安裝是否正常運作： docker run hello-world # 尋找 Docker 映射儲存體資料夾 Docker 會建立兩個散發資料夾來儲存資料： \\wsl$\\docker-desktop \\wsl$\\docker-desktop-data 您可以開啟 WSL Linux 發行版本並輸入： explorer.exe . 在 Windows 檔案總管中檢視資料夾，以找到這些資料夾。 輸入： \\\\wsl$","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Windows/"}]},{"title":"虛擬化技術","slug":"computer-science/DevOps/Docker/虛擬化技術","date":"2023-05-16T08:52:42.000Z","updated":"2023-12-15T18:59:55.140Z","comments":true,"path":"computer-science/DevOps/Docker/虛擬化技術/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/%E8%99%9B%E6%93%AC%E5%8C%96%E6%8A%80%E8%A1%93/","excerpt":"","text":"# 虛擬化技術 虛擬化要解決的問題是:「當我寫了一個程式，在我電腦上可以執行，但在別人電腦上就不行」。 # But why? 作業系統不同 硬體配置不同 簡單來說：我的程式可能剛好只跟我的電腦的環境相容。😢 # 何謂虛擬化技術？ 而虛擬化要做的就是模擬出一個環境，讓程式可以在不同硬體或作業系統上執行時，都以為自己在同一個環境中執行，以此來避免前面所述的問題。 目前常見用來比較的虛擬化技術有兩種: 在系統層級的虛擬化技術，稱虛擬機器（Virtual machine） 例如 : Virtual Box 。 在作業系統層級技術，此稱容器（Container） 例如 : Docker 。 # 虛擬機器 以作業系統為中心 傳統虛擬化的目標： 將一個應用程式所需的執行環境打包起來，建立一個獨立環境，方便在不同的硬體中移動。 虛擬機器是在系統層上虛擬化， 簡單來說， Virtual Box 就是一個可以讓你在作業系統（Host OS）上面再裝一個作業系統（Guest OS），然後讓兩個作業系統彼此不會打架的平台。 # 容器 以應用程式為中心 容器化的目標： 改善虛擬機器因為需要裝 Guest OS 導致啟動慢、佔較大記憶體的問題。 容器是在作業系統層上虛擬化， 透過 Container Manager 直接將一個應用程式所需的程式碼、函式庫打包， 建立資源控管機制隔離各個容器，並分配 Host OS 上的系統資源。 透過容器，應用程式不需要再另外安裝作業系統（Guest OS）也可以執行。 # VM vs. CONTAINER","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[]},{"title":"Docker Information","slug":"computer-science/DevOps/Docker/Docker-Information","date":"2023-05-16T07:52:43.000Z","updated":"2023-12-15T18:59:14.941Z","comments":true,"path":"computer-science/DevOps/Docker/Docker-Information/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/computer-science/DevOps/Docker/Docker-Information/","excerpt":"","text":"# 簡介 # 什麼是 Docker? Docker 是一個開源軟體，出現於 2013 年初，最初是 Dotcloud 公司內部的 Side-Project。 它基於 Google 公司推出的 Go 語言實作。(Dotcloud 公司後來改名為 Docker) # 為什麼要使用 Docker? 更有效率的利用資源 統一環境 對於 DevOps 的好處 使開發高效且可以預測 消除了重複的、平凡的配置任務，在整個開發生命週期中用於快速、簡單和可移植的應用程序開發。 Docker 想解決的問題: 改善傳統虛擬機器因為需要額外安裝作業系統（Guest OS），導致啟動慢、佔較大記憶體的問題。 Docker 要提供的解法： 以應用程式為核心虛擬化，取代傳統需要 Guest OS 的虛擬化技術。 # 概念 Docker 是一種工具，可用來建立、部署及執行使用容器的應用程式。 容器可讓開發人員封裝含有其所需全部元件 (程式庫、架構、相依性等) 的應用程式，且全部以一個套件的形式出貨。 使用容器可確保應用程式會以相同的方式執行，而不管任何自訂的設定或先前在執行該應用程式的電腦 (可能與用來撰寫和測試應用程式程式碼的電腦不同) 上安裝的程式庫。 這可讓開發人員專注於撰寫程式碼，而不需擔心程式碼將在其上執行的系統。 # Docker 三元素 要使用 Docker 時最重要的三個元素： 映像檔 (Image)、 容器 (Container)、 倉庫 (Repository)。 用一個簡單的比喻來解釋 : 如果映像檔是一個做蛋糕的模具，容器則是用該模具烤出來的蛋糕，而倉庫是用來集中放置模具們的收納櫃。 # Image 映像檔為一個唯獨的模板。 內可包含完整的 ubuntu 作業系統環境。 映像檔可用來快速生產 Docker 容器，並可重複產生。 映像檔可以透過 (撰寫由命令行構成的) Dockerfile 建立，或是開放公開下載的地方取得。 舉例來說，如果我今天想要一個 node.js 的執行環境跑我寫好的程式，我可以直接到上 Docker Hub 找到相對應的 node.js 映像檔 ，而不需要自己想辦法打包一個執行環境。 它是 Docker 的映像檔主要是一個唯讀的檔案， 是啟動 Docker container 要使用到的檔案。 另外 Docker 的 image 可以像是堆積木一樣， 一層一層的把 Docker image 堆起來。 如右圖： # Container 容器是由映像檔建立出來的實例。 Docker 即是利用容器來執行關鍵技術。 容器可以被啟動、開始、停止、刪除。 且容器與容器之間是相互隔離、保證安全的。 可以把容器看做是一個執行的應用程式加上執行它的簡易版 Linux 環境（包括 root 使用者權限、程式空間、使用者空間和網路空間等） Docker Container 是透過 Docker image 執行起來的 Process，同一個 Docker image 可以啟動多個 Docker Container。 Docker container 和 Docker container 之間的環境是隔離開離來的，不會發生 container1 開 8080 的 port，container2 開 8080 的 port 有衝到的問題 # Repository 倉庫是集中存放映像檔檔案的場所，每個倉庫中又包含了多個映像檔。 每個映像檔有不同的標籤（tag）。 倉庫分為公開倉庫（Public）和私有倉庫（Private）兩種形式 而最大的公開倉庫為 Docker Hub，裡面存放了大量的現成、實用映像檔供使用者下載。 而 Docker 倉庫註冊伺服器的概念就跟 Github 類似，你可以在上面建立多個倉庫，然後透過 push、pull 的方式上傳、存取。","categories":[{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"}],"tags":[]},{"title":"2637. Promise Time Limit","slug":"coding/leetcode/Easy/2637-Promise-Time-Limit","date":"2023-05-16T07:21:24.000Z","updated":"2023-05-28T17:12:05.518Z","comments":true,"path":"coding/leetcode/Easy/2637-Promise-Time-Limit/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2637-Promise-Time-Limit/","excerpt":"","text":"⭐️ # 題目敘述 Given an asyncronous function fn and a time t in milliseconds, return a new time limited version of the input function. A time limited function is a function that is identical to the original unless it takes longer than t milliseconds to fullfill. In that case, it will reject with &quot;Time Limit Exceeded&quot; . Note that it should reject with a string, not an Error . # Example 1 Input: fn = async (n) =&gt; { await new Promise(res =&gt; setTimeout(res, 100)); return n * n; } inputs = [5] t = 50 Output: {&quot;rejected&quot;:&quot;Time Limit Exceeded&quot;,&quot;time&quot;:50} Explanation: The provided function is set to resolve after 100ms. However, the time limit is set to 50ms. It rejects at t=50ms because the time limit was reached. # Example 2 Input: fn = async (n) =&gt; { await new Promise(res =&gt; setTimeout(res, 100)); return n * n; } inputs = [5] t = 150 Output: {&quot;resolved&quot;:25,&quot;time&quot;:100} Explanation: The function resolved 5 * 5 = 25 at t=100ms. The time limit is never reached. # Example 3 Input: fn = async (a, b) =&gt; { await new Promise(res =&gt; setTimeout(res, 120)); return a + b; } inputs = [5,10] t = 150 Output: {&quot;resolved&quot;:15,&quot;time&quot;:120} Explanation: The function resolved 5 + 10 = 15 at t=120ms. The time limit is never reached. # Example 4 Input: fn = async () =&gt; { throw &quot;Error&quot;; } inputs = [] t = 1000 Output: {&quot;rejected&quot;:&quot;Error&quot;,&quot;time&quot;:0} Explanation: The function immediately throws an error. # 解題思路 Promise.race([arr]); : race 中的陣列哪一個 Function 先跑完，return 該 Function。 # Solution /** * @param &#123;Function&#125; fn * @param &#123;number&#125; t * @return &#123;Function&#125; */var timeLimit = function(fn, t) &#123; return async function(...args) &#123; const timeout = new Promise((resolved, reject) => &#123; setTimeout(() => reject(\"Time Limit Exceeded\"), t); &#125;); return Promise.race([fn(...args), timeout]); &#125;&#125;;/** * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100); * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms */ type Fn = (...params: any[]) => Promise&lt;any>;function timeLimit(fn: Fn, t: number): Fn &#123; return async function(...args) &#123; const timeout: Promise&lt;any> = new Promise((resolved: any, reject: any) => &#123; setTimeout(() => reject(\"Time Limit Exceeded\"), t); &#125;); return Promise.race([fn(...args), timeout]); &#125;&#125;;/** * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100); * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"24. Swap Nodes in Pairs","slug":"coding/leetcode/Medium/24-Swap-Nodes-in-Pairs","date":"2023-05-16T06:38:14.000Z","updated":"2023-12-15T19:06:51.588Z","comments":true,"path":"coding/leetcode/Medium/24-Swap-Nodes-in-Pairs/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/24-Swap-Nodes-in-Pairs/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.) # Example 1 Input: head = [1,2,3,4] Output: [2,1,4,3] # Example 2 Input: head = [] Output: [] # Example 3 Input: head = [1] Output: [1] # 解題思路 # Solution // Definition for singly-linked list.public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode ans = new ListNode(0); ans.next = head; ListNode curr = ans; while (curr.next != null &amp;&amp; curr.next.next != null) &#123; ListNode first = curr.next; ListNode second = curr.next.next; curr.next = second; first.next = second.next; second.next = first; curr = curr.next.next; &#125; return ans.next; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Linked List","slug":"Linked-List","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Linked-List/"},{"name":"Recursion","slug":"Recursion","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Recursion/"}]},{"title":"2621. Sleep","slug":"coding/leetcode/Easy/2621-Sleep","date":"2023-05-15T02:35:00.000Z","updated":"2023-05-28T17:11:46.917Z","comments":true,"path":"coding/leetcode/Easy/2621-Sleep/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2621-Sleep/","excerpt":"","text":"⭐️ # 題目敘述 Given a positive integer millis , write an asyncronous function that sleeps for millis milliseconds. It can resolve any value. # Example 1 Input: millis = 100 Output: 100 Explanation: It should return a promise that resolves after 100ms. let t = Date.now(); sleep(100).then(() =&gt; { console.log(Date.now() - t); // 100 }); # Example 2 Input: millis = 200 Output: 200 Explanation: It should return a promise that resolves after 200ms. # 解題思路 # Solution /** * @param &#123;number&#125; millis */async function sleep(millis) &#123; return new Promise(function(val)&#123; return setTimeout(val, millis); &#125;);&#125;/** * let t = Date.now() * sleep(100).then(() => console.log(Date.now() - t)) // 100 */ async function sleep(millis: number): Promise&lt;void> &#123; return new Promise(function(val: any): any&#123; return setTimeout(val, millis); &#125;);&#125;/** * let t = Date.now() * sleep(100).then(() => console.log(Date.now() - t)) // 100 */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"1721. Swapping Nodes in a Linked List","slug":"coding/leetcode/Medium/1721-Swapping-Nodes-in-a-Linked-List","date":"2023-05-15T01:48:06.000Z","updated":"2023-12-15T19:09:00.301Z","comments":true,"path":"coding/leetcode/Medium/1721-Swapping-Nodes-in-a-Linked-List/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1721-Swapping-Nodes-in-a-Linked-List/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given the head of a linked list, and an integer k . Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed). # Example 1 Input: head = [1,2,3,4,5], k = 2 Output: [1,4,3,2,5] # Example 2 Input: head = [7,9,6,6,7,8,3,0,9,5], k = 5 Output: [7,9,6,6,8,7,3,0,9,5] # 解題思路 # Solution // Definition for singly-linked list.public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; class Solution &#123; public ListNode swapNodes(ListNode head, int k) &#123; ListNode start = head, end = head; for (int i = 1; i &lt; k; i++) &#123; start = start.next; &#125; ListNode curr = start; while (curr.next != null) &#123; curr = curr.next; end = end.next; &#125; int temp = start.val; start.val = end.val; end.val = temp; return head; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Linked List","slug":"Linked-List","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Linked-List/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"}]},{"title":"2666. Allow One Function Call","slug":"coding/leetcode/Easy/2666-Allow-One-Function-Call","date":"2023-05-12T03:26:20.000Z","updated":"2023-05-28T17:12:13.981Z","comments":true,"path":"coding/leetcode/Easy/2666-Allow-One-Function-Call/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2666-Allow-One-Function-Call/","excerpt":"","text":"⭐️ # 題目敘述 Given a function fn , return a new function that is identical to the original function except that it ensures fn is called at most once. The first time the returned function is called, it should return the same result as fn . Every subsequent time it is called, it should return undefined . # Example 1 Input: fn = (a,b,c) =&gt; (a + b + c), calls = [[1,2,3],[2,3,6]] Output: [{&quot;calls&quot;:1,&quot;value&quot;:6}] Explanation: const onceFn = once(fn); onceFn(1, 2, 3); // 6 onceFn(2, 3, 6); // undefined, fn was not called # Example 2 Input: fn = (a,b,c) =&gt; (a * b * c), calls = [[5,7,4],[2,3,6],[4,6,8]] Output: [{&quot;calls&quot;:1,&quot;value&quot;:140}] Explanation: const onceFn = once(fn); onceFn(5, 7, 4); // 140 onceFn(2, 3, 6); // undefined, fn was not called onceFn(4, 6, 8); // undefined, fn was not called # 解題思路 # Solution /** * @param &#123;Function&#125; fn * @return &#123;Function&#125; */var once = function(fn) &#123; let isCall = false; return function(...args)&#123; if(!isCall)&#123; isCall = true; return fn(...args); &#125; &#125;&#125;;/** * let fn = (a,b,c) => (a + b + c) * let onceFn = once(fn) * * onceFn(1,2,3); // 6 * onceFn(2,3,6); // returns undefined without calling fn */ function once&lt;T extends (...args: any[]) => any>(fn: T): ((...args: Parameters&lt;T>) => ReturnType&lt;T> | undefined) &#123; let isCall: Boolean = false; return function (...args) &#123; if(!isCall)&#123; isCall = true; return fn(...args); &#125; &#125;;&#125;/** * let fn = (a,b,c) => (a + b + c) * let onceFn = once(fn) * * onceFn(1,2,3); // 6 * onceFn(2,3,6); // returns undefined without calling fn */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"2140. Solving Questions With Brainpower","slug":"coding/leetcode/Medium/2140-Solving-Questions-With-Brainpower","date":"2023-05-12T02:48:50.000Z","updated":"2023-12-15T19:09:18.805Z","comments":true,"path":"coding/leetcode/Medium/2140-Solving-Questions-With-Brainpower/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2140-Solving-Questions-With-Brainpower/","excerpt":"","text":"⭐️ # 題目敘述 You are given a 0-indexed 2D integer array questions where questions[i] = [pointsi, brainpoweri] . The array describes the questions of an exam, where you have to process the questions in order (i.e., starting from question 0 ) and make a decision whether to solve or skip each question. Solving question i will earn you pointsi points but you will be unable to solve each of the next brainpoweri questions. If you skip question i , you get to make the decision on the next question. For example, given questions = [[3, 2], [4, 3], [4, 4], [2, 5]] : If question 0 is solved, you will earn 3 points but you will be unable to solve questions 1 and 2 . If instead, question 0 is skipped and question 1 is solved, you will earn 4 points but you will be unable to solve questions 2 and 3 . Return the maximum points you can earn for the exam. # Example 1: Input: questions = [[3,2],[4,3],[4,4],[2,5]] Output: 5 Explanation: The maximum points can be earned by solving questions 0 and 3. Solve question 0: Earn 3 points, will be unable to solve the next 2 questions Unable to solve questions 1 and 2 Solve question 3: Earn 2 points Total points earned: 3 + 2 = 5. There is no other way to earn 5 or more points. # Example 2: Input: questions = [[1,1],[2,2],[3,3],[4,4],[5,5]] Output: 7 Explanation: The maximum points can be earned by solving questions 1 and 4. Skip question 0 Solve question 1: Earn 2 points, will be unable to solve the next 2 questions Unable to solve questions 2 and 3 Solve question 4: Earn 5 points Total points earned: 2 + 5 = 7. There is no other way to earn 7 or more points. # 解題思路 # Solution class Solution &#123; public long mostPoints(int[][] questions) &#123; int n = questions.length; long[] dp = new long[n]; dp[n - 1] = questions[n - 1][0]; for (int i = n - 2; i >= 0; --i) &#123; dp[i] = questions[i][0]; int skip = questions[i][1]; if (i + skip + 1 &lt; n) &#123; dp[i] += dp[i + skip + 1]; &#125; // dp[i] = max(solve it, skip it) dp[i] = Math.max(dp[i], dp[i + 1]); &#125; return dp[0]; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"2629. Function Composition","slug":"coding/leetcode/Easy/2629-Function-Composition","date":"2023-05-11T01:58:09.000Z","updated":"2023-05-28T17:11:53.699Z","comments":true,"path":"coding/leetcode/Easy/2629-Function-Composition/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2629-Function-Composition/","excerpt":"","text":"⭐️ # 題目敘述 Given an array of functions [f1, f2, f3, ..., fn] , return a new function fn that is the function composition of the array of functions. The function composition of [f(x), g(x), h(x)] is fn(x) = f(g(h(x))) . The function composition of an empty list of functions is the identity function f(x) = x . You may assume each function in the array accepts one integer as input and returns one integer as output. # Example 1 Input: functions = [x =&gt; x + 1, x =&gt; x * x, x =&gt; 2 * x], x = 4 Output: 65 Explanation: Evaluating from right to left ... Starting with x = 4. 2 * (4) = 8 (8) * (8) = 64 (64) + 1 = 65 # Example 2 Input: functions = [x =&gt; 10 * x, x =&gt; 10 * x, x =&gt; 10 * x], x = 1 Output: 1000 Explanation: Evaluating from right to left ... 10 * (1) = 10 10 * (10) = 100 10 * (100) = 1000 # Example 3 Input: functions = [], x = 42 Output: 42 Explanation: The composition of zero functions is the identity function # 解題思路 # Solution /** * @param &#123;Function[]&#125; functions * @return &#123;Function&#125; */var compose = function(functions) &#123; return function(x) &#123; functions.reverse().foreach(fn => &#123; x = fn(x) &#125;); return x; &#125;&#125;;/** * const fn = compose([x => x + 1, x => 2 * x]) * fn(4) // 9 */ type F = (x: number) => number;function compose(functions: F[]): F &#123; return function(x): number &#123; functions.reverse().forEach((fn: F) => &#123; x = fn(x); &#125;); return x; &#125;&#125;;/** * const fn = compose([x => x + 1, x => 2 * x]) * fn(4) // 9 */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"1035. Uncrossed Lines","slug":"coding/leetcode/Medium/1035-Uncrossed-Lines","date":"2023-05-11T01:31:10.000Z","updated":"2023-12-15T19:08:20.527Z","comments":true,"path":"coding/leetcode/Medium/1035-Uncrossed-Lines/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1035-Uncrossed-Lines/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given two integer arrays nums1 and nums2 . We write the integers of nums1 and nums2 (in the order they are given) on two separate horizontal lines. We may draw connecting lines: a straight line connecting two numbers nums1[i] and nums2[j] such that: nums1[i] == nums2[j] , and the line we draw does not intersect any other connecting (non-horizontal) line. Note that a connecting line cannot intersect even at the endpoints (i.e., each number can only belong to one connecting line). Return the maximum number of connecting lines we can draw in this way. # Example 1: ![](https://hackmd.io/_uploads/rkIjNpKN3.png =400x) Input: nums1 = [1,4,2], nums2 = [1,2,4] Output: 2 Explanation: We can draw 2 uncrossed lines as in the diagram. We cannot draw 3 uncrossed lines, because the line from nums1[1] = 4 to nums2[2] = 4 will intersect the line from nums1[2]=2 to nums2[1]=2. # Example 2: Input: nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2] Output: 3 # Example 3: Input: nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1] Output: 2 # 解題思路 # Solution class Solution &#123; public int maxUncrossedLines(int[] nums1, int[] nums2) &#123; int n = nums1.length, m = nums2.length; int[][] dp = new int[n + 1][m + 1]; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; dp[i][j] = (nums1[i - 1] == nums2[j - 1] ? 1 + dp[i - 1][j - 1] : Math.max(dp[i][j - 1], dp[i - 1][j])); &#125; &#125; return dp[n][m]; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"2626. Array Reduce Transformation","slug":"coding/leetcode/Easy/2626-Array-Reduce-Transformation","date":"2023-05-10T01:49:13.000Z","updated":"2023-05-28T17:11:50.011Z","comments":true,"path":"coding/leetcode/Easy/2626-Array-Reduce-Transformation/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2626-Array-Reduce-Transformation/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer array nums , a reducer function fn , and an initial value init , return a reduced array. A reduced array is created by applying the following operation: val = fn(init, nums[0]) , val = fn(val, nums[1]) , val = fn(val, nums[2]) , ... until every element in the array has been processed. The final value of val is returned. If the length of the array is 0, it should return init . Please solve it without using the built-in Array.reduce method. # Example 1 Input: nums = [1,2,3,4] fn = function sum(accum, curr) { return accum + curr; } init = 0 Output: 10 Explanation: initially, the value is init=0. (0) + nums[0] = 1 (1) + nums[1] = 3 (3) + nums[2] = 6 (6) + nums[3] = 10 The final answer is 10. # Example 2: Input: nums = [1,2,3,4] fn = function sum(accum, curr) { return accum + curr * curr; } init = 100 Output: 130 Explanation: initially, the value is init=100. (100) + nums[0]^2 = 101 (101) + nums[1]^2 = 105 (105) + nums[2]^2 = 114 (114) + nums[3]^2 = 130 The final answer is 130. # Example 3: Input: nums = [] fn = function sum(accum, curr) { return 0; } init = 25 Output: 25 Explanation: For empty arrays, the answer is always init. # 解題思路 # Solution /** * @param &#123;number[]&#125; nums * @param &#123;Function&#125; fn * @param &#123;number&#125; init * @return &#123;number&#125; */var reduce = function(nums, fn, init) &#123; nums.forEach(function(num)&#123; init = fn(init, num); &#125;); return init;&#125;; type Fn = (accum: number, curr: number) => numberfunction reduce(nums: number[], fn: Fn, init: number): number &#123; nums.forEach(function(num)&#123; init = fn(init, num); &#125;); return init;&#125;; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"59. Spiral Matrix II","slug":"coding/leetcode/Medium/59-Spiral-Matrix-II","date":"2023-05-10T01:32:58.000Z","updated":"2023-12-15T19:07:03.402Z","comments":true,"path":"coding/leetcode/Medium/59-Spiral-Matrix-II/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/59-Spiral-Matrix-II/","excerpt":"","text":"⭐️ # 題目敘述 Given a positive integer n , generate an n x n matrix filled with elements from 1 to n^2 in spiral order. # Example 1: Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]] # Example 2: Input: n = 1 Output: [[1]] # 解題思路 # Solution class Solution &#123; public int[][] generateMatrix(int n) &#123; int[][] ans = new int[n][n]; int count = 1; int left = 0, right = n - 1, top = 0, bottom = n - 1; while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123; for (int i = left; i &lt;= right; i++) &#123; ans[top][i] = count++; &#125; top++; for (int i = top; i &lt;= bottom; i++) &#123; ans[i][right] = count++; &#125; right--; if (top &lt;= bottom) &#123; for (int i = right; i >= left; i--) &#123; ans[bottom][i] = count++; &#125; bottom--; &#125; if (left &lt;= right) &#123; for (int i = bottom; i >= top; i--) &#123; ans[i][left] = count++; &#125; left++; &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"}]},{"title":"2634. Filter Elements from Array","slug":"coding/leetcode/Easy/2634-Filter-Elements-from-Array","date":"2023-05-09T05:25:29.000Z","updated":"2023-05-28T17:11:57.691Z","comments":true,"path":"coding/leetcode/Easy/2634-Filter-Elements-from-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2634-Filter-Elements-from-Array/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer array arr and a filtering function fn , return a new array with a fewer or equal number of elements. The returned array should only contain elements where fn(arr[i], i) evaluated to a truthy value. Please solve it without the built-in Array.filter method. # Example 1: Input: arr = [0,10,20,30], fn = function greaterThan10(n) { return n &gt; 10; } Output: [20,30] Explanation: const newArray = filter(arr, fn); // [20, 30] The function filters out values that are not greater than 10 # Example 2: Input: arr = [1,2,3], fn = function firstIndex(n, i) { return i === 0; } Output: [1] Explanation: fn can also accept the index of each element In this case, the function removes elements not at index 0 # Example 3: Input: arr = [-2,-1,0,1,2], fn = function plusOne(n) { return n + 1 } Output: [-2,0,1,2] Explanation: Falsey values such as 0 should be filtered out # 解題思路 # Solution /** * @param &#123;number[]&#125; arr * @param &#123;Function&#125; fn * @return &#123;number[]&#125; */var filter = function(arr, fn) &#123; let ans = []; for (let i=0; i&lt;arr.length; i++) &#123; if (fn(arr[i], i))&#123; ans.push(arr[i]); &#125; &#125; return ans;&#125;; function filter(arr: number[], fn: (n: number, i: number) => any): number[] &#123; const ans: number[] = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (fn(arr[i], i))&#123; ans.push(arr[i]); &#125; &#125; return ans;&#125;; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"54. Spiral Matrix","slug":"coding/leetcode/Medium/54-Spiral-Matrix","date":"2023-05-09T04:53:03.000Z","updated":"2023-12-15T19:06:58.329Z","comments":true,"path":"coding/leetcode/Medium/54-Spiral-Matrix/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/54-Spiral-Matrix/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given an m x n matrix , return all elements of the matrix in spiral order. # Example 1: Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [1,2,3,6,9,8,7,4,5] # Example 2: Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] Output: [1,2,3,4,8,12,11,10,9,5,6,7] # 解題思路 # Solution import java.util.ArrayList;import java.util.List;class Solution &#123; public List&lt;Integer> spiralOrder(int[][] matrix) &#123; int rows = matrix.length; int cols = matrix[0].length; List&lt;Integer> ans = new ArrayList&lt;>(); if (rows == 0) &#123; return ans; &#125; int left = 0, right = cols - 1, top = 0, bottom = rows - 1; while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123; for (int i = left; i &lt;= right; i++) &#123; ans.add(matrix[top][i]); &#125; top++; for (int i = top; i &lt;= bottom; i++) &#123; ans.add(matrix[i][right]); &#125; right--; if (top &lt;= bottom) &#123; for (int i = right; i >= left; i--) &#123; ans.add(matrix[bottom][i]); &#125; bottom--; &#125; if (left &lt;= right) &#123; for (int i = bottom; i >= top; i--) &#123; ans.add(matrix[i][left]); &#125; left++; &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"}]},{"title":"2635. Apply Transform Over Each Element in Array","slug":"coding/leetcode/Easy/2635-Apply-Transform-Over-Each-Element-in-Array","date":"2023-05-08T02:04:46.000Z","updated":"2023-12-15T19:05:05.497Z","comments":true,"path":"coding/leetcode/Easy/2635-Apply-Transform-Over-Each-Element-in-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2635-Apply-Transform-Over-Each-Element-in-Array/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer array arr and a mapping function fn , return a new array with a transformation applied to each element. The returned array should be created such that returnedArray[i] = fn(arr[i], i) . Please solve it without the built-in Array.map method. # Example 1: Input: arr = [1,2,3], fn = function plusone(n) { return n + 1; } Output: [2,3,4] Explanation: const newArray = map(arr, plusone); // [2,3,4] The function increases each value in the array by one. # Example 2: Input: arr = [1,2,3], fn = function plusI(n, i) { return n + i; } Output: [1,3,5] Explanation: The function increases each value by the index it resides in. # Example 3: Input: arr = [10,20,30], fn = function constant() { return 42; } Output: [42,42,42] Explanation: The function always returns 42. # 解題思路 # Solution /** * @param &#123;number[]&#125; arr * @param &#123;Function&#125; fn * @return &#123;number[]&#125; */var map = function(arr, fn) &#123; return arr.map((val, index) => val = fn(val, index));&#125;; function map(arr: number[], fn: (n: number, i: number) => number): number[] &#123; return arr.map((val: number, idx: number) => val = fn(val, idx));&#125;; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"1572. Matrix Diagonal Sum","slug":"coding/leetcode/Easy/1572-Matrix-Diagonal-Sum","date":"2023-05-08T01:28:16.000Z","updated":"2023-12-15T19:04:43.756Z","comments":true,"path":"coding/leetcode/Easy/1572-Matrix-Diagonal-Sum/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1572-Matrix-Diagonal-Sum/","excerpt":"","text":"⭐️⭐️ # 題目敘述 Given a square matrix mat , return the sum of the matrix diagonals. Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal. # Example 1: Input: mat = [[1,2,3], [4,5,6], [7,8,9]] Output: 25 Explanation: Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25 Notice that element mat[1][1] = 5 is counted only once. # Example 2: Input: mat = [[1,1,1,1], [1,1,1,1], [1,1,1,1], [1,1,1,1]] Output: 8 # Example 3: Input: mat = [[5]] Output: 5 # 解題思路 # Solution class Solution &#123; public int diagonalSum(int[][] mat) &#123; int m = mat.length - 1; int ans = 0; for(int i = 0; i &lt;= m; i++)&#123; ans += mat[i][i]; ans += mat[i][m - i]; &#125; if(m % 2 == 0)&#123; ans -= mat[m / 2][m / 2]; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"}]},{"title":"2665. Counter II","slug":"coding/leetcode/Easy/2665-Counter-II","date":"2023-05-07T12:04:22.000Z","updated":"2023-05-28T17:12:09.382Z","comments":true,"path":"coding/leetcode/Easy/2665-Counter-II/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2665-Counter-II/","excerpt":"","text":"⭐️ # 題目敘述 Write a function createCounter . It should accept an initial integer init . It should return an object with three functions. The three functions are: increment() increases the current value by 1 and then returns it. decrement() reduces the current value by 1 and then returns it. reset() sets the current value to init and then returns it. # Example 1: Input: init = 5, calls = [&quot;increment&quot;,&quot;reset&quot;,&quot;decrement&quot;] Output: [6,5,4] Explanation: const counter = createCounter(5); counter.increment(); // 6 counter.reset(); // 5 counter.decrement(); // 4 # Example 2: Input: init = 0, calls = [&quot;increment&quot;,&quot;increment&quot;,&quot;decrement&quot;,&quot;reset&quot;,&quot;reset&quot;] Output: [1,2,1,0,0] Explanation: const counter = createCounter(0); counter.increment(); // 1 counter.increment(); // 2 counter.decrement(); // 1 counter.reset(); // 0 counter.reset(); // 0 # 解題思路 # Solution /** * @param &#123;integer&#125; init * @return &#123; increment: Function, decrement: Function, reset: Function &#125; */var createCounter = function(init) &#123; let counter = init; const increment = () => counter += 1; const decrement = () => counter -= 1; const reset = () => counter = init; return&#123;increment, decrement, reset&#125;;&#125;;/** * const counter = createCounter(5) * counter.increment(); // 6 * counter.reset(); // 5 * counter.decrement(); // 4 */ type ReturnObj = &#123; increment: () => number, decrement: () => number, reset: () => number,&#125;function createCounter(init: number): ReturnObj &#123; let counter: number = init; const increment = (): number => counter += 1; const decrement = (): number => counter -= 1; const reset = (): number => counter = init; return &#123;increment, decrement, reset&#125;;&#125;;/** * const counter = createCounter(5) * counter.increment(); // 6 * counter.reset(); // 5 * counter.decrement(); // 4 */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"1964. Find the Longest Valid Obstacle Course at Each Position","slug":"coding/leetcode/Hard/1964-Find-the-Longest-Valid-Obstacle-Course-at-Each-Position","date":"2023-05-07T08:40:52.000Z","updated":"2023-12-15T19:06:13.731Z","comments":true,"path":"coding/leetcode/Hard/1964-Find-the-Longest-Valid-Obstacle-Course-at-Each-Position/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/1964-Find-the-Longest-Valid-Obstacle-Course-at-Each-Position/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 You want to build some obstacle courses. You are given a 0-indexed integer array obstacles of length n , where obstacles[i] describes the height of the ith obstacle. For every index i between 0 and n - 1 (inclusive), find the length of the longest obstacle course in obstacles such that: You choose any number of obstacles between 0 and i inclusive. You must include the ith obstacle in the course. You must put the chosen obstacles in the same order as they appear in obstacles . Every obstacle (except the first) is taller than or the same height as the obstacle immediately before it. Return an array ans of length n , where ans[i] is the length of the longest obstacle course for index i as described above. # Example 1: Input: obstacles = [1,2,3,2] Output: [1,2,3,3] Explanation: The longest valid obstacle course at each position is: i = 0: [1], [1] has length 1. i = 1: [1,2], [1,2] has length 2. i = 2: [1,2,3], [1,2,3] has length 3. i = 3: [1,2,3,2], [1,2,2] has length 3. # Example 2: Input: obstacles = [2,2,1] Output: [1,2,1] Explanation: The longest valid obstacle course at each position is: i = 0: [2], [2] has length 1. i = 1: [2,2], [2,2] has length 2. i = 2: [2,2,1], [1] has length 1. # Example 3: Input: obstacles = [3,1,5,6,4,2] Output: [1,1,2,3,2,2] Explanation: The longest valid obstacle course at each position is: i = 0: [3], [3] has length 1. i = 1: [3,1], [1] has length 1. i = 2: [3,1,5], [3,5] has length 2. [1,5] is also valid. i = 3: [3,1,5,6], [3,5,6] has length 3. [1,5,6] is also valid. i = 4: [3,1,5,6,4], [3,4] has length 2. [1,4] is also valid. i = 5: [3,1,5,6,4,2], [1,2] has length 2. # 解題思路 # Solution class Solution &#123; public int[] longestObstacleCourseAtEachPosition(int[] obstacles) &#123; int n = obstacles.length; int length = 0; int[] result = new int[n]; int[] sub = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; int left = 0, right = length; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (sub[mid] &lt;= obstacles[i]) left = mid + 1; else right = mid; &#125; result[i] = left + 1; if (length == left) length++; sub[left] = obstacles[i]; &#125; return result; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Binary Indexed Tree","slug":"Binary-Indexed-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Indexed-Tree/"}]},{"title":"1498. Number of Subsequences That Satisfy the Given Sum Condition","slug":"coding/leetcode/Medium/1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition","date":"2023-05-06T05:21:16.000Z","updated":"2023-12-15T19:08:45.426Z","comments":true,"path":"coding/leetcode/Medium/1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an array of integers nums and an integer target . Return the number of non-empty subsequences of nums such that the sum of the minimum and maximum element on it is less or equal to target . Since the answer may be too large, return it modulo 10^9 + 7 . # Example 1: Input: nums = [3,5,6,7], target = 9 Output: 4 Explanation: There are 4 subsequences that satisfy the condition. [3] -&gt; Min value + max value &lt;= target (3 + 3 &lt;= 9) [3,5] -&gt; (3 + 5 &lt;= 9) [3,5,6] -&gt; (3 + 6 &lt;= 9) [3,6] -&gt; (3 + 6 &lt;= 9) # Example 2: Input: nums = [3,3,6,8], target = 10 Output: 6 Explanation: There are 6 subsequences that satisfy the condition. (nums can have repeated numbers). [3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6] # Example 3: Input: nums = [2,3,3,4,6,7], target = 12 Output: 61 Explanation: There are 63 non-empty subsequences, two of them do not satisfy the condition ([6,7], [7]). Number of valid subsequences (63 - 2 = 61). # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public int numSubseq(int[] nums, int target) &#123; int n = nums.length; int mod = 1000000007; int ans = 0; Arrays.sort(nums); int[] count = new int[n]; count[0] = 1; for (int i = 1; i &lt; n; i++) &#123; count[i] = (count[i - 1] * 2) % mod; &#125; int left = 0, right = n - 1; while (left &lt;= right) &#123; if (nums[left] + nums[right] &lt;= target) &#123; ans = (ans + count[right - left]) % mod; left++; &#125; else &#123; right--; &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"}]},{"title":"2620. Counter","slug":"coding/leetcode/Easy/2620-Counter","date":"2023-05-06T03:23:28.000Z","updated":"2023-05-28T17:11:43.153Z","comments":true,"path":"coding/leetcode/Easy/2620-Counter/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2620-Counter/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer n , return a counter function. This counter function initially returns n and then returns 1 more than the previous value every subsequent time it is called ( n , n + 1 , n + 2 , etc). # Example 1: Input: n = 10 [&quot;call&quot;,&quot;call&quot;,&quot;call&quot;] Output: [10,11,12] Explanation: counter() = 10 // The first time counter() is called, it returns n. counter() = 11 // Returns 1 more than the previous time. counter() = 12 // Returns 1 more than the previous time. # Example 2: Input: n = -2 [&quot;call&quot;,&quot;call&quot;,&quot;call&quot;,&quot;call&quot;,&quot;call&quot;] Output: [-2,-1,0,1,2] Explanation: counter() initially returns -2. Then increases after each sebsequent call. # 解題思路 # Solution /** * @param &#123;number&#125; n * @return &#123;Function&#125; counter */var createCounter = function(n) &#123; let counter = n - 1; return function() &#123; counter += 1; return counter; &#125;;&#125;;/** * const counter = createCounter(10) * counter() // 10 * counter() // 11 * counter() // 12 */ function createCounter(n: number): () => number &#123; let counter = n - 1; return function() &#123; counter += 1; return counter; &#125;&#125;/** * const counter = createCounter(10) * counter() // 10 * counter() // 11 * counter() // 12 */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"1456. Maximum Number of Vowels in a Substring of Given Length","slug":"coding/leetcode/Medium/1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length","date":"2023-05-05T02:32:53.000Z","updated":"2023-12-15T19:08:39.616Z","comments":true,"path":"coding/leetcode/Medium/1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length/","excerpt":"","text":"⭐️⭐️ # 題目敘述 Given a string s and an integer k , return the maximum number of vowel letters in any substring of s with length k . Vowel letters in English are 'a' , 'e' , 'i' , 'o' , and 'u' . # Example 1: Input: s = &quot;abciiidef&quot;, k = 3 Output: 3 Explanation: The substring &quot;iii&quot; contains 3 vowel letters. # Example 2: Input: s = &quot;aeiou&quot;, k = 2 Output: 2 Explanation: Any substring of length 2 contains 2 vowels. # Example 3: Input: s = &quot;leetcode&quot;, k = 3 Output: 2 Explanation: &quot;lee&quot;, &quot;eet&quot; and &quot;ode&quot; contain 2 vowels. # 解題思路 # Solution class Solution &#123; public int maxVowels(String s, int k) &#123; int ans = 0; String temp = s.substring(0, k); for (char t : temp.toCharArray()) &#123; if (isVowel(t))&#123; ans++; &#125; &#125; int cur = ans; for (int i = k; i &lt; s.length(); i++) &#123; if (isVowel(s.charAt(i))) cur++; if (isVowel(s.charAt(i - k))) cur--; ans = Math.max(ans, cur); &#125; return ans; &#125; public boolean isVowel(char c) &#123; if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') return true; return false; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"2667. Create Hello World Function","slug":"coding/leetcode/Easy/2667-Create-Hello-World-Function","date":"2023-05-05T01:26:51.000Z","updated":"2023-05-28T17:12:17.463Z","comments":true,"path":"coding/leetcode/Easy/2667-Create-Hello-World-Function/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2667-Create-Hello-World-Function/","excerpt":"","text":"⭐️ # 題目敘述 Write a function createHelloWorld . It should return a new function that always returns &quot;Hello World&quot; . # Example 1: Input: args = [] Output: &quot;Hello World&quot; Explanation: const f = createHelloWorld(); f(); // &quot;Hello World&quot; The function returned by createHelloWorld should always return &quot;Hello World&quot;. # Example 2: Input: args = [{},null,42] Output: &quot;Hello World&quot; Explanation: const f = createHelloWorld(); f({}, null, 42); // &quot;Hello World&quot; Any arguments could be passed to the function but it should still always return &quot;Hello World&quot;. # 解題思路 # Solution /** * @return &#123;Function&#125; */var createHelloWorld = function() &#123; return function(...args) &#123; return \"Hello World\"; &#125;&#125;;/** * const f = createHelloWorld(); * f(); // \"Hello World\" */ function createHelloWorld() &#123; return function(...args): string &#123; return \"Hello World\"; &#125;;&#125;;/** * const f = createHelloWorld(); * f(); // \"Hello World\" */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"}]},{"title":"649. Dota2 Senate","slug":"coding/leetcode/Medium/649-Dota2-Senate","date":"2023-05-04T01:30:30.000Z","updated":"2023-12-15T19:07:46.491Z","comments":true,"path":"coding/leetcode/Medium/649-Dota2-Senate/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/649-Dota2-Senate/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 In the world of Dota2, there are two parties: the Radiant and the Dire. The Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights: Ban one senator's right: A senator can make another senator lose all his rights in this and all the following rounds. Announce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game. Given a string senate representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party. Then if there are n senators, the size of the given string will be n . The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure. Suppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be &quot;Radiant&quot; or &quot;Dire&quot; . # Example 1: Input: senate = &quot;RD&quot; Output: &quot;Radiant&quot; Explanation: The first senator comes from Radiant and he can just ban the next senator's right in round 1. And the second senator can't exercise any rights anymore since his right has been banned. And in round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote. # Example 2: Input: senate = &quot;RDD&quot; Output: &quot;Dire&quot; Explanation: The first senator comes from Radiant and he can just ban the next senator's right in round 1. And the second senator can't exercise any rights anymore since his right has been banned. And the third senator comes from Dire and he can ban the first senator's right in round 1. And in round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote. # 解題思路 # Solution import java.util.LinkedList;import java.util.Queue;class Solution &#123; public String predictPartyVictory(String senate) &#123; int n = senate.length(); Queue&lt;Integer> rQueue = new LinkedList&lt;>(); Queue&lt;Integer> dQueue = new LinkedList&lt;>(); for (int i = 0; i &lt; n; i++) &#123; if (senate.charAt(i) == 'R') &#123; rQueue.add(i); &#125; else &#123; dQueue.add(i); &#125; &#125; while (!rQueue.isEmpty() &amp;&amp; !dQueue.isEmpty()) &#123; int rTurn = rQueue.poll(); int dTurn = dQueue.poll(); if (dTurn &lt; rTurn) &#123; dQueue.add(dTurn + n); &#125; else &#123; rQueue.add(rTurn + n); &#125; &#125; return rQueue.isEmpty() ? \"Dire\" : \"Radiant\"; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Queue","slug":"Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Queue/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"2215. Find the Difference of Two Arrays","slug":"coding/leetcode/Easy/2215-Find-the-Difference-of-Two-Arrays","date":"2023-05-03T01:24:55.000Z","updated":"2023-12-15T19:04:52.363Z","comments":true,"path":"coding/leetcode/Easy/2215-Find-the-Difference-of-Two-Arrays/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/2215-Find-the-Difference-of-Two-Arrays/","excerpt":"","text":"⭐️ # 題目敘述 Given two 0-indexed integer arrays nums1 and nums2 , return a list answer of size 2 where: answer[0] is a list of all distinct integers in nums1 which are not present in nums2 . answer[1] is a list of all distinct integers in nums2 which are not present in nums1 . Note that the integers in the lists may be returned in any order. # Example 1: Input: nums1 = [1,2,3], nums2 = [2,4,6] Output: [[1,3],[4,6]] Explanation: For nums1, nums1[1] = 2 is present at index 0 of nums2, whereas nums1[0] = 1 and nums1[2] = 3 are not present in nums2. Therefore, answer[0] = [1,3]. For nums2, nums2[0] = 2 is present at index 1 of nums1, whereas nums2[1] = 4 and nums2[2] = 6 are not present in nums2. Therefore, answer[1] = [4,6]. # Example 2: Input: nums1 = [1,2,3,3], nums2 = [1,1,2,2] Output: [[3],[]] Explanation: For nums1, nums1[2] and nums1[3] are not present in nums2. Since nums1[2] == nums1[3], their value is only included once and answer[0] = [3]. Every integer in nums2 is present in nums1. Therefore, answer[1] = []. # 解題思路 # Solution import java.util.ArrayList;import java.util.List;class Solution &#123; public List&lt;List&lt;Integer>> findDifference(int[] nums1, int[] nums2) &#123; List&lt;List&lt;Integer>> ans = new ArrayList&lt;>(); List&lt;Integer> map1 = new ArrayList&lt;>(), map2 = new ArrayList&lt;>(); for(int n : nums1) map1.add(n); for(int n : nums2) map2.add(n); List&lt;Integer> temp1 = new ArrayList&lt;>(); for(int n : nums1)&#123; if(!map2.contains(n) &amp;&amp; !temp1.contains(n))&#123; temp1.add(n); &#125; &#125; ans.add(temp1); List&lt;Integer> temp2 = new ArrayList&lt;>(); for(int n : nums2)&#123; if(!map1.contains(n) &amp;&amp; !temp2.contains(n))&#123; temp2.add(n); &#125; &#125; ans.add(temp2); return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"}]},{"title":"1822. Sign of the Product of an Array","slug":"coding/leetcode/Easy/1822-Sign-of-the-Product-of-an-Array","date":"2023-05-02T04:00:20.000Z","updated":"2023-12-15T19:04:50.044Z","comments":true,"path":"coding/leetcode/Easy/1822-Sign-of-the-Product-of-an-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1822-Sign-of-the-Product-of-an-Array/","excerpt":"","text":"⭐️ # 題目敘述 There is a function signFunc(x) that returns: 1 if x is positive. -1 if x is negative. 0 if x is equal to 0 . You are given an integer array nums . Let product be the product of all values in the array nums . Return signFunc(product) . # Example 1: Input: nums = [-1,-2,-3,-4,3,2,1] Output: 1 Explanation: The product of all values in the array is 144, and signFunc(144) = 1 # Example 2: Input: nums = [1,5,0,2,-3] Output: 0 Explanation: The product of all values in the array is 0, and signFunc(0) = 0 # Example 3: Input: nums = [-1,1,-1,1,-1] Output: -1 Explanation: The product of all values in the array is -1, and signFunc(-1) = -1 # 解題思路 # Solution class Solution &#123; public int arraySign(int[] nums) &#123; int sign = 1; for(int num : nums)&#123; if(num == 0) return 0; if(num &lt; 0) sign *= -1; &#125; return sign; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"}]},{"title":"1491. Average Salary Excluding the Minimum and Maximum Salary","slug":"coding/leetcode/Easy/1491-Average-Salary-Excluding-the-Minimum-and-Maximum-Salary","date":"2023-05-01T05:46:14.000Z","updated":"2023-12-15T19:04:38.150Z","comments":true,"path":"coding/leetcode/Easy/1491-Average-Salary-Excluding-the-Minimum-and-Maximum-Salary/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1491-Average-Salary-Excluding-the-Minimum-and-Maximum-Salary/","excerpt":"","text":"⭐️ # 題目敘述 You are given an array of unique integers salary where salary[i] is the salary of the ith employee. Return the average salary of employees excluding the minimum and maximum salary. Answers within 10-5 of the actual answer will be accepted. # Example 1: Input: salary = [4000,3000,1000,2000] Output: 2500.00000 Explanation: Minimum salary and maximum salary are 1000 and 4000 respectively. Average salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500 # Example 2: Input: salary = [1000,2000,3000] Output: 2000.00000 Explanation: Minimum salary and maximum salary are 1000 and 3000 respectively. Average salary excluding minimum and maximum salary is (2000) / 1 = 2000 # 解題思路 # Solution import java.util.Arrays;class Solution &#123; public double average(int[] salary) &#123; Arrays.sort(salary); long sum = 0; for(int i = 1; i &lt; salary.length - 1; i++)&#123; sum += salary[i]; &#125; return sum / (salary.length - 2 * 1.0); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"}]},{"title":"1579. Remove Max Number of Edges to Keep Graph Fully Traversable","slug":"coding/leetcode/Hard/1579-Remove-Max-Number-of-Edges-to-Keep-Graph-Fully-Traversable","date":"2023-04-30T03:18:16.000Z","updated":"2023-12-15T19:06:03.117Z","comments":true,"path":"coding/leetcode/Hard/1579-Remove-Max-Number-of-Edges-to-Keep-Graph-Fully-Traversable/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/1579-Remove-Max-Number-of-Edges-to-Keep-Graph-Fully-Traversable/","excerpt":"","text":"⭐️ # 題目敘述 Alice and Bob have an undirected graph of n nodes and three types of edges: Type 1: Can be traversed by Alice only. Type 2: Can be traversed by Bob only. Type 3: Can be traversed by both Alice and Bob. Given an array edges where edges[i] = [typei, ui, vi] represents a bidirectional edge of type typei between nodes ui and vi , find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes. Return the maximum number of edges you can remove, or return -1 if Alice and Bob cannot fully traverse the graph. # Example 1: Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]] Output: 2 Explanation: If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2. # Example 2: Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]] Output: 0 Explanation: Notice that removing any edge will not make the graph fully traversable by Alice and Bob. # Example 3: Input: n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]] Output: -1 Explanation: In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable. # 解題思路 # Solution 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"}]},{"title":"1697. Checking Existence of Edge Length Limited Paths","slug":"coding/leetcode/Hard/1697-Checking-Existence-of-Edge-Length-Limited-Paths","date":"2023-04-29T06:04:59.000Z","updated":"2023-12-15T19:06:07.132Z","comments":true,"path":"coding/leetcode/Hard/1697-Checking-Existence-of-Edge-Length-Limited-Paths/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/1697-Checking-Existence-of-Edge-Length-Limited-Paths/","excerpt":"","text":"⭐️ # 題目敘述 An undirected graph of n nodes is defined by edgeList , where edgeList[i] = [ui, vi, disi] denotes an edge between nodes ui and vi with distance disi . Note that there may be multiple edges between two nodes. Given an array queries , where queries[j] = [pj, qj, limitj] , your task is to determine for each queries[j] whether there is a path between pj and qj such that each edge on the path has a distance strictly less than limitj . Return a boolean array answer , where answer.length == queries.length and the jth value of answer is true if there is a path for queries[j] is true , and false otherwise. # Example 1: Input: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]] Output: [false,true] Explanation: The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16. For the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query. For the second query, there is a path (0 -&gt; 1 -&gt; 2) of two edges with distances less than 5, thus we return true for this query. # Example 2: Input: n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]] Output: [true,false] Exaplanation: The above figure shows the given graph. # 解題思路 # Solution 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"}]},{"title":"839. Similar String Groups","slug":"coding/leetcode/Hard/839-Similar-String-Groups","date":"2023-04-28T01:29:37.000Z","updated":"2023-12-15T19:05:43.382Z","comments":true,"path":"coding/leetcode/Hard/839-Similar-String-Groups/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/839-Similar-String-Groups/","excerpt":"","text":"⭐️ # 題目敘述 Two strings X and Y are similar if we can swap two letters (in different positions) of X , so that it equals Y . Also two strings X and Y are similar if they are equal. For example, &quot;tars&quot; and &quot;rats&quot; are similar (swapping at positions 0 and 2 ), and &quot;rats&quot; and &quot;arts&quot; are similar, but &quot;star&quot; is not similar to &quot;tars&quot; , &quot;rats&quot; , or &quot;arts&quot; . Together, these form two connected groups by similarity: &#123;&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;&#125; and &#123;&quot;star&quot;&#125; . Notice that &quot;tars&quot; and &quot;arts&quot; are in the same group even though they are not similar. Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group. We are given a list strs of strings where every string in strs is an anagram of every other string in strs . How many groups are there? # Example 1: Input: strs = [&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;] Output: 2 # Example 2: Input: strs = [&quot;omv&quot;,&quot;ovm&quot;] Output: 1 # 解題思路 # Solution 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"}]},{"title":"319. Bulb Switcher","slug":"coding/leetcode/Medium/319-Bulb-Switcher","date":"2023-04-27T01:54:17.000Z","updated":"2023-12-15T19:07:29.904Z","comments":true,"path":"coding/leetcode/Medium/319-Bulb-Switcher/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/319-Bulb-Switcher/","excerpt":"","text":"⭐️ # 題目敘述 There are n bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Return the number of bulbs that are on after n rounds. # Example 1: Input: n = 3 Output: 1 Explanation: At first, the three bulbs are [off, off, off]. After the first round, the three bulbs are [on, on, on]. After the second round, the three bulbs are [on, off, on]. After the third round, the three bulbs are [on, off, off]. So you should return 1 because there is only one bulb is on. # Example 2: Input: n = 0 Output: 0 # Example 3: Input: n = 1 Output: 1 # 解題思路 # Solution class Solution &#123; public int bulbSwitch(int n) &#123; return (int)Math.sqrt(n); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"},{"name":"Brainteaser","slug":"Brainteaser","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Brainteaser/"}]},{"title":"258. Add Digits","slug":"coding/leetcode/Easy/258-Add-Digits","date":"2023-04-26T01:27:56.000Z","updated":"2023-12-15T19:03:55.331Z","comments":true,"path":"coding/leetcode/Easy/258-Add-Digits/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/258-Add-Digits/","excerpt":"","text":"⭐️ # 題目敘述 Given an integer num , repeatedly add all its digits until the result has only one digit, and return it. # Example 1: Input: num = 38 Output: 2 Explanation: The process is 38 --&gt; 3 + 8 --&gt; 11 11 --&gt; 1 + 1 --&gt; 2 Since 2 has only one digit, return it. # Example 2: Input: num = 0 Output: 0 # 解題思路 # Solution class Solution &#123; public int addDigits(int num) &#123; while(num >= 10)&#123; String str = Integer.toString(num); num = 0; for(int i = 0; i &lt; str.length(); i++)&#123; num += Integer.parseInt(str.substring(i, i + 1)); &#125; &#125; return num; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Number-Theory/"}]},{"title":"2336. Smallest Number in Infinite Set","slug":"coding/leetcode/Medium/2336-Smallest-Number-in-Infinite-Set","date":"2023-04-25T02:20:39.000Z","updated":"2023-12-15T19:09:21.547Z","comments":true,"path":"coding/leetcode/Medium/2336-Smallest-Number-in-Infinite-Set/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2336-Smallest-Number-in-Infinite-Set/","excerpt":"","text":"⭐️⭐️ # 題目敘述 You have a set which contains all positive integers [1, 2, 3, 4, 5, ...] . Implement the SmallestInfiniteSet class: SmallestInfiniteSet() Initializes the SmallestInfiniteSet object to contain all positive integers. int popSmallest() Removes and returns the smallest integer contained in the infinite set. void addBack(int num) Adds a positive integer num back into the infinite set, if it is not already in the infinite set. # Example 1: Input [&quot;SmallestInfiniteSet&quot;, &quot;addBack&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;, &quot;addBack&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;] [[], [2], [], [], [], [1], [], [], []] Output [null, null, 1, 2, 3, null, 1, 4, 5] Explanation SmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet(); smallestInfiniteSet.addBack(2); // 2 is already in the set, so no change is made. smallestInfiniteSet.popSmallest(); // return 1, since 1 is the smallest number, and remove it from the set. smallestInfiniteSet.popSmallest(); // return 2, and remove it from the set. smallestInfiniteSet.popSmallest(); // return 3, and remove it from the set. smallestInfiniteSet.addBack(1); // 1 is added back to the set. smallestInfiniteSet.popSmallest(); // return 1, since 1 was added back to the set and // is the smallest number, and remove it from the set. smallestInfiniteSet.popSmallest(); // return 4, and remove it from the set. smallestInfiniteSet.popSmallest(); // return 5, and remove it from the set. # 解題思路 # Solution import java.util.PriorityQueue;class SmallestInfiniteSet &#123; PriorityQueue&lt;Integer> pQ; public SmallestInfiniteSet() &#123; pQ = new PriorityQueue&lt;>(); for(int i = 1; i &lt;= 1000; i++)&#123; pQ.add(i); &#125; &#125; public int popSmallest() &#123; int num = pQ.poll(); return num; &#125; public void addBack(int num) &#123; if(!pQ.contains(num))&#123; pQ.add(num); &#125; &#125;&#125;/** * Your SmallestInfiniteSet object will be instantiated and called as such: * SmallestInfiniteSet obj = new SmallestInfiniteSet(); * int param_1 = obj.popSmallest(); * obj.addBack(num); */ 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Design","slug":"Design","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Design/"}]},{"title":"1046. Last Stone Weight","slug":"coding/leetcode/Easy/1046-Last-Stone-Weight","date":"2023-04-24T02:48:10.000Z","updated":"2023-12-15T19:04:22.641Z","comments":true,"path":"coding/leetcode/Easy/1046-Last-Stone-Weight/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1046-Last-Stone-Weight/","excerpt":"","text":"⭐️ # 題目敘述 You are given an array of integers stones where stones[i] is the weight of the ith stone. We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x &lt;= y . The result of this smash is: If x == y , both stones are destroyed, and If x != y , the stone of weight x is destroyed, and the stone of weight y has new weight y - x . At the end of the game, there is at most one stone left. Return the weight of the last remaining stone. If there are no stones left, return 0 . # Example 1: Input: stones = [2,7,4,1,8,1] Output: 1 Explanation: We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then, we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then, we combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone. # Example 2: Input: stones = [1] Output: 1 # 解題思路 # Solution import java.util.Comparator;import java.util.PriorityQueue;class Solution &#123; public int lastStoneWeight(int[] stones) &#123; if(stones.length == 0) return 0; PriorityQueue&lt;Integer> pQ = new PriorityQueue&lt;>(Comparator.reverseOrder()); for(int s : stones)&#123; pQ.add(s); &#125; while(pQ.size() >= 2)&#123; int first = pQ.poll(); int second = pQ.poll(); pQ.add(first - second); &#125; return pQ.peek(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"}]},{"title":"879. Profitable Schemes","slug":"coding/leetcode/Hard/879-Profitable-Schemes","date":"2023-04-21T01:21:14.000Z","updated":"2023-12-15T19:05:50.999Z","comments":true,"path":"coding/leetcode/Hard/879-Profitable-Schemes/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/879-Profitable-Schemes/","excerpt":"","text":"⭐️ # 題目敘述 There is a group of n members, and a list of various crimes they could commit. The ith crime generates a profit[i] and requires group[i] members to participate in it. If a member participates in one crime, that member can't participate in another crime. Let's call a profitable scheme any subset of these crimes that generates at least minProfit profit, and the total number of members participating in that subset of crimes is at most n . Return the number of schemes that can be chosen. Since the answer may be very large, return it modulo 10^9 + 7 . # Example 1: Input: n = 5, minProfit = 3, group = [2,2], profit = [2,3] Output: 2 Explanation: To make a profit of at least 3, the group could either commit crimes 0 and 1, or just crime 1. In total, there are 2 schemes. # Example 2: Input: n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8] Output: 7 Explanation: To make a profit of at least 5, the group could commit any crimes, as long as they commit one. There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2). # 解題思路 # Solution class Solution &#123; public int mod = (int) 1e9 + 7; public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) &#123; int[][] dp = new int[n + 1][minProfit + 1]; dp[0][0] = 1; for (int k = 1; k &lt;= group.length; k++) &#123; int g = group[k - 1]; int p = profit[k - 1]; for (int i = n; i >= g; i--) &#123; for (int j = minProfit; j >= 0; j--) &#123; dp[i][j] = (dp[i][j] + dp[i - g][Math.max(0, j - p)]) % mod; &#125; &#125; &#125; int sum = 0; for (int i = 0; i &lt;= n; i++) &#123; sum = (sum + dp[i][minProfit]) % mod; &#125; return sum; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"}]},{"title":"662. Maximum Width of Binary Tree","slug":"coding/leetcode/Medium/662-Maximum-Width-of-Binary-Tree","date":"2023-04-20T01:23:38.000Z","updated":"2023-12-15T19:07:48.839Z","comments":true,"path":"coding/leetcode/Medium/662-Maximum-Width-of-Binary-Tree/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/662-Maximum-Width-of-Binary-Tree/","excerpt":"","text":"⭐️⭐️ # 題目敘述 Given the root of a binary tree, return the maximum width of the given tree. The maximum width of a tree is the maximum width among all levels. The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation. It is guaranteed that the answer will in the range of a 32-bit signed integer. # Example 1: Input: root = [1,3,2,5,3,null,9] Output: 4 Explanation: The maximum width exists in the third level with length 4 (5,3,null,9). # Example 2: Input: root = [1,3,2,5,null,null,9,6,null,7] Output: 7 Explanation: The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7). # Example 3: Input: root = [1,3,2,5] Output: 2 Explanation: The maximum width exists in the second level with length 2 (3,2). # 解題思路 # Solution import javafx.util.Pair;import java.util.ArrayDeque;import java.util.Deque;// Definition for a binary tree node.public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode() &#123;&#125; TreeNode(int val) &#123; this.val = val; &#125; TreeNode(int val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125;&#125;class Solution &#123; public int widthOfBinaryTree(TreeNode root) &#123; if(root == null) return 0; int ans = 0; Deque&lt;Pair&lt;TreeNode, Integer>> deque = new ArrayDeque&lt;>(); deque.add(new Pair&lt;>(root, 0)); while(!deque.isEmpty())&#123; int len = deque.size(); int start = deque.peekFirst().getValue(); int end = deque.peekLast().getValue(); ans = Math.max(ans, end - start + 1); for(int i = 0; i &lt; len; i++)&#123; Pair&lt;TreeNode, Integer> node = deque.pop(); TreeNode curr = node.getKey(); int index = node.getValue(); if(curr.left != null) deque.add(new Pair&lt;>(curr.left, 2 * index)); if(curr.right != null) deque.add(new Pair&lt;>(curr.right, 2 * index + 1)); &#125; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Tree","slug":"Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Tree/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Tree/"}]},{"title":"1372. Longest ZigZag Path in a Binary Tree","slug":"coding/leetcode/Medium/1372-Longest-ZigZag-Path-in-a-Binary-Tree","date":"2023-04-19T01:58:24.000Z","updated":"2023-12-15T19:08:37.013Z","comments":true,"path":"coding/leetcode/Medium/1372-Longest-ZigZag-Path-in-a-Binary-Tree/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1372-Longest-ZigZag-Path-in-a-Binary-Tree/","excerpt":"","text":"⭐️⭐️ # 題目敘述 You are given the root of a binary tree. A ZigZag path for a binary tree is defined as follow: Choose any node in the binary tree and a direction (right or left). If the current direction is right, move to the right child of the current node; otherwise, move to the left child. Change the direction from right to left or from left to right. Repeat the second and third steps until you can't move in the tree. Zigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0). Return the longest ZigZag path contained in that tree. # Example 1 Input: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1] Output: 3 Explanation: Longest ZigZag path in blue nodes (right -&gt; left -&gt; right). # Example 2 Input: root = [1,1,1,null,1,null,null,1,1,null,1] Output: 4 Explanation: Longest ZigZag path in blue nodes (left -&gt; right -&gt; left -&gt; right). # Example 3: Input: root = [1] Output: 0 # 解題思路 # Solution class Solution &#123; int ans = 0; public int longestZigZag(TreeNode root) &#123; dfs(root, false, 0); dfs(root, true, 0); return ans; &#125; public void dfs(TreeNode node, boolean goLeft, int steps) &#123; if (node == null) &#123; return ; &#125; ans = Math.max(ans, steps); if (goLeft) &#123; dfs(node.left, false, steps + 1); dfs(node.right, true, 1); &#125; else &#123; dfs(node.left, false, 1); dfs(node.right, true, steps + 1); &#125; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Tree","slug":"Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Tree/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Tree/"}]},{"title":"1431. Kids With the Greatest Number of Candies","slug":"coding/leetcode/Easy/1431-Kids-With-the-Greatest-Number-of-Candies","date":"2023-04-17T01:49:25.000Z","updated":"2023-12-15T19:04:28.800Z","comments":true,"path":"coding/leetcode/Easy/1431-Kids-With-the-Greatest-Number-of-Candies/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/1431-Kids-With-the-Greatest-Number-of-Candies/","excerpt":"","text":"⭐️ # 題目敘述 There are n kids with candies. You are given an integer array candies , where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies , denoting the number of extra candies that you have. Return a boolean array result of length n , where result[i] is true if, after giving the ith kid all the extraCandies , they will have the greatest number of candies among all the kids, or false otherwise. Note that multiple kids can have the greatest number of candies. # Example 1: Input: candies = [2,3,5,1,3], extraCandies = 3 Output: [true,true,true,false,true] Explanation: If you give all extraCandies to: Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids. Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids. Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids. Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids. Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids. # Example 2: Input: candies = [4,2,1,1,2], extraCandies = 1 Output: [true,false,false,false,false] Explanation: There is only 1 extra candy. Kid 1 will always have the greatest number of candies, even if a different kid is given the extra candy. # Example 3: Input: candies = [12,1,12], extraCandies = 10 Output: [true,false,true] # 解題思路 # Solution import java.util.ArrayList;import java.util.List;class Solution &#123; public List&lt;Boolean> kidsWithCandies(int[] candies, int extraCandies) &#123; int max = 0; for(int candy : candies)&#123; max = Math.max(candy, max); &#125; List&lt;Boolean> ans = new ArrayList&lt;>(); for(int candy : candies)&#123; int temp = candy + extraCandies; ans.add(temp &lt; max ? false : true); &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"}]},{"title":"2218. Maximum Value of K Coins From Piles","slug":"coding/leetcode/Hard/2218-Maximum-Value-of-K-Coins-From-Piles","date":"2023-04-15T04:01:24.000Z","updated":"2023-12-15T19:06:17.672Z","comments":true,"path":"coding/leetcode/Hard/2218-Maximum-Value-of-K-Coins-From-Piles/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/2218-Maximum-Value-of-K-Coins-From-Piles/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 There are n piles of coins on a table. Each pile consists of a positive number of coins of assorted denominations. In one move, you can choose any coin on top of any pile, remove it, and add it to your wallet. Given a list piles , where piles[i] is a list of integers denoting the composition of the ith pile from top to bottom, and a positive integer k , return the maximum total value of coins you can have in your wallet if you choose exactly k coins optimally. # Example 1: Input: piles = [[1,100,3],[7,8,9]], k = 2 Output: 101 Explanation: The above diagram shows the different ways we can choose k coins. The maximum total we can obtain is 101. # Example 2: Input: piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7 Output: 706 Explanation: The maximum total can be obtained if we choose all coins from the last pile. # 解題思路 # Solution import java.util.Arrays;import java.util.List;class Solution &#123; public int maxValueOfCoins(List&lt;List&lt;Integer>> piles, int k) &#123; int[][] dp = new int[piles.size() + 1][k + 1]; Arrays.fill(dp[0], 0); for (int i = 1; i &lt;= piles.size(); i++) &#123; dp[i][0] = 0; &#125; for (int i = 1; i &lt;= piles.size(); i++) &#123; for (int j = 1; j &lt;= k; j++) &#123; int curr = 0; for (int x = 0; x &lt; Math.min(piles.get(i - 1).size(), j); x++) &#123; curr += piles.get(i - 1).get(x); dp[i][j] = Math.max(dp[i][j], curr + dp[i - 1][j - x - 1]); &#125; dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]); &#125; &#125; return dp[piles.size()][k]; &#125;&#125; 單字 denoting 表示 to represent something 片語 & 搭配詞 assorted denominations 個種面額","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"}]},{"title":"516. Longest Palindromic Subsequence","slug":"coding/leetcode/Medium/516-Longest-Palindromic-Subsequence","date":"2023-04-14T17:08:29.000Z","updated":"2023-12-15T19:07:40.453Z","comments":true,"path":"coding/leetcode/Medium/516-Longest-Palindromic-Subsequence/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/516-Longest-Palindromic-Subsequence/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a string s , find the longest palindromic subsequence's length in s . A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. # Example 1: Input: s = &quot;bbbab&quot; Output: 4 Explanation: One possible longest palindromic subsequence is &quot;bbbb&quot;. # Example 2: Input: s = &quot;cbbd&quot; Output: 2 Explanation: One possible longest palindromic subsequence is &quot;bb&quot;. # 解題思路 # Solution class Solution &#123; public int longestPalindromeSubseq(String s) &#123; int n = s.length(); int[] dp = new int[n]; for (int i = n - 1; i >= 0; i--) &#123; int[] newdp = new int[n]; newdp[i] = 1; for (int j = i + 1; j &lt; n; j++) &#123; if (s.charAt(i) == s.charAt(j)) &#123; newdp[j] = 2 + dp[j-1]; &#125; else &#123; newdp[j] = Math.max(dp[j], newdp[j-1]); &#125; &#125; dp = newdp; &#125; return dp[n-1]; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"946. Validate Stack Sequences","slug":"coding/leetcode/Medium/946-Validate-Stack-Sequences","date":"2023-04-13T01:21:33.000Z","updated":"2023-12-15T19:08:10.611Z","comments":true,"path":"coding/leetcode/Medium/946-Validate-Stack-Sequences/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/946-Validate-Stack-Sequences/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given two integer arrays pushed and popped each with distinct values, return true if this could have been the result of a sequence of push and pop operations on an initially empty stack, or false otherwise. # Example 1: Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1] Output: true Explanation: We might do the following sequence: push(1), push(2), push(3), push(4), pop() -&gt; 4, push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1 # Example 2: Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2] Output: false Explanation: 1 cannot be popped before 2. # 解題思路 # Solution import java.util.Stack;class Solution &#123; public boolean validateStackSequences(int[] pushed, int[] popped) &#123; Stack&lt;Integer> stack = new Stack&lt;>(); int index = 0; for(int p : pushed)&#123; stack.push(p); while(!stack.isEmpty() &amp;&amp; stack.peek() == popped[index])&#123; stack.pop(); index++; &#125; &#125; return stack.isEmpty(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"}]},{"title":"71. Simplify Path","slug":"coding/leetcode/Medium/71-Simplify-Path","date":"2023-04-12T03:22:17.000Z","updated":"2023-12-15T19:07:05.904Z","comments":true,"path":"coding/leetcode/Medium/71-Simplify-Path/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/71-Simplify-Path/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a string path , which is an absolute path (starting with a slash '/' ) to a file or directory in a Unix-style file system, convert it to the simplified canonical path. In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//' ) are treated as a single slash '/' . For this problem, any other format of periods such as '...' are treated as file/directory names. The canonical path should have the following format: The path starts with a single slash '/'. Any two directories are separated by a single slash '/'. The path does not end with a trailing '/'. The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..') Return the simplified canonical path. # Example 1: Input: path = &quot;/home/&quot; Output: &quot;/home&quot; Explanation: Note that there is no trailing slash after the last directory name. # Example 2: Input: path = &quot;/../&quot; Output: &quot;/&quot; Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. # Example 3: Input: path = &quot;/home//foo/&quot; Output: &quot;/home/foo&quot; Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. # 解題思路 # Solution import java.util.Stack;class Solution &#123; public String simplifyPath(String path) &#123; Stack&lt;String> stack = new Stack&lt;>(); for (String str : path.split(\"/\")) &#123; if (!stack.isEmpty() &amp;&amp; str.equals(\"..\")) &#123; stack.pop(); &#125; else if (!str.equals(\".\") &amp;&amp; !str.equals(\"\") &amp;&amp; !str.equals(\"..\")) &#123; stack.add(str); &#125; &#125; StringBuilder ans = new StringBuilder(); for (String str : stack) &#123; ans.append(\"/\").append(str); &#125; return ans.length() == 0 ? \"/\" : ans.toString(); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"}]},{"title":"2390. Removing Stars From a String","slug":"coding/leetcode/Medium/2390-Removing-Stars-From-a-String","date":"2023-04-11T03:05:05.000Z","updated":"2023-12-15T19:09:27.948Z","comments":true,"path":"coding/leetcode/Medium/2390-Removing-Stars-From-a-String/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2390-Removing-Stars-From-a-String/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given a string s , which contains stars * . In one operation, you can: Choose a star in s . Remove the closest non-star character to its left, as well as remove the star itself. Return the string after all stars have been removed. Note: The input will be generated such that the operation is always possible. It can be shown that the resulting string will always be unique. # Example 1: Input: s = &quot;leet**cod*e&quot; Output: &quot;lecoe&quot; Explanation: Performing the removals from left to right: The closest character to the 1st star is 't' in &quot;leet**cod*e&quot; . s becomes &quot;lee*cod*e&quot; . The closest character to the 2nd star is 'e' in &quot;lee*cod*e&quot; . s becomes &quot;lecod*e&quot; . The closest character to the 3rd star is 'd' in &quot;lecod*e&quot; . s becomes &quot;lecoe&quot; . There are no more stars, so we return &quot;lecoe&quot; . # Example 2: Input: s = &quot;erase*****&quot; Output: &quot;&quot; Explanation: The entire string is removed, so we return an empty string. # 解題思路 # Solution import java.util.Stack;class Solution &#123; public String removeStars(String s) &#123; char[] toChar = s.toCharArray(); Stack&lt;Character> stack = new Stack&lt;>(); for(int i = 0; i &lt; s.length(); i++)&#123; if(toChar[i] == '*')&#123; stack.pop(); &#125;else &#123; stack.add(toChar[i]); &#125; &#125; String ans = \"\"; while(!stack.isEmpty())&#123; ans = stack.pop() + ans; &#125; return ans; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"}]},{"title":"20. Valid Parentheses","slug":"coding/leetcode/Easy/20-Valid-Parentheses","date":"2023-04-10T01:44:58.000Z","updated":"2023-12-15T19:03:45.719Z","comments":true,"path":"coding/leetcode/Easy/20-Valid-Parentheses/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Easy/20-Valid-Parentheses/","excerpt":"","text":"⭐️ # 題目敘述 Given a string s containing just the characters '(' , ')' , '&#123;' , '&#125;' , '[' and ']' , determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type. # Example 1: Input: s = &quot;()&quot; Output: true # Example 2: Input: s = &quot;(){}&quot; Output: true # Example 3: Input: s = &quot;(]&quot; Output: false # 解題思路 利用 stack。 # Solution import java.util.Stack;class Solution &#123; public boolean isValid(String s) &#123; if (s.length() % 2 != 0) &#123; return false; &#125; Stack&lt;Character> stack = new Stack&lt;>(); for (char c : s.toCharArray()) &#123; switch(c)&#123; case '(': case '&#123;': case '[': stack.push(c); break; case ')': if(stack.isEmpty() || stack.pop() != '(') return false; break; case '&#125;': if(stack.isEmpty() || stack.pop() != '&#123;') return false; break; case ']': if(stack.isEmpty() || stack.pop() != '[') return false; break; &#125; &#125; return (stack.isEmpty()); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"}],"tags":[{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"}]},{"title":"1857. Largest Color Value in a Directed Graph","slug":"coding/leetcode/Hard/1857-Largest-Color-Value-in-a-Directed-Graph","date":"2023-04-09T04:05:26.000Z","updated":"2023-12-15T19:06:10.427Z","comments":true,"path":"coding/leetcode/Hard/1857-Largest-Color-Value-in-a-Directed-Graph/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Hard/1857-Largest-Color-Value-in-a-Directed-Graph/","excerpt":"","text":"⭐️⭐️⭐️⭐️⭐️ # 題目敘述 There is a directed graph of n colored nodes and m edges. The nodes are numbered from 0 to n - 1 . You are given a string colors where colors[i] is a lowercase English letter representing the color of the ith node in this graph (0-indexed). You are also given a 2D array edges where edges[j] = [aj, bj] indicates that there is a directed edge from node aj to node bj . A valid path in the graph is a sequence of nodes x1 -&gt; x2 -&gt; x3 -&gt; ... -&gt; xk such that there is a directed edge from xi to xi+1 for every 1 &lt;= i &lt; k . The color value of the path is the number of nodes that are colored the most frequently occurring color along that path. Return the largest color value of any valid path in the given graph, or -1 if the graph contains a cycle. # Example 1: Input: colors = &quot;abaca&quot;, edges = [[0,1],[0,2],[2,3],[3,4]] Output: 3 Explanation: The path 0 -&gt; 2 -&gt; 3 -&gt; 4 contains 3 nodes that are colored &quot;a&quot; (red in the above image) . # Example 2: Input: colors = &quot;a&quot;, edges = [[0,0]] Output: -1 Explanation: There is a cycle from 0 to 0. # 解題思路 # Solution import java.util.ArrayList;import java.util.LinkedList;import java.util.List;import java.util.Queue;class Solution &#123; public int largestPathValue(String colors, int[][] edges) &#123; List&lt;List&lt;Integer>> graph = new ArrayList&lt;>(); int length = colors.length(); int inDegree[] = new int[length]; int colorsDP[][] = new int[length][26]; int visited = 0; for (int i = 0; i &lt; length; i++) &#123; graph.add(new ArrayList&lt;>()); &#125; for (int i = 0; i &lt; edges.length; i++) &#123; int start = edges[i][0]; int end = edges[i][1]; graph.get(start).add(end); inDegree[end]++; &#125; Queue&lt;Integer> queue = new LinkedList&lt;>(); for (int i = 0; i &lt; inDegree.length; i++) &#123; if (inDegree[i] == 0) &#123; queue.add(i); &#125; &#125; while (!queue.isEmpty()) &#123; int parent = queue.poll(); int parentColor = colors.charAt(parent) - 'a'; colorsDP[parent][parentColor] = colorsDP[parent][parentColor] + 1; for (Integer child : graph.get(parent)) &#123; inDegree[child]--; if (inDegree[child] == 0) &#123; queue.add(child); &#125; for (int i = 0; i &lt; 26; i++) &#123; colorsDP[child][i] = Math.max(colorsDP[child][i], colorsDP[parent][i]); &#125; &#125; visited++; &#125; if (visited != length) return -1; int maxColor = 0; for (int i = 0; i &lt; colorsDP.length; i++) &#123; for (int j = 0; j &lt; 26; j++) &#123; maxColor = Math.max(maxColor, colorsDP[i][j]); &#125; &#125; return maxColor; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Topological Sort","slug":"Topological-Sort","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Topological-Sort/"},{"name":"Memoization","slug":"Memoization","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Memoization/"}]},{"title":"133. Clone Graph","slug":"coding/leetcode/Medium/133-Clone-Graph","date":"2023-04-08T03:40:24.000Z","updated":"2023-12-15T19:07:11.621Z","comments":true,"path":"coding/leetcode/Medium/133-Clone-Graph/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/133-Clone-Graph/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Each node in the graph contains a value ( int ) and a list ( List[Node] ) of its neighbors. class Node &#123; public int val; public List&lt;Node&gt; neighbors; &#125; Test case format: For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1 , the second node with val == 2 , and so on. The graph is represented in the test case using an adjacency list. An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph. The given node will always be the first node with val = 1 . You must return the copy of the given node as a reference to the cloned graph. # Example 1: Input: adjList = [[2,4],[1,3],[2,4],[1,3]] Output: [[2,4],[1,3],[2,4],[1,3]] Explanation: There are 4 nodes in the graph. 1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4). 2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3). 3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4). 4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3). # Example 2: Input: adjList = [[]] Output: [[]] Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors. # Example 3: Input: adjList = [] Output: [] Explanation: This an empty graph, it does not have any nodes. # 解題思路 # Solution import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;// Definition for a Node.class Node &#123; public int val; public List&lt;Node> neighbors; public Node() &#123; val = 0; neighbors = new ArrayList&lt;Node>(); &#125; public Node(int _val) &#123; val = _val; neighbors = new ArrayList&lt;Node>(); &#125; public Node(int _val, ArrayList&lt;Node> _neighbors) &#123; val = _val; neighbors = _neighbors; &#125;&#125;class Solution &#123; Map&lt;Node, Node> map = new HashMap&lt;>(); public Node cloneGraph(Node node) &#123; if (node == null) return null; if (map.containsKey(node)) return map.get(node); map.put(node, new Node(node.val)); for (Node val : node.neighbors) &#123; map.get(node).neighbors.add(cloneGraph(val)); &#125; return map.get(node); &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"}]},{"title":"Reading Highlights 1: Uber: The Worlds Modern Taxi","slug":"language/english/Reading Highlights/Reading-Highlights-1-Uber-The-Worlds-Modern-Taxi","date":"2023-04-07T04:26:45.000Z","updated":"2023-09-03T09:30:12.007Z","comments":true,"path":"language/english/Reading Highlights/Reading-Highlights-1-Uber-The-Worlds-Modern-Taxi/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/language/english/Reading%20Highlights/Reading-Highlights-1-Uber-The-Worlds-Modern-Taxi/","excerpt":"","text":"⭐️⭐️⭐️⭐️ # Uber: The World's Modern Taxi A new taxi trend is taking over the world. Uber doesn't have a long history, but it has proven it's here to stay by providing major benefits and a competitive spirit. Travis Kalanick and Garrett Camp launched the Uber transportation app in 2009 in San Francisco, California, US. In May 2011, it started spreading to other American cities. In December of the same year, it expanded into its first international city - Pairs, France. Uber now operates in 58 countries and 300 cities across the globe. It's worth an estimated US$50 billion. Uber combines the traditional taxi ride with the morden technology of the 21st century. All Uber transactions are handled electronically; the app finds you a drive, navigates, and processes the paymemt. The only interaction you have with the driver is pleasant conversation. Using Uber is slightly different from a normal taxi ride because you can estimate the cost of your ride before you decide to hire a drive and split the fare with other passengers. Additionally, the app can send a text message with your Uber ride information to friends or family, adding an element of safety to your ride. Despite its many advantages, Uber has its critics. Some goverments have banned the app because its drivers aren't properly trained or insured. On February 19, Uber was declared illegal in Taiwan The goverment said that the drivers had violated the Highway Act and Transportation Management Regulations. Taxi companies have also opposed Uber, as they've lost business because of Uber's cheap rates and fast reaponse time. Protestes against Uber have become common, locally and internationally. It remains to be seen whether Uber's many advantages will win out against traditional taxis. Which one would you choose to take a ride in? # 段落大意 第一段: 告知主題是要闡述 new Taxi 第二段 Uber 發展史 第三段 Uber 的運作模式，好處等等 第四段 Uber 的問題或不足 # Reading Questions Which of the following statements about Uber is TRUE? It is illegal in some countries. It was started by a US taxi driver in 2009. It is more popular abroad than in the US. It operates through a control center. According to the passage, how does Uber work? Ubers can share the ride with other passengers. Ubers pay the transportation fare directly to the drivers. Ubers can negotiate the cost of the ride with the driver. Users have to register in paper from before using the service. Compared with normal taxis, Uber is all of the following EXCEPT . more advanced greener less costly more convenient What is one criticism of Uber based on the passage? The drivers don't show up fast enough. The drivers are not paid enough. The drivers lack sufficient training. The customer service is lousy.","categories":[{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"Reading Highlight","slug":"language/english/Reading-Highlight","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/Reading-Highlight/"}],"tags":[{"name":"英文文章","slug":"英文文章","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0/"}]},{"title":"1020. Number of Enclaves","slug":"coding/leetcode/Medium/1020-Number-of-Enclaves","date":"2023-04-07T01:25:06.000Z","updated":"2023-12-15T19:08:13.400Z","comments":true,"path":"coding/leetcode/Medium/1020-Number-of-Enclaves/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1020-Number-of-Enclaves/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an m x n binary matrix grid , where 0 represents a sea cell and 1 represents a land cell. A move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid . Return the number of land cells in grid for which we cannot walk off the boundary of the grid in any number of moves. # Example 1: Input: grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] Output: 3 Explanation: There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary. # Example 2: Input: grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]] Output: 0 Explanation: All 1s are either on the boundary or can reach the boundary. # 解題思路 # Solution class Solution &#123; public int numEnclaves(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; int ans = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if ((i == 0 || j == 0 || i == m - 1 || j == n - 1) &amp;&amp; grid[i][j] == 1) &#123; dfs(i, j, m, n, grid); &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j] == 1) &#123; ans++; &#125; &#125; &#125; return ans; &#125; public void dfs(int x, int y, int m, int n, int[][] grid) &#123; grid[x][y] = 0; int[] dirx = &#123; 0, 1, 0, -1 &#125;; int[] diry = &#123; -1, 0, 1, 0 &#125;; for (int i = 0; i &lt; 4; i++) &#123; int r = x + dirx[i]; int c = y + diry[i]; if (r >= 0 &amp;&amp; r &lt; m &amp;&amp; c >= 0 &amp;&amp; c &lt; n &amp;&amp; grid[r][c] == 1) &#123; dfs(r, c, m, n, grid); &#125; &#125; &#125;&#125; 單字 ** ** !! !! 片語 & 搭配詞 !! !!","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"}]},{"title":"1254. Number of Closed Islands","slug":"coding/leetcode/Medium/1254-Number-of-Closed-Islands","date":"2023-04-06T05:47:04.000Z","updated":"2023-12-15T19:08:26.884Z","comments":true,"path":"coding/leetcode/Medium/1254-Number-of-Closed-Islands/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/1254-Number-of-Closed-Islands/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a 2D grid consists of 0s (land) and 1s (water). An island is a maximal 4-directionally connected group of 0s and a closed island is an island totally (all left, top, right, bottom) surrounded by 1s . Return the number of closed islands. # Example 1: Input: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]] Output: 2 Explanation: Islands in gray are closed because they are completely surrounded by water (group of 1s). # Example 2: Input: grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]] Output: 1 # Example 3: Input: grid = [[1,1,1,1,1,1,1],[1,0,0,0,0,0,1],[1,0,1,1,1,0,1],[1,0,1,0,1,0,1], [1,0,1,1,1,0,1],[1,0,0,0,0,0,1],[1,1,1,1,1,1,1]] Output: 2 # 解題思路 利用 dfs(Depth-First Search) 去檢查如果該陣列為 0 ，他前後左右是否會碰到 1 ，如果碰到邊界表示封閉，如果碰到 0 再繼續找。 # Solution class Solution &#123; public int closedIsland(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; boolean[][] visit = new boolean[m][n]; int ans = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j] == 0 &amp;&amp; !visit[i][j]) &#123; if(dfs(i, j, m, n, grid, visit)) ans++; &#125; &#125; &#125; return ans; &#125; public boolean dfs(int x, int y, int m, int n, int[][] grid, boolean[][] visit) &#123; if (x &lt; 0 || x >= m || y &lt; 0 || y >= n) &#123; return false; &#125; if (grid[x][y] == 1 || visit[x][y]) &#123; return true; &#125; visit[x][y] = true; boolean isClosed = true; int[] dirx = &#123;0, 1, 0, -1&#125;; int[] diry = &#123;-1, 0, 1, 0&#125;; for (int i = 0; i &lt; 4; i++) &#123; int r = x + dirx[i]; int c = y + diry[i]; isClosed &amp;= dfs(r, c, m, n, grid, visit); &#125; return isClosed; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"}]},{"title":"2439. Minimize Maximum of Array","slug":"coding/leetcode/Medium/2439-Minimize-Maximum-of-Array","date":"2023-04-05T03:58:41.000Z","updated":"2023-12-15T19:09:33.739Z","comments":true,"path":"coding/leetcode/Medium/2439-Minimize-Maximum-of-Array/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2439-Minimize-Maximum-of-Array/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given a 0-indexed array nums comprising of n non-negative integers. In one operation, you must: Choose an integer i such that 1 &lt;= i &lt; n and nums[i] &gt; 0 . Decrease nums[i] by 1. Increase nums[i - 1] by 1. Return the minimum possible value of the maximum integer of nums after performing any number of operations. # Example 1: Input: nums = [3,7,1,6] Output: 5 Explanation: One set of optimal operations is as follows: Choose i = 1, and nums becomes [4,6,1,6]. Choose i = 3, and nums becomes [4,6,2,5]. Choose i = 1, and nums becomes [5,5,2,5]. The maximum integer of nums is 5. It can be shown that the maximum number cannot be less than 5. Therefore, we return 5. # Example 2: Input: nums = [10,1] Output: 10 Explanation: It is optimal to leave nums as is, and since 10 is the maximum value, we return 10. # 解題思路 在題目敘述中我們可以知道， nums 這個陣列無法將前面較大的數值向後移，只能將後面的數值向前移動。 因此我們可以藉由 prefix sum 來計算到目前的總值，除以現在的陣列數目，得到平均值利用高斯取頂 (ceiling function) ⇒\\Rightarrow⇒ 得到當前 subArray 數目的最大值 並與前面的最大值比較: 如果比較大 ⇒\\Rightarrow⇒ 就代表後面的值可以再向前移動。 如果比較小 ⇒\\Rightarrow⇒ 就表示雖然平均最大值可能有更小的，但是前面的值不可以往後移，因此不採用。 # Algorithm Initialize ans = 0 and prefixSum = 0 . Iterate over nums , for each index i : Update the prefix sum as prefixSum += nums[i] . Check the maximum value we can obtain by averaging prefixSum into i + 1 evenly using ceiling division. Take the larger one from ans and the result from the previous integer division. Return ans # Solution class Solution &#123; public int minimizeArrayValue(int[] nums) &#123; long prefixSum = 0; int ans = 0; for(int i = 0; i &lt; nums.length; i++)&#123; prefixSum += nums[i]; ans = Math.max(ans, (int)Math.ceil(prefixSum * 1.0 / (i + 1))); &#125; return ans; &#125;&#125; 單字 decrease 減少 to become less, or to make something become less increase 增加 to (make something) become larger in amount or size 片語 & 搭配詞 comprising of 包括","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"}]},{"title":"2405. Optimal Partition of String","slug":"coding/leetcode/Medium/2405-Optimal-Partition-of-String","date":"2023-04-04T04:02:30.000Z","updated":"2023-12-15T19:09:30.997Z","comments":true,"path":"coding/leetcode/Medium/2405-Optimal-Partition-of-String/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/2405-Optimal-Partition-of-String/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 Given a string s , partition the string into one or more substrings such that the characters in each substring are unique. That is, no letter appears in a single substring more than once. Return the minimum number of substrings in such a partition. Note that each character should belong to exactly one substring in a partition. # Example 1: Input: s = &quot;abacaba&quot; Output: 4 Explanation: Two possible partitions are (&quot;a&quot;,&quot;ba&quot;,&quot;cab&quot;,&quot;a&quot;) and (&quot;ab&quot;,&quot;a&quot;,&quot;ca&quot;,&quot;ba&quot;). It can be shown that 4 is the minimum number of substrings needed. # Example 2: Input: s = &quot;ssssss&quot; Output: 6 Explanation: The only valid partition is (&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;). # 解題思路 # Solution Solution.javaclass Solution &#123; public int partitionString(String s) &#123; int[] hashTable = new int[26]; int ans = 0; for(int i = 0; i &lt; s.length(); i++)&#123; int temp = s.charAt(i) - 'a'; if(hashTable[temp] == 1)&#123; hashTable = new int[26]; ans++; hashTable[temp]++; &#125;else&#123; hashTable[temp]++; &#125; &#125; return ans + 1; &#125;&#125; 單字 exactly 確切地 used when you are giving or asking for information that is completely correct","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"}]},{"title":"881. Boats to Save People","slug":"coding/leetcode/Medium/881-Boats-to-Save-People","date":"2023-04-03T08:26:41.000Z","updated":"2023-12-15T19:08:06.480Z","comments":true,"path":"coding/leetcode/Medium/881-Boats-to-Save-People/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/coding/leetcode/Medium/881-Boats-to-Save-People/","excerpt":"","text":"⭐️⭐️⭐️ # 題目敘述 You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit . Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit . Return the minimum number of boats to carry every given person. # Example 1 Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2) # Example 2 Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3) # Example 3 Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) # 解題思路 # Solution Solution.javaimport java.util.Arrays;class Solution &#123; public int numRescueBoats(int[] people, int limit) &#123; Arrays.sort(people); int ans = 0; int left = 0, right = people.length - 1; while (left &lt;= right) &#123; if (people[left] + people[right--] &lt;= limit) &#123; left++; &#125; ans++; &#125; return ans; &#125;&#125;","categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-04-02T12:45:48.000Z","updated":"2023-11-07T07:00:01.193Z","comments":true,"path":"hello-world/","link":"","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. # Quick Start # Create a new post h$ hexo new \"My New Post\"More info: Writing # Run server h$ hexo serverMore info: Server # Generate static files h$ hexo generateMore info: Generating # Deploy to remote sites h$ hexo deployMore info: Deployment","categories":[],"tags":[{"name":"Hello World","slug":"Hello-World","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hello-World/"}]}],"categories":[{"name":"解題筆記","slug":"coding","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/"},{"name":"Leetcode","slug":"coding/leetcode","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/"},{"name":"Easy","slug":"coding/leetcode/Easy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Easy/"},{"name":"Medium","slug":"coding/leetcode/Medium","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Medium/"},{"name":"資訊工程","slug":"computer-science","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/"},{"name":"Artificial-Intelligence","slug":"computer-science/Artificial-Intelligence","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Artificial-Intelligence/"},{"name":"Hard","slug":"coding/leetcode/Hard","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/leetcode/Hard/"},{"name":"HPC","slug":"computer-science/HPC","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/HPC/"},{"name":"MPI","slug":"computer-science/HPC/MPI","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/HPC/MPI/"},{"name":"Information-Security","slug":"computer-science/Information-Security","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Information-Security/"},{"name":"Linux","slug":"computer-science/HPC/Linux","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/HPC/Linux/"},{"name":"CPE","slug":"coding/cpe","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/"},{"name":"One Star","slug":"coding/cpe/One-Star","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/coding/cpe/One-Star/"},{"name":"Website","slug":"computer-science/Information-Security/Website","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Information-Security/Website/"},{"name":"Programming Language","slug":"computer-science/program-language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/"},{"name":"Framework","slug":"computer-science/program-language/Framework","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/Framework/"},{"name":"Svelte","slug":"computer-science/program-language/Framework/Svelte","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/Framework/Svelte/"},{"name":"DevOps","slug":"computer-science/DevOps","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/"},{"name":"Docker","slug":"computer-science/DevOps/Docker","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Docker/"},{"name":"語言","slug":"language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/"},{"name":"英文","slug":"language/english","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/"},{"name":"文法","slug":"language/english/文法","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/%E6%96%87%E6%B3%95/"},{"name":"Note","slug":"computer-science/Note","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/Note/"},{"name":"C Programming Language","slug":"computer-science/program-language/C-Programming-Language","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/C-Programming-Language/"},{"name":"PHP","slug":"computer-science/program-language/PHP","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/PHP/"},{"name":"Java Spring Boot","slug":"computer-science/program-language/Framework/Java-Spring-Boot","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/Framework/Java-Spring-Boot/"},{"name":"Vue","slug":"computer-science/program-language/Framework/Vue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/program-language/Framework/Vue/"},{"name":"Git","slug":"computer-science/DevOps/Git","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/computer-science/DevOps/Git/"},{"name":"Reading Highlight","slug":"language/english/Reading-Highlight","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/categories/language/english/Reading-Highlight/"}],"tags":[{"name":"Linked List","slug":"Linked-List","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Linked-List/"},{"name":"Recursion","slug":"Recursion","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Recursion/"},{"name":"Array","slug":"Array","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Array/"},{"name":"Heap (Priority Queue)","slug":"Heap-Priority-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Heap-Priority-Queue/"},{"name":"Sorting","slug":"Sorting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sorting/"},{"name":"Greedy","slug":"Greedy","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Greedy/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Table/"},{"name":"Counting","slug":"Counting","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Counting/"},{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Prefix-Sum/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sliding-Window/"},{"name":"String","slug":"String","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/String/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Search/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Two-Pointers/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Dynamic-Programming/"},{"name":"Graph","slug":"Graph","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Graph/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Depth-First-Search/"},{"name":"Breadth-First Search","slug":"Breadth-First-Search","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Breadth-First-Search/"},{"name":"Shortest Path","slug":"Shortest-Path","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Shortest-Path/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bit-Manipulation/"},{"name":"Math","slug":"Math","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Math/"},{"name":"Simulation","slug":"Simulation","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Simulation/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Divide-and-Conquer/"},{"name":"Deep Reinforcement Learning","slug":"Deep-Reinforcement-Learning","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Deep-Reinforcement-Learning/"},{"name":"Reinforcement Learning","slug":"Reinforcement-Learning","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Reinforcement-Learning/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Deep-Learning/"},{"name":"MCTS","slug":"MCTS","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/MCTS/"},{"name":"Bucket Sort","slug":"Bucket-Sort","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bucket-Sort/"},{"name":"Alpha-Beta","slug":"Alpha-Beta","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Alpha-Beta/"},{"name":"Queue","slug":"Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Queue/"},{"name":"Enumeration","slug":"Enumeration","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Enumeration/"},{"name":"Stack","slug":"Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Stack/"},{"name":"Monotonic Stack","slug":"Monotonic-Stack","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Monotonic-Stack/"},{"name":"nullArray","slug":"nullArray","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/nullArray/"},{"name":"Design","slug":"Design","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Design/"},{"name":"Tree","slug":"Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Tree/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Tree/"},{"name":"Backtracking","slug":"Backtracking","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Backtracking/"},{"name":"Matrix","slug":"Matrix","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Matrix/"},{"name":"Memoization","slug":"Memoization","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Memoization/"},{"name":"Randomized","slug":"Randomized","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Randomized/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Machine-Learning/"},{"name":"Supervised learning","slug":"Supervised-learning","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Supervised-learning/"},{"name":"Ordered Set","slug":"Ordered-Set","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Ordered-Set/"},{"name":"stand-alone","slug":"stand-alone","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/stand-alone/"},{"name":"website","slug":"website","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/website/"},{"name":"Monotonic Queue","slug":"Monotonic-Queue","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Monotonic-Queue/"},{"name":"Iterator","slug":"Iterator","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Iterator/"},{"name":"Interactive","slug":"Interactive","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Interactive/"},{"name":"Hash Function","slug":"Hash-Function","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hash-Function/"},{"name":"Game Theory","slug":"Game-Theory","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Game-Theory/"},{"name":"Sotring","slug":"Sotring","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Sotring/"},{"name":"Bitmask","slug":"Bitmask","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Bitmask/"},{"name":"Union Find","slug":"Union-Find","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Union-Find/"},{"name":"Minimum Spanning Tree","slug":"Minimum-Spanning-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Minimum-Spanning-Tree/"},{"name":"英文文法","slug":"英文文法","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95/"},{"name":"Quickselect","slug":"Quickselect","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Quickselect/"},{"name":"Web","slug":"Web","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Web/"},{"name":"前端框架","slug":"前端框架","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Javascript","slug":"Javascript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Typescript/"},{"name":"Windows","slug":"Windows","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Windows/"},{"name":"Practise","slug":"Practise","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Practise/"},{"name":"Binary Indexed Tree","slug":"Binary-Indexed-Tree","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Binary-Indexed-Tree/"},{"name":"Brainteaser","slug":"Brainteaser","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Brainteaser/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Number-Theory/"},{"name":"Topological Sort","slug":"Topological-Sort","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Topological-Sort/"},{"name":"英文文章","slug":"英文文章","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0/"},{"name":"Hello World","slug":"Hello-World","permalink":"https://chenhsingyu-0212.github.io/chenhsingyu-0212.github.io/tags/Hello-World/"}]}